
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>分類: Java - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../#about"
            >
        
        
            <img class="header-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/"
                            aria-label=": JAVA-Spring Boot开发"
                        >
                            JAVA-Spring Boot开发
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T16:48:03+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="使用Conditional">使用Conditional</h2>
<p>使用Profile能根据不同的Profile进行条件装配，但是Profile控制比较糙，如果想要精细控制，例如，配置本地存储，AWS存储和阿里云存储，将来很可能会增加Azure存储等，用Profile就很难实现。</p>
<p>Spring本身提供了条件装配<code>@Conditional</code>，但是要自己编写比较复杂的<code>Condition</code>来做判断，比较麻烦。Spring Boot则为我们准备好了几个非常有用的条件：</p>
<ul>
<li>@ConditionalOnProperty：如果有指定的配置，条件生效；</li>
<li>@ConditionalOnBean：如果有指定的Bean，条件生效；</li>
<li>@ConditionalOnMissingBean：如果没有指定的Bean，条件生效；</li>
<li>@ConditionalOnMissingClass：如果没有指定的Class，条件生效；</li>
<li>@ConditionalOnWebApplication：在Web环境中条件生效；</li>
<li>@ConditionalOnExpression：根据表达式判断条件是否生效。</li>
</ul>
<p>我们以最常用的<code>@ConditionalOnProperty</code>为例，把上一节的<code>StorageService</code>改写如下。首先，定义配置<code>storage.type=xxx</code>，用来判断条件，默认为<code>local</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">$&#123;STORAGE_TYPE:local&#125;</span></span><br></pre></td></tr></table></figure>
<p>设定为<code>local</code>时，启用<code>LocalStorageService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;local&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设定为<code>aws</code>时，启用<code>AwsStorageService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aws&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwsStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设定为<code>aliyun</code>时，启用<code>AliyunStorageService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;storage.type&quot;, havingValue = &quot;aliyun&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>LocalStorageService</code>的注解，当指定配置为<code>local</code>，或者配置不存在，均启用<code>LocalStorageService</code>。</p>
<p>可见，Spring Boot提供的条件装配使得应用程序更加具有灵活性。</p>
<h3 id="练习">练习</h3>
<p>使用Spring Boot提供的条件装配。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/conditional/springboot-conditional.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>Spring Boot提供了几个非常有用的条件装配注解，可实现灵活的条件装配。</p>
<hr>
<hr>
<p>Profile本身是Spring提供的功能，我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/conditional/index.html">使用条件装配</a>中已经讲到了，Profile表示一个环境的概念，如开发、测试和生产这3个环境：</p>
<ul>
<li>native</li>
<li>test</li>
<li>production</li>
</ul>
<p>或者按git分支定义master、dev这些环境：</p>
<ul>
<li>master</li>
<li>dev</li>
</ul>
<p>在启动一个Spring应用程序的时候，可以传入一个或多个环境，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=test,master</span><br></pre></td></tr></table></figure>
<p>大多数情况下，使用一个环境就足够了。</p>
<p>Spring Boot对Profiles的支持在于，可以在<code>application.yml</code>中为每个环境进行配置。下面是一个示例配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">validation-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pebble:</span></span><br><span class="line">  <span class="attr">suffix:</span></span><br><span class="line">  <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;APP_PORT:8080&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">production</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pebble:</span></span><br><span class="line">  <span class="attr">cache:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>注意到分隔符<code>---</code>，最前面的配置是默认配置，不需要指定Profile，后面的每段配置都必须以<code>spring.config.activate.on-profile: xxx</code>开头，表示一个Profile。上述配置默认使用8080端口，但是在<code>test</code>环境下，使用<code>8000</code>端口，在<code>production</code>环境下，使用<code>80</code>端口，并且启用Pebble的缓存。</p>
<p>如果我们不指定任何Profile，直接启动应用程序，那么Profile实际上就是<code>default</code>，可以从Spring Boot启动日志看出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">2022-11-25T11:10:34.006+08:00  INFO 13537 --- [           main] com.itranswarp.learnjava.Application     : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br></pre></td></tr></table></figure>
<p>上述日志显示未设置Profile，使用默认的Profile为<code>default</code>。</p>
<p>要以<code>test</code>环境启动，可输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ java -Dspring.profiles.active=test -jar springboot-profiles-1.0-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">2022-11-25T11:09:02.946+08:00  INFO 13510 --- [           main] com.itranswarp.learnjava.Application     : The following 1 profile is active: &quot;test&quot;</span><br><span class="line">...</span><br><span class="line">2022-11-25T11:09:05.124+08:00  INFO 13510 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8000 (http) with context path &#x27;&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从日志看到活动的Profile是<code>test</code>，Tomcat的监听端口是<code>8000</code>。</p>
<p>通过Profile可以实现一套代码在不同环境启用不同的配置和功能。假设我们需要一个存储服务，在本地开发时，直接使用文件存储即可，但是，在测试和生产环境，需要存储到云端如S3上，如何通过Profile实现该功能？</p>
<p>首先，我们要定义存储接口<code>StorageService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据URI打开InputStream:</span></span><br><span class="line">    InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据扩展名+InputStream保存并返回URI:</span></span><br><span class="line">    String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地存储可通过<code>LocalStorageService</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Profile(&quot;default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.local:/var/static&#125;&quot;)</span></span><br><span class="line">    String localStorageRootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File localStorageRoot;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Intializing local storage with root dir: &#123;&#125;&quot;</span>, <span class="built_in">this</span>.localStorageRootDir);</span><br><span class="line">        <span class="built_in">this</span>.localStorageRoot = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRootDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRoot, uri);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(targetFile));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + <span class="string">&quot;.&quot;</span> + extName;</span><br><span class="line">        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.localStorageRoot, fileName);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile))) &#123;</span><br><span class="line">            input.transferTo(output);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而云端存储可通过<code>CloudStorageService</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Profile(&quot;!default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloudStorageService</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.cloud.bucket:&#125;&quot;)</span></span><br><span class="line">    String bucket;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.cloud.access-key:&#125;&quot;)</span></span><br><span class="line">    String accessKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.cloud.access-secret:&#125;&quot;)</span></span><br><span class="line">    String accessSecret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        logger.info(<span class="string">&quot;Initializing cloud storage...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">openInputStream</span><span class="params">(String uri)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found: &quot;</span> + uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">store</span><span class="params">(String extName, InputStream input)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unable to access cloud storage.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>LocalStorageService</code>使用了条件装配<code>@Profile(&quot;default&quot;)</code>，即默认启用<code>LocalStorageService</code>，而<code>CloudStorageService</code>使用了条件装配<code>@Profile(&quot;!default&quot;)</code>，即非<code>default</code>环境时，自动启用<code>CloudStorageService</code>。这样，一套代码，就实现了不同环境启用不同的配置。</p>
<h3 id="练习-2">练习</h3>
<p>使用Profile启动Spring Boot应用。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/profiles/springboot-profiles.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>Spring Boot允许在一个配置文件中针对不同Profile进行配置；</p>
<p>Spring Boot在未指定Profile时默认为<code>default</code>。</p>
<h2 id="使用Actuator">使用Actuator</h2>
<p>在生产环境中，需要对应用程序的状态进行监控。前面我们已经介绍了使用JMX对Java应用程序包括JVM进行监控，使用JMX需要把一些监控信息以MBean的形式暴露给JMX Server，而Spring Boot已经内置了一个监控功能，它叫Actuator。</p>
<p>使用Actuator非常简单，只需添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后正常启动应用程序，Actuator会把它能收集到的所有信息都暴露给JMX。此外，Actuator还可以通过URL<code>/actuator/</code>挂载一些监控点，例如，输入<code>http://localhost:8080/actuator/health</code>，我们可以查看应用程序当前状态：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>许多网关作为反向代理需要一个URL来探测后端集群应用是否存活，这个URL就可以提供给网关使用。</p>
<p>Actuator默认把所有访问点暴露给JMX，但处于安全原因，只有<code>health</code>和<code>info</code>会暴露给Web。Actuator提供的所有访问点均在官方文档列出，要暴露更多的访问点给Web，需要在<code>application.yml</code>中加上配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">info,</span> <span class="string">health,</span> <span class="string">beans,</span> <span class="string">env,</span> <span class="string">metrics</span></span><br></pre></td></tr></table></figure>
<p>要特别注意暴露的URL的安全性，例如，<code>/actuator/env</code>可以获取当前机器的所有环境变量，不可暴露给公网。</p>
<h3 id="练习-3">练习</h3>
<p>使用Actuator实现监控。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/actuator/springboot-actuator.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>Spring Boot提供了一个Actuator，可以方便地实现监控，并可通过Web访问特定类型的监控。</p>
<hr>
<hr>
<h2 id="打包Spring-Boot应用">打包Spring Boot应用</h2>
<p>我们在Maven的<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/maven/plugin/index.html">使用插件</a>一节中介绍了如何使用<code>maven-shade-plugin</code>打包一个可执行的jar包。在Spring Boot应用中，打包更加简单，因为Spring Boot自带一个更简单的<code>spring-boot-maven-plugin</code>插件用来打包，我们只需要在<code>pom.xml</code>中加入以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>无需任何配置，Spring Boot的这款插件会自动定位应用程序的入口Class，我们执行以下Maven命令即可打包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean package</span><br></pre></td></tr></table></figure>
<p>以<code>springboot-exec-jar</code>项目为例，打包后我们在<code>target</code>目录下可以看到两个jar文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">classes</span><br><span class="line">generated-sources</span><br><span class="line">maven-archiver</span><br><span class="line">maven-status</span><br><span class="line">springboot-exec-jar-1.0-SNAPSHOT.jar</span><br><span class="line">springboot-exec-jar-1.0-SNAPSHOT.jar.original</span><br></pre></td></tr></table></figure>
<p>其中，<code>springboot-exec-jar-1.0-SNAPSHOT.jar.original</code>是Maven标准打包插件打的jar包，它只包含我们自己的Class，不包含依赖，而<code>springboot-exec-jar-1.0-SNAPSHOT.jar</code>是Spring Boot打包插件创建的包含依赖的jar，可以直接运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar springboot-exec-jar-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>这样，部署一个Spring Boot应用就非常简单，无需预装任何服务器，只需要上传jar包即可。</p>
<p>在打包的时候，因为打包后的Spring Boot应用不会被修改，因此，默认情况下，<code>spring-boot-devtools</code>这个依赖不会被打包进去。但是要注意，使用早期的Spring Boot版本时，需要配置一下才能排除<code>spring-boot-devtools</code>这个依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>true<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不喜欢默认的项目名+版本号作为文件名，可以加一个配置指定文件名：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>awesome-app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样打包后的文件名就是<code>awesome-app.jar</code>。</p>
<h3 id="练习-4">练习</h3>
<p>使用Spring Boot插件打包可执行jar。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/package/springboot-exec-jar.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>Spring Boot提供了一个Maven插件用于打包所有依赖到单一jar文件，此插件十分易用，无需配置。</p>
<hr>
<hr>
<p>在开发阶段，我们经常要修改代码，然后重启Spring Boot应用。经常手动停止再启动，比较麻烦。</p>
<p>Spring Boot提供了一个开发者工具，可以监控classpath路径上的文件。只要源码或配置文件发生修改，Spring Boot应用可以自动重启。在开发阶段，这个功能比较有用。</p>
<p>要使用这一开发者功能，我们只需添加如下依赖到<code>pom.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，没有然后了。直接启动应用程序，然后试着修改源码，保存，观察日志输出，Spring Boot会自动重新加载。</p>
<p>默认配置下，针对<code>/static</code>、<code>/public</code>和<code>/templates</code>目录中的文件修改，不会自动重启，因为禁用缓存后，这些文件的修改可以实时更新。</p>
<h3 id="练习-5">练习</h3>
<p>使用devtools检测修改并自动重启。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/devtools/springboot-devtools.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>Spring Boot提供了一个开发阶段非常有用的<code>spring-boot-devtools</code>，能自动检测classpath路径上文件修改并自动重启。</p>
<p>要了解Spring Boot，我们先来编写第一个Spring Boot应用程序，看看与前面我们编写的Spring应用程序有何异同。</p>
<p>我们新建一个<code>springboot-hello</code>的工程，创建标准的Maven目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">springboot-hello</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">│           ├── application.yml</span><br><span class="line">│           ├── logback-spring.xml</span><br><span class="line">│           ├── static</span><br><span class="line">│           └── templates</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>
<p>其中，在<code>src/main/resources</code>目录下，注意到几个文件：</p>
<h3 id="application-yml">application.yml</h3>
<p>这是Spring Boot默认的配置文件，它采用<a target="_blank" rel="noopener" href="https://yaml.org/">YAML</a>格式而不是<code>.properties</code>格式，文件名必须是<code>application.yml</code>而不是其他名称。</p>
<p>YAML格式比<code>key=value</code>格式的<code>.properties</code>文件更易读。比较一下两者的写法：</p>
<p>使用<code>.properties</code>格式：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.hikari.auto-commit</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.validation-timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.max-lifetime</span>=<span class="string">60000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>
<p>使用YAML格式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">$&#123;APP_NAME:unnamed&#125;</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">validation-timeout:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可见，YAML是一种层级格式，它和<code>.properties</code>很容易互相转换，它的优点是去掉了大量重复的前缀，并且更加易读。</p>
<p>提示</p>
<p>也可以使用application.properties作为配置文件，但不如YAML格式简单。</p>
<h3 id="使用环境变量">使用环境变量</h3>
<p>在配置文件中，我们经常使用如下的格式对某个key进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;DB_HOST:localhost&#125;</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">$&#123;DB_USER:root&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;DB_PASSWORD:password&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种<code>$&#123;DB_HOST:localhost&#125;</code>意思是，首先从环境变量查找<code>DB_HOST</code>，如果环境变量定义了，那么使用环境变量的值，否则，使用默认值<code>localhost</code>。</p>
<p>这使得我们在开发和部署时更加方便，因为开发时无需设定任何环境变量，直接使用默认值即本地数据库，而实际线上运行的时候，只需要传入环境变量即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ DB_HOST=10.0.1.123 DB_USER=prod DB_PASSWORD=xxxx java -jar xxx.jar</span><br></pre></td></tr></table></figure>
<h3 id="logback-spring-xml">logback-spring.xml</h3>
<p>这是Spring Boot的logback配置文件名称（也可以使用<code>logback.xml</code>），一个标准的写法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;APP_LOG&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">file</span>&gt;</span>app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>app.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;APP_LOG&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它主要通过<code>&lt;include resource=&quot;...&quot; /&gt;</code>引入了Spring Boot的一个缺省配置，这样我们就可以引用类似<code>$&#123;CONSOLE_LOG_PATTERN&#125;</code>这样的变量。上述配置定义了一个控制台输出和文件输出，可根据需要修改。</p>
<p><code>static</code>是静态文件目录，<code>templates</code>是模板文件目录，注意它们不再存放在<code>src/main/webapp</code>下，而是直接放到<code>src/main/resources</code>这个classpath目录，因为在Spring Boot中已经不需要专门的webapp目录了。</p>
<p>以上就是Spring Boot的标准目录结构，它完全是一个基于Java应用的普通Maven项目。</p>
<p>我们再来看源码目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">src/main/java</span><br><span class="line">└── com</span><br><span class="line">    └── itranswarp</span><br><span class="line">        └── learnjava</span><br><span class="line">            ├── Application.java</span><br><span class="line">            ├── entity</span><br><span class="line">            │   └── User.java</span><br><span class="line">            ├── service</span><br><span class="line">            │   └── UserService.java</span><br><span class="line">            └── web</span><br><span class="line">                └── UserController.java</span><br></pre></td></tr></table></figure>
<p>在存放源码的<code>src/main/java</code>目录中，Spring Boot对Java包的层级结构有一个要求。注意到我们的根package是<code>com.itranswarp.learnjava</code>，下面还有<code>entity</code>、<code>service</code>、<code>web</code>等子package。Spring Boot要求<code>main()</code>方法所在的启动类必须放到根package下，命名不做要求，这里我们以<code>Application.java</code>命名，它的内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动Spring Boot应用程序只需要一行代码加上一个注解<code>@SpringBootApplication</code>，该注解实际上又包含了：</p>
<ul>
<li>@SpringBootConfiguration
<ul>
<li>@Configuration</li>
</ul>
</li>
<li>@EnableAutoConfiguration
<ul>
<li>@AutoConfigurationPackage</li>
</ul>
</li>
<li>@ComponentScan</li>
</ul>
<p>这样一个注解就相当于启动了自动配置和自动扫描。</p>
<p>我们再观察<code>pom.xml</code>，它的内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pebble.version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">pebble.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 集成Pebble View --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.pebbletemplates<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pebble-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pebble.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- JDBC驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用Spring Boot时，强烈推荐从<code>spring-boot-starter-parent</code>继承，因为这样就可以引入Spring Boot的预置配置。</p>
<p>紧接着，我们引入了依赖<code>spring-boot-starter-web</code>和<code>spring-boot-starter-jdbc</code>，它们分别引入了Spring MVC相关依赖和Spring JDBC相关依赖，无需指定版本号，因为引入的<code>&lt;parent&gt;</code>内已经指定了，只有我们自己引入的某些第三方jar包需要指定版本号。这里我们引入<code>pebble-spring-boot-starter</code>作为View，以及<code>hsqldb</code>作为嵌入式数据库。<code>hsqldb</code>已在<code>spring-boot-starter-jdbc</code>中预置了版本号<code>3.0.0</code>，因此此处无需指定版本号。</p>
<p>根据<code>pebble-spring-boot-starter</code>的<a target="_blank" rel="noopener" href="https://pebbletemplates.io/wiki/guide/spring-boot-integration/">文档</a>，加入如下配置到<code>application.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pebble:</span></span><br><span class="line">  <span class="comment"># 默认为&quot;.peb&quot;，改为&quot;&quot;:</span></span><br><span class="line">  <span class="attr">suffix:</span></span><br><span class="line">  <span class="comment"># 开发阶段禁用模板缓存:</span></span><br><span class="line">  <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>对<code>Application</code>稍作改动，添加<code>WebMvcConfigurer</code>这个Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    WebMvcConfigurer <span class="title function_">createWebMvcConfigurer</span><span class="params">(<span class="meta">@Autowired</span> HandlerInterceptor[] interceptors)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">                <span class="comment">// 映射路径`/static/`到classpath路径:</span></span><br><span class="line">                registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>)</span><br><span class="line">                        .addResourceLocations(<span class="string">&quot;classpath:/static/&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就可以直接运行<code>Application</code>，启动后观察Spring Boot的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::                (v3.0.0)</span><br><span class="line"></span><br><span class="line">2022-11-25T10:49:31.100+08:00  INFO 13105 --- [           main] com.itranswarp.learnjava.Application     : Starting Application using Java 17 with PID 13105 (/Users/liaoxuefeng/Git/springboot-hello/target/classes started by liaoxuefeng in /Users/liaoxuefeng/Git/springboot-hello)</span><br><span class="line">2022-11-25T10:49:31.107+08:00  INFO 13105 --- [           main] com.itranswarp.learnjava.Application     : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2022-11-25T10:49:32.404+08:00  INFO 13105 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="line">2022-11-25T10:49:32.423+08:00  INFO 13105 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2022-11-25T10:49:32.426+08:00  INFO 13105 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.1]</span><br><span class="line">2022-11-25T10:49:32.549+08:00  INFO 13105 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2022-11-25T10:49:32.551+08:00  INFO 13105 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1327 ms</span><br><span class="line">2022-11-25T10:49:32.668+08:00  WARN 13105 --- [           main] com.zaxxer.hikari.HikariConfig           : HikariPool-1 - idleTimeout is close to or more than maxLifetime, disabling it.</span><br><span class="line">2022-11-25T10:49:32.669+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2022-11-25T10:49:32.996+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Driver does not support get/set network timeout for connections. (feature not supported)</span><br><span class="line">2022-11-25T10:49:32.998+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection org.hsqldb.jdbc.JDBCConnection@31a2a9fa</span><br><span class="line">2022-11-25T10:49:33.002+08:00  INFO 13105 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">2022-11-25T10:49:33.391+08:00  WARN 13105 --- [           main] ocalVariableTableParameterNameDiscoverer : Using deprecated &#x27;-debug&#x27; fallback for parameter name resolution. Compile the affected code with &#x27;-parameters&#x27; instead or avoid its introspection: io.pebbletemplates.boot.autoconfigure.PebbleServletWebConfiguration</span><br><span class="line">2022-11-25T10:49:33.398+08:00  WARN 13105 --- [           main] ocalVariableTableParameterNameDiscoverer : Using deprecated &#x27;-debug&#x27; fallback for parameter name resolution. Compile the affected code with &#x27;-parameters&#x27; instead or avoid its introspection: io.pebbletemplates.boot.autoconfigure.PebbleAutoConfiguration</span><br><span class="line">2022-11-25T10:49:33.619+08:00  INFO 13105 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;&#x27;</span><br><span class="line">2022-11-25T10:49:33.637+08:00  INFO 13105 --- [           main] com.itranswarp.learnjava.Application     : Started Application in 3.151 seconds (process running for 3.835)</span><br></pre></td></tr></table></figure>
<p>Spring Boot自动启动了嵌入式Tomcat，当看到<code>Started Application in xxx seconds</code>时，Spring Boot应用启动成功。</p>
<p>现在，我们在浏览器输入<code>localhost:8080</code>就可以直接访问页面。那么问题来了：</p>
<p>前面我们定义的数据源、声明式事务、JdbcTemplate在哪创建的？怎么就可以直接注入到自己编写的<code>UserService</code>中呢？</p>
<p>这些自动创建的Bean就是Spring Boot的特色：AutoConfiguration。</p>
<p>当我们引入<code>spring-boot-starter-jdbc</code>时，启动时会自动扫描所有的<code>XxxAutoConfiguration</code>：</p>
<ul>
<li><code>DataSourceAutoConfiguration</code>：自动创建一个<code>DataSource</code>，其中配置项从<code>application.yml</code>的<code>spring.datasource</code>读取；</li>
<li><code>DataSourceTransactionManagerAutoConfiguration</code>：自动创建了一个基于JDBC的事务管理器；</li>
<li><code>JdbcTemplateAutoConfiguration</code>：自动创建了一个<code>JdbcTemplate</code>。</li>
</ul>
<p>因此，我们自动得到了一个<code>DataSource</code>、一个<code>DataSourceTransactionManager</code>和一个<code>JdbcTemplate</code>。</p>
<p>类似的，当我们引入<code>spring-boot-starter-web</code>时，自动创建了：</p>
<ul>
<li><code>ServletWebServerFactoryAutoConfiguration</code>：自动创建一个嵌入式Web服务器，默认是Tomcat；</li>
<li><code>DispatcherServletAutoConfiguration</code>：自动创建一个<code>DispatcherServlet</code>；</li>
<li><code>HttpEncodingAutoConfiguration</code>：自动创建一个<code>CharacterEncodingFilter</code>；</li>
<li><code>WebMvcAutoConfiguration</code>：自动创建若干与MVC相关的Bean。</li>
<li>…</li>
</ul>
<p>引入第三方<code>pebble-spring-boot-starter</code>时，自动创建了：</p>
<ul>
<li><code>PebbleAutoConfiguration</code>：自动创建了一个<code>PebbleViewResolver</code>。</li>
</ul>
<p>Spring Boot大量使用<code>XxxAutoConfiguration</code>来使得许多组件被自动化配置并创建，而这些创建过程又大量使用了Spring的Conditional功能。例如，我们观察<code>JdbcTemplateAutoConfiguration</code>，它的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JdbcProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当满足条件：</p>
<ul>
<li><code>@ConditionalOnClass</code>：在classpath中能找到<code>DataSource</code>和<code>JdbcTemplate</code>；</li>
<li><code>@ConditionalOnSingleCandidate(DataSource.class)</code>：在当前Bean的定义中能找到唯一的<code>DataSource</code>；</li>
</ul>
<p>该<code>JdbcTemplateAutoConfiguration</code>就会起作用。实际创建由导入的<code>JdbcTemplateConfiguration</code>完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(JdbcOperations.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JdbcTemplateConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource, JdbcProperties properties)</span> &#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">        JdbcProperties.<span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> properties.getTemplate();</span><br><span class="line">        jdbcTemplate.setFetchSize(template.getFetchSize());</span><br><span class="line">        jdbcTemplate.setMaxRows(template.getMaxRows());</span><br><span class="line">        <span class="keyword">if</span> (template.getQueryTimeout() != <span class="literal">null</span>) &#123;</span><br><span class="line">            jdbcTemplate.setQueryTimeout((<span class="type">int</span>) template.getQueryTimeout().getSeconds());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>JdbcTemplate</code>之前，要满足<code>@ConditionalOnMissingBean(JdbcOperations.class)</code>，即不存在<code>JdbcOperations</code>的Bean。</p>
<p>如果我们自己创建了一个<code>JdbcTemplate</code>，例如，在<code>Application</code>中自己写个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么根据条件<code>@ConditionalOnMissingBean(JdbcOperations.class)</code>，Spring Boot就不会再创建一个重复的<code>JdbcTemplate</code>（因为<code>JdbcOperations</code>是<code>JdbcTemplate</code>的父类）。</p>
<p>可见，Spring Boot自动装配功能是通过自动扫描+条件装配实现的，这一套机制在默认情况下工作得很好，但是，如果我们要手动控制某个Bean的创建，就需要详细地了解Spring Boot自动创建的原理，很多时候还要跟踪<code>XxxAutoConfiguration</code>，以便设定条件使得某个Bean不会被自动创建。</p>
<h3 id="练习-6">练习</h3>
<p>使用Spring Boot编写hello应用程序。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/first-webapp/springboot-hello.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>Spring Boot是一个基于Spring提供了开箱即用的一组套件，它可以让我们基于很少的配置和代码快速搭建出一个完整的应用程序。</p>
<p>Spring Boot有非常强大的AutoConfiguration功能，它是通过自动扫描+条件装配实现的。</p>
<h2 id="Spring-Boot开发">Spring Boot开发</h2>
<p>我们已经在前面详细介绍了Spring框架，它的主要功能包括IoC容器、AOP支持、事务支持、MVC开发以及强大的第三方集成功能等。</p>
<p>那么，Spring Boot又是什么？它和Spring是什么关系？</p>
<p>Spring Boot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序。</p>
<p>以汽车为例，如果我们想组装一辆汽车，我们需要发动机、传动、轮胎、底盘、外壳、座椅、内饰等各种部件，然后把它们装配起来。Spring就相当于提供了一系列这样的部件，但是要装好汽车上路，还需要我们自己动手。而Spring Boot则相当于已经帮我们预装好了一辆可以上路的汽车，如果有特殊的要求，例如把发动机从普通款换成涡轮增压款，可以通过修改配置或编写少量代码完成。</p>
<p>因此，Spring Boot和Spring的关系就是整车和零部件的关系，它们不是取代关系，试图跳过Spring直接学习Spring Boot是不可能的。</p>
<p>Spring Boot的目标就是提供一个开箱即用的应用程序架构，我们基于Spring Boot的预置结构继续开发，省时省力。</p>
<p>本章我们将详细介绍如何使用Spring Boot。</p>
<p>本教程使用的Spring Boot版本是3.x版，如果使用Spring Boot 2.x则需注意，两者有以下不同：</p>
<table>
<thead>
<tr>
<th></th>
<th>Spring Boot 2.x</th>
<th>Spring Boot 3.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring版本</td>
<td>Spring 5.x</td>
<td>Spring 6.x</td>
</tr>
<tr>
<td>JDK版本</td>
<td>&gt;= 1.8</td>
<td>&gt;= 17</td>
</tr>
<tr>
<td>Tomcat版本</td>
<td>9.x</td>
<td>10.x</td>
</tr>
<tr>
<td>Annotation包</td>
<td>javax.annotation</td>
<td>jakarta.annotation</td>
</tr>
<tr>
<td>Servlet包</td>
<td>javax.servlet</td>
<td>jakarta.servlet</td>
</tr>
<tr>
<td>JMS包</td>
<td>javax.jms</td>
<td>jakarta.jms</td>
</tr>
<tr>
<td>JavaMail包</td>
<td>javax.mail</td>
<td>jakarta.mail</td>
</tr>
</tbody>
</table>
<p>如果使用Spring Boot的其他版本，则需要根据需要调整代码。</p>
<p>Spring Boot的官网入口是<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">这里</a>，建议添加到浏览器收藏夹。</p>
<hr>
<hr>
<h2 id="加载配置文件">加载配置文件</h2>
<p>加载配置文件可以直接使用注解<code>@Value</code>，例如，我们定义了一个最大允许上传的文件大小配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="number">102400</span></span><br></pre></td></tr></table></figure>
<p>在某个FileUploader里，需要获取该配置，可使用<code>@Value</code>注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.local.max-size:102400&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在另一个<code>UploadFilter</code>中，因为要检查文件的MD5，同时也要检查输入流的大小，因此，也需要该配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;storage.local.max-size:100000&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多次引用同一个<code>@Value</code>不但麻烦，而且<code>@Value</code>使用字符串，缺少编译器检查，容易造成多处引用不一致（例如，<code>UploadFilter</code>把缺省值误写为<code>100000</code>）。</p>
<p>为了更好地管理配置，Spring Boot允许创建一个Bean，持有一组配置，并由Spring Boot自动注入。</p>
<p>假设我们在<code>application.yml</code>中添加了如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="comment"># 文件存储根目录:</span></span><br><span class="line">    <span class="attr">root-dir:</span> <span class="string">$&#123;STORAGE_LOCAL_ROOT:/var/storage&#125;</span></span><br><span class="line">    <span class="comment"># 最大文件大小，默认100K:</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="string">$&#123;STORAGE_LOCAL_MAX_SIZE:102400&#125;</span></span><br><span class="line">    <span class="comment"># 是否允许空文件:</span></span><br><span class="line">    <span class="attr">allow-empty:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 允许的文件类型:</span></span><br><span class="line">    <span class="attr">allow-types:</span> <span class="string">jpg,</span> <span class="string">png,</span> <span class="string">gif</span></span><br></pre></td></tr></table></figure>
<p>可以首先定义一个Java Bean，持有该组配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> allowEmpty;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; allowTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证Java Bean的属性名称与配置一致即可。然后，我们添加两个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;storage.local&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageConfiguration</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>@ConfigurationProperties(&quot;storage.local&quot;)</code>表示将从配置项<code>storage.local</code>读取该项的所有子项配置，并且，<code>@Configuration</code>表示<code>StorageConfiguration</code>也是一个Spring管理的Bean，可直接注入到其他Bean中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StorageConfiguration storageConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Load configuration: root-dir = &#123;&#125;&quot;</span>, storageConfig.getRootDir());</span><br><span class="line">        logger.info(<span class="string">&quot;Load configuration: max-size = &#123;&#125;&quot;</span>, storageConfig.getMaxSize());</span><br><span class="line">        logger.info(<span class="string">&quot;Load configuration: allowed-types = &#123;&#125;&quot;</span>, storageConfig.getAllowTypes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，引入<code>storage.local</code>的相关配置就很容易了，因为只需要注入<code>StorageConfiguration</code>这个Bean，这样可以由编译器检查类型，无需编写重复的<code>@Value</code>注解。</p>
<h3 id="练习-7">练习</h3>
<p>用Spring Boot加载配置文件。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/configuration/springboot-configuration.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>Spring Boot提供了<code>@ConfigurationProperties</code>注解，可以非常方便地把一段配置加载到一个Bean中。</p>
<hr>
<hr>
<p>Spring Boot大量使用自动配置和默认配置，极大地减少了代码，通常只需要加上几个注解，并按照默认规则设定一下必要的配置即可。例如，配置JDBC，默认情况下，只需要配置一个<code>spring.datasource</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot就会自动创建出<code>DataSource</code>、<code>JdbcTemplate</code>、<code>DataSourceTransactionManager</code>，非常方便。</p>
<p>但是，有时候，我们又必须要禁用某些自动配置。例如，系统有主从两个数据库，而Spring Boot的自动配置只能配一个，怎么办？</p>
<p>这个时候，针对<code>DataSource</code>相关的自动配置，就必须关掉。我们需要用<code>exclude</code>指定需要关掉的自动配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 启动自动配置，但排除指定的自动配置:</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，Spring Boot不再给我们自动创建<code>DataSource</code>、<code>JdbcTemplate</code>和<code>DataSourceTransactionManager</code>了，要实现主从数据库支持，怎么办？</p>
<p>让我们一步一步开始编写支持主从数据库的功能。首先，我们需要把主从数据库配置写到<code>application.yml</code>中，仍然按照Spring Boot默认的格式写，但<code>datasource</code>改为<code>datasource-master</code>和<code>datasource-slave</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource-master:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br><span class="line">  <span class="attr">datasource-slave:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:hsqldb:file:testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">dirver-class-name:</span> <span class="string">org.hsqldb.jdbc.JDBCDriver</span></span><br></pre></td></tr></table></figure>
<p>注意到两个数据库实际上是同一个库。如果使用MySQL，可以创建一个只读用户，作为<code>datasource-slave</code>的用户来模拟一个从库。</p>
<p>下一步，我们分别创建两个HikariCP的<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterDataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;masterDataSourceProperties&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource-master&quot;)</span></span><br><span class="line">    DataSourceProperties <span class="title function_">dataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;masterDataSource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSourceProperties&quot;)</span> DataSourceProperties props)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> props.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlaveDataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;slaveDataSourceProperties&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource-slave&quot;)</span></span><br><span class="line">    DataSourceProperties <span class="title function_">dataSourceProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProperties</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;slaveDataSource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSourceProperties&quot;)</span> DataSourceProperties props)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> props.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到上述class并未添加<code>@Configuration</code>和<code>@Component</code>，要使之生效，可以使用<code>@Import</code>导入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; MasterDataSourceConfiguration.class, SlaveDataSourceConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，上述两个<code>DataSource</code>的Bean名称分别为<code>masterDataSource</code>和<code>slaveDataSource</code>，我们还需要一个最终的<code>@Primary</code>标注的<code>DataSource</code>，它采用Spring提供的<code>AbstractRoutingDataSource</code>，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从ThreadLocal中取出key:</span></span><br><span class="line">        <span class="keyword">return</span> RoutingDataSourceContext.getDataSourceRoutingKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RoutingDataSource</code>本身并不是真正的<code>DataSource</code>，它通过Map关联一组<code>DataSource</code>，下面的代码创建了包含两个<code>DataSource</code>的<code>RoutingDataSource</code>，关联的key分别为<code>masterDataSource</code>和<code>slaveDataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource,</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSource</span>();</span><br><span class="line">        <span class="comment">// 关联两个DataSource:</span></span><br><span class="line">        ds.setTargetDataSources(Map.of(</span><br><span class="line">                <span class="string">&quot;masterDataSource&quot;</span>, masterDataSource,</span><br><span class="line">                <span class="string">&quot;slaveDataSource&quot;</span>, slaveDataSource));</span><br><span class="line">        <span class="comment">// 默认使用masterDataSource:</span></span><br><span class="line">        ds.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSourceTransactionManager <span class="title function_">dataSourceTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然需要自己创建<code>JdbcTemplate</code>和<code>PlatformTransactionManager</code>，注入的是标记为<code>@Primary</code>的<code>RoutingDataSource</code>。</p>
<p>这样，我们通过如下的代码就可以切换<code>RoutingDataSource</code>底层使用的真正的<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RoutingDataSourceContext.setDataSourceRoutingKey(<span class="string">&quot;slaveDataSource&quot;</span>);</span><br><span class="line">jdbcTemplate.query(...);</span><br></pre></td></tr></table></figure>
<p>只不过写代码切换DataSource即麻烦又容易出错，更好的方式是通过注解配合AOP实现自动切换，这样，客户端代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">	<span class="meta">@RoutingWithSlave</span> <span class="comment">// &lt;-- 指示在此方法中使用slave数据库</span></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">profile</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现上述功能需要编写一个<code>@RoutingWithSlave</code>注解，一个AOP织入和一个<code>ThreadLocal</code>来保存key。由于代码比较简单，这里我们不再详述。</p>
<p>如果我们想要确认是否真的切换了<code>DataSource</code>，可以覆写<code>determineTargetDataSource()</code>方法并打印出<code>DataSource</code>的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DataSource <span class="title function_">determineTargetDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="built_in">super</span>.determineTargetDataSource();</span><br><span class="line">        logger.info(<span class="string">&quot;determin target datasource: &#123;&#125;&quot;</span>, ds);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问不同的URL，可以在日志中看到两个<code>DataSource</code>，分别是<code>HikariPool-1</code>和<code>hikariPool-2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-06-14 17:55:21.676  INFO 91561 --- [nio-8080-exec-7] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-1)</span><br><span class="line">2020-06-14 17:57:08.992  INFO 91561 --- [io-8080-exec-10] c.i.learnjava.config.RoutingDataSource   : determin target datasource: HikariDataSource (HikariPool-2)</span><br></pre></td></tr></table></figure>
<p>我们用一个图来表示创建的DataSource以及相关Bean的关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────┐       ┌──────────────────┐</span><br><span class="line">│@Primary            │&lt;──────│   JdbcTemplate   │</span><br><span class="line">│RoutingDataSource   │       └──────────────────┘</span><br><span class="line">│ ┌────────────────┐ │       ┌──────────────────┐</span><br><span class="line">│ │MasterDataSource│ │&lt;──────│DataSource        │</span><br><span class="line">│ └────────────────┘ │       │TransactionManager│</span><br><span class="line">│ ┌────────────────┐ │       └──────────────────┘</span><br><span class="line">│ │SlaveDataSource │ │</span><br><span class="line">│ └────────────────┘ │</span><br><span class="line">└────────────────────┘</span><br></pre></td></tr></table></figure>
<p>注意到<code>DataSourceTransactionManager</code>和<code>JdbcTemplate</code>引用的都是<code>RoutingDataSource</code>，所以，这种设计的一个限制就是：在一个请求中，一旦切换了内部数据源，在同一个事务中，不能再切到另一个，否则，<code>DataSourceTransactionManager</code>和<code>JdbcTemplate</code>操作的就不是同一个数据库连接。</p>
<h3 id="练习-8">练习</h3>
<p>禁用DataSourceAutoConfiguration并配置多数据源。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/disable-auto-config/springboot-multi-datasource.zip">下载练习</a></p>
<h3 id="小结-8">小结</h3>
<p>可以通过<code>@EnableAutoConfiguration(exclude = &#123;...&#125;)</code>指定禁用的自动配置；</p>
<p>可以通过<code>@Import(&#123;...&#125;)</code>导入自定义配置。</p>
<h2 id="添加Filter">添加Filter</h2>
<p>我们在Spring中已经学过了<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/filter/index.html">集成Filter</a>，本质上就是通过代理，把Spring管理的Bean注册到Servlet容器中，不过步骤比较繁琐，需要配置<code>web.xml</code>。</p>
<p>在Spring Boot中，添加一个<code>Filter</code>更简单了，可以做到零配置。我们来看看在Spring Boot中如何添加<code>Filter</code>。</p>
<p>Spring Boot会自动扫描所有的<code>FilterRegistrationBean</code>类型的Bean，然后，将它们返回的<code>Filter</code>自动注册到Servlet容器中，无需任何配置。</p>
<p>我们还是以<code>AuthFilter</code>为例，首先编写一个<code>AuthFilterRegistrationBean</code>，它继承自<code>FilterRegistrationBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilterRegistrationBean</span> <span class="keyword">extends</span> <span class="title class_">FilterRegistrationBean</span>&lt;Filter&gt; &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Filter <span class="title function_">getFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        setOrder(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthFilter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FilterRegistrationBean</code>本身不是<code>Filter</code>，它实际上是<code>Filter</code>的工厂。Spring Boot会调用<code>getFilter()</code>，把返回的<code>Filter</code>注册到Servlet容器中。因为我们可以在<code>FilterRegistrationBean</code>中注入需要的资源，然后，在返回的<code>AuthFilter</code>中，这个内部类可以引用外部类的所有字段，自然也包括注入的<code>UserService</code>，所以，整个过程完全基于Spring的IoC容器完成。</p>
<p>再注意到<code>AuthFilterRegistrationBean</code>使用了<code>setOrder(10)</code>，因为Spring Boot支持给多个<code>Filter</code>排序，数字小的在前面，所以，多个<code>Filter</code>的顺序是可以固定的。</p>
<p>我们再编写一个<code>ApiFilter</code>，专门过滤<code>/api/*</code>这样的URL。首先编写一个<code>ApiFilterRegistrationBean</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiFilterRegistrationBean</span> <span class="keyword">extends</span> <span class="title class_">FilterRegistrationBean</span>&lt;Filter&gt; &#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        setOrder(<span class="number">20</span>);</span><br><span class="line">        setFilter(<span class="keyword">new</span> <span class="title class_">ApiFilter</span>());</span><br><span class="line">        setUrlPatterns(List.of(<span class="string">&quot;/api/*&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ApiFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>ApiFilterRegistrationBean</code>和<code>AuthFilterRegistrationBean</code>又有所不同。因为我们要过滤URL，而不是针对所有URL生效，因此，在<code>@PostConstruct</code>方法中，通过<code>setFilter()</code>设置一个<code>Filter</code>实例后，再调用<code>setUrlPatterns()</code>传入要过滤的URL列表。</p>
<h3 id="练习-9">练习</h3>
<p>在Spring Boot中添加Filter并指定顺序。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/filter/springboot-filter.zip">下载练习</a></p>
<h3 id="小结-9">小结</h3>
<p>在Spring Boot中添加<code>Filter</code>更加方便，并且支持对多个<code>Filter</code>进行排序。</p>
<hr>
<hr>
<p>和Spring相比，使用Spring Boot通过自动配置来集成第三方组件通常来说更简单。</p>
<p>我们将详细介绍如何通过Spring Boot集成常用的第三方组件，包括：</p>
<ul>
<li>Open API</li>
<li>Redis</li>
<li>Artemis</li>
<li>RabbitMQ</li>
<li>Kafka</li>
</ul>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/boot.png" alt="spring-boot"></p>
<p><a target="_blank" rel="noopener" href="https://www.openapis.org/">Open API</a>是一个标准，它的主要作用是描述REST API，既可以作为文档给开发者阅读，又可以让机器根据这个文档自动生成客户端代码等。</p>
<p>在Spring Boot应用中，假设我们编写了一堆REST API，如何添加Open API的支持？</p>
<p>我们只需要在<code>pom.xml</code>中加入以下依赖：</p>
<ul>
<li>org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.0</li>
</ul>
<p>然后呢？没有然后了，直接启动应用，打开浏览器输入<code>http://localhost:8080/swagger-ui.html</code>：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/open-api/open-api.png" alt="swagger-ui"></p>
<p>立刻可以看到自动生成的API文档，这里列出了3个API，来自<code>api-controller</code>（因为定义在<code>ApiController</code>这个类中），点击某个API还可以交互，即输入API参数，点“Try it out”按钮，获得运行结果。</p>
<h2 id="是不是太方便了！">是不是太方便了！</h2>
<p>因为我们引入<code>springdoc-openapi-ui</code>这个依赖后，它自动引入Swagger UI用来创建API文档。可以给API加入一些描述信息，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Operation(summary = &quot;Get specific user object by it&#x27;s id.&quot;)</span></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">user</span><span class="params">(<span class="meta">@Parameter(description = &quot;id of the user.&quot;)</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> userService.getUserById(id);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Operation</code>可以对API进行描述，<code>@Parameter</code>可以对参数进行描述，它们的目的是用于生成API文档的描述信息。添加了描述的API文档如下：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/open-api/open-api-desc.png" alt="api-description"></p>
<p>大多数情况下，不需要任何配置，我们就直接得到了一个运行时动态生成的可交互的API文档，该API文档总是和代码保持同步，大大简化了文档的编写工作。</p>
<p>要自定义文档的样式、控制某些API显示等，请参考<a target="_blank" rel="noopener" href="https://springdoc.org/">springdoc文档</a>。</p>
<h3 id="配置反向代理">配置反向代理</h3>
<p>如果在服务器上，用户访问的域名是<code>https://example.com</code>，但内部是通过类似Nginx这样的反向代理访问实际的Spring Boot应用，比如<code>http://localhost:8080</code>，这个时候，在页面<code>https://example.com/swagger-ui.html</code>上，显示的URL仍然是<code>http://localhost:8080</code>，这样一来，就无法直接在页面执行API，非常不方便。</p>
<p>这是因为Spring Boot内置的Tomcat默认获取的服务器名称是<code>localhost</code>，端口是实际监听端口，而不是对外暴露的域名和<code>80</code>或<code>443</code>端口。要让Tomcat获取到对外暴露的域名等信息，必须在Nginx配置中传入必要的HTTP Header，常用的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Nginx配置</span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在Spring Boot的<code>application.yml</code>中，加入如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment"># 实际监听端口:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="comment"># 从反向代理读取相关的HTTP Header:</span></span><br><span class="line">  <span class="attr">forward-headers-strategy:</span> <span class="string">native</span></span><br></pre></td></tr></table></figure>
<p>重启Spring Boot应用，即可在Swagger中显示正确的URL。</p>
<h3 id="练习-10">练习</h3>
<p>利用springdoc实现API文档。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/open-api/springboot-openapi.zip">下载练习</a></p>
<h3 id="小结-10">小结</h3>
<p>使用springdoc让其自动创建API文档非常容易，引入依赖后无需任何配置即可访问交互式API文档。</p>
<p>可以对API添加注解以便生成更详细的描述。</p>
<p>在Spring Boot中，要访问Redis，可以直接引入<code>spring-boot-starter-data-redis</code>依赖，它实际上是Spring Data的一个子项目——Spring Data Redis，主要用到了这几个组件：</p>
<ul>
<li>Lettuce：一个基于Netty的高性能Redis客户端；</li>
<li>RedisTemplate：一个类似于JdbcTemplate的接口，用于简化Redis的操作。</li>
</ul>
<p>因为Spring Data Redis引入的依赖项很多，如果只是为了使用Redis，完全可以只引入Lettuce，剩下的操作都自己来完成。</p>
<p>本节我们稍微深入一下Redis的客户端，看看怎么一步一步把一个第三方组件引入到Spring Boot中。</p>
<p>首先，我们添加必要的几个依赖项：</p>
<ul>
<li>io.lettuce:lettuce-core</li>
<li>org.apache.commons:commons-pool2</li>
</ul>
<p>注意我们并未指定版本号，因为在<code>spring-boot-starter-parent</code>中已经把常用组件的版本号确定下来了。</p>
<p>第一步是在配置文件<code>application.yml</code>中添加Redis的相关配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;REDIS_HOST:localhost&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;REDIS_PORT:6379&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;REDIS_PASSWORD:&#125;</span></span><br><span class="line">    <span class="attr">ssl:</span> <span class="string">$&#123;REDIS_SSL:false&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;REDIS_DATABASE:0&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后，通过<code>RedisConfiguration</code>来加载它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String host;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再编写一个<code>@Bean</code>方法来创建<code>RedisClient</code>，可以直接放在<code>RedisConfiguration</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RedisClient <span class="title function_">redisClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisURI</span> <span class="variable">uri</span> <span class="operator">=</span> RedisURI.Builder.redis(<span class="built_in">this</span>.host, <span class="built_in">this</span>.port)</span><br><span class="line">                .withPassword(<span class="built_in">this</span>.password)</span><br><span class="line">                .withDatabase(<span class="built_in">this</span>.database)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> RedisClient.create(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动入口引入该配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Import(RedisConfiguration.class)</span> <span class="comment">// 加载Redis配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果在<code>RedisConfiguration</code>中标注<code>@Configuration</code>，则可通过Spring Boot的自动扫描机制自动加载，否则，使用<code>@Import</code>手动加载。</p>
<p>紧接着，我们用一个<code>RedisService</code>来封装所有的Redis操作。基础代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    GenericObjectPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt; redisConnectionPool;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        GenericObjectPoolConfig&lt;StatefulRedisConnection&lt;String, String&gt;&gt; poolConfig = <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>&lt;&gt;();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">20</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">5</span>);</span><br><span class="line">        poolConfig.setTestOnReturn(<span class="literal">true</span>);</span><br><span class="line">        poolConfig.setTestWhileIdle(<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.redisConnectionPool = ConnectionPoolSupport.createGenericObjectPool(() -&gt; redisClient.connect(), poolConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisConnectionPool.close();</span><br><span class="line">        <span class="built_in">this</span>.redisClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到上述代码引入了Commons Pool的一个对象池，用于缓存Redis连接。因为Lettuce本身是基于Netty的异步驱动，在异步访问时并不需要创建连接池，但基于Servlet模型的同步访问时，连接池是有必要的。连接池在<code>@PostConstruct</code>方法中初始化，在<code>@PreDestroy</code>方法中关闭。</p>
<p>下一步，是在<code>RedisService</code>中添加Redis访问方法。为了简化代码，我们仿照<code>JdbcTemplate.execute(ConnectionCallback)</code>方法，传入回调函数，可大幅减少样板代码。</p>
<p>首先定义回调函数接口<code>SyncCommandCallback</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SyncCommandCallback</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 在此操作Redis:</span></span><br><span class="line">    T <span class="title function_">doInConnection</span><span class="params">(RedisCommands&lt;String, String&gt; commands)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写<code>executeSync</code>方法，在该方法中，获取Redis连接，利用callback操作Redis，最后释放连接，并返回操作结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">executeSync</span><span class="params">(SyncCommandCallback&lt;T&gt; callback)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = redisConnectionPool.borrowObject()) &#123;</span><br><span class="line">        connection.setAutoFlushCommands(<span class="literal">true</span>);</span><br><span class="line">        RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">        <span class="keyword">return</span> callback.doInConnection(commands);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;executeSync redis failed.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的童鞋觉得这样访问Redis的代码太复杂了，实际上我们可以针对常用操作把它封装一下，例如<code>set</code>和<code>get</code>命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.set(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，<code>hget</code>和<code>hset</code>操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String field, String value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.hset(key, field, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hget</span><span class="params">(String key, String field)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.hget(key, field));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">hgetall</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeSync(commands -&gt; commands.hgetall(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用命令可以提供方法接口，如果要执行任意复杂的操作，就可以通过<code>executeSync(SyncCommandCallback&lt;T&gt;)</code>来完成。</p>
<p>完成了<code>RedisService</code>后，我们就可以使用Redis了。例如，在<code>UserController</code>中，我们在Session中只存放登录用户的ID，用户信息存放到Redis，提供两个方法用于读写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_USER_ID</span> <span class="operator">=</span> <span class="string">&quot;__userid__&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_USERS</span> <span class="operator">=</span> <span class="string">&quot;__users__&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Autowired</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把User写入Redis:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">putUserIntoRedis</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        redisService.hset(KEY_USERS, user.getId().toString(), objectMapper.writeValueAsString(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Redis读取User:</span></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">getUserFromRedis</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> (Long) session.getAttribute(KEY_USER_ID);</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisService.hget(KEY_USERS, id.toString());</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> objectMapper.readValue(s, User.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户登录成功后，把ID放入Session，把<code>User</code>实例放入Redis：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSignin</span><span class="params">(<span class="meta">@RequestParam(&quot;email&quot;)</span> String email, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password, HttpSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.signin(email, password);</span><br><span class="line">        session.setAttribute(KEY_USER_ID, user.getId());</span><br><span class="line">        putUserIntoRedis(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;signin.html&quot;</span>, Map.of(<span class="string">&quot;email&quot;</span>, email, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;Signin failed&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;redirect:/profile&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要获取<code>User</code>时，从Redis取出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">profile</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getUserFromRedis(session);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;redirect:/signin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;profile.html&quot;</span>, Map.of(<span class="string">&quot;user&quot;</span>, user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Redis读写Java对象时，序列化和反序列化是应用程序的工作，上述代码使用JSON作为序列化方案，简单可靠。也可将相关序列化操作封装到<code>RedisService</code>中，这样可以提供更加通用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(String key, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">set</span><span class="params">(String key, T value)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习-11">练习</h3>
<p>在Spring Boot中访问Redis。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/redis/springboot-redis.zip">下载练习</a></p>
<h3 id="小结-11">小结</h3>
<p>Spring Boot默认使用Lettuce作为Redis客户端，同步使用时，应通过连接池提高效率。</p>
<h2 id="集成Artemis">集成Artemis</h2>
<p>ActiveMQ Artemis是一个JMS服务器，在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/jms/index.html">集成JMS</a>一节中我们已经详细讨论了如何在Spring中集成Artemis，本节我们讨论如何在Spring Boot中集成Artemis。</p>
<p>我们还是以实际工程为例，创建一个<code>springboot-jms</code>工程，引入的依赖除了<code>spring-boot-starter-web</code>，<code>spring-boot-starter-jdbc</code>等以外，新增<code>spring-boot-starter-artemis</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-artemis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样无需指定版本号。</p>
<p>如何创建Artemis服务器我们已经在集成JMS一节中详细讲述了，此处不再重复。创建Artemis服务器后，我们在<code>application.yml</code>中加入相关配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">artemis:</span></span><br><span class="line">    <span class="comment"># 指定连接外部Artemis服务器，而不是启动嵌入式服务:</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">native</span></span><br><span class="line">    <span class="comment"># 服务器地址和端口号:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">61616</span></span><br><span class="line">    <span class="comment"># 连接用户名和口令由创建Artemis服务器时指定:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>
<p>和Spring版本的JMS代码相比，使用Spring Boot集成JMS时，只要引入了<code>spring-boot-starter-artemis</code>，Spring Boot会自动创建JMS相关的<code>ConnectionFactory</code>、<code>JmsListenerContainerFactory</code>、<code>JmsTemplate</code>等，无需我们再手动配置了。</p>
<p>发送消息时只需要引入<code>JmsTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessagingService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMailMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">        jmsTemplate.send(<span class="string">&quot;jms/queue/mail&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageCreator</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Message <span class="title function_">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException &#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收消息时只需要标注<code>@JmsListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailMessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;jms/queue/mail&quot;, concurrency = &quot;10&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMailMessageReceived</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;received message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，应用程序收发消息的逻辑和Spring中使用JMS完全相同，只是通过Spring Boot，我们把工程简化到只需要设定Artemis相关配置。</p>
<h3 id="练习-12">练习</h3>
<p>在Spring Boot中使用Artemis。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/artemis/springboot-jms.zip">下载练习</a></p>
<h3 id="小结-12">小结</h3>
<p>在Spring Boot中使用Artemis作为JMS服务时，只需引入<code>spring-boot-starter-artemis</code>依赖，即可直接使用JMS。</p>
<hr>
<hr>
<p>前面我们讲了ActiveMQ Artemis，它实现了JMS的消息服务协议。JMS是JavaEE的消息服务标准接口，但是，如果Java程序要和另一种语言编写的程序通过消息服务器进行通信，那么JMS就不太适合了。</p>
<p>AMQP是一种使用广泛的独立于语言的消息协议，它的全称是Advanced Message Queuing Protocol，即高级消息队列协议，它定义了一种二进制格式的消息流，任何编程语言都可以实现该协议。实际上，Artemis也支持AMQP，但实际应用最广泛的AMQP服务器是使用<a target="_blank" rel="noopener" href="https://www.erlang.org/">Erlang</a>编写的<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">RabbitMQ</a>。</p>
<h3 id="安装RabbitMQ">安装RabbitMQ</h3>
<p>我们先从RabbitMQ的官网<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/download.html">下载</a>并安装RabbitMQ，安装和启动RabbitMQ请参考官方文档。要验证启动是否成功，可以访问RabbitMQ的管理后台<a target="_blank" rel="noopener" href="http://localhost:15672/">http://localhost:15672</a>，如能看到登录界面表示RabbitMQ启动成功：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/rabbitmq.jpg" alt="rabbitmq-manage"></p>
<p>RabbitMQ后台管理的默认用户名和口令均为<code>guest</code>。</p>
<h3 id="AMQP协议">AMQP协议</h3>
<p>AMQP协议和前面我们介绍的JMS协议有所不同。在JMS中，有两种类型的消息通道：</p>
<ol>
<li>点对点的Queue，即Producer发送消息到指定的Queue，接收方从Queue收取消息；</li>
<li>一对多的Topic，即Producer发送消息到指定的Topic，任意多个在线的接收方均可从Topic获得一份完整的消息副本。</li>
</ol>
<p>但是AMQP协议比JMS要复杂一点，它只有Queue，没有Topic，并且引入了Exchange的概念。当Producer想要发送消息的时候，它将消息发送给Exchange，由Exchange将消息根据各种规则投递到一个或多个Queue：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                                    ┌───────┐</span><br><span class="line">                                ┌──▶│Queue-1│</span><br><span class="line">                  ┌──────────┐  │   └───────┘</span><br><span class="line">              ┌──▶│Exchange-1│──┤</span><br><span class="line">┌──────────┐  │   └──────────┘  │   ┌───────┐</span><br><span class="line">│Producer-1│──┤                 ├──▶│Queue-2│</span><br><span class="line">└──────────┘  │   ┌──────────┐  │   └───────┘</span><br><span class="line">              └──▶│Exchange-2│──┤</span><br><span class="line">                  └──────────┘  │   ┌───────┐</span><br><span class="line">                                └──▶│Queue-3│</span><br><span class="line">                                    └───────┘</span><br></pre></td></tr></table></figure>
<p>如果某个Exchange总是把消息发送到固定的Queue，那么这个消息通道就相当于JMS的Queue。如果某个Exchange把消息发送到多个Queue，那么这个消息通道就相当于JMS的Topic。和JMS的Topic相比，Exchange的投递规则更灵活，比如一个“登录成功”的消息被投递到Queue-1和Queue-2，而“登录失败”的消息则被投递到Queue-3。这些路由规则称之为Binding，通常都在RabbitMQ的管理后台设置。</p>
<p>我们以具体的业务为例子，在RabbitMQ中，首先创建3个Queue，分别用于发送邮件、短信和App通知：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/queue.jpg" alt="queues"></p>
<p>创建Queue时注意到可配置为持久化（Durable）和非持久化（Transient），当Consumer不在线时，持久化的Queue会暂存消息，非持久化的Queue会丢弃消息。</p>
<p>紧接着，我们在Exchanges中创建一个Direct类型的Exchange，命名为<code>registration</code>，并添加如下两个Binding：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/exchange.png" alt="exchange-registration"></p>
<p>上述Binding的规则就是：凡是发送到<code>registration</code>这个Exchange的消息，均被发送到<code>q_mail</code>和<code>q_sms</code>这两个Queue。</p>
<p>我们再创建一个Direct类型的Exchange，命名为<code>login</code>，并添加如下Binding：</p>
<p><img src="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/exchange2.png" alt="exchange-login"></p>
<p>上述Binding的规则稍微复杂一点，当发送消息给<code>login</code>这个Exchange时，如果消息没有指定Routing Key，则被投递到<code>q_app</code>和<code>q_mail</code>，如果消息指定了Routing Key=“login_failed”，那么消息被投递到<code>q_sms</code>。</p>
<p>配置好RabbitMQ后，我们就可以基于Spring Boot开发AMQP程序。</p>
<h3 id="使用RabbitMQ">使用RabbitMQ</h3>
<p>我们首先创建Spring Boot工程<code>springboot-rabbitmq</code>，并添加如下依赖引入RabbitMQ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在<code>application.yml</code>中添加RabbitMQ相关配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>
<p>我们还需要在<code>Application</code>中添加一个<code>MessageConverter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    MessageConverter <span class="title function_">createMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MessageConverter</code>用于将Java对象转换为RabbitMQ的消息。默认情况下，Spring Boot使用<code>SimpleMessageConverter</code>，只能发送<code>String</code>和<code>byte[]</code>类型的消息，不太方便。使用<code>Jackson2JsonMessageConverter</code>，我们就可以发送JavaBean对象，由Spring Boot自动序列化为JSON并以文本消息传递。</p>
<p>因为引入了starter，所有RabbitMQ相关的Bean均自动装配，我们需要在Producer注入的是<code>RabbitTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessagingService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRegistrationMessage</span><span class="params">(RegistrationMessage msg)</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;registration&quot;</span>, <span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLoginMessage</span><span class="params">(LoginMessage msg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> msg.success ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;login_failed&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;login&quot;</span>, routingKey, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息时，使用<code>convertAndSend(exchange, routingKey, message)</code>可以指定Exchange、Routing Key以及消息本身。这里传入JavaBean后会自动序列化为JSON文本。上述代码将<code>RegistrationMessage</code>发送到<code>registration</code>，将<code>LoginMessage</code>发送到<code>login</code>，并根据登录是否成功来指定Routing Key。</p>
<p>接收消息时，需要在消息处理的方法上标注<code>@RabbitListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueMessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_MAIL</span> <span class="operator">=</span> <span class="string">&quot;q_mail&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_SMS</span> <span class="operator">=</span> <span class="string">&quot;q_sms&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_APP</span> <span class="operator">=</span> <span class="string">&quot;q_app&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_MAIL)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRegistrationMessageFromMailQueue</span><span class="params">(RegistrationMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received registration message: &#123;&#125;&quot;</span>, QUEUE_MAIL, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_SMS)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRegistrationMessageFromSmsQueue</span><span class="params">(RegistrationMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received registration message: &#123;&#125;&quot;</span>, QUEUE_SMS, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_MAIL)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginMessageFromMailQueue</span><span class="params">(LoginMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received message: &#123;&#125;&quot;</span>, QUEUE_MAIL, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_SMS)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginMessageFromSmsQueue</span><span class="params">(LoginMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received message: &#123;&#125;&quot;</span>, QUEUE_SMS, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = QUEUE_APP)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginMessageFromAppQueue</span><span class="params">(LoginMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;queue &#123;&#125; received message: &#123;&#125;&quot;</span>, QUEUE_APP, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码一共定义了5个Consumer，监听3个Queue。</p>
<p>启动应用程序，我们注册一个新用户，然后发送一条<code>RegistrationMessage</code>消息。此时，根据<code>registration</code>这个Exchange的设定，我们会在两个Queue收到消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try register by bob@example.com...</span><br><span class="line">... c.i.learnjava.web.UserController         : user registered: bob@example.com</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_mail received registration message: [RegistrationMessage: email=bob@example.com, name=Bob, timestamp=1594559871495]</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_sms received registration message: [RegistrationMessage: email=bob@example.com, name=Bob, timestamp=1594559871495]</span><br></pre></td></tr></table></figure>
<p>当我们登录失败时，发送<code>LoginMessage</code>并设定Routing Key为<code>login_failed</code>，此时，只有<code>q_sms</code>会收到消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try login by bob@example.com...</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_sms received message: [LoginMessage: email=bob@example.com, name=(unknown), success=false, timestamp=1594559886722]</span><br></pre></td></tr></table></figure>
<p>登录成功后，发送<code>LoginMessage</code>，此时，<code>q_mail</code>和<code>q_app</code>将收到消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try login by bob@example.com...</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_mail received message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594559895251]</span><br><span class="line">... c.i.l.service.QueueMessageListener       : queue q_app received message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594559895251]</span><br></pre></td></tr></table></figure>
<p>RabbitMQ还提供了使用Topic的Exchange（此Topic指消息的标签，并非JMS的Topic概念），可以使用<code>*</code>进行匹配并路由。可见，掌握RabbitMQ的核心是理解其消息的路由规则。</p>
<p>直接指定一个Queue并投递消息也是可以的，此时指定Routing Key为Queue的名称即可，因为RabbitMQ提供了一个<code>default exchange</code>用于根据Routing Key查找Queue并直接投递消息到指定的Queue。但是要实现一对多的投递就必须自己配置Exchange。</p>
<h3 id="练习-13">练习</h3>
<p>在Spring Boot中使用RabbitMQ。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/rabbitmq/springboot-rabbitmq.zip">下载练习</a></p>
<h3 id="小结-13">小结</h3>
<p>Spring Boot提供了AMQP的集成，默认使用RabbitMQ作为AMQP消息服务器。</p>
<p>使用RabbitMQ发送消息时，理解Exchange如何路由至一个或多个Queue至关重要。</p>
<p>我们在前面已经介绍了JMS和AMQP，JMS是JavaEE的标准消息接口，Artemis是一个JMS实现产品，AMQP是跨语言的一个标准消息接口，RabbitMQ是一个AMQP实现产品。</p>
<p>Kafka也是一个消息服务器，它的特点一是快，二是有巨大的吞吐量，那么Kafka实现了什么标准消息接口呢？</p>
<p>Kafka没有实现任何标准的消息接口，它自己提供的API就是Kafka的接口。</p>
<blockquote>
<p>哥没有实现任何标准，哥自己就是标准。</p>
<p>—— Kafka</p>
</blockquote>
<p>Kafka本身是Scala编写的，运行在JVM之上。Producer和Consumer都通过Kafka的客户端使用网络来与之通信。从逻辑上讲，Kafka设计非常简单，它只有一种类似JMS的Topic的消息通道：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                           ┌──────────┐</span><br><span class="line">                       ┌──▶│Consumer-1│</span><br><span class="line">                       │   └──────────┘</span><br><span class="line">┌────────┐    ┌─────┐  │   ┌──────────┐</span><br><span class="line">│Producer│───▶│Topic│──┼──▶│Consumer-2│</span><br><span class="line">└────────┘    └─────┘  │   └──────────┘</span><br><span class="line">                       │   ┌──────────┐</span><br><span class="line">                       └──▶│Consumer-3│</span><br><span class="line">                           └──────────┘</span><br></pre></td></tr></table></figure>
<p>那么Kafka如何支持十万甚至百万的并发呢？答案是分区。Kafka的一个Topic可以有一个至多个Partition，并且可以分布到多台机器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">            ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">             Topic</span><br><span class="line">            │                   │</span><br><span class="line">                ┌───────────┐        ┌──────────┐</span><br><span class="line">            │┌─▶│Partition-1│──┐│┌──▶│Consumer-1│</span><br><span class="line">             │  └───────────┘  │ │   └──────────┘</span><br><span class="line">┌────────┐  ││  ┌───────────┐  │││   ┌──────────┐</span><br><span class="line">│Producer│───┼─▶│Partition-2│──┼─┼──▶│Consumer-2│</span><br><span class="line">└────────┘  ││  └───────────┘  │││   └──────────┘</span><br><span class="line">             │  ┌───────────┐  │ │   ┌──────────┐</span><br><span class="line">            │└─▶│Partition-3│──┘│└──▶│Consumer-3│</span><br><span class="line">                └───────────┘        └──────────┘</span><br><span class="line">            └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>Kafka只保证在一个Partition内部，消息是有序的，但是，存在多个Partition的情况下，Producer发送的3个消息会依次发送到Partition-1、Partition-2和Partition-3，Consumer从3个Partition接收的消息并不一定是Producer发送的顺序，因此，多个Partition只能保证接收消息大概率按发送时间有序，并不能保证完全按Producer发送的顺序。这一点在使用Kafka作为消息服务器时要特别注意，对发送顺序有严格要求的Topic只能有一个Partition。</p>
<p>Kafka的另一个特点是消息发送和接收都尽量使用批处理，一次处理几十甚至上百条消息，比一次一条效率要高很多。</p>
<p>最后要注意的是消息的持久性。Kafka总是将消息写入Partition对应的文件，消息保存多久取决于服务器的配置，可以按照时间删除（默认3天），也可以按照文件大小删除，因此，只要Consumer在离线期内的消息还没有被删除，再次上线仍然可以接收到完整的消息流。这一功能实际上是客户端自己实现的，客户端会存储它接收到的最后一个消息的offsetId，再次上线后按上次的offsetId查询。offsetId是Kafka标识某个Partion的每一条消息的递增整数，客户端通常将它存储在ZooKeeper中。</p>
<p>有了Kafka消息设计的基本概念，我们来看看如何在Spring Boot中使用Kafka。</p>
<h3 id="安装Kafka">安装Kafka</h3>
<p>首先从Kafka官网<a target="_blank" rel="noopener" href="https://kafka.apache.org/downloads">下载</a>最新版Kafaka，解压后在<code>bin</code>目录找到两个文件：</p>
<ul>
<li><code>zookeeper-server-start.sh</code>：启动ZooKeeper（已内置在Kafka中）；</li>
<li><code>kafka-server-start.sh</code>：启动Kafka。</li>
</ul>
<p>先启动ZooKeeper：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./zookeeper-server-start.sh ../config/zookeeper.properties </span><br></pre></td></tr></table></figure>
<p>再启动Kafka：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-server-start.sh ../config/server.properties</span><br></pre></td></tr></table></figure>
<p>看到如下输出表示启动成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... INFO [KafkaServer id=0] started (kafka.server.KafkaServer)</span><br></pre></td></tr></table></figure>
<p>如果要关闭Kafka和ZooKeeper，依次按Ctrl-C退出即可。注意这是在本地开发时使用Kafka的方式，线上Kafka服务推荐使用云服务厂商托管模式（AWS的MSK，阿里云的消息队列Kafka版）。</p>
<h3 id="使用Kafka">使用Kafka</h3>
<p>在Spring Boot中使用Kafka，首先要引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这个依赖是<code>spring-kafka</code>项目提供的。</p>
<p>然后，在<code>application.yml</code>中添加Kafka配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">latest</span></span><br><span class="line">      <span class="attr">max-poll-records:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">max-partition-fetch-bytes:</span> <span class="number">1000000</span></span><br></pre></td></tr></table></figure>
<p>除了<code>bootstrap-servers</code>必须指定外，<code>consumer</code>相关的配置项均为调优选项。例如，<code>max-poll-records</code>表示一次最多抓取100条消息。配置名称去哪里看？IDE里定义一个<code>KafkaProperties.Consumer</code>的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KafkaProperties.<span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>然后按住Ctrl查看源码即可。</p>
<h3 id="发送消息">发送消息</h3>
<p>Spring Boot自动为我们创建一个<code>KafkaTemplate</code>用于发送消息。注意到这是一个泛型类，而默认配置总是使用<code>String</code>作为Kafka消息的类型，所以注入<code>KafkaTemplate&lt;String, String&gt;</code>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessagingService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRegistrationMessage</span><span class="params">(RegistrationMessage msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        send(<span class="string">&quot;topic_registration&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLoginMessage</span><span class="params">(LoginMessage msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        send(<span class="string">&quot;topic_login&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String topic, Object msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ProducerRecord&lt;String, String&gt; pr = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, objectMapper.writeValueAsString(msg));</span><br><span class="line">        pr.headers().add(<span class="string">&quot;type&quot;</span>, msg.getClass().getName().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        kafkaTemplate.send(pr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息时，需指定Topic名称，消息正文。为了发送一个JavaBean，这里我们没有使用<code>MessageConverter</code>来转换JavaBean，而是直接把消息类型作为Header添加到消息中，Header名称为<code>type</code>，值为Class全名。消息正文是序列化的JSON。</p>
<h3 id="接收消息">接收消息</h3>
<p>接收消息可以使用<code>@KafkaListener</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicMessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;topic_registration&quot;, groupId = &quot;group1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRegistrationMessage</span><span class="params">(<span class="meta">@Payload</span> String message, <span class="meta">@Header(&quot;type&quot;)</span> String type)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">RegistrationMessage</span> <span class="variable">msg</span> <span class="operator">=</span> objectMapper.readValue(message, getType(type));</span><br><span class="line">        logger.info(<span class="string">&quot;received registration message: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;topic_login&quot;, groupId = &quot;group1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoginMessage</span><span class="params">(<span class="meta">@Payload</span> String message, <span class="meta">@Header(&quot;type&quot;)</span> String type)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">LoginMessage</span> <span class="variable">msg</span> <span class="operator">=</span> objectMapper.readValue(message, getType(type));</span><br><span class="line">        logger.info(<span class="string">&quot;received login message: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;topic_login&quot;, groupId = &quot;group2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processLoginMessage</span><span class="params">(<span class="meta">@Payload</span> String message, <span class="meta">@Header(&quot;type&quot;)</span> String type)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">LoginMessage</span> <span class="variable">msg</span> <span class="operator">=</span> objectMapper.readValue(message, getType(type));</span><br><span class="line">        logger.info(<span class="string">&quot;process login message: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Class&lt;T&gt; <span class="title function_">getType</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> use cache:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Class&lt;T&gt;) Class.forName(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接收消息的方法中，使用<code>@Payload</code>表示传入的是消息正文，使用<code>@Header</code>可传入消息的指定Header，这里传入<code>@Header(&quot;type&quot;)</code>，就是我们发送消息时指定的Class全名。接收消息时，我们需要根据Class全名来反序列化获得JavaBean。</p>
<p>上述代码一共定义了3个Listener，其中有两个方法监听的是同一个Topic，但它们的Group ID不同。假设Producer发送的消息流是A、B、C、D，Group ID不同表示这是两个不同的Consumer，它们将分别收取完整的消息流，即各自均收到A、B、C、D。Group ID相同的多个Consumer实际上被视作一个Consumer，即如果有两个Group ID相同的Consumer，那么它们各自收到的很可能是A、C和B、D。</p>
<p>运行应用程序，注册新用户后，观察日志输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try register by bob@example.com...</span><br><span class="line">... c.i.learnjava.web.UserController         : user registered: bob@example.com</span><br><span class="line">... c.i.l.service.TopicMessageListener       : received registration message: [RegistrationMessage: email=bob@example.com, name=Bob, timestamp=1594637517458]</span><br></pre></td></tr></table></figure>
<p>用户登录后，观察日志输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">... c.i.learnjava.service.UserService        : try login by bob@example.com...</span><br><span class="line">... c.i.l.service.TopicMessageListener       : received login message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594637523470]</span><br><span class="line">... c.i.l.service.TopicMessageListener       : process login message: [LoginMessage: email=bob@example.com, name=Bob, success=true, timestamp=1594637523470]</span><br></pre></td></tr></table></figure>
<p>因为Group ID不同，同一个消息被两个Consumer分别独立接收。如果把Group ID改为相同，那么同一个消息只会被两者之一接收。</p>
<p>有细心的童鞋可能会问，在Kafka中是如何创建Topic的？又如何指定某个Topic的分区数量？</p>
<p>实际上开发使用的Kafka默认允许自动创建Topic，创建Topic时默认的分区数量是2，可以通过<code>server.properties</code>修改默认分区数量。</p>
<p>在生产环境中通常会关闭自动创建功能，Topic需要由运维人员先创建好。和RabbitMQ相比，Kafka并不提供网页版管理后台，管理Topic需要使用命令行，比较繁琐，只有云服务商通常会提供更友好的管理后台。</p>
<h3 id="练习-14">练习</h3>
<p>在Spring Boot中使用Kafka。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/springboot/integration/kafka/springboot-kafka.zip">下载练习</a></p>
<h3 id="小结-14">小结</h3>
<p>Spring Boot通过<code>KafkaTemplate</code>发送消息，通过<code>@KafkaListener</code>接收消息；</p>
<p>配置Consumer时，指定Group ID非常重要。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/26/java/JAVA-Spring-Boot%E5%BC%80%E5%8F%91/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"
                            aria-label=": JAVA-Spring开发-集成第三方组件"
                        >
                            JAVA-Spring开发-集成第三方组件
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T16:41:16+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Spring框架不仅提供了标准的IoC容器、AOP支持、数据库访问以及WebMVC等标准功能，还可以非常方便地集成许多常用的第三方组件：</p>
<ul>
<li>可以集成JavaMail发送邮件；</li>
<li>可以集成JMS消息服务；</li>
<li>可以集成Quartz实现定时任务；</li>
<li>可以集成Redis等服务。</li>
</ul>
<p>本章我们介绍如何在Spring中简单快捷地集成这些第三方组件。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/send-email/index.html">发送Email</a>和<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/receive-email/index.html">接收Email</a>中已经介绍了如何通过JavaMail来收发电子邮件。在Spring中，同样可以集成JavaMail。</p>
<p>因为在服务器端，主要以发送邮件为主，例如在注册成功、登录时、购物付款后通知用户，基本上不会遇到接收用户邮件的情况，所以本节我们只讨论如何在Spring中发送邮件。</p>
<p>在Spring中，发送邮件最终也是需要JavaMail，Spring只对JavaMail做了一点简单的封装，目的是简化代码。为了在Spring中集成JavaMail，我们在<code>pom.xml</code>中添加以下依赖：</p>
<ul>
<li>org.springframework:spring-context-support:6.0.0</li>
<li>jakarta.mail:jakarta.mail-api:2.0.1</li>
<li>com.sun.mail:jakarta.mail:2.0.1</li>
</ul>
<p>以及其他Web相关依赖。</p>
<p>我们希望用户在注册成功后能收到注册邮件，为此，我们先定义一个<code>JavaMailSender</code>的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">JavaMailSender <span class="title function_">createJavaMailSender</span><span class="params">(</span></span><br><span class="line"><span class="params">        // smtp.properties:</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.host&#125;&quot;)</span> String host,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.port&#125;&quot;)</span> <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.auth&#125;&quot;)</span> String auth,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.username&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.password&#125;&quot;)</span> String password,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;smtp.debug:true&#125;&quot;)</span> String debug)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">mailSender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaMailSenderImpl</span>();</span><br><span class="line">    mailSender.setHost(host);</span><br><span class="line">    mailSender.setPort(port);</span><br><span class="line">    mailSender.setUsername(username);</span><br><span class="line">    mailSender.setPassword(password);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> mailSender.getJavaMailProperties();</span><br><span class="line">    props.put(<span class="string">&quot;mail.transport.protocol&quot;</span>, <span class="string">&quot;smtp&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;mail.smtp.auth&quot;</span>, auth);</span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">587</span>) &#123;</span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.starttls.enable&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">465</span>) &#123;</span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.socketFactory.port&quot;</span>, <span class="string">&quot;465&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.socketFactory.class&quot;</span>, <span class="string">&quot;javax.net.ssl.SSLSocketFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    props.put(<span class="string">&quot;mail.debug&quot;</span>, debug);</span><br><span class="line">    <span class="keyword">return</span> mailSender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>JavaMailSender</code>接口的实现类是<code>JavaMailSenderImpl</code>，初始化时，传入的参数与JavaMail是完全一致的。</p>
<p>另外注意到需要注入的属性是从<code>smtp.properties</code>中读取的，因此，<code>AppConfig</code>导入的就不止一个<code>.properties</code>文件，可以导入多个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/smtp.properties&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步是封装一个<code>MailService</code>，并定义<code>sendRegistrationMail()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.from&#125;&quot;)</span></span><br><span class="line">    String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRegistrationMail</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            helper.setFrom(from);</span><br><span class="line">            helper.setTo(user.getEmail());</span><br><span class="line">            helper.setSubject(<span class="string">&quot;Welcome to Java course!&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> String.format(<span class="string">&quot;&lt;p&gt;Hi, %s,&lt;/p&gt;&lt;p&gt;Welcome to Java course!&lt;/p&gt;&lt;p&gt;Sent at %s&lt;/p&gt;&quot;</span>, user.getName(), LocalDateTime.now());</span><br><span class="line">            helper.setText(html, <span class="literal">true</span>);</span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，<code>MimeMessage</code>是JavaMail的邮件对象，而<code>MimeMessageHelper</code>是Spring提供的用于简化设置MimeMessage的类，比如我们设置HTML邮件就可以直接调用<code>setText(String text, boolean html)</code>方法，而不必再调用比较繁琐的JavaMail接口方法。</p>
<p>最后一步是调用<code>JavaMailSender.send()</code>方法把邮件发送出去。</p>
<p>在MVC的某个Controller方法中，当用户注册成功后，我们就启动一个新线程来异步发送邮件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.register(email, password, name);</span><br><span class="line">logger.info(<span class="string">&quot;user registered: &#123;&#125;&quot;</span>, user.getEmail());</span><br><span class="line"><span class="comment">// send registration mail:</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    mailService.sendRegistrationMail(user);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>因为发送邮件是一种耗时的任务，从几秒到几分钟不等，因此，异步发送是保证页面能快速显示的必要措施。这里我们直接启动了一个新的线程，但实际上还有更优化的方法，我们在下一节讨论。</p>
<h3 id="练习">练习</h3>
<p>使用Spring发送邮件。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/javamail/spring-integration-mail.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>Spring可以集成JavaMail，通过简单的封装，能简化邮件发送代码。其核心是定义一个<code>JavaMailSender</code>的Bean，然后调用其<code>send()</code>方法。</p>
<p>JMS即Java Message Service，是JavaEE的消息服务接口。JMS主要有两个版本：1.1和2.0。2.0和1.1相比，主要是简化了收发消息的代码。</p>
<p>所谓消息服务，就是两个进程之间，通过消息服务器传递消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌────────┐    ┌──────────────┐    ┌────────┐</span><br><span class="line">│Producer│───▶│Message Server│───▶│Consumer│</span><br><span class="line">└────────┘    └──────────────┘    └────────┘</span><br></pre></td></tr></table></figure>
<p>使用消息服务，而不是直接调用对方的API，它的好处是：</p>
<ul>
<li>双方各自无需知晓对方的存在，消息可以异步处理，因为消息服务器会在Consumer离线的时候自动缓存消息；</li>
<li>如果Producer发送的消息频率高于Consumer的处理能力，消息可以积压在消息服务器，不至于压垮Consumer；</li>
<li>通过一个消息服务器，可以连接多个Producer和多个Consumer。</li>
</ul>
<p>因为消息服务在各类应用程序中非常有用，所以JavaEE专门定义了JMS规范。注意到JMS是一组接口定义，如果我们要使用JMS，还需要选择一个具体的JMS产品。常用的JMS服务器有开源的<a target="_blank" rel="noopener" href="https://activemq.apache.org/">ActiveMQ</a>，商业服务器如WebLogic、WebSphere等也内置了JMS支持。这里我们选择开源的ActiveMQ作为JMS服务器，因此，在开发JMS之前我们必须首先安装ActiveMQ。</p>
<p>现在问题来了：从官网下载ActiveMQ时，蹦出一个页面，让我们选择ActiveMQ Classic或者ActiveMQ Artemis，这两个是什么关系，又有什么区别？</p>
<p>实际上ActiveMQ Classic原来就叫ActiveMQ，是Apache开发的基于JMS 1.1的消息服务器，目前稳定版本号是5.x，而ActiveMQ Artemis是由RedHat捐赠的<a target="_blank" rel="noopener" href="https://hornetq.jboss.org/">HornetQ</a>服务器代码的基础上开发的，目前稳定版本号是2.x。和ActiveMQ Classic相比，Artemis版的代码与Classic完全不同，并且，它支持JMS 2.0，使用基于Netty的异步IO，大大提升了性能。此外，Artemis不仅提供了JMS接口，它还提供了AMQP接口，STOMP接口和物联网使用的MQTT接口。选择Artemis，相当于一鱼四吃。</p>
<p>所以，我们这里直接选择ActiveMQ Artemis。从官网<a target="_blank" rel="noopener" href="https://activemq.apache.org/components/artemis/download/">下载</a>最新的2.x版本，解压后设置环境变量<code>ARTEMIS_HOME</code>，指向Artemis根目录，例如<code>C:\Apps\artemis</code>，然后，把<code>ARTEMIS_HOME/bin</code>加入PATH环境变量：</p>
<ul>
<li>Windows下添加<code>%ARTEMIS_HOME%\bin</code>到Path路径；</li>
<li>Mac和Linux下添加<code>$ARTEMIS_HOME/bin</code>到PATH路径。</li>
</ul>
<p>Artemis有个很好的设计，就是它把程序和数据完全分离了。我们解压后的<code>ARTEMIS_HOME</code>目录是程序目录，要启动一个Artemis服务，还需要创建一个数据目录。我们把数据目录直接设定在项目<code>spring-integration-jms</code>的<code>jms-data</code>目录下。执行命令<code>artemis create jms-data</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/Users/liaoxuefeng/workspace/spring-integration-jms</span><br><span class="line"></span><br><span class="line">$ artemis create jms-data</span><br><span class="line">Creating ActiveMQ Artemis instance at: /Users/liaoxuefeng/workspace/spring-integration-jms/jms-data</span><br><span class="line"></span><br><span class="line">--user: is a mandatory property!</span><br><span class="line">Please provide the default username:</span><br><span class="line">admin</span><br><span class="line"></span><br><span class="line">--password: is mandatory with this configuration:</span><br><span class="line">Please provide the default password:</span><br><span class="line">********</span><br><span class="line"></span><br><span class="line">--allow-anonymous | --require-login: is a mandatory property!</span><br><span class="line">Allow anonymous access?, valid values are Y,N,True,False</span><br><span class="line">N</span><br><span class="line"></span><br><span class="line">Auto tuning journal ...</span><br><span class="line">done! Your system can make 0.09 writes per millisecond, your journal-buffer-timeout will be 11392000</span><br><span class="line"></span><br><span class="line">You can now start the broker by executing:  </span><br><span class="line"></span><br><span class="line">   &quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis&quot; run</span><br><span class="line"></span><br><span class="line">Or you can run the broker in the background using:</span><br><span class="line"></span><br><span class="line">   &quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis-service&quot; start</span><br></pre></td></tr></table></figure>
<p>在创建过程中，会要求输入连接用户和口令，这里我们设定<code>admin</code>和<code>password</code>，以及是否允许匿名访问（这里选择<code>N</code>）。</p>
<p>此数据目录<code>jms-data</code>不仅包含消息数据、日志，还自动创建了两个启动服务的命令<code>bin/artemis</code>和<code>bin/artemis-service</code>，前者在前台启动运行，按Ctrl+C结束，后者会一直在后台运行。</p>
<p>我们把目录切换到<code>jms-data/bin</code>，直接运行<code>artemis run</code>即可启动Artemis服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./artemis run</span><br><span class="line">     _        _               _</span><br><span class="line">    / \  ____| |_  ___ __  __(_) _____</span><br><span class="line">   / _ \|  _ \ __|/ _ \  \/  | |/  __/</span><br><span class="line">  / ___ \ | \/ |_/  __/ |\/| | |\___ \</span><br><span class="line"> /_/   \_\|   \__\____|_|  |_|_|/___ /</span><br><span class="line"> Apache ActiveMQ Artemis 2.13.0</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2020-06-02 07:50:21,718 INFO  [org.apache.activemq.artemis] AMQ241001: HTTP Server started at http://localhost:8161</span><br><span class="line">2020-06-02 07:50:21,718 INFO  [org.apache.activemq.artemis] AMQ241002: Artemis Jolokia REST API available at http://localhost:8161/console/jolokia</span><br><span class="line">2020-06-02 07:50:21,719 INFO  [org.apache.activemq.artemis] AMQ241004: Artemis Console available at http://localhost:8161/console</span><br></pre></td></tr></table></figure>
<p>启动成功后，Artemis提示可以通过URL<code>http://localhost:8161/console</code>访问管理后台。注意<em>不要关闭命令行窗口</em>。</p>
<p>注意</p>
<p>如果Artemis启动时显示警告：AMQ222212: Disk Full! … Clients will report blocked.这是因为磁盘空间不够，可以在etc/broker.xml配置中找到并改为99。</p>
<p>在编写JMS代码之前，我们首先得理解JMS的消息模型。JMS把生产消息的一方称为Producer，处理消息的一方称为Consumer。有两种类型的消息通道，一种是Queue：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌────────┐    ┌────────┐    ┌────────┐</span><br><span class="line">│Producer│───▶│ Queue  │───▶│Consumer│</span><br><span class="line">└────────┘    └────────┘    └────────┘</span><br></pre></td></tr></table></figure>
<p>一种是Topic：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                            ┌────────┐</span><br><span class="line">                         ┌─▶│Consumer│</span><br><span class="line">                         │  └────────┘</span><br><span class="line">┌────────┐    ┌────────┐ │  ┌────────┐</span><br><span class="line">│Producer│───▶│ Topic  │─┼─▶│Consumer│</span><br><span class="line">└────────┘    └────────┘ │  └────────┘</span><br><span class="line">                         │  ┌────────┐</span><br><span class="line">                         └─▶│Consumer│</span><br><span class="line">                            └────────┘</span><br></pre></td></tr></table></figure>
<p>它们的区别在于，Queue是一种一对一的通道，如果Consumer离线无法处理消息时，Queue会把消息存起来，等Consumer再次连接的时候发给它。设定了持久化机制的Queue不会丢失消息。如果有多个Consumer接入同一个Queue，那么它们等效于以集群方式处理消息，例如，发送方发送的消息是A，B，C，D，E，F，两个Consumer可能分别收到A，C，E和B，D，F，即每个消息只会交给其中一个Consumer处理。</p>
<p>Topic则是一种一对多通道。一个Producer发出的消息，会被多个Consumer同时收到，即每个Consumer都会收到一份完整的消息流。那么问题来了：如果某个Consumer暂时离线，过一段时间后又上线了，那么在它离线期间产生的消息还能不能收到呢？</p>
<p>这取决于消息服务器对Topic类型消息的持久化机制。如果消息服务器不存储Topic消息，那么离线的Consumer会丢失部分离线时期的消息，如果消息服务器存储了Topic消息，那么离线的Consumer可以收到自上次离线时刻开始后产生的所有消息。JMS规范通过Consumer指定一个持久化订阅可以在上线后收取所有离线期间的消息，如果指定的是非持久化订阅，那么离线期间的消息会全部丢失。</p>
<p>细心的童鞋可以看出来，如果一个Topic的消息全部都持久化了，并且只有一个Consumer，那么它和Queue其实是一样的。实际上，很多消息服务器内部都只有Topic类型的消息架构，Queue可以通过Topic“模拟”出来。</p>
<p>无论是Queue还是Topic，对Producer没有什么要求。多个Producer也可以写入同一个Queue或者Topic，此时消息服务器内部会自动排序确保消息总是有序的。</p>
<p>以上是消息服务的基本模型。具体到某个消息服务器时，Producer和Consumer通常是通过TCP连接消息服务器，在编写JMS程序时，又会遇到<code>ConnectionFactory</code>、<code>Connection</code>、<code>Session</code>等概念，其实这和JDBC连接是类似的：</p>
<ul>
<li>ConnectionFactory：代表一个到消息服务器的连接池，类似JDBC的DataSource；</li>
<li>Connection：代表一个到消息服务器的连接，类似JDBC的Connection；</li>
<li>Session：代表一个经过认证后的连接会话；</li>
<li>Message：代表一个消息对象。</li>
</ul>
<p>在JMS 1.1中，发送消息的典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建连接:</span></span><br><span class="line">        connection = connectionFactory.createConnection();</span><br><span class="line">        <span class="comment">// 创建会话:</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">// 创建一个Producer并关联到某个Queue:</span></span><br><span class="line">        <span class="type">MessageProducer</span> <span class="variable">messageProducer</span> <span class="operator">=</span> session.createProducer(queue);</span><br><span class="line">        <span class="comment">// 创建一个文本消息:</span></span><br><span class="line">        <span class="type">TextMessage</span> <span class="variable">textMessage</span> <span class="operator">=</span> session.createTextMessage(text);</span><br><span class="line">        <span class="comment">// 发送消息:</span></span><br><span class="line">        messageProducer.send(textMessage);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭连接:</span></span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException ex) &#123;</span><br><span class="line">    <span class="comment">// 处理JMS异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JMS 2.0改进了一些API接口，发送消息变得更简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">JMSContext</span> <span class="variable">context</span> <span class="operator">=</span> connectionFactory.createContext()) &#123;</span><br><span class="line">    context.createProducer().send(queue, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JMSContext</code>实现了<code>AutoCloseable</code>接口，可以使用<code>try(resource)</code>语法，代码更简单。</p>
<p>有了以上预备知识，我们就可以开始开发JMS应用了。</p>
<p>首先，我们在<code>pom.xml</code>中添加如下依赖：</p>
<ul>
<li>org.springframework:spring-jms:6.0.0</li>
<li>org.apache.activemq:artemis-jakarta-client:2.27.0</li>
</ul>
<p>Artemis的Client接口依赖了<code>jakarta.jms:jakarta.jms-api</code>，因此不必再引入JMS API的依赖。</p>
<p>在AppConfig中，通过<code>@EnableJms</code>让Spring自动扫描JMS相关的Bean，并加载JMS配置文件<code>jms.properties</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableJms</span> <span class="comment">// 启用JMS</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/jms.properties&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要创建的Bean是<code>ConnectionFactory</code>，即连接消息服务器的连接池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ConnectionFactory <span class="title function_">createJMSConnectionFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@Value(&quot;$&#123;jms.uri:tcp://localhost:61616&#125;&quot;)</span> String uri,</span></span><br><span class="line"><span class="params">    <span class="meta">@Value(&quot;$&#123;jms.username:admin&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">    <span class="meta">@Value(&quot;$&#123;jms.password:password&#125;&quot;)</span> String password)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveMQJMSConnectionFactory</span>(uri, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们使用的消息服务器是ActiveMQ Artemis，所以<code>ConnectionFactory</code>的实现类就是消息服务器提供的<code>ActiveMQJMSConnectionFactory</code>，它需要的参数均由配置文件读取后传入，并设置了默认值。</p>
<p>我们再创建一个<code>JmsTemplate</code>，它是Spring提供的一个工具类，和<code>JdbcTemplate</code>类似，可以简化发送消息的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">JmsTemplate <span class="title function_">createJmsTemplate</span><span class="params">(<span class="meta">@Autowired</span> ConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JmsTemplate</span>(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步要创建的是<code>JmsListenerContainerFactory</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;jmsListenerContainerFactory&quot;)</span></span><br><span class="line">DefaultJmsListenerContainerFactory <span class="title function_">createJmsListenerContainerFactory</span><span class="params">(<span class="meta">@Autowired</span> ConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultJmsListenerContainerFactory</span>();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了必须指定Bean的名称为<code>jmsListenerContainerFactory</code>外，这个Bean的作用是处理和Consumer相关的Bean。我们先跳过它的原理，继续编写<code>MessagingService</code>来发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessagingService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Autowired</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMailMessage</span><span class="params">(MailMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> objectMapper.writeValueAsString(msg);</span><br><span class="line">        jmsTemplate.send(<span class="string">&quot;jms/queue/mail&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageCreator</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Message <span class="title function_">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException &#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JMS的消息类型支持以下几种：</p>
<ul>
<li>TextMessage：文本消息；</li>
<li>BytesMessage：二进制消息；</li>
<li>MapMessage：包含多个Key-Value对的消息；</li>
<li>ObjectMessage：直接序列化Java对象的消息；</li>
<li>StreamMessage：一个包含基本类型序列的消息。</li>
</ul>
<p>最常用的是发送基于JSON的文本消息，上述代码通过<code>JmsTemplate</code>创建一个<code>TextMessage</code>并发送到名称为<code>jms/queue/mail</code>的Queue。</p>
<p>注意：Artemis消息服务器默认配置下会自动创建Queue，因此不必手动创建一个名为<code>jms/queue/mail</code>的Queue，但不是所有的消息服务器都会自动创建Queue，生产环境的消息服务器通常会关闭自动创建功能，需要手动创建Queue。</p>
<p>再注意到<code>MailMessage</code>是我们自己定义的一个JavaBean，真正的JMS消息是创建的<code>TextMessage</code>，它的内容是JSON。</p>
<p>当用户注册成功后，我们就调用<code>MessagingService.sendMailMessage()</code>发送一条JMS消息，此代码十分简单，这里不再贴出。</p>
<p>下面我们要详细讨论的是如何处理消息，即编写Consumer。从理论上讲，可以创建另一个Java进程来处理消息，但对于我们这个简单的Web程序来说没有必要，直接在同一个Web应用中接收并处理消息即可。</p>
<p>处理消息的核心代码是编写一个Bean，并在处理方法上标注<code>@JmsListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailMessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Autowired</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;jms/queue/mail&quot;, concurrency = &quot;10&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMailMessageReceived</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;received message: &quot;</span> + message);</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> TextMessage) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> ((TextMessage) message).getText();</span><br><span class="line">            <span class="type">MailMessage</span> <span class="variable">mm</span> <span class="operator">=</span> objectMapper.readValue(text, MailMessage.class);</span><br><span class="line">            mailService.sendRegistrationMail(mm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;unable to process non-text message!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>@JmsListener</code>指定了Queue的名称，因此，凡是发到此Queue的消息都会被这个<code>onMailMessageReceived()</code>方法处理，方法参数是JMS的<code>Message</code>接口，我们通过强制转型为<code>TextMessage</code>并提取JSON，反序列化后获得自定义的JavaBean，也就获得了发送邮件所需的所有信息。</p>
<p>下面问题来了：Spring处理JMS消息的流程是什么？</p>
<p>如果我们直接调用JMS的API来处理消息，那么编写的代码大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建JMS连接:</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.createConnection();</span><br><span class="line"><span class="comment">// 创建会话:</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">// 创建一个Consumer:</span></span><br><span class="line"><span class="type">MessageConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> session.createConsumer(queue);</span><br><span class="line"><span class="comment">// 为Consumer指定一个消息处理器:</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处理消息... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 启动接收消息的循环:</span></span><br><span class="line">connection.start();</span><br></pre></td></tr></table></figure>
<p>我们自己编写的<code>MailMessageListener.onMailMessageReceived()</code>相当于消息处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        mailMessageListener.onMailMessageReceived(message); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所以，Spring根据<code>AppConfig</code>的注解<code>@EnableJms</code>自动扫描带有<code>@JmsListener</code>的Bean方法，并为其创建一个<code>MessageListener</code>把它包装起来。</p>
<p>注意到前面我们还创建了一个<code>JmsListenerContainerFactory</code>的Bean，它的作用就是为每个<code>MessageListener</code>创建<code>MessageConsumer</code>并启动消息接收循环。</p>
<p>再注意到<code>@JmsListener</code>还有一个<code>concurrency</code>参数，10表示可以最多同时并发处理10个消息，<code>5-10</code>表示并发处理的线程可以在5~10之间调整。</p>
<p>因此，Spring在通过<code>MessageListener</code>接收到消息后，并不是直接调用<code>mailMessageListener.onMailMessageReceived()</code>，而是用线程池调用，因此，要时刻牢记，<code>onMailMessageReceived()</code>方法可能被多线程并发执行，一定要保证线程安全。</p>
<p>我们总结一下Spring接收消息的步骤：</p>
<p>通过<code>JmsListenerContainerFactory</code>配合<code>@EnableJms</code>扫描所有<code>@JmsListener</code>方法，自动创建<code>MessageConsumer</code>、<code>MessageListener</code>以及线程池，启动消息循环接收处理消息，最终由我们自己编写的<code>@JmsListener</code>方法处理消息，可能会由多线程同时并发处理。</p>
<p>要验证消息发送和处理，我们注册一个新用户，可以看到如下日志输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> 08:<span class="number">04</span>:<span class="number">27</span> INFO  c.i.learnjava.web.UserController - user registered: bob<span class="meta">@example</span>.com</span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> 08:<span class="number">04</span>:<span class="number">27</span> INFO  c.i.l.service.MailMessageListener - received message: ActiveMQMessage[ID:9fc5...]:PERSISTENT/ClientMessageImpl[messageID=<span class="number">983</span>, durable=<span class="literal">true</span>, address=jms/queue/mail, ...]]</span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> 08:<span class="number">04</span>:<span class="number">27</span> INFO  c.i.learnjava.service.MailService - [send mail] sending registration mail to bob<span class="meta">@example</span>.com...</span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> 08:<span class="number">04</span>:<span class="number">30</span> INFO  c.i.learnjava.service.MailService - [send mail] registration mail was sent to bob<span class="meta">@example</span>.com.</span><br></pre></td></tr></table></figure>
<p>可见，消息被成功发送到Artemis，然后在很短的时间内被接收处理了。</p>
<p>使用消息服务对发送Email进行改造的好处是，发送Email的能力通常是有限的，通过JMS消息服务，如果短时间内需要给大量用户发送Email，可以先把消息堆积在JMS服务器上慢慢发送，对于批量发送邮件、短信等尤其有用。</p>
<h3 id="练习-2">练习</h3>
<p>使用JMS。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/jms/spring-integration-jms.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>JMS是Java消息服务，可以通过JMS服务器实现消息的异步处理。</p>
<p>消息服务主要解决Producer和Consumer生产和处理速度不匹配的问题。</p>
<p>在很多应用程序中，经常需要执行定时任务。例如，每天或每月给用户发送账户汇总报表，定期检查并发送系统状态报告，等等。</p>
<p>定时任务我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/threading/pool/index.html">使用线程池</a>一节中已经讲到了，Java标准库本身就提供了定时执行任务的功能。在Spring中，使用定时任务更简单，不需要手写线程池相关代码，只需要两个注解即可。</p>
<p>我们还是以实际代码为例，建立工程<code>spring-integration-schedule</code>，无需额外的依赖，我们可以直接在<code>AppConfig</code>中加上<code>@EnableScheduling</code>就开启了定时任务的支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot;, &quot;classpath:/task.properties&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们可以直接在一个Bean中编写一个<code>public void</code>无参数方法，然后加上<code>@Scheduled</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 60_000, fixedRate = 60_000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkSystemStatusEveryMinute</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Start check system status...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述注解指定了启动延迟60秒，并以60秒的间隔执行任务。现在，我们直接运行应用程序，就可以在控制台看到定时任务打印的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-06-03 18:47:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...</span><br><span class="line">2020-06-03 18:48:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...</span><br><span class="line">2020-06-03 18:49:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start check system status...</span><br></pre></td></tr></table></figure>
<p>如果没有看到定时任务的日志，需要检查：</p>
<ul>
<li>是否忘记了在<code>AppConfig</code>中标注<code>@EnableScheduling</code>；</li>
<li>是否忘记了在定时任务的方法所在的class标注<code>@Component</code>。</li>
</ul>
<p>除了可以使用<code>fixedRate</code>外，还可以使用<code>fixedDelay</code>，两者的区别我们已经在使用线程池一节中讲过，这里不再重复。</p>
<p>有的童鞋在实际开发中会遇到一个问题，因为Java的注解全部是常量，写死了<code>fixedDelay=30000</code>，如果根据实际情况要改成60秒怎么办，只能重新编译？</p>
<p>我们可以把定时任务的配置放到配置文件中，例如<code>task.properties</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task.checkDiskSpace=30000</span><br></pre></td></tr></table></figure>
<p>这样就可以随时修改配置文件而无需动代码。但是在代码中，我们需要用<code>fixedDelayString</code>取代<code>fixedDelay</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:30000&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkDiskSpaceEveryMinute</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Start check disk space...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到上述代码的注解参数<code>fixedDelayString</code>是一个属性占位符，并配有默认值30000，Spring在处理<code>@Scheduled</code>注解时，如果遇到<code>String</code>，会根据占位符自动用配置项替换，这样就可以灵活地修改定时任务的配置。</p>
<p>此外，<code>fixedDelayString</code>还可以使用更易读的<code>Duration</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:PT2M30S&#125;&quot;)</span></span><br></pre></td></tr></table></figure>
<p>以字符串<code>PT2M30S</code>表示的<code>Duration</code>就是2分30秒，请参考<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/datetime/local-datetime/index.html">LocalDateTime</a>一节的Duration相关部分。</p>
<p>多个<code>@Scheduled</code>方法完全可以放到一个Bean中，这样便于统一管理各类定时任务。</p>
<h3 id="使用Cron任务">使用Cron任务</h3>
<p>还有一类定时任务，它不是简单的重复执行，而是按时间触发，我们把这类任务称为Cron任务，例如：</p>
<ul>
<li>每天凌晨2:15执行报表任务；</li>
<li>每个工作日12:00执行特定任务；</li>
<li>……</li>
</ul>
<p>Cron源自Unix/Linux系统自带的crond守护进程，以一个简洁的表达式定义任务触发时间。在Spring中，也可以使用Cron表达式来执行Cron任务，在Spring中，它的格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">秒 分 小时 天 月份 星期 年</span><br></pre></td></tr></table></figure>
<p>年是可以忽略的，通常不写。每天凌晨2:15执行的Cron表达式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 15 2 * * *</span><br></pre></td></tr></table></figure>
<p>每个工作日12:00执行的Cron表达式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 12 * * MON-FRI</span><br></pre></td></tr></table></figure>
<p>每个月1号，2号，3号和10号12:00执行的Cron表达式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 12 1-3,10 * *</span><br></pre></td></tr></table></figure>
<p>在Spring中，我们定义一个每天凌晨2:15执行的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;$&#123;task.report:0 15 2 * * *&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cronDailyReport</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Start daily report task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cron任务同样可以使用属性占位符，这样修改起来更加方便。</p>
<p>Cron表达式还可以表达每10分钟执行，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 */10 * * * *</span><br></pre></td></tr></table></figure>
<p>这样，在每个小时的0:00，10:00，20:00，30:00，40:00，50:00均会执行任务，实际上它可以取代<code>fixedRate</code>类型的定时任务。</p>
<h3 id="集成Quartz">集成Quartz</h3>
<p>在Spring中使用定时任务和Cron任务都十分简单，但是要注意到，这些任务的调度都是在每个JVM进程中的。如果在本机启动两个进程，或者在多台机器上启动应用，这些进程的定时任务和Cron任务都是独立运行的，互不影响。</p>
<p>如果一些定时任务要以集群的方式运行，例如每天23:00执行检查任务，只需要集群中的一台运行即可，这个时候，可以考虑使用<a target="_blank" rel="noopener" href="https://www.quartz-scheduler.org/">Quartz</a>。</p>
<p>Quartz可以配置一个JDBC数据源，以便存储所有的任务调度计划以及任务执行状态。也可以使用内存来调度任务，但这样配置就和使用Spring的调度没啥区别了，额外集成Quartz的意义就不大。</p>
<p>Quartz的JDBC配置比较复杂，Spring对其也有一定的支持。要详细了解Quartz的集成，请参考<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-quartz">Spring的文档</a>。</p>
<p>思考：如果不使用Quartz的JDBC配置，多个Spring应用同时运行时，如何保证某个任务只在某一台机器执行？</p>
<h3 id="练习-3">练习</h3>
<p>使用Scheduler执行定时任务。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/scheduler/spring-integration-schedule.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>Spring内置定时任务和Cron任务的支持，编写调度任务十分方便。</p>
<p>在Spring中，可以方便地集成JMX。</p>
<p>那么第一个问题来了：什么是JMX？</p>
<p>JMX是Java Management Extensions，它是一个Java平台的管理和监控接口。为什么要搞JMX呢？因为在所有的应用程序中，对运行中的程序进行监控都是非常重要的，Java应用程序也不例外。我们肯定希望知道Java应用程序当前的状态，例如，占用了多少内存，分配了多少内存，当前有多少活动线程，有多少休眠线程等等。如何获取这些信息呢？</p>
<p>为了标准化管理和监控，Java平台使用JMX作为管理和监控的标准接口，任何程序，只要按JMX规范访问这个接口，就可以获取所有管理与监控信息。</p>
<p>实际上，常用的运维监控如Zabbix、Nagios等工具对JVM本身的监控都是通过JMX获取的信息。</p>
<p>因为JMX是一个标准接口，不但可以用于管理JVM，还可以管理应用程序自身。下图是JMX的架构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    ┌─────────┐  ┌─────────┐</span><br><span class="line">    │jconsole │  │   Web   │</span><br><span class="line">    └─────────┘  └─────────┘</span><br><span class="line">         │            │</span><br><span class="line">┌ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─</span><br><span class="line"> JVM     ▼            ▼        │</span><br><span class="line">│   ┌─────────┐  ┌─────────┐</span><br><span class="line">  ┌─┤Connector├──┤ Adaptor ├─┐ │</span><br><span class="line">│ │ └─────────┘  └─────────┘ │</span><br><span class="line">  │       MBeanServer        │ │</span><br><span class="line">│ │ ┌──────┐┌──────┐┌──────┐ │</span><br><span class="line">  └─┤MBean1├┤MBean2├┤MBean3├─┘ │</span><br><span class="line">│   └──────┘└──────┘└──────┘</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>JMX把所有被管理的资源都称为MBean（Managed Bean），这些MBean全部由MBeanServer管理，如果要访问MBean，可以通过MBeanServer对外提供的访问接口，例如通过RMI或HTTP访问。</p>
<p>注意到使用JMX不需要安装任何额外组件，也不需要第三方库，因为MBeanServer已经内置在JavaSE标准库中了。JavaSE还提供了一个<code>jconsole</code>程序，用于通过RMI连接到MBeanServer，这样就可以管理整个Java进程。</p>
<p>除了JVM会把自身的各种资源以MBean注册到JMX中，我们自己的配置、监控信息也可以作为MBean注册到JMX，这样，管理程序就可以直接控制我们暴露的MBean。因此，应用程序使用JMX，只需要两步：</p>
<ol>
<li>编写MBean提供管理接口和监控数据；</li>
<li>注册MBean。</li>
</ol>
<p>在Spring应用程序中，使用JMX只需要一步：</p>
<ol>
<li>编写MBean提供管理接口和监控数据。</li>
</ol>
<p>第二步注册的过程由Spring自动完成。我们以实际工程为例，首先在<code>AppConfig</code>中加上<code>@EnableMBeanExport</code>注解，告诉Spring自动注册MBean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableMBeanExport</span> <span class="comment">// 自动注册MBean</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&#123; &quot;classpath:/jdbc.properties&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的全部工作就是编写MBean。我们以实际问题为例，假设我们希望给应用程序添加一个IP黑名单功能，凡是在黑名单中的IP禁止访问，传统的做法是定义一个配置文件，启动的时候读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># blacklist.txt</span><br><span class="line">1.2.3.4</span><br><span class="line">5.6.7.8</span><br><span class="line">2.2.3.4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果要修改黑名单怎么办？修改配置文件，然后重启应用程序。</p>
<p>但是每次都重启应用程序实在是太麻烦了，能不能不重启应用程序？可以自己写一个定时读取配置文件的功能，检测到文件改动时自动重新读取。</p>
<p>上述需求本质上是在应用程序运行期间对参数、配置等进行热更新并要求尽快生效。如果以JMX的方式实现，我们不必自己编写自动重新读取等任何代码，只需要提供一个符合JMX标准的MBean来存储配置即可。</p>
<p>还是以IP黑名单为例，JMX的MBean通常以MBean结尾，因此我们遵循标准命名规范，首先编写一个<code>BlacklistMBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistMBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; ips = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getBlacklist() &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBlacklist</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        ips.add(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBlacklist</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        ips.remove(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldBlock</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.contains(ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个MBean没什么特殊的，它的逻辑和普通Java类没有任何区别。</p>
<p>下一步，我们要使用JMX的客户端来实时热更新这个MBean，所以要给它加上一些注解，让Spring能根据注解自动把相关方法注册到MBeanServer中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ManagedResource(objectName = &quot;sample:name=blacklist&quot;, description = &quot;Blacklist of IP addresses&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistMBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; ips = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManagedAttribute(description = &quot;Get IP addresses in blacklist&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBlacklist() &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManagedOperation</span></span><br><span class="line">    <span class="meta">@ManagedOperationParameter(name = &quot;ip&quot;, description = &quot;Target IP address that will be added to blacklist&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBlacklist</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        ips.add(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManagedOperation</span></span><br><span class="line">    <span class="meta">@ManagedOperationParameter(name = &quot;ip&quot;, description = &quot;Target IP address that will be removed from blacklist&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBlacklist</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        ips.remove(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldBlock</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.contains(ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，<code>BlacklistMBean</code>首先是一个标准的Spring管理的Bean，其次，添加了<code>@ManagedResource</code>表示这是一个MBean，将要被注册到JMX。objectName指定了这个MBean的名字，通常以<code>company:name=Xxx</code>来分类MBean。</p>
<p>对于属性，使用<code>@ManagedAttribute</code>注解标注。上述MBean只有get属性，没有set属性，说明这是一个只读属性。</p>
<p>对于操作，使用<code>@ManagedOperation</code>注解标准。上述MBean定义了两个操作：<code>addBlacklist()</code>和<code>removeBlacklist()</code>，其他方法如<code>shouldBlock()</code>不会被暴露给JMX。</p>
<p>使用MBean和普通Bean是完全一样的。例如，我们在<code>BlacklistInterceptor</code>对IP进行黑名单拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BlacklistMBean blacklistMBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">        logger.info(<span class="string">&quot;check ip address &#123;&#125;...&quot;</span>, ip);</span><br><span class="line">        <span class="comment">// 是否在黑名单中:</span></span><br><span class="line">        <span class="keyword">if</span> (blacklistMBean.shouldBlock(ip)) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;will block ip &#123;&#125; for it is in blacklist.&quot;</span>, ip);</span><br><span class="line">            <span class="comment">// 发送403错误响应:</span></span><br><span class="line">            response.sendError(<span class="number">403</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步就是正常启动Web应用程序，不要关闭它，我们打开另一个命令行窗口，输入<code>jconsole</code>启动JavaSE自带的一个JMX客户端程序：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/jconsole.png" alt="jconsole"></p>
<p>通过jconsole连接到一个Java进程最简单的方法是直接在Local Process中找到正在运行的<code>AppConfig</code>，点击Connect即可连接到我们当前正在运行的Web应用，在jconsole中可直接看到内存、CPU等资源的监控。</p>
<p>我们点击MBean，左侧按分类列出所有MBean，可以在<code>java.lang</code>查看内存等信息：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbeans.png" alt="mbean"></p>
<p>细心的童鞋可以看到HikariCP连接池也是通过JMX监控的。</p>
<p>在<code>sample</code>中可以看到我们自己的MBean，点击可查看属性<code>blacklist</code>：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/my-mbean.png" alt="mbean-value"></p>
<p>点击<code>Operations</code>-<code>addBlacklist</code>，可以填入<code>127.0.0.1</code>并点击<code>addBlacklist</code>按钮，相当于jconsole通过JMX接口，调用了我们自己的<code>BlacklistMBean</code>的<code>addBlacklist()</code>方法，传入的参数就是填入的<code>127.0.0.1</code>：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbean-edit.png" alt="mbean-invoke-ok"></p>
<p>再次查看属性<code>blacklist</code>，可以看到结果已经更新了：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbean-attr.png" alt="mbean-modified"></p>
<p>我们可以在浏览器中测试一下黑名单功能是否已生效：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/integration/jmx/mbean-enabled.png" alt="403"></p>
<p>可见，<code>127.0.0.1</code>确实被添加到了黑名单，后台日志打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-06-06 20:22:12 INFO  c.i.l.web.BlacklistInterceptor - check ip address 127.0.0.1...</span><br><span class="line">2020-06-06 20:22:12 WARN  c.i.l.web.BlacklistInterceptor - will block ip 127.0.0.1 for it is in blacklist.</span><br></pre></td></tr></table></figure>
<p>注意：如果使用IPv6，那么需要把<code>0:0:0:0:0:0:0:1</code>这个本机地址加到黑名单。</p>
<p>如果从jconsole中调用<code>removeBlacklist</code>移除<code>127.0.0.1</code>，刷新浏览器可以看到又允许访问了。</p>
<p>使用jconsole直接通过Local Process连接JVM有个限制，就是jconsole和正在运行的JVM必须在同一台机器。如果要远程连接，首先要打开JMX端口。我们在启动<code>AppConfig</code>时，需要传入以下JVM启动参数：</p>
<ul>
<li>-Dcom.sun.management.jmxremote.port=19999</li>
<li>-Dcom.sun.management.jmxremote.authenticate=false</li>
<li>-Dcom.sun.management.jmxremote.ssl=false</li>
</ul>
<p>第一个参数表示在19999端口监听JMX连接，第二个和第三个参数表示无需验证，不使用SSL连接，在开发测试阶段比较方便，生产环境必须指定验证方式并启用SSL。详细参数可参考Oracle<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html#gdeum">官方文档</a>。这样jconsole可以用<code>ip:19999</code>的远程方式连接JMX。连接后的操作是完全一样的。</p>
<p>许多JavaEE服务器如JBoss的管理后台都是通过JMX提供管理接口，并由Web方式访问，对用户更加友好。</p>
<p>在实际项目中，通过JMX实现配置的实时更新其实并不常用，JMX更多地用于收集JVM的运行状态和应用程序的性能数据，然后通过监控服务器汇总数据后实现监控与报警。一个典型的监控系统架构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐   ┌───────────────┐</span><br><span class="line">│  Web Console  │◀──│Metrics Server │</span><br><span class="line">└───────────────┘   └───────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │</span><br><span class="line">   ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ┐</span><br><span class="line">     ┌───────────────┐      │</span><br><span class="line">   │ │      App      │      │    │</span><br><span class="line">     ├─────────┬─────┤   ┌─────┐</span><br><span class="line">   │ │         │ JMX │──▶│Agent│ │</span><br><span class="line">     │         └─────┤   └─────┘</span><br><span class="line">   │ │      JVM      │           │</span><br><span class="line">     └───────────────┘</span><br><span class="line">   └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>其中，App自身和JVM的的统计数据都通过JMX收集并发送给本机的一个Agent，Agent再将数据发送至监控服务器，最后以可视化的形式将监控数据通过Web等形式展示给用户。常用的监控系统有开源的<a target="_blank" rel="noopener" href="https://prometheus.io/">Prometheus</a>和以云服务方式提供的<a target="_blank" rel="noopener" href="https://www.datadoghq.com/">DataDog</a>等。</p>
<h3 id="练习-4">练习</h3>
<p>编写一个MBean统计当前注册用户数量，并在jconsole中查看：</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/integration/jmx/spring-integration-jmx.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>在Spring中使用JMX需要：</p>
<ul>
<li>通过<code>@EnableMBeanExport</code>启用自动注册MBean；</li>
<li>编写MBean并实现管理属性和管理操作。</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/"
                            aria-label=": JAVA-Spring开发-开发Web应用"
                        >
                            JAVA-Spring开发-开发Web应用
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T16:40:47+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/index.html">Web开发</a>一章中，我们已经详细介绍了JavaEE中Web开发的基础：Servlet。具体地说，有以下几点：</p>
<ol>
<li>Servlet规范定义了几种标准组件：Servlet、JSP、Filter和Listener；</li>
<li>Servlet的标准组件总是运行在Servlet容器中，如Tomcat、Jetty、WebLogic等。</li>
</ol>
<p>直接使用Servlet进行Web开发好比直接在JDBC上操作数据库，比较繁琐，更好的方法是在Servlet基础上封装MVC框架，基于MVC开发Web应用，大部分时候，不需要接触Servlet API，开发省时省力。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/mvc/index.html">MVC开发</a>和<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/mvc-adv/index.html">MVC高级开发</a>已经由浅入深地介绍了如何编写MVC框架。当然，自己写的MVC主要是理解原理，要实现一个功能全面的MVC需要大量的工作以及广泛的测试。</p>
<p>因此，开发Web应用，首先要选择一个优秀的MVC框架。常用的MVC框架有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://struts.apache.org/">Struts</a>：最古老的一个MVC框架，目前版本是2，和1.x有很大的区别；</li>
<li>WebWork：一个比Struts设计更优秀的MVC框架，但不知道出于什么原因，从2.0开始把自己的代码全部塞给Struts 2了；</li>
<li><a target="_blank" rel="noopener" href="https://turbine.apache.org/">Turbine</a>：一个重度使用Velocity，强调布局的MVC框架；</li>
<li>其他100+MVC框架……（略）</li>
</ul>
<p>Spring虽然都可以集成任何Web框架，但是，Spring本身也开发了一个MVC框架，就叫<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html">Spring MVC</a>。这个MVC框架设计得足够优秀以至于我们已经不想再费劲去集成类似Struts这样的框架了。</p>
<p>本章我们会详细介绍如何基于Spring MVC开发Web应用。</p>
<p>我们已经介绍了Java Web的基础：Servlet容器，以及标准的Servlet组件：</p>
<ul>
<li>Servlet：能处理HTTP请求并将HTTP响应返回；</li>
<li>JSP：一种嵌套Java代码的HTML，将被编译为Servlet；</li>
<li>Filter：能过滤指定的URL以实现拦截功能；</li>
<li>Listener：监听指定的事件，如ServletContext、HttpSession的创建和销毁。</li>
</ul>
<p>此外，Servlet容器为每个Web应用程序自动创建一个唯一的<code>ServletContext</code>实例，这个实例就代表了Web应用程序本身。</p>
<p>在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/mvc-adv/index.html">MVC高级开发</a>中，我们手撸了一个MVC框架，接口和Spring MVC类似。如果直接使用Spring MVC，我们写出来的代码类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">signin</span><span class="params">(<span class="meta">@RequestParam(&quot;email&quot;)</span> String email, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，Spring提供的是一个IoC容器，所有的Bean，包括Controller，都在Spring IoC容器中被初始化，而Servlet容器由JavaEE服务器提供（如Tomcat），Servlet容器对Spring一无所知，他们之间到底依靠什么进行联系，又是以何种顺序初始化的？</p>
<p>在理解上述问题之前，我们先把基于Spring MVC开发的项目结构搭建起来。首先创建基于Web的Maven工程，引入如下依赖：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
<li>org.springframework:spring-webmvc:6.0.0</li>
<li>org.springframework:spring-jdbc:6.0.0</li>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
<li>io.pebbletemplates:pebble-spring6:3.2.0</li>
<li>ch.qos.logback:logback-core:1.4.4</li>
<li>ch.qos.logback:logback-classic:1.4.4</li>
<li>com.zaxxer:HikariCP:5.0.1</li>
<li>org.hsqldb:hsqldb:2.7.0</li>
</ul>
<p>以及<code>provided</code>依赖：</p>
<ul>
<li>org.apache.tomcat.embed:tomcat-embed-core:10.1.1</li>
<li>org.apache.tomcat.embed:tomcat-embed-jasper:10.1.1</li>
</ul>
<p>这个标准的Maven Web工程目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">spring-web-mvc</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java</span><br><span class="line">        │               ├── DatabaseInitializer.java</span><br><span class="line">        │               ├── entity</span><br><span class="line">        │               │   └── User.java</span><br><span class="line">        │               ├── service</span><br><span class="line">        │               │   └── UserService.java</span><br><span class="line">        │               └── web</span><br><span class="line">        │                   └── UserController.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   ├── jdbc.properties</span><br><span class="line">        │   └── logback.xml</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   ├── templates</span><br><span class="line">            │   │   ├── _base.html</span><br><span class="line">            │   │   ├── index.html</span><br><span class="line">            │   │   ├── profile.html</span><br><span class="line">            │   │   ├── register.html</span><br><span class="line">            │   │   └── signin.html</span><br><span class="line">            │   └── web.xml</span><br><span class="line">            └── static</span><br><span class="line">                ├── css</span><br><span class="line">                │   └── bootstrap.css</span><br><span class="line">                └── js</span><br><span class="line">                    └── jquery.js</span><br></pre></td></tr></table></figure>
<p>其中，<code>src/main/webapp</code>是标准web目录，<code>WEB-INF</code>存放<code>web.xml</code>，编译的class，第三方jar，以及不允许浏览器直接访问的View模版，<code>static</code>目录存放所有静态文件。</p>
<p>在<code>src/main/resources</code>目录中存放的是Java程序读取的classpath资源文件，除了JDBC的配置文件<code>jdbc.properties</code>外，我们又新增了一个<code>logback.xml</code>，这是Logback的默认查找的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.itranswarp.learnjava&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面给出了一个写入到标准输出的Logback配置，可以基于上述配置添加写入到文件的配置。</p>
<p>在<code>src/main/java</code>中就是我们编写的Java代码了。</p>
<h3 id="配置Spring-MVC">配置Spring MVC</h3>
<p>和普通Spring配置一样，我们编写正常的<code>AppConfig</code>后，只需加上<code>@EnableWebMvc</code>注解，就“激活”了Spring MVC：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span> <span class="comment">// 启用Spring MVC</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了创建<code>DataSource</code>、<code>JdbcTemplate</code>、<code>PlatformTransactionManager</code>外，<code>AppConfig</code>需要额外创建几个用于Spring MVC的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">WebMvcConfigurer <span class="title function_">createWebMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">            registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>).addResourceLocations(<span class="string">&quot;/static/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WebMvcConfigurer</code>并不是必须的，但我们在这里创建一个默认的<code>WebMvcConfigurer</code>，只覆写<code>addResourceHandlers()</code>，目的是让Spring MVC自动处理静态文件，并且映射路径为<code>/static/**</code>。</p>
<p>另一个必须要创建的Bean是<code>ViewResolver</code>，因为Spring MVC允许集成任何模板引擎，使用哪个模板引擎，就实例化一个对应的<code>ViewResolver</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ViewResolver <span class="title function_">createViewResolver</span><span class="params">(<span class="meta">@Autowired</span> ServletContext servletContext)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PebbleEngine</span>.Builder().autoEscaping(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// cache:</span></span><br><span class="line">            .cacheActive(<span class="literal">false</span>)</span><br><span class="line">            <span class="comment">// loader:</span></span><br><span class="line">            .loader(<span class="keyword">new</span> <span class="title class_">Servlet5Loader</span>(servletContext))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="type">var</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PebbleViewResolver</span>(engine);</span><br><span class="line">    viewResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">    viewResolver.setSuffix(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ViewResolver</code>通过指定<code>prefix</code>和<code>suffix</code>来确定如何查找View。上述配置使用Pebble引擎，指定模板文件存放在<code>/WEB-INF/templates/</code>目录下。</p>
<p>剩下的Bean都是普通的<code>@Component</code>，但Controller必须标记为<code>@Controller</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller使用@Controller标记而不是@Component:</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// 正常使用@Autowired注入:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理一个URL映射:</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是普通的Java应用程序，我们通过<code>main()</code>方法可以很简单地创建一个Spring容器的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是问题来了，现在是Web应用程序，而Web应用程序总是由Servlet容器创建，那么，Spring容器应该由谁创建？在什么时候创建？Spring容器中的Controller又是如何通过Servlet调用的？</p>
<p>在Web应用中启动Spring容器有很多种方法，可以通过Listener启动，也可以通过Servlet启动，可以使用XML配置，也可以使用注解配置。这里，我们只介绍一种<em>最简单</em>的启动Spring容器的方式。</p>
<p>第一步，我们在<code>web.xml</code>中配置Spring MVC提供的<code>DispatcherServlet</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itranswarp.learnjava.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>初始化参数<code>contextClass</code>指定使用注解配置的<code>AnnotationConfigWebApplicationContext</code>，配置文件的位置参数<code>contextConfigLocation</code>指向<code>AppConfig</code>的完整类名，最后，把这个Servlet映射到<code>/*</code>，即处理所有URL。</p>
<p>上述配置可以看作一个样板配置，有了这个配置，Servlet容器会首先初始化Spring MVC的<code>DispatcherServlet</code>，在<code>DispatcherServlet</code>启动时，它根据配置<code>AppConfig</code>创建了一个类型是<code>WebApplicationContext</code>的IoC容器，完成所有Bean的初始化，并将容器绑到<code>ServletContext</code>上。</p>
<p>因为<code>DispatcherServlet</code>持有IoC容器，能从IoC容器中获取所有<code>@Controller</code>的Bean，因此，<code>DispatcherServlet</code>接收到所有HTTP请求后，根据Controller方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的<code>ModelAndView</code>决定如何渲染页面。</p>
<p>最后，我们在<code>AppConfig</code>中通过<code>main()</code>方法启动嵌入式Tomcat：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">    tomcat.setPort(Integer.getInteger(<span class="string">&quot;port&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">    tomcat.getConnector();</span><br><span class="line">    <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> tomcat.addWebapp(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/main/webapp&quot;</span>).getAbsolutePath());</span><br><span class="line">    <span class="type">WebResourceRoot</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardRoot</span>(ctx);</span><br><span class="line">    resources.addPreResources(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DirResourceSet</span>(resources, <span class="string">&quot;/WEB-INF/classes&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target/classes&quot;</span>).getAbsolutePath(), <span class="string">&quot;/&quot;</span>));</span><br><span class="line">    ctx.setResources(resources);</span><br><span class="line">    tomcat.start();</span><br><span class="line">    tomcat.getServer().await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述Web应用程序就是我们使用Spring MVC时的一个最小启动功能集。由于使用了JDBC和数据库，用户的注册、登录信息会被持久化：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/mvc/spring-mvc.png" alt="spring-mvc"></p>
<h3 id="编写Controller">编写Controller</h3>
<p>有了Web应用程序的最基本的结构，我们的重点就可以放在如何编写Controller上。Spring MVC对Controller没有固定的要求，也不需要实现特定的接口。以<code>UserController</code>为例，编写Controller只需要遵循以下要点：</p>
<p>总是标记<code>@Controller</code>而不是<code>@Component</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个方法对应一个HTTP请求路径，用<code>@GetMapping</code>或<code>@PostMapping</code>表示GET或POST请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSignin</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;email&quot;)</span> String email,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;password&quot;)</span> String password,</span></span><br><span class="line"><span class="params">        HttpSession session)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要接收的HTTP参数以<code>@RequestParam()</code>标注，可以设置默认值。如果方法参数需要传入<code>HttpServletRequest</code>、<code>HttpServletResponse</code>或者<code>HttpSession</code>，直接添加这个类型的参数即可，Spring MVC会自动按类型传入。</p>
<p>返回的ModelAndView通常包含View的路径和一个Map作为Model，但也可以没有Model，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;signin.html&quot;</span>); <span class="comment">// 仅View，没有Model</span></span><br></pre></td></tr></table></figure>
<p>返回重定向时既可以写<code>new ModelAndView(&quot;redirect:/signin&quot;)</code>，也可以直接返回String：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/signin&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/profile&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在方法内部直接操作<code>HttpServletResponse</code>发送响应，返回<code>null</code>表示无需进一步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">download</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] data = ...</span><br><span class="line">    response.setContentType(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">    output.write(data);</span><br><span class="line">    output.flush();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对URL进行分组，每组对应一个Controller是一种很好的组织形式，并可以在Controller的class定义出添加URL前缀，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// 注意实际URL映射是/user/profile</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">profile</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意实际URL映射是/user/changePassword</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/changePassword&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">changePassword</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际方法的URL映射总是前缀+路径，这种形式还可以有效避免不小心导致的重复的URL映射。</p>
<p>可见，Spring MVC允许我们编写既简单又灵活的Controller实现。</p>
<h3 id="练习">练习</h3>
<p>使用Spring MVC，在注册、登录等功能的基础上增加一个修改口令的页面。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/mvc/spring-web-mvc.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>使用Spring MVC时，整个Web应用程序按如下顺序启动：</p>
<ol>
<li>启动Tomcat服务器；</li>
<li>Tomcat读取<code>web.xml</code>并初始化<code>DispatcherServlet</code>；</li>
<li><code>DispatcherServlet</code>创建IoC容器并自动注册到<code>ServletContext</code>中。</li>
</ol>
<p>启动后，浏览器发出的HTTP请求全部由<code>DispatcherServlet</code>接收，并根据配置转发到指定Controller的指定方法处理。</p>
<p>使用Spring MVC开发Web应用程序的主要工作就是编写Controller逻辑。在Web应用中，除了需要使用MVC给用户显示页面外，还有一类API接口，我们称之为REST，通常输入输出都是JSON，便于第三方调用或者使用页面JavaScript与之交互。</p>
<p>直接在Controller中处理JSON是可以的，因为Spring MVC的<code>@GetMapping</code>和<code>@PostMapping</code>都支持指定输入和输出的格式。如果我们想接收JSON，输出JSON，那么可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/rest&quot;,</span></span><br><span class="line"><span class="meta">             consumes = &quot;application/json;charset=UTF-8&quot;,</span></span><br><span class="line"><span class="meta">             produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">rest</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;restSupport\&quot;:true&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的Maven工程需要加入Jackson这个依赖：<code>com.fasterxml.jackson.core:jackson-databind:2.14.0</code></p>
<p>注意到<code>@PostMapping</code>使用<code>consumes</code>声明能接收的类型，使用<code>produces</code>声明输出的类型，并且额外加了<code>@ResponseBody</code>表示返回的<code>String</code>无需额外处理，直接作为输出内容写入<code>HttpServletResponse</code>。输入的JSON则根据注解<code>@RequestBody</code>直接被Spring反序列化为<code>User</code>这个JavaBean。</p>
<p>使用curl命令测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;email&quot;:&quot;bob@example.com&quot;&#125;&#x27; http://localhost:8080/rest      </span><br><span class="line">&gt; POST /rest HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Content-Type: application/json</span><br><span class="line">&gt; Content-Length: 27</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 </span><br><span class="line">&lt; Content-Type: application/json;charset=utf-8</span><br><span class="line">&lt; Content-Length: 20</span><br><span class="line">&lt; Date: Sun, 10 May 2020 09:56:01 GMT</span><br><span class="line">&lt; </span><br><span class="line">&#123;&quot;restSupport&quot;:true&#125;</span><br></pre></td></tr></table></figure>
<p>输出正是我们写入的字符串。</p>
<p>直接用Spring的Controller配合一大堆注解写REST太麻烦了，因此，Spring还额外提供了一个<code>@RestController</code>注解，使用<code>@RestController</code>替代<code>@Controller</code>后，每个方法自动变成API接口方法。我们还是以实际代码举例，编写<code>ApiController</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">users</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">signin</span><span class="params">(<span class="meta">@RequestBody</span> SignInRequest signinRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.signin(signinRequest.email, signinRequest.password);</span><br><span class="line">            <span class="keyword">return</span> Map.of(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Map.of(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;SIGNIN_FAILED&quot;</span>, <span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SignInRequest</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String email;</span><br><span class="line">        <span class="keyword">public</span> String password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写REST接口只需要定义<code>@RestController</code>，然后，每个方法都是一个API接口，输入和输出只要能被Jackson序列化或反序列化为JSON就没有问题。我们用浏览器测试GET请求，可直接显示JSON响应：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/rest/spring-rest.png" alt="user-api"></p>
<p>要测试POST请求，可以用curl命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;email&quot;:&quot;bob@example.com&quot;,&quot;password&quot;:&quot;bob123&quot;&#125;&#x27; http://localhost:8080/api/signin</span><br><span class="line">&gt; POST /api/signin HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Content-Type: application/json</span><br><span class="line">&gt; Content-Length: 47</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 </span><br><span class="line">&lt; Content-Type: application/json</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Date: Sun, 10 May 2020 08:14:13 GMT</span><br><span class="line">&lt; </span><br><span class="line">&#123;&quot;user&quot;:&#123;&quot;id&quot;:1,&quot;email&quot;:&quot;bob@example.com&quot;,&quot;password&quot;:&quot;bob123&quot;,&quot;name&quot;:&quot;Bob&quot;,...</span><br></pre></td></tr></table></figure>
<p>注意观察上述JSON的输出，<code>User</code>能被正确地序列化为JSON，但暴露了<code>password</code>属性，这是我们不期望的。要避免输出<code>password</code>属性，可以把<code>User</code>复制到另一个<code>UserBean</code>对象，该对象只持有必要的属性，但这样做比较繁琐。另一种简单的方法是直接在<code>User</code>的<code>password</code>属性定义处加上<code>@JsonIgnore</code>表示完全忽略该属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样一来，如果写一个<code>register(User user)</code>方法，那么该方法的User对象也拿不到注册时用户传入的密码了。如果要允许输入<code>password</code>，但不允许输出<code>password</code>，即在JSON序列化和反序列化时，允许写属性，禁用读属性，可以更精细地控制如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(access = Access.WRITE_ONLY)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，可以使用<code>@JsonProperty(access = Access.READ_ONLY)</code>允许输出，不允许输入。</p>
<h3 id="练习-2">练习</h3>
<p>使用REST实现API。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/rest/spring-web-mvc-rest.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>使用<code>@RestController</code>可以方便地编写REST服务，Spring默认使用JSON作为输入和输出。</p>
<p>要控制序列化和反序列化，可以使用Jackson提供的<code>@JsonIgnore</code>和<code>@JsonProperty</code>注解。</p>
<p>在Spring MVC中，<code>DispatcherServlet</code>只需要固定配置到<code>web.xml</code>中，剩下的工作主要是专注于编写Controller。</p>
<p>但是，在Servlet规范中，我们还可以<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/filter/index.html">使用Filter</a>。如果要在Spring MVC中使用<code>Filter</code>，应该怎么做？</p>
<p>有的童鞋在上一节的Web应用中可能发现了，如果注册时输入中文会导致乱码，因为Servlet默认按非UTF-8编码读取参数。为了修复这一问题，我们可以简单地使用一个EncodingFilter，在全局范围类给<code>HttpServletRequest</code>和<code>HttpServletResponse</code>强制设置为UTF-8编码。</p>
<p>可以自己编写一个EncodingFilter，也可以直接使用Spring MVC自带的一个<code>CharacterEncodingFilter</code>。配置Filter时，只需在<code>web.xml</code>中声明即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为这种Filter和我们业务关系不大，注意到<code>CharacterEncodingFilter</code>其实和Spring的IoC容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种Filter十分简单。</p>
<p>我们再考虑这样一个问题：如果允许用户使用Basic模式进行用户验证，即在HTTP请求中添加头<code>Authorization: Basic email:password</code>，这个需求如何实现？</p>
<p>编写一个<code>AuthFilter</code>是最简单的实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 获取Authorization头:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authHeader</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="literal">null</span> &amp;&amp; authHeader.startsWith(<span class="string">&quot;Basic &quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 从Header中提取email和password:</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> prefixFrom(authHeader);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> suffixFrom(authHeader);</span><br><span class="line">            <span class="comment">// 登录:</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.signin(email, password);</span><br><span class="line">            <span class="comment">// 放入Session:</span></span><br><span class="line">            req.getSession().setAttribute(UserController.KEY_USER, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续处理请求:</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在问题来了：在Spring中创建的这个<code>AuthFilter</code>是一个普通Bean，Servlet容器并不知道，所以它不会起作用。</p>
<p>如果我们直接在<code>web.xml</code>中声明这个<code>AuthFilter</code>，注意到<code>AuthFilter</code>的实例将由Servlet容器而不是Spring容器初始化，因此，<code>@Autowire</code>根本不生效，用于登录的<code>UserService</code>成员变量永远是<code>null</code>。</p>
<p>所以，得通过一种方式，让Servlet容器实例化的Filter，间接引用Spring容器实例化的<code>AuthFilter</code>。Spring MVC提供了一个<code>DelegatingFilterProxy</code>，专门来干这个事情：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>authFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>authFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们来看实现原理：</p>
<ol>
<li>Servlet容器从<code>web.xml</code>中读取配置，实例化<code>DelegatingFilterProxy</code>，注意命名是<code>authFilter</code>；</li>
<li>Spring容器通过扫描<code>@Component</code>实例化<code>AuthFilter</code>。</li>
</ol>
<p>当<code>DelegatingFilterProxy</code>生效后，它会自动查找注册在<code>ServletContext</code>上的Spring容器，再试图从容器中查找名为<code>authFilter</code>的Bean，也就是我们用<code>@Component</code>声明的<code>AuthFilter</code>。</p>
<p><code>DelegatingFilterProxy</code>将请求代理给<code>AuthFilter</code>，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingFilterProxy</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Filter delegate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(...)</span> <span class="keyword">throws</span> ... &#123;</span><br><span class="line">        <span class="keyword">if</span> (delegate == <span class="literal">null</span>) &#123;</span><br><span class="line">            delegate = findBeanFromSpringContainer();</span><br><span class="line">        &#125;</span><br><span class="line">        delegate.doFilter(req, resp, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/structural/proxy/index.html">代理模式</a>的简单应用。我们画个图表示它们之间的引用关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class="line">  ┌─────────────────────┐        ┌───────────┐   │</span><br><span class="line">│ │DelegatingFilterProxy│─│─│─ ─▶│AuthFilter │</span><br><span class="line">  └─────────────────────┘        └───────────┘   │</span><br><span class="line">│ ┌─────────────────────┐ │ │    ┌───────────┐</span><br><span class="line">  │  DispatcherServlet  │─ ─ ─ ─▶│Controllers│   │</span><br><span class="line">│ └─────────────────────┘ │ │    └───────────┘</span><br><span class="line">                                                 │</span><br><span class="line">│    Servlet Container    │ │  Spring Container</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>如果在<code>web.xml</code>中配置的Filter名字和Spring容器的Bean的名字不一致，那么需要指定Bean的名字：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>basicAuthFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定Bean的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetBeanName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>authFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际应用时，尽量保持名字一致，以减少不必要的配置。</p>
<p>要使用Basic模式的用户认证，我们可以使用curl命令测试。例如，用户登录名是<code>tom@example.com</code>，口令是<code>tomcat</code>，那么先构造一个使用URL编码的<code>用户名:口令</code>的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tom%40example.com:tomcat</span><br></pre></td></tr></table></figure>
<p>对其进行Base64编码，最终构造出的Header如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0</span><br></pre></td></tr></table></figure>
<p>使用如下的<code>curl</code>命令并获得响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H &#x27;Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0&#x27; http://localhost:8080/profile</span><br><span class="line">&gt; GET /profile HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 </span><br><span class="line">&lt; Set-Cookie: JSESSIONID=CE0F4BFC394816F717443397D4FEABBE; Path=/; HttpOnly</span><br><span class="line">&lt; Content-Type: text/html;charset=UTF-8</span><br><span class="line">&lt; Content-Language: en-CN</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Date: Wed, 29 Apr 2020 00:15:50 GMT</span><br><span class="line">&lt; </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">...HTML输出...</span><br></pre></td></tr></table></figure>
<p>上述响应说明<code>AuthFilter</code>已生效。</p>
<p>注意</p>
<p>Basic认证模式并不安全，本节只用来作为使用Filter的示例。</p>
<h3 id="练习-3">练习</h3>
<p>使用DelegatingFilterProxy实现AuthFilter。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/filter/spring-web-mvc-filter.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>当一个Filter作为Spring容器管理的Bean存在时，可以通过<code>DelegatingFilterProxy</code>间接地引用它并使其生效。</p>
<p>在Web程序中，注意到使用Filter的时候，Filter由Servlet容器管理，它在Spring MVC的Web应用程序中作用范围如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">         │   ▲</span><br><span class="line">         ▼   │</span><br><span class="line">       ┌───────┐</span><br><span class="line">       │Filter1│</span><br><span class="line">       └───────┘</span><br><span class="line">         │   ▲</span><br><span class="line">         ▼   │</span><br><span class="line">       ┌───────┐</span><br><span class="line">┌ ─ ─ ─│Filter2│─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">       └───────┘</span><br><span class="line">│        │   ▲                  │</span><br><span class="line">         ▼   │</span><br><span class="line">│ ┌─────────────────┐           │</span><br><span class="line">  │DispatcherServlet│◀───┐</span><br><span class="line">│ └─────────────────┘    │      │</span><br><span class="line">   │              ┌────────────┐</span><br><span class="line">│  │              │ModelAndView││</span><br><span class="line">   │              └────────────┘</span><br><span class="line">│  │                     ▲      │</span><br><span class="line">   │    ┌───────────┐    │</span><br><span class="line">│  ├───▶│Controller1│────┤      │</span><br><span class="line">   │    └───────────┘    │</span><br><span class="line">│  │                     │      │</span><br><span class="line">   │    ┌───────────┐    │</span><br><span class="line">│  └───▶│Controller2│────┘      │</span><br><span class="line">        └───────────┘</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>上图虚线框就是Filter2的拦截范围，Filter组件实际上并不知道后续内部处理是通过Spring MVC提供的<code>DispatcherServlet</code>还是其他Servlet组件，因为Filter是Servlet规范定义的标准组件，它可以应用在任何基于Servlet的程序中。</p>
<p>如果只基于Spring MVC开发应用程序，还可以使用Spring MVC提供的一种功能类似Filter的拦截器：Interceptor。和Filter相比，Interceptor拦截范围不是后续整个处理流程，而是仅针对Controller拦截：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">       │   ▲</span><br><span class="line">       ▼   │</span><br><span class="line">     ┌───────┐</span><br><span class="line">     │Filter1│</span><br><span class="line">     └───────┘</span><br><span class="line">       │   ▲</span><br><span class="line">       ▼   │</span><br><span class="line">     ┌───────┐</span><br><span class="line">     │Filter2│</span><br><span class="line">     └───────┘</span><br><span class="line">       │   ▲</span><br><span class="line">       ▼   │</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│DispatcherServlet│◀───┐</span><br><span class="line">└─────────────────┘    │</span><br><span class="line"> │ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ┐</span><br><span class="line"> │                     │</span><br><span class="line"> │ │            ┌────────────┐ │</span><br><span class="line"> │              │   Render   │</span><br><span class="line"> │ │            └────────────┘ │</span><br><span class="line"> │                     ▲</span><br><span class="line"> │ │                   │       │</span><br><span class="line"> │              ┌────────────┐</span><br><span class="line"> │ │            │ModelAndView│ │</span><br><span class="line"> │              └────────────┘</span><br><span class="line"> │ │                   ▲       │</span><br><span class="line"> │    ┌───────────┐    │</span><br><span class="line"> ├─┼─▶│Controller1│────┤       │</span><br><span class="line"> │    └───────────┘    │</span><br><span class="line"> │ │                   │       │</span><br><span class="line"> │    ┌───────────┐    │</span><br><span class="line"> └─┼─▶│Controller2│────┘       │</span><br><span class="line">      └───────────┘</span><br><span class="line">   └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>上图虚线框就是Interceptor的拦截范围，注意到Controller的处理方法一般都类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/path/to/hello&quot;)</span></span><br><span class="line">    ModelAndView <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，Interceptor的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回<code>ModelAndView</code>并渲染后，后续处理就脱离了Interceptor的拦截范围。</p>
<p>使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的<code>@Order</code>指定顺序。我们先写一个<code>LoggerInterceptor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;preHandle &#123;&#125;...&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;debug&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            pw.write(<span class="string">&quot;&lt;p&gt;DEBUG MODE&lt;/p&gt;&quot;</span>);</span><br><span class="line">            pw.flush();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;postHandle &#123;&#125;.&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">if</span> (modelAndView != <span class="literal">null</span>) &#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__time__&quot;</span>, LocalDateTime.now());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;afterCompletion &#123;&#125;: exception = &#123;&#125;&quot;</span>, request.getRequestURI(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Interceptor必须实现<code>HandlerInterceptor</code>接口，可以选择实现<code>preHandle()</code>、<code>postHandle()</code>和<code>afterCompletion()</code>方法。<code>preHandle()</code>是Controller方法调用前执行，<code>postHandle()</code>是Controller方法正常返回后执行，而<code>afterCompletion()</code>无论Controller方法是否抛异常都会执行，参数<code>ex</code>就是Controller方法抛出的异常（未抛出异常是<code>null</code>）。</p>
<p>在<code>preHandle()</code>中，也可以直接处理响应，然后返回<code>false</code>表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在<code>postHandle()</code>中，因为捕获了Controller方法返回的<code>ModelAndView</code>，所以可以继续往<code>ModelAndView</code>里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。</p>
<p>我们再继续添加一个<code>AuthInterceptor</code>，用于替代上一节使用<code>AuthFilter</code>进行Basic认证的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;pre authenticate &#123;&#125;...&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            authenticateByHeader(request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;login by authorization header failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">authenticateByHeader</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authHeader</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="literal">null</span> &amp;&amp; authHeader.startsWith(<span class="string">&quot;Basic &quot;</span>)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;try authenticate by authorization header...&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">up</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Base64.getDecoder().decode(authHeader.substring(<span class="number">6</span>)), StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> up.indexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> URLDecoder.decode(up.substring(<span class="number">0</span>, pos), StandardCharsets.UTF_8);</span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> URLDecoder.decode(up.substring(pos + <span class="number">1</span>), StandardCharsets.UTF_8);</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.signin(email, password);</span><br><span class="line">                req.getSession().setAttribute(UserController.KEY_USER, user);</span><br><span class="line">                logger.info(<span class="string">&quot;user &#123;&#125; login by authorization header ok.&quot;</span>, email);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>AuthInterceptor</code>是由Spring容器直接管理的，因此注入<code>UserService</code>非常方便。</p>
<p>最后，要让拦截器生效，我们在<code>WebMvcConfigurer</code>中注册所有的Interceptor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">WebMvcConfigurer <span class="title function_">createWebMvcConfigurer</span><span class="params">(<span class="meta">@Autowired</span> HandlerInterceptor[] interceptors)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> interceptor : interceptors) &#123;</span><br><span class="line">                registry.addInterceptor(interceptor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<p>如果拦截器没有生效，请检查是否忘了在WebMvcConfigurer中注册。</p>
<h3 id="处理异常">处理异常</h3>
<p>在Controller中，Spring MVC还允许定义基于<code>@ExceptionHandler</code>注解的异常处理方法。我们来看具体的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleUnknowException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;500.html&quot;</span>, Map.of(<span class="string">&quot;error&quot;</span>, ex.getClass().getSimpleName(), <span class="string">&quot;message&quot;</span>, ex.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常处理方法没有固定的方法签名，可以传入<code>Exception</code>、<code>HttpServletRequest</code>等，返回值可以是<code>void</code>，也可以是<code>ModelAndView</code>，上述代码通过<code>@ExceptionHandler(RuntimeException.class)</code>表示当发生<code>RuntimeException</code>的时候，就自动调用此方法处理。</p>
<p>注意到我们返回了一个新的<code>ModelAndView</code>，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的500 Internal Server Error或404 Not Found。例如B站的错误页：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/interceptor/404.png" alt="ERROR"></p>
<p>可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理<code>LoginException</code>使得页面可以自动跳转到登录页。</p>
<p>使用<code>ExceptionHandler</code>时，要注意它仅作用于当前的Controller，即ControllerA中定义的一个<code>ExceptionHandler</code>方法对ControllerB不起作用。如果我们有很多Controller，每个Controller都需要处理一些通用的异常，例如<code>LoginException</code>，思考一下应该怎么避免重复代码？</p>
<h3 id="练习-4">练习</h3>
<p>使用Interceptor。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/interceptor/spring-web-mvc-interceptor.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>Spring MVC提供了Interceptor组件来拦截Controller方法，使用时要注意Interceptor的作用范围。</p>
<p>在开发REST应用时，很多时候，是通过页面的JavaScript和后端的REST API交互。</p>
<p>在JavaScript与REST交互的时候，有很多安全限制。默认情况下，浏览器按同源策略放行JavaScript调用API，即：</p>
<ul>
<li>如果A站在域名<code>a.com</code>页面的JavaScript调用A站自己的API时，没有问题；</li>
<li>如果A站在域名<code>a.com</code>页面的JavaScript调用B站<code>b.com</code>的API时，将被浏览器拒绝访问，因为不满足同源策略。</li>
</ul>
<p>同源要求域名要完全相同（<code>a.com</code>和<code>www.a.com</code>不同），协议要相同（<code>http</code>和<code>https</code>不同），端口要相同 。</p>
<p>那么，在域名<code>a.com</code>页面的JavaScript要调用B站<code>b.com</code>的API时，还有没有办法？</p>
<p>办法是有的，那就是CORS，全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。如果A站的JavaScript访问B站API的时候，B站能够返回响应头<code>Access-Control-Allow-Origin: http://a.com</code>，那么，浏览器就允许A站的JavaScript访问B站的API。</p>
<p>注意到跨域访问能否成功，取决于B站是否愿意给A站返回一个正确的<code>Access-Control-Allow-Origin</code>响应头，所以决定权永远在提供API的服务方手中。</p>
<p>关于CORS的详细信息可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">MDN文档</a>，这里不再详述。</p>
<p>使用Spring的<code>@RestController</code>开发REST应用时，同样会面对跨域问题。如果我们允许指定的网站通过页面JavaScript访问这些REST API，就必须正确地设置CORS。</p>
<p>有好几种方法设置CORS，我们来一一介绍。</p>
<h3 id="使用-CrossOrigin">使用@CrossOrigin</h3>
<p>第一种方法是使用<code>@CrossOrigin</code>注解，可以在<code>@RestController</code>的class级别或方法级别定义一个<code>@CrossOrigin</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://local.liaoxuefeng.com:8080&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述定义在<code>ApiController</code>处的<code>@CrossOrigin</code>指定了只允许来自<code>local.liaoxuefeng.com</code>跨域访问，允许多个域访问需要写成数组形式，例如<code>origins = &#123;&quot;http://a.com&quot;, &quot;https://www.b.com&quot;&#125;)</code>。如果要允许任何域访问，写成<code>origins = &quot;*&quot;</code>即可。</p>
<p>如果有多个REST Controller都需要使用CORS，那么，每个Controller都必须标注<code>@CrossOrigin</code>注解。</p>
<h3 id="使用CorsRegistry">使用CorsRegistry</h3>
<p>第二种方法是在<code>WebMvcConfigurer</code>中定义一个全局CORS配置，下面是一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">WebMvcConfigurer <span class="title function_">createWebMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">            registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                    .allowedOrigins(<span class="string">&quot;http://local.liaoxuefeng.com:8080&quot;</span>)</span><br><span class="line">                    .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>)</span><br><span class="line">                    .maxAge(<span class="number">3600</span>);</span><br><span class="line">            <span class="comment">// 可以继续添加其他URL规则:</span></span><br><span class="line">            <span class="comment">// registry.addMapping(&quot;/rest/v2/**&quot;)...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式可以创建一个全局CORS配置，如果仔细地设计URL结构，那么可以一目了然地看到各个URL的CORS规则，推荐使用这种方式配置CORS。</p>
<h3 id="使用CorsFilter">使用CorsFilter</h3>
<p>第三种方法是使用Spring提供的<code>CorsFilter</code>，我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/filter/index.html">集成Filter</a>中详细介绍了将Spring容器内置的Bean暴露为Servlet容器的Filter的方法，由于这种配置方式需要修改<code>web.xml</code>，也比较繁琐，所以推荐使用第二种方式。</p>
<h3 id="测试">测试</h3>
<p>当我们配置好CORS后，可以在浏览器中测试一下规则是否生效。</p>
<p>我们先用<code>http://localhost:8080</code>在Chrome浏览器中打开首页，然后打开Chrome的开发者工具，切换到Console，输入一个JavaScript语句来跨域访问API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(<span class="string">&quot;http://local.liaoxuefeng.com:8080/api/users&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)));</span><br></pre></td></tr></table></figure>
<p>上述源站的域是<code>http://localhost:8080</code>，跨域访问的是<code>http://local.liaoxuefeng.com:8080</code>，因为配置的CORS不允许<code>localhost</code>访问，所以不出意外地得到一个错误：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/cors/cors-error.png" alt="cors-deny"></p>
<p>浏览题打印了错误原因就是<code>been blocked by CORS policy</code>。</p>
<p>我们再用<code>http://local.liaoxuefeng.com:8080</code>在Chrome浏览器中打开首页，在Console中执行JavaScript访问<code>localhost</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(<span class="string">&quot;http://localhost:8080/api/users&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)));</span><br></pre></td></tr></table></figure>
<p>因为CORS规则允许来自<code>http://local.liaoxuefeng.com:8080</code>的访问，因此访问成功，打印出API的返回值：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/cors/cors-ok.png" alt="cors-ok"></p>
<h3 id="练习-5">练习</h3>
<p>使用CORS控制跨域。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/cors/spring-web-mvc-cors.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>CORS可以控制指定域的页面JavaScript能否访问API。</p>
<p>在开发应用程序的时候，经常会遇到支持多语言的需求，这种支持多语言的功能称之为国际化，英文是internationalization，缩写为i18n（因为首字母i和末字母n中间有18个字母）。</p>
<p>还有针对特定地区的本地化功能，英文是localization，缩写为L10n，本地化是指根据地区调整类似姓名、日期的显示等。</p>
<p>也有把上面两者合称为全球化，英文是globalization，缩写为g11n。</p>
<p>在Java中，支持多语言和本地化是通过<code>MessageFormat</code>配合<code>Locale</code>实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MessageFormat</span></span><br><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Time</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">123.5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        Object[] arguments = &#123; price, number &#125;;</span><br><span class="line">        <span class="type">MessageFormat</span> <span class="variable">mfUS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageFormat</span>(<span class="string">&quot;Pay &#123;0,number,currency&#125; for &#123;1&#125; books.&quot;</span>, Locale.US);</span><br><span class="line">        System.out.println(mfUS.format(arguments));</span><br><span class="line">        <span class="type">MessageFormat</span> <span class="variable">mfZH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageFormat</span>(<span class="string">&quot;&#123;1&#125;本书一共&#123;0,number,currency&#125;。&quot;</span>, Locale.CHINA);</span><br><span class="line">        System.out.println(mfZH.format(arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Web应用程序，要实现国际化功能，主要是渲染View的时候，要把各种语言的资源文件提出来，这样，不同的用户访问同一个页面时，显示的语言就是不同的。</p>
<p>我们来看看在Spring MVC应用程序中如何实现国际化。</p>
<h3 id="获取Locale">获取Locale</h3>
<p>实现国际化的第一步是获取到用户的<code>Locale</code>。在Web应用程序中，HTTP规范规定了浏览器会在请求中携带<code>Accept-Language</code>头，用来指示用户浏览器设定的语言顺序，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.2</span><br></pre></td></tr></table></figure>
<p>上述HTTP请求头表示优先选择简体中文，其次选择中文，最后选择英文。<code>q</code>表示权重，解析后我们可获得一个根据优先级排序的语言列表，把它转换为Java的<code>Locale</code>，即获得了用户的<code>Locale</code>。大多数框架通常只返回权重最高的<code>Locale</code>。</p>
<p>Spring MVC通过<code>LocaleResolver</code>来自动从<code>HttpServletRequest</code>中获取<code>Locale</code>。有多种<code>LocaleResolver</code>的实现类，其中最常用的是<code>CookieLocaleResolver</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">LocaleResolver <span class="title function_">createLocaleResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">clr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookieLocaleResolver</span>();</span><br><span class="line">    clr.setDefaultLocale(Locale.ENGLISH);</span><br><span class="line">    clr.setDefaultTimeZone(TimeZone.getDefault());</span><br><span class="line">    <span class="keyword">return</span> clr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CookieLocaleResolver</code>从<code>HttpServletRequest</code>中获取<code>Locale</code>时，首先根据一个特定的Cookie判断是否指定了<code>Locale</code>，如果没有，就从HTTP头获取，如果还没有，就返回默认的<code>Locale</code>。</p>
<p>当用户第一次访问网站时，<code>CookieLocaleResolver</code>只能从HTTP头获取<code>Locale</code>，即使用浏览器的默认语言。通常网站也允许用户自己选择语言，此时，<code>CookieLocaleResolver</code>就会把用户选择的语言存放到Cookie中，下一次访问时，就会返回用户上次选择的语言而不是浏览器默认语言。</p>
<h3 id="提取资源文件">提取资源文件</h3>
<p>第二步是把写死在模板中的字符串以资源文件的方式存储在外部。对于多语言，主文件名如果命名为<code>messages</code>，那么资源文件必须按如下方式命名并放入classpath中：</p>
<ul>
<li>默认语言，文件名必须为<code>messages.properties</code>；</li>
<li>简体中文，Locale是<code>zh_CN</code>，文件名必须为<code>messages_zh_CN.properties</code>；</li>
<li>日文，Locale是<code>ja_JP</code>，文件名必须为<code>messages_ja_JP.properties</code>；</li>
<li>其它更多语言……</li>
</ul>
<p>每个资源文件都有相同的key，例如，默认语言是英文，文件<code>messages.properties</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language.select=Language</span><br><span class="line">home=Home</span><br><span class="line">signin=Sign In</span><br><span class="line">copyright=Copyright©&#123;0,number,#&#125;</span><br></pre></td></tr></table></figure>
<p>文件<code>messages_zh_CN.properties</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language.select=语言</span><br><span class="line">home=首页</span><br><span class="line">signin=登录</span><br><span class="line">copyright=版权所有©&#123;0,number,#&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建MessageSource">创建MessageSource</h3>
<p>第三步是创建一个Spring提供的<code>MessageSource</code>实例，它自动读取所有的<code>.properties</code>文件，并提供一个统一接口来实现“翻译”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code, arguments, locale:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> messageSource.getMessage(<span class="string">&quot;signin&quot;</span>, <span class="literal">null</span>, locale);</span><br></pre></td></tr></table></figure>
<p>其中，<code>signin</code>是我们在<code>.properties</code>文件中定义的key，第二个参数是<code>Object[]</code>数组作为格式化时传入的参数，最后一个参数就是获取的用户<code>Locale</code>实例。</p>
<p>创建<code>MessageSource</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;i18n&quot;)</span></span><br><span class="line">MessageSource <span class="title function_">createMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">messageSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceBundleMessageSource</span>();</span><br><span class="line">    <span class="comment">// 指定文件是UTF-8编码:</span></span><br><span class="line">    messageSource.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 指定主文件名:</span></span><br><span class="line">    messageSource.setBasename(<span class="string">&quot;messages&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>ResourceBundleMessageSource</code>会自动根据主文件名自动把所有相关语言的资源文件都读进来。</p>
<p>再注意到Spring容器会创建不只一个<code>MessageSource</code>实例，我们自己创建的这个<code>MessageSource</code>是专门给页面国际化使用的，因此命名为<code>i18n</code>，不会与其它<code>MessageSource</code>实例冲突。</p>
<h3 id="实现多语言">实现多语言</h3>
<p>要在View中使用<code>MessageSource</code>加上<code>Locale</code>输出多语言，我们通过编写一个<code>MvcInterceptor</code>，把相关资源注入到<code>ModelAndView</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意注入的MessageSource名称是i18n:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;i18n&quot;)</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (modelAndView != <span class="literal">null</span> <span class="comment">// 返回了ModelAndView</span></span><br><span class="line">            &amp;&amp; modelAndView.getViewName() != <span class="literal">null</span> <span class="comment">// 设置了View</span></span><br><span class="line">            &amp;&amp; !modelAndView.getViewName().startsWith(<span class="string">&quot;redirect:&quot;</span>) <span class="comment">// 不是重定向</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 解析用户的Locale:</span></span><br><span class="line">            <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> localeResolver.resolveLocale(request);</span><br><span class="line">            <span class="comment">// 放入Model:</span></span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__messageSource__&quot;</span>, messageSource);</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__locale__&quot;</span>, locale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要忘了在<code>WebMvcConfigurer</code>中注册<code>MvcInterceptor</code>。现在，就可以在View中调用<code>MessageSource.getMessage()</code>方法来实现多语言：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/signin&quot;</span>&gt;</span>&#123;&#123; __messageSource__.getMessage(&#x27;signin&#x27;, null, __locale__) &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述这种写法虽然可行，但格式太复杂了。使用View时，要根据每个特定的View引擎定制国际化函数。在Pebble中，我们可以封装一个国际化函数，名称就是下划线<code>_</code>，改造一下创建<code>ViewResolver</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ViewResolver <span class="title function_">createViewResolver</span><span class="params">(<span class="meta">@Autowired</span> ServletContext servletContext, <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;i18n&quot;)</span> MessageSource messageSource)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PebbleEngine</span>.Builder()</span><br><span class="line">            .autoEscaping(<span class="literal">true</span>)</span><br><span class="line">            .cacheActive(<span class="literal">false</span>)</span><br><span class="line">            .loader(<span class="keyword">new</span> <span class="title class_">Servlet5Loader</span>(servletContext))</span><br><span class="line">            <span class="comment">// 添加扩展:</span></span><br><span class="line">            .extension(createExtension(messageSource))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="type">var</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PebbleViewResolver</span>();</span><br><span class="line">    viewResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">    viewResolver.setSuffix(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    viewResolver.setPebbleEngine(engine);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Extension <span class="title function_">createExtension</span><span class="params">(MessageSource messageSource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractExtension</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String, Function&gt; <span class="title function_">getFunctions</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Map.of(<span class="string">&quot;_&quot;</span>, <span class="keyword">new</span> <span class="title class_">Function</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(Map&lt;String, Object&gt; args, PebbleTemplate self, EvaluationContext context, <span class="type">int</span> lineNumber)</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String) args.get(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                    List&lt;Object&gt; arguments = <span class="built_in">this</span>.extractArguments(args);</span><br><span class="line">                    <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> (Locale) context.getVariable(<span class="string">&quot;__locale__&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> messageSource.getMessage(key, arguments.toArray(), <span class="string">&quot;???&quot;</span> + key + <span class="string">&quot;???&quot;</span>, locale);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> List&lt;Object&gt; <span class="title function_">extractArguments</span><span class="params">(Map&lt;String, Object&gt; args)</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    List&lt;Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="keyword">while</span> (args.containsKey(String.valueOf(i))) &#123;</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> args.get(String.valueOf(i));</span><br><span class="line">                        arguments.add(param);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> arguments;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getArgumentNames</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们可以把多语言页面改写为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/signin&quot;</span>&gt;</span>&#123;&#123; _(&#x27;signin&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果是带参数的多语言，需要把参数传进去：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>&#123;&#123; _(&#x27;copyright&#x27;, 2020) &#125;&#125;<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用其它View引擎时，也应当根据引擎接口实现更方便的语法。</p>
<h3 id="切换Locale">切换Locale</h3>
<p>最后，我们需要允许用户手动切换<code>Locale</code>，编写一个<code>LocaleController</code>来实现该功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocaleController</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/locale/&#123;lo&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setLocale</span><span class="params">(<span class="meta">@PathVariable(&quot;lo&quot;)</span> String lo, HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据传入的lo创建Locale实例:</span></span><br><span class="line">        <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> lo.indexOf(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">lang</span> <span class="operator">=</span> lo.substring(<span class="number">0</span>, pos);</span><br><span class="line">            <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> lo.substring(pos + <span class="number">1</span>);</span><br><span class="line">            locale = <span class="keyword">new</span> <span class="title class_">Locale</span>(lang, country);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            locale = <span class="keyword">new</span> <span class="title class_">Locale</span>(lo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设定此Locale:</span></span><br><span class="line">        localeResolver.setLocale(request, response, locale);</span><br><span class="line">        logger.info(<span class="string">&quot;locale is set to &#123;&#125;.&quot;</span>, locale);</span><br><span class="line">        <span class="comment">// 刷新页面:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">referer</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:&quot;</span> + (referer == <span class="literal">null</span> ? <span class="string">&quot;/&quot;</span> : referer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在页面设计中，通常在右上角给用户提供一个语言选择列表，来看看效果：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/i18n/en.png" alt="i18n-en"></p>
<p>切换到中文：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/i18n/zh.png" alt="i18n-zh-cn"></p>
<h3 id="练习-6">练习</h3>
<p>在Spring MVC程序中实现国际化。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/i18n/spring-web-mvc-i18n.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>多语言支持需要从HTTP请求中解析用户的Locale，然后针对不同Locale显示不同的语言；</p>
<p>Spring MVC应用程序通过<code>MessageSource</code>和<code>LocaleResolver</code>，配合View实现国际化。</p>
<p>在Servlet模型中，每个请求都是由某个线程处理，然后，将响应写入IO流，发送给客户端。从开始处理请求，到写入响应完成，都是在同一个线程中处理的。</p>
<p>实现Servlet容器的时候，只要每处理一个请求，就创建一个新线程处理它，就能保证正确实现了Servlet线程模型。在实际产品中，例如Tomcat，总是通过线程池来处理请求，它仍然符合一个请求从头到尾都由某一个线程处理。</p>
<p>这种线程模型非常重要，因为Spring的JDBC事务是基于<code>ThreadLocal</code>实现的，如果在处理过程中，一会由线程A处理，一会又由线程B处理，那事务就全乱套了。此外，很多安全认证，也是基于<code>ThreadLocal</code>实现的，可以保证在处理请求的过程中，各个线程互不影响。</p>
<p>但是，如果一个请求处理的时间较长，例如几秒钟甚至更长，那么，这种基于线程池的同步模型很快就会把所有线程耗尽，导致服务器无法响应新的请求。如果把长时间处理的请求改为异步处理，那么线程池的利用率就会大大提高。Servlet从3.0规范开始添加了异步支持，允许对一个请求进行异步处理。</p>
<p>我们先来看看在Spring MVC中如何实现对请求进行异步处理的逻辑。首先建立一个Web工程，然后编辑<code>web.xml</code>文件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itranswarp.learnjava.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和前面普通的MVC程序相比，这个<code>web.xml</code>主要对<code>DispatcherServlet</code>的配置多了一个<code>&lt;async-supported&gt;</code>，默认值是<code>false</code>，必须明确写成<code>true</code>，这样Servlet容器才会支持async处理。</p>
<p>下一步就是在Controller中编写async处理逻辑。我们以<code>ApiController</code>为例，演示如何异步处理请求。</p>
<p>第一种async处理方式是返回一个<code>Callable</code>，Spring MVC自动把返回的<code>Callable</code>放入线程池执行，等待结果返回后再写入响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Callable&lt;List&lt;User&gt;&gt; <span class="title function_">users</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 模拟3秒耗时:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种async处理方式是返回一个<code>DeferredResult</code>对象，然后在另一个线程中，设置此对象的值并写入响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DeferredResult&lt;User&gt; <span class="title function_">user</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">    DeferredResult&lt;User&gt; result = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;&gt;(<span class="number">3000L</span>); <span class="comment">// 3秒超时</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 等待1秒:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUserById(id);</span><br><span class="line">            <span class="comment">// 设置正常结果并由Spring MVC写入Response:</span></span><br><span class="line">            result.setResult(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 设置错误结果并由Spring MVC写入Response:</span></span><br><span class="line">            result.setErrorResult(Map.of(<span class="string">&quot;error&quot;</span>, e.getClass().getSimpleName(), <span class="string">&quot;message&quot;</span>, e.getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>DeferredResult</code>时，可以设置超时，超时会自动返回超时错误响应。在另一个线程中，可以调用<code>setResult()</code>写入结果，也可以调用<code>setErrorResult()</code>写入一个错误结果。</p>
<p>运行程序，当我们访问<code>http://localhost:8080/api/users/1</code>时，假定用户存在，则浏览器在1秒后返回结果：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/async/deferred.png" alt="deferred-result-ok"></p>
<p>访问一个不存在的User ID，则等待1秒后返回错误结果：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/web/async/deferred2.png" alt="deferred-result-error"></p>
<h3 id="使用Filter">使用Filter</h3>
<p>当我们使用async模式处理请求时，原有的Filter也可以工作，但我们必须在<code>web.xml</code>中添加<code>&lt;async-supported&gt;</code>并设置为<code>true</code>。我们用两个Filter：SyncFilter和AsyncFilter分别测试：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>sync-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.itranswarp.learnjava.web.SyncFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>async-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.itranswarp.learnjava.web.AsyncFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>sync-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/version<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>async-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个声明为支持<code>&lt;async-supported&gt;</code>的Filter既可以过滤async处理请求，也可以过滤正常的同步处理请求，而未声明<code>&lt;async-supported&gt;</code>的Filter无法支持async请求，如果一个普通的Filter遇到async请求时，会直接报错，因此，务必注意普通Filter的<code>&lt;url-pattern&gt;</code>不要匹配async请求路径。</p>
<p>在<code>logback.xml</code>配置文件中，我们把输出格式加上<code>[%thread]</code>，可以输出当前线程的名称：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于同步请求，例如<code>/api/version</code>，我们可以看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - start SyncFilter...</span><br><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...</span><br><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.ApiController - get version...</span><br><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.</span><br><span class="line">2020-05-16 11:22:40 [http-nio-8080-exec-1] INFO  c.i.learnjava.web.SyncFilter - end SyncFilter.</span><br></pre></td></tr></table></figure>
<p>可见，每个Filter和<code>ApiController</code>都是由同一个线程执行。</p>
<p>对于异步请求，例如<code>/api/users</code>，我们可以看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...</span><br><span class="line">2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.ApiController - get users...</span><br><span class="line">2020-05-16 11:23:49 [http-nio-8080-exec-4] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.</span><br><span class="line">2020-05-16 11:23:52 [MvcAsync1] INFO  c.i.learnjava.web.ApiController - return users...</span><br></pre></td></tr></table></figure>
<p>可见，<code>AsyncFilter</code>和<code>ApiController</code>是由同一个线程执行的，但是，返回响应的是另一个线程。</p>
<p>对<code>DeferredResult</code>测试，可以看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - start AsyncFilter...</span><br><span class="line">2020-05-16 11:25:24 [http-nio-8080-exec-8] INFO  c.i.learnjava.web.AsyncFilter - end AsyncFilter.</span><br><span class="line">2020-05-16 11:25:25 [Thread-2] INFO  c.i.learnjava.web.ApiController - deferred result is set.</span><br></pre></td></tr></table></figure>
<p>同样，返回响应的是另一个线程。</p>
<p>在实际使用时，经常用到的就是<code>DeferredResult</code>，因为返回<code>DeferredResult</code>时，可以设置超时、正常结果和错误结果，易于编写比较灵活的逻辑。</p>
<p>使用async异步处理响应时，要时刻牢记，在另一个异步线程中的事务和Controller方法中执行的事务不是同一个事务，在Controller中绑定的<code>ThreadLocal</code>信息也无法在异步线程中获取。</p>
<p>此外，Servlet 3.0规范添加的异步支持是针对同步模型打了一个“补丁”，虽然可以异步处理请求，但高并发异步请求时，它的处理效率并不高，因为这种异步模型并没有用到真正的“原生”异步。Java标准库提供了封装操作系统的异步IO包<code>java.nio</code>，是真正的多路复用IO模型，可以用少量线程支持大量并发。使用NIO编程复杂度比同步IO高很多，因此我们很少直接使用NIO。相反，大部分需要高性能异步IO的应用程序会选择<a target="_blank" rel="noopener" href="https://netty.io/">Netty</a>这样的框架，它基于NIO提供了更易于使用的API，方便开发异步应用程序。</p>
<h3 id="练习-7">练习</h3>
<p>使用Spring MVC实现异步处理请求。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/async/spring-web-mvc-async.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>在Spring MVC中异步处理请求需要正确配置<code>web.xml</code>，并返回<code>Callable</code>或<code>DeferredResult</code>对象。</p>
<p>WebSocket是一种基于HTTP的长链接技术。传统的HTTP协议是一种请求-响应模型，如果浏览器不发送请求，那么服务器无法主动给浏览器推送数据。如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。</p>
<p>因为HTTP本身是基于TCP连接的，所以，WebSocket在HTTP协议的基础上做了一个简单的升级，即建立TCP连接后，浏览器发送请求时，附带几个头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>就表示客户端希望升级连接，变成长连接的WebSocket，服务器返回升级成功的响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。</p>
<p>现代浏览器都已经支持WebSocket协议，服务器则需要底层框架支持。Java的Servlet规范从3.1开始支持WebSocket，所以，必须选择支持Servlet 3.1或更高规范的Servlet容器，才能支持WebSocket。最新版本的Tomcat、Jetty等开源服务器均支持WebSocket。</p>
<p>我们以实际代码演示如何在Spring MVC中实现对WebSocket的支持。首先，我们需要在<code>pom.xml</code>中加入以下依赖：</p>
<ul>
<li>org.apache.tomcat.embed:tomcat-embed-websocket:10.1.1</li>
<li>org.springframework:spring-websocket:6.0.0</li>
</ul>
<p>第一项是嵌入式Tomcat支持WebSocket的组件，第二项是Spring封装的支持WebSocket的接口。</p>
<p>接下来，我们需要在<code>AppConfig</code>中加入Spring Web对WebSocket的配置，先增加一个<code>@EnableWebSocket</code>注解，然后创建一个<code>WebSocketConfigurer</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">// 启用WebSocket支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    WebSocketConfigurer <span class="title function_">createWebSocketConfigurer</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> ChatHandler chatHandler,</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> ChatHandshakeInterceptor chatInterceptor)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebSocketConfigurer</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">                <span class="comment">// 把URL与指定的WebSocketHandler关联，可关联多个:</span></span><br><span class="line">                registry.addHandler(chatHandler, <span class="string">&quot;/chat&quot;</span>).addInterceptors(chatInterceptor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此实例在内部通过<code>WebSocketHandlerRegistry</code>注册能处理WebSocket的<code>WebSocketHandler</code>，以及可选的WebSocket拦截器<code>HandshakeInterceptor</code>。我们注入的这两个类都是自己编写的业务逻辑，后面我们详细讨论如何编写它们，这里只需关注浏览器连接到WebSocket的URL是<code>/chat</code>。</p>
<h3 id="处理WebSocket连接">处理WebSocket连接</h3>
<p>和处理普通HTTP请求不同，没法用一个方法处理一个URL。Spring提供了<code>TextWebSocketHandler</code>和<code>BinaryWebSocketHandler</code>分别处理文本消息和二进制消息，这里我们选择文本消息作为聊天室的协议，因此，<code>ChatHandler</code>需要继承自<code>TextWebSocketHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当浏览器请求一个WebSocket连接后，如果成功建立连接，Spring会自动调用<code>afterConnectionEstablished()</code>方法，任何原因导致WebSocket连接中断时，Spring会自动调用<code>afterConnectionClosed</code>方法，因此，覆写这两个方法即可处理连接成功和结束后的业务逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 保存所有Client的WebSocket会话实例:</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, WebSocketSession&gt; clients = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 新会话根据ID放入Map:</span></span><br><span class="line">        clients.put(session.getId(), session);</span><br><span class="line">        session.getAttributes().put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Guest1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients.remove(session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个WebSocket会话以<code>WebSocketSession</code>表示，且已分配唯一ID。和WebSocket相关的数据，例如用户名称等，均可放入关联的<code>getAttributes()</code>中。</p>
<p>用实例变量<code>clients</code>持有当前所有的<code>WebSocketSession</code>是为了广播，即向所有用户推送同一消息时，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">TextMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextMessage</span>(json);</span><br><span class="line"><span class="keyword">for</span> (String id : clients.keySet()) &#123;</span><br><span class="line">    <span class="type">WebSocketSession</span> <span class="variable">session</span> <span class="operator">=</span> clients.get(id);</span><br><span class="line">    session.sendMessage(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发送的消息是序列化后的JSON，可以用<code>ChatMessage</code>表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatMessage</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> timestamp;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每收到一个用户的消息后，我们就需要广播给所有用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> message.getPayload();</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> ... <span class="comment">// 根据输入消息构造待发送消息</span></span><br><span class="line">        broadcastMessage(r); <span class="comment">// 推送给所有用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要推送给指定的几个用户，那就需要在<code>clients</code>中根据条件查找出某些<code>WebSocketSession</code>，然后发送消息。</p>
<p>注意到我们在注册WebSocket时还传入了一个<code>ChatHandshakeInterceptor</code>，这个类实际上可以从<code>HttpSessionHandshakeInterceptor</code>继承，它的主要作用是在WebSocket建立连接后，把HttpSession的一些属性复制到WebSocketSession，例如，用户的登录信息等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHandshakeInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HttpSessionHandshakeInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatHandshakeInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 指定从HttpSession复制属性到WebSocketSession:</span></span><br><span class="line">        <span class="built_in">super</span>(List.of(UserController.KEY_USER));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在<code>ChatHandler</code>中，可以从<code>WebSocketSession.getAttributes()</code>中获取到复制过来的属性。</p>
<h3 id="客户端开发">客户端开发</h3>
<p>在完成了服务器端的开发后，我们还需要在页面编写一点JavaScript逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建WebSocket连接:</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://&#x27;</span> + location.<span class="property">host</span> + <span class="string">&#x27;/chat&#x27;</span>);</span><br><span class="line"><span class="comment">// 连接成功时:</span></span><br><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;websocket connected.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 收到消息时:</span></span><br><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;message: &#x27;</span> + event.<span class="property">data</span>);</span><br><span class="line">    <span class="keyword">var</span> msgs = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 连接关闭时:</span></span><br><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;websocket closed.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 绑定到全局变量:</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">chatWs</span> = ws;</span><br></pre></td></tr></table></figure>
<p>用户可以在连接成功后任何时候给服务器发送消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputText = <span class="string">&#x27;Hello, WebSocket.&#x27;</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">chatWs</span>.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">text</span>: inputText&#125;));</span><br></pre></td></tr></table></figure>
<p>最后，连调浏览器和服务器端，如果一切无误，可以开多个不同的浏览器测试WebSocket的推送和广播。</p>
<p>和上一节我们介绍的异步处理类似，Servlet的线程模型并不适合大规模的长链接。基于NIO的Netty等框架更适合处理WebSocket长链接，我们将在后面介绍。</p>
<h3 id="练习-8">练习</h3>
<p>使用WebSocket编写一个聊天室。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/web/websocket/spring-web-mvc-websocket.zip">下载练习</a></p>
<h3 id="小结-8">小结</h3>
<p>在Servlet中使用WebSocket需要3.1及以上版本；</p>
<p>通过<code>spring-websocket</code>可以简化WebSocket的开发。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"
                            aria-label=": JAVA-Spring开发-访问数据库"
                        >
                            JAVA-Spring开发-访问数据库
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T16:32:39+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。</p>
<p>我们在前面已经介绍了Java程序访问数据库的标准接口JDBC，它的实现方式非常简洁，即：Java标准库定义接口，各数据库厂商以“驱动”的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以jar包形式引入进来，同时自身仅使用JDBC接口，编译期并不需要特定厂商的驱动。</p>
<p>使用JDBC虽然简单，但代码比较繁琐。Spring为了简化数据库访问，主要做了以下几点工作：</p>
<ul>
<li>提供了简化的访问JDBC的模板类，不必手动释放资源；</li>
<li>提供了一个统一的DAO类以实现Data Access Object模式；</li>
<li>把<code>SQLException</code>封装为<code>DataAccessException</code>，这个异常是一个<code>RuntimeException</code>，并且让我们能区分SQL异常的原因，例如，<code>DuplicateKeyException</code>表示违反了一个唯一约束；</li>
<li>能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。</li>
</ul>
<p>本章我们将详细讲解在Spring中访问数据库的最佳实践。</p>
<p>我们在前面介绍<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/jdbc/index.html">JDBC编程</a>时已经讲过，Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：</p>
<ul>
<li>创建全局<code>DataSource</code>实例，表示数据库连接池；</li>
<li>在需要读写数据库的方法内部，按如下步骤访问数据库：
<ul>
<li>从全局<code>DataSource</code>实例获取<code>Connection</code>实例；</li>
<li>通过<code>Connection</code>实例创建<code>PreparedStatement</code>实例；</li>
<li>执行SQL语句，如果是查询，则通过<code>ResultSet</code>读取结果集，如果是修改，则获得<code>int</code>结果。</li>
</ul>
</li>
</ul>
<p>正确编写JDBC代码的关键是使用<code>try ... finally</code>释放资源，涉及到事务的代码需要正确提交或回滚事务。</p>
<p>在Spring使用JDBC，首先我们通过IoC容器创建并管理一个<code>DataSource</code>实例，然后，Spring提供了一个<code>JdbcTemplate</code>，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个<code>JdbcTemplate</code>。顾名思义，这个类主要使用了<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/template-method/index.html">Template模式</a>。</p>
<p>编写示例代码或者测试代码时，我们强烈推荐使用<a target="_blank" rel="noopener" href="https://hsqldb.org/">HSQLDB</a>这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。</p>
<p>我们以实际工程为例，先创建Maven工程<code>spring-data-jdbc</code>，然后引入以下依赖：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
<li>org.springframework:spring-jdbc:6.0.0</li>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
<li>com.zaxxer:HikariCP:5.0.1</li>
<li>org.hsqldb:hsqldb:2.7.1</li>
</ul>
<p>在<code>AppConfig</code>中，我们需要创建以下几个必须的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String jdbcUsername;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        config.setJdbcUrl(jdbcUrl);</span><br><span class="line">        config.setUsername(jdbcUsername);</span><br><span class="line">        config.setPassword(jdbcPassword);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;autoCommit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        config.addDataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述配置中：</p>
<ol>
<li>通过<code>@PropertySource(&quot;jdbc.properties&quot;)</code>读取数据库配置文件；</li>
<li>通过<code>@Value(&quot;$&#123;jdbc.url&#125;&quot;)</code>注入配置文件的相关配置；</li>
<li>创建一个DataSource实例，它的实际类型是<code>HikariDataSource</code>，创建时需要用到注入的配置；</li>
<li>创建一个JdbcTemplate实例，它需要注入<code>DataSource</code>，这是通过方法参数完成注入的。</li>
</ol>
<p>最后，针对HSQLDB写一个配置文件<code>jdbc.properties</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 数据库文件名为testdb:</span><br><span class="line">jdbc.url=jdbc:hsqldb:file:testdb</span><br><span class="line"></span><br><span class="line"># Hsqldb默认的用户名是sa，口令是空字符串:</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=</span><br></pre></td></tr></table></figure>
<p>可以通过HSQLDB自带的工具来初始化数据库表，这里我们写一个Bean，在Spring容器启动时自动创建一个<code>users</code>表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;CREATE TABLE IF NOT EXISTS users (&quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;id BIGINT IDENTITY NOT NULL PRIMARY KEY, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;email VARCHAR(100) NOT NULL, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;password VARCHAR(100) NOT NULL, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;name VARCHAR(100) NOT NULL, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;UNIQUE (email))&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，所有准备工作都已完毕。我们只需要在需要访问数据库的Bean中，注入<code>JdbcTemplate</code>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JdbcTemplate用法">JdbcTemplate用法</h3>
<p>Spring提供的<code>JdbcTemplate</code>采用Template模式，提供了一系列以回调为特点的工具方法，目的是避免繁琐的<code>try...catch</code>语句。</p>
<p>我们以具体的示例来说明JdbcTemplate的用法。</p>
<p>首先我们看<code>T execute(ConnectionCallback&lt;T&gt; action)</code>方法，它提供了Jdbc的<code>Connection</code>供我们使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意传入的是ConnectionCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute((Connection conn) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:</span></span><br><span class="line">        <span class="comment">// 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)) &#123;</span><br><span class="line">            ps.setObject(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                            rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，上述回调方法允许获取Connection，然后做任何基于Connection的操作。</p>
<p>我们再看<code>T execute(String sql, PreparedStatementCallback&lt;T&gt; action)</code>的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 需要传入SQL语句，以及PreparedStatementCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute(<span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>, (PreparedStatement ps) -&gt; &#123;</span><br><span class="line">        <span class="comment">// PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:</span></span><br><span class="line">        ps.setObject(<span class="number">1</span>, name);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们看<code>T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入SQL，参数和RowMapper实例:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT * FROM users WHERE email = ?&quot;</span>,</span><br><span class="line">            (ResultSet rs, <span class="type">int</span> rowNum) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 将ResultSet的当前行映射为一个JavaBean:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;,</span><br><span class="line">            email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>queryForObject()</code>方法中，传入SQL以及SQL参数后，<code>JdbcTemplate</code>会自动创建<code>PreparedStatement</code>，自动执行查询并返回<code>ResultSet</code>，我们提供的<code>RowMapper</code>需要做的事情就是把<code>ResultSet</code>的当前行映射成一个JavaBean并返回。整个过程中，使用<code>Connection</code>、<code>PreparedStatement</code>和<code>ResultSet</code>都不需要我们手动管理。</p>
<p><code>RowMapper</code>不一定返回JavaBean，实际上它可以返回任何Java对象。例如，使用<code>SELECT COUNT(*)</code>查询时，可以返回<code>Long</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT COUNT(*) FROM users&quot;</span>, (ResultSet rs, <span class="type">int</span> rowNum) -&gt; &#123;</span><br><span class="line">        <span class="comment">// SELECT COUNT(*)查询只有一列，取第一列数据:</span></span><br><span class="line">        <span class="keyword">return</span> rs.getLong(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们期望返回多行记录，而不是一行，可以用<code>query()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(<span class="type">int</span> pageIndex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> limit * (pageIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(<span class="string">&quot;SELECT * FROM users LIMIT ? OFFSET ?&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class),</span><br><span class="line">            limit, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述<code>query()</code>方法传入的参数仍然是SQL、SQL参数以及<code>RowMapper</code>实例。这里我们直接使用Spring提供的<code>BeanPropertyRowMapper</code>。如果数据库表的结构恰好和JavaBean的属性名称一致，那么<code>BeanPropertyRowMapper</code>就可以直接把一行记录按列名转换为JavaBean。</p>
<p>如果我们执行的不是查询，而是插入、更新和删除操作，那么需要使用<code>update()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入SQL，SQL参数，返回更新的行数:</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != jdbcTemplate.update(<span class="string">&quot;UPDATE users SET name = ? WHERE id = ?&quot;</span>, user.getName(), user.getId())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User not found by id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一种<code>INSERT</code>操作比较特殊，那就是如果某一列是自增列（例如自增主键），通常，我们需要获取插入后的自增值。<code>JdbcTemplate</code>提供了一个<code>KeyHolder</code>来简化这一操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个KeyHolder:</span></span><br><span class="line">    <span class="type">KeyHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneratedKeyHolder</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != jdbcTemplate.update(</span><br><span class="line">        <span class="comment">// 参数1:PreparedStatementCreator</span></span><br><span class="line">        (conn) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(<span class="string">&quot;INSERT INTO users(email, password, name) VALUES(?, ?, ?)&quot;</span>,</span><br><span class="line">                    Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">            ps.setObject(<span class="number">1</span>, email);</span><br><span class="line">            ps.setObject(<span class="number">2</span>, password);</span><br><span class="line">            ps.setObject(<span class="number">3</span>, name);</span><br><span class="line">            <span class="keyword">return</span> ps;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 参数2:KeyHolder</span></span><br><span class="line">        holder)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Insert failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从KeyHolder中获取返回的自增值:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(holder.getKey().longValue(), email, password, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JdbcTemplate</code>还有许多重载方法，这里我们不一一介绍。需要强调的是，<code>JdbcTemplate</code>只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写<code>try(resource) &#123;...&#125;</code>的代码，对于查询，主要通过<code>RowMapper</code>实现了JDBC结果集到Java对象的转换。</p>
<p>我们总结一下<code>JdbcTemplate</code>的用法，那就是：</p>
<ul>
<li>针对简单查询，优选<code>query()</code>和<code>queryForObject()</code>，因为只需提供SQL语句、参数和<code>RowMapper</code>；</li>
<li>针对更新操作，优选<code>update()</code>，因为只需提供SQL语句和参数；</li>
<li>任何复杂的操作，最终也可以通过<code>execute(ConnectionCallback)</code>实现，因为拿到<code>Connection</code>就可以做任何JDBC操作。</li>
</ul>
<p>实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用<code>BeanPropertyRowMapper</code>就很方便。如果表结构和JavaBean不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。</p>
<p>例如，表的列名是<code>office_address</code>，而JavaBean属性是<code>workAddress</code>，就需要指定别名，改写查询如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, email, office_address AS workAddress, name FROM users <span class="type">WHERE</span> <span class="variable">email</span> <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>
<h3 id="练习">练习</h3>
<p>使用JdbcTemplate。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/jdbc/spring-data-jdbc.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>Spring提供了<code>JdbcTemplate</code>来简化JDBC操作；</p>
<p>使用<code>JdbcTemplate</code>时，根据需要优先选择高级方法；</p>
<p>任何JDBC操作都可以使用保底的<code>execute(ConnectionCallback)</code>方法。</p>
<p>使用Spring操作JDBC虽然方便，但是我们在前面讨论JDBC的时候，讲到过<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/jdbc/tx/index.html">JDBC事务</a>，如果要在Spring中操作事务，没必要手写JDBC事务，可以使用Spring提供的高级接口来操作事务。</p>
<p>Spring提供了一个<code>PlatformTransactionManager</code>来表示事务管理器，所有的事务都由它负责管理。而事务由<code>TransactionStatus</code>表示。如果手写事务代码，使用<code>try...catch</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开启事务:</span></span><br><span class="line">    tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="comment">// 相关JDBC操作:</span></span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="comment">// 提交事务:</span></span><br><span class="line">    txManager.commit(tx);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务:</span></span><br><span class="line">    txManager.rollback(tx);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring为啥要抽象出<code>PlatformTransactionManager</code>和<code>TransactionStatus</code>？原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。</p>
<p>Spring为了同时支持JDBC和JTA两种事务模型，就抽象出<code>PlatformTransactionManager</code>。因为我们的代码只需要JDBC事务，因此，在<code>AppConfig</code>中，需要再定义一个<code>PlatformTransactionManager</code>对应的Bean，它的实际类型是<code>DataSourceTransactionManager</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在<code>AppConfig</code>中追加一个上述定义的<code>PlatformTransactionManager</code>外，再加一个<code>@EnableTransactionManagement</code>就可以启用声明式事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 启用声明式</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，对需要事务支持的方法，加一个<code>@Transactional</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 此public方法自动具有事务支持:</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者更简单一点，直接在Bean的<code>class</code>处加上，表示所有<code>public</code>方法都具有事务支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring对一个声明式事务的方法，如何开启事务支持？原理仍然是AOP代理，即通过自动创建Bean的Proxy实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService$$EnhancerBySpringCGLIB</span> <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> ...</span><br><span class="line">    <span class="type">PlatformTransactionManager</span> <span class="variable">txManager</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx = txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">            target.register(email, password, name);</span><br><span class="line">            txManager.commit(tx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            txManager.rollback(tx);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：声明了<code>@EnableTransactionManagement</code>后，不必额外添加<code>@EnableAspectJAutoProxy</code>。</p>
<h3 id="回滚事务">回滚事务</h3>
<p>默认情况下，如果发生了<code>RuntimeException</code>，Spring的声明式事务将自动回滚。在一个事务方法中，如果程序判断需要回滚事务，只需抛出<code>RuntimeException</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">buyProducts</span><span class="params">(<span class="type">long</span> productId, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (store &lt; num) &#123;</span><br><span class="line">        <span class="comment">// 库存不够，购买失败:</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No enough products&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要针对Checked Exception回滚事务，需要在<code>@Transactional</code>注解中写出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;RuntimeException.class, IOException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">buyProducts</span><span class="params">(<span class="type">long</span> productId, <span class="type">int</span> num)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码表示在抛出<code>RuntimeException</code>或<code>IOException</code>时，事务将回滚。</p>
<p>为了简化代码，我们强烈建议业务异常体系从<code>RuntimeException</code>派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginException</span> <span class="keyword">extends</span> <span class="title class_">BusinessException</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentException</span> <span class="keyword">extends</span> <span class="title class_">BusinessException</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事务边界">事务边界</h3>
<p>在使用事务的时候，明确事务边界非常重要。对于声明式事务，例如，下面的<code>register()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123; <span class="comment">// 事务开始</span></span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="comment">// 事务结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的事务边界就是<code>register()</code>方法开始和结束。</p>
<p>类似的，一个负责给用户增加积分的<code>addBonus()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BonusService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBonus</span><span class="params">(<span class="type">long</span> userId, <span class="type">int</span> bonus)</span> &#123; <span class="comment">// 事务开始</span></span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="comment">// 事务结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的事务边界就是<code>addBonus()</code>方法开始和结束。</p>
<p>在现实世界中，问题总是要复杂一点点。用户注册后，能自动获得100积分，因此，实际代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BonusService bonusService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 插入用户记录:</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.insert(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="comment">// 增加100积分:</span></span><br><span class="line">        bonusService.addBonus(user.id, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在问题来了：调用方（比如<code>RegisterController</code>）调用<code>UserService.register()</code>这个事务方法，它在内部又调用了<code>BonusService.addBonus()</code>这个事务方法，一共有几个事务？如果<code>addBonus()</code>抛出了异常需要回滚事务，<code>register()</code>方法的事务是否也要回滚？</p>
<p>问题的复杂度是不是一下子提高了10倍？</p>
<h3 id="事务传播">事务传播</h3>
<p>要解决上面的问题，我们首先要定义事务的传播模型。</p>
<p>假设用户注册的入口是<code>RegisterController</code>，它本身没有事务，仅仅是调用<code>UserService.register()</code>这个事务方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doRegister</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.register(email, password, name);</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，<code>UserService.register()</code>这个事务方法的起始和结束，就是事务的范围。</p>
<p>我们需要关心的问题是，在<code>UserService.register()</code>这个事务方法内，调用<code>BonusService.addBonus()</code>，我们期待的事务行为是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 事务已开启:</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.insert(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="comment">// ???:</span></span><br><span class="line">    bonusService.addBonus(user.id, <span class="number">100</span>);</span><br><span class="line">&#125; <span class="comment">// 事务结束</span></span><br></pre></td></tr></table></figure>
<p>对于大多数业务来说，我们期待<code>BonusService.addBonus()</code>的调用，和<code>UserService.register()</code>应当融合在一起，它的行为应该如下：</p>
<p><code>UserService.register()</code>已经开启了一个事务，那么在内部调用<code>BonusService.addBonus()</code>时，<code>BonusService.addBonus()</code>方法就没必要再开启一个新事务，直接加入到<code>BonusService.register()</code>的事务里就好了。</p>
<p>其实就相当于：</p>
<ol>
<li><code>UserService.register()</code>先执行了一条INSERT语句：<code>INSERT INTO users ...</code></li>
<li><code>BonusService.addBonus()</code>再执行一条INSERT语句：<code>INSERT INTO bonus ...</code></li>
</ol>
<p>因此，Spring的声明式事务为事务传播定义了几个级别，默认传播级别就是REQUIRED，它的意思是，如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。</p>
<p>我们观察<code>UserService.register()</code>方法，它在<code>RegisterController</code>中执行，因为<code>RegisterController</code>没有事务，因此，<code>UserService.register()</code>方法会自动创建一个新事务。</p>
<p>在<code>UserService.register()</code>方法内部，调用<code>BonusService.addBonus()</code>方法时，因为<code>BonusService.addBonus()</code>检测到当前已经有事务了，因此，它会加入到当前事务中执行。</p>
<p>因此，整个业务流程的事务边界就清晰了：它只有一个事务，并且范围就是<code>UserService.register()</code>方法。</p>
<p>有的童鞋会问：把<code>BonusService.addBonus()</code>方法的<code>@Transactional</code>去掉，变成一个普通方法，那不就规避了复杂的传播模型吗？</p>
<p>去掉<code>BonusService.addBonus()</code>方法的<code>@Transactional</code>，会引来另一个问题，即其他地方如果调用<code>BonusService.addBonus()</code>方法，那就没法保证事务了。例如，规定用户登录时积分+5：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BonusService bonusService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doLogin</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ...</span><br><span class="line">        bonusService.addBonus(user.id, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，<code>BonusService.addBonus()</code>方法必须要有<code>@Transactional</code>，否则，登录后积分就无法添加了。</p>
<p>默认的事务传播级别是<code>REQUIRED</code>，它满足绝大部分的需求。还有一些其他的传播级别：</p>
<p><code>SUPPORTS</code>：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；</p>
<p><code>MANDATORY</code>：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；</p>
<p><code>REQUIRES_NEW</code>：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；</p>
<p><code>NOT_SUPPORTED</code>：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；</p>
<p><code>NEVER</code>：和<code>NOT_SUPPORTED</code>相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；</p>
<p><code>NESTED</code>：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。</p>
<p>上面这么多种事务的传播级别，其实默认的<code>REQUIRED</code>已经满足绝大部分需求，<code>SUPPORTS</code>和<code>REQUIRES_NEW</code>在少数情况下会用到，其他基本不会用到，因为把事务搞得越复杂，不仅逻辑跟着复杂，而且速度也会越慢。</p>
<p>定义事务的传播级别也是写在<code>@Transactional</code>注解里的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只剩最后一个问题了：Spring是如何传播事务的？</p>
<p>我们<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/jdbc/tx/index.html">在JDBC中使用事务</a>的时候，是这么个写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> openConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭自动提交:</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 执行多条SQL语句:</span></span><br><span class="line">    insert(); update(); delete();</span><br><span class="line">    <span class="comment">// 提交事务:</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务:</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？</p>
<p>答案是<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/threading/thread-local/index.html">使用ThreadLocal</a>。Spring总是把JDBC相关的<code>Connection</code>和<code>TransactionStatus</code>实例绑定到<code>ThreadLocal</code>。如果一个事务方法从<code>ThreadLocal</code>未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从<code>ThreadLocal</code>获取的JDBC连接以及<code>TransactionStatus</code>。</p>
<p>因此，事务能正确传播的前提是，方法调用是在一个线程内才行。如果像下面这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123; <span class="comment">// BEGIN TX-A</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.insert(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// BEGIN TX-B:</span></span><br><span class="line">        bonusService.addBonus(user.id, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// END TX-B</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125; <span class="comment">// END TX-A</span></span><br></pre></td></tr></table></figure>
<p>在另一个线程中调用<code>BonusService.addBonus()</code>，它根本获取不到当前事务，因此，<code>UserService.register()</code>和<code>BonusService.addBonus()</code>两个方法，将分别开启两个完全独立的事务。</p>
<p>换句话说，事务只能在当前线程传播，无法跨线程传播。</p>
<p>那如果我们想实现跨线程传播事务呢？原理很简单，就是要想办法把当前线程绑定到<code>ThreadLocal</code>的<code>Connection</code>和<code>TransactionStatus</code>实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。</p>
<h3 id="练习-2">练习</h3>
<p>使用声明式事务。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/declarative-tx/spring-data-tx.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>Spring提供的声明式事务极大地方便了在数据库中使用事务，正确使用声明式事务的关键在于确定好事务边界，理解事务传播级别。</p>
<p>在传统的多层应用程序中，通常是Web层调用业务层，业务层调用数据访问层。业务层负责处理各种业务逻辑，而数据访问层只负责对数据进行增删改查。因此，实现数据访问层就是用<code>JdbcTemplate</code>实现对数据库的操作。</p>
<p>编写数据访问层的时候，可以使用DAO模式。DAO即Data Access Object的缩写，它没有什么神秘之处，实现起来基本如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(<span class="type">int</span> page)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring提供了一个<code>JdbcDaoSupport</code>类，用于简化DAO的实现。这个<code>JdbcDaoSupport</code>没什么复杂的，核心代码就是持有一个<code>JdbcTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JdbcDaoSupport</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setJdbcTemplate</span><span class="params">(JdbcTemplate jdbcTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">        initTemplateConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的意图是子类直接从<code>JdbcDaoSupport</code>继承后，可以随时调用<code>getJdbcTemplate()</code>获得<code>JdbcTemplate</code>的实例。那么问题来了：因为<code>JdbcDaoSupport</code>的<code>jdbcTemplate</code>字段没有标记<code>@Autowired</code>，所以，子类想要注入<code>JdbcTemplate</code>，还得自己想个办法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setJdbcTemplate(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的童鞋可能看出来了：既然<code>UserDao</code>都已经注入了<code>JdbcTemplate</code>，那再把它放到父类里，通过<code>getJdbcTemplate()</code>访问岂不是多此一举？</p>
<p>如果使用传统的XML配置，并不需要编写<code>@Autowired JdbcTemplate jdbcTemplate</code>，但是考虑到现在基本上是使用注解的方式，我们可以编写一个<code>AbstractDao</code>，专门负责注入<code>JdbcTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDao</span> <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setJdbcTemplate(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，子类的代码就非常干净，可以直接调用<code>getJdbcTemplate()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">AbstractDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getJdbcTemplate().queryForObject(</span><br><span class="line">                <span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class),</span><br><span class="line">                id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若肯再多写一点样板代码，就可以把<code>AbstractDao</code>改成泛型，并实现<code>getById()</code>，<code>getAll()</code>，<code>deleteById()</code>这样的通用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDao</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String table;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; entityClass;</span><br><span class="line">    <span class="keyword">private</span> RowMapper&lt;T&gt; rowMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前类型的泛型类型:</span></span><br><span class="line">        <span class="built_in">this</span>.entityClass = getParameterizedType();</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="built_in">this</span>.entityClass.getSimpleName().toLowerCase() + <span class="string">&quot;s&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.rowMapper = <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(entityClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getJdbcTemplate().queryForObject(<span class="string">&quot;SELECT * FROM &quot;</span> + table + <span class="string">&quot; WHERE id = ?&quot;</span>, <span class="built_in">this</span>.rowMapper, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getAll</span><span class="params">(<span class="type">int</span> pageIndex)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> limit * (pageIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getJdbcTemplate().query(<span class="string">&quot;SELECT * FROM &quot;</span> + table + <span class="string">&quot; LIMIT ? OFFSET ?&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; limit, offset &#125;,</span><br><span class="line">                <span class="built_in">this</span>.rowMapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        getJdbcTemplate().update(<span class="string">&quot;DELETE FROM &quot;</span> + table + <span class="string">&quot; WHERE id = ?&quot;</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，每个子类就自动获得了这些通用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">AbstractDao</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 已经有了:</span></span><br><span class="line">    <span class="comment">// User getById(long)</span></span><br><span class="line">    <span class="comment">// List&lt;User&gt; getAll(int)</span></span><br><span class="line">    <span class="comment">// void deleteById(long)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">AbstractDao</span>&lt;Book&gt; &#123;</span><br><span class="line">    <span class="comment">// 已经有了:</span></span><br><span class="line">    <span class="comment">// Book getById(long)</span></span><br><span class="line">    <span class="comment">// List&lt;Book&gt; getAll(int)</span></span><br><span class="line">    <span class="comment">// void deleteById(long)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，DAO模式就是一个简单的数据访问模式，是否使用DAO，根据实际情况决定，因为很多时候，直接在Service层操作数据库也是完全没有问题的。</p>
<h3 id="练习-3">练习</h3>
<p>使用DAO模式访问数据库。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/dao/spring-data-dao.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>Spring提供了<code>JdbcDaoSupport</code>来便于我们实现DAO模式；</p>
<p>可以基于泛型实现更通用、更简洁的DAO模式。</p>
<p>使用<code>JdbcTemplate</code>的时候，我们用得最多的方法就是<code>List&lt;T&gt; query(String, RowMapper, Object...)</code>。这个<code>RowMapper</code>的作用就是把<code>ResultSet</code>的一行记录映射为Java Bean。</p>
<p>这种把关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping。ORM既可以把记录转换成Java对象，也可以把Java对象转换为行记录。</p>
<p>使用<code>JdbcTemplate</code>配合<code>RowMapper</code>可以看作是最原始的ORM。如果要实现更自动化的ORM，可以选择成熟的ORM框架，例如<a target="_blank" rel="noopener" href="https://hibernate.org/">Hibernate</a>。</p>
<p>我们来看看如何在Spring中集成Hibernate。</p>
<p>Hibernate作为ORM框架，它可以替代<code>JdbcTemplate</code>，但Hibernate仍然需要JDBC驱动，所以，我们需要引入JDBC驱动、连接池，以及Hibernate本身。在Maven中，我们加入以下依赖项：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
<li>org.springframework:spring-orm:6.0.0</li>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
<li>jakarta.persistence:jakarta.persistence-api:3.1.0</li>
<li>org.hibernate:hibernate-core:6.1.4.Final</li>
<li>com.zaxxer:HikariCP:5.0.1</li>
<li>org.hsqldb:hsqldb:2.7.1</li>
</ul>
<p>在<code>AppConfig</code>中，我们仍然需要创建<code>DataSource</code>、引入JDBC配置文件，以及启用声明式事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了启用Hibernate，我们需要创建一个<code>LocalSessionFactoryBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    LocalSessionFactoryBean <span class="title function_">createSessionFactory</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>); <span class="comment">// 生产环境不要使用</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.dialect&quot;</span>, <span class="string">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="type">var</span> <span class="variable">sessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalSessionFactoryBean</span>();</span><br><span class="line">        sessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 扫描指定的package获取所有entity class:</span></span><br><span class="line">        sessionFactoryBean.setPackagesToScan(<span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>);</span><br><span class="line">        sessionFactoryBean.setHibernateProperties(props);</span><br><span class="line">        <span class="keyword">return</span> sessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/customize/index.html">定制Bean</a>中讲到过<code>FactoryBean</code>，<code>LocalSessionFactoryBean</code>是一个<code>FactoryBean</code>，它会再自动创建一个<code>SessionFactory</code>，在Hibernate中，<code>Session</code>是封装了一个JDBC <code>Connection</code>的实例，而<code>SessionFactory</code>是封装了JDBC <code>DataSource</code>的实例，即<code>SessionFactory</code>持有连接池，每次需要操作数据库的时候，<code>SessionFactory</code>创建一个新的<code>Session</code>，相当于从连接池获取到一个新的<code>Connection</code>。<code>SessionFactory</code>就是Hibernate提供的最核心的一个对象，但<code>LocalSessionFactoryBean</code>是Spring提供的为了让我们方便创建<code>SessionFactory</code>的类。</p>
<p>注意到上面创建<code>LocalSessionFactoryBean</code>的代码，首先用<code>Properties</code>持有Hibernate初始化<code>SessionFactory</code>时用到的所有设置，常用的设置请参考<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#configurations">Hibernate文档</a>，这里我们只定义了3个设置：</p>
<ul>
<li><code>hibernate.hbm2ddl.auto=update</code>：表示自动创建数据库的表结构，注意不要在生产环境中启用；</li>
<li><code>hibernate.dialect=org.hibernate.dialect.HSQLDialect</code>：指示Hibernate使用的数据库是HSQLDB。Hibernate使用一种HQL的查询语句，它和SQL类似，但真正在“翻译”成SQL时，会根据设定的数据库“方言”来生成针对数据库优化的SQL；</li>
<li><code>hibernate.show_sql=true</code>：让Hibernate打印执行的SQL，这对于调试非常有用，我们可以方便地看到Hibernate生成的SQL语句是否符合我们的预期。</li>
</ul>
<p>除了设置<code>DataSource</code>和<code>Properties</code>之外，注意到<code>setPackagesToScan()</code>我们传入了一个<code>package</code>名称，它指示Hibernate扫描这个包下面的所有Java类，自动找出能映射为数据库表记录的JavaBean。后面我们会仔细讨论如何编写符合Hibernate要求的JavaBean。</p>
<p>紧接着，我们还需要创建<code>HibernateTransactionManager</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> SessionFactory sessionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HibernateTransactionManager</span>(sessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HibernateTransactionManager</code>是配合Hibernate使用声明式事务所必须的。到此为止，所有的配置都定义完毕，我们来看看如何将数据库表结构映射为Java对象。</p>
<p>考察如下的数据库表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> <span class="keyword">user</span></span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    createdAt <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `email` (`email`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中，<code>id</code>是自增主键，<code>email</code>、<code>password</code>、<code>name</code>是<code>VARCHAR</code>类型，<code>email</code>带唯一索引以确保唯一性，<code>createdAt</code>存储整型类型的时间戳。用JavaBean表示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Long createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种映射关系十分易懂，但我们需要添加一些注解来告诉Hibernate如何把<code>User</code>类映射到表记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个JavaBean被用于映射，我们就标记一个<code>@Entity</code>。默认情况下，映射的表名是<code>user</code>，如果实际的表名不同，例如实际表名是<code>users</code>，可以追加一个<code>@Table(name=&quot;users&quot;)</code>表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个属性到数据库列的映射用<code>@Column()</code>标识，<code>nullable</code>指示列是否允许为<code>NULL</code>，<code>updatable</code>指示该列是否允许被用在<code>UPDATE</code>语句，<code>length</code>指示<code>String</code>类型的列的长度（如果没有指定，默认是<code>255</code>）。</p>
<p>对于主键，还需要用<code>@Id</code>标识，自增主键再追加一个<code>@GeneratedValue</code>，以便Hibernate能读取到自增主键的值。</p>
<p>细心的童鞋可能还注意到，主键<code>id</code>定义的类型不是<code>long</code>，而是<code>Long</code>。这是因为Hibernate如果检测到主键为<code>null</code>，就不会在<code>INSERT</code>语句中指定主键的值，而是返回由数据库生成的自增值，否则，Hibernate认为我们的程序指定了主键的值，会在<code>INSERT</code>语句中直接列出。<code>long</code>型字段总是具有默认值<code>0</code>，因此，每次插入的主键值总是0，导致除第一次外后续插入都将失败。</p>
<p><code>createdAt</code>虽然是整型，但我们并没有使用<code>long</code>，而是<code>Long</code>，这是因为使用基本类型会导致findByExample查询会添加意外的条件，这里只需牢记，作为映射使用的JavaBean，所有属性都使用包装类型而不是基本类型。</p>
<p>注意</p>
<p>使用Hibernate时，不要使用基本类型的属性，总是使用包装类型，如Long或Integer。</p>
<p>类似的，我们再定义一个<code>Book</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果仔细观察<code>User</code>和<code>Book</code>，会发现它们定义的<code>id</code>、<code>createdAt</code>属性是一样的，这在数据库表结构的设计中很常见：对于每个表，通常我们会统一使用一种主键生成机制，并添加<code>createdAt</code>表示创建时间，<code>updatedAt</code>表示修改时间等通用字段。</p>
<p>不必在<code>User</code>和<code>Book</code>中重复定义这些通用字段，我们可以把它们提到一个抽象类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getCreatedAt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">public</span> ZonedDateTime <span class="title function_">getCreatedDateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(<span class="built_in">this</span>.createdAt).atZone(ZoneId.systemDefault());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        setCreatedAt(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>AbstractEntity</code>来说，我们要标注一个<code>@MappedSuperclass</code>表示它用于继承。此外，注意到我们定义了一个<code>@Transient</code>方法，它返回一个“虚拟”的属性。因为<code>getCreatedDateTime()</code>是计算得出的属性，而不是从数据库表读出的值，因此必须要标注<code>@Transient</code>，否则Hibernate会尝试从数据库读取名为<code>createdDateTime</code>这个不存在的字段从而出错。</p>
<p>再注意到<code>@PrePersist</code>标识的方法，它表示在我们将一个JavaBean持久化到数据库之前（即执行INSERT语句），Hibernate会先执行该方法，这样我们就可以自动设置好<code>createdAt</code>属性。</p>
<p>有了<code>AbstractEntity</code>，我们就可以大幅简化<code>User</code>和<code>Book</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">AbstractEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, unique = true, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到使用的所有注解均来自<code>jakarta.persistence</code>，它是JPA规范的一部分。这里我们只介绍使用注解的方式配置Hibernate映射关系，不再介绍传统的比较繁琐的XML配置。通过Spring集成Hibernate时，也不再需要<code>hibernate.cfg.xml</code>配置文件，用一句话总结：</p>
<p>提示</p>
<p>使用Spring集成Hibernate，配合JPA注解，无需任何额外的XML配置。</p>
<p>类似<code>User</code>、<code>Book</code>这样的用于ORM的Java Bean，我们通常称之为Entity Bean。</p>
<p>最后，我们来看看如果对<code>user</code>表进行增删改查。因为使用了Hibernate，因此，我们要做的，实际上是对<code>User</code>这个JavaBean进行“增删改查”。我们编写一个<code>UserService</code>，注入<code>SessionFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SessionFactory sessionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Insert操作">Insert操作</h3>
<p>要持久化一个<code>User</code>实例，我们只需调用<code>persist()</code>方法。以<code>register()</code>方法为例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个User对象:</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">// 设置好各个属性:</span></span><br><span class="line">    user.setEmail(email);</span><br><span class="line">    user.setPassword(password);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="comment">// 不要设置id，因为使用了自增主键</span></span><br><span class="line">    <span class="comment">// 保存到数据库:</span></span><br><span class="line">    sessionFactory.getCurrentSession().persist(user);</span><br><span class="line">    <span class="comment">// 现在已经自动获得了id:</span></span><br><span class="line">    System.out.println(user.getId());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Delete操作">Delete操作</h3>
<p>删除一个<code>User</code>相当于从表中删除对应的记录。注意Hibernate总是用<code>id</code>来删除记录，因此，要正确设置<code>User</code>的<code>id</code>属性才能正常删除记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sessionFactory.getCurrentSession().byId(User.class).load(id);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        sessionFactory.getCurrentSession().remove(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过主键删除记录时，一个常见的用法是先根据主键加载该记录，再删除。注意到当记录不存在时，<code>load()</code>返回<code>null</code>。</p>
<h3 id="Update操作">Update操作</h3>
<p>更新记录相当于先更新<code>User</code>的指定属性，然后调用<code>merge()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id, String name)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sessionFactory.getCurrentSession().byId(User.class).load(id);</span><br><span class="line">    user.setName(name);</span><br><span class="line">    sessionFactory.getCurrentSession().merge(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们在定义<code>User</code>时，对有的属性标注了<code>@Column(updatable=false)</code>。Hibernate在更新记录时，它只会把<code>@Column(updatable=true)</code>的属性加入到<code>UPDATE</code>语句中，这样可以提供一层额外的安全性，即如果不小心修改了<code>User</code>的<code>email</code>、<code>createdAt</code>等属性，执行<code>update()</code>时并不会更新对应的数据库列。但也必须牢记：这个功能是Hibernate提供的，如果绕过Hibernate直接通过JDBC执行<code>UPDATE</code>语句仍然可以更新数据库的任意列的值。</p>
<p>最后，我们编写的大部分方法都是各种各样的查询。根据<code>id</code>查询我们可以直接调用<code>load()</code>，如果要使用条件查询，例如，假设我们想执行以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> email <span class="operator">=</span> ? <span class="keyword">AND</span> password <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>
<p>我们来看看可以使用什么查询。</p>
<h3 id="使用HQL查询">使用HQL查询</h3>
<p>一种常用的查询是直接编写Hibernate内置的HQL查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = sessionFactory.getCurrentSession()</span><br><span class="line">        .createQuery(<span class="string">&quot;from User u where u.email = ?1 and u.password = ?2&quot;</span>, User.class)</span><br><span class="line">        .setParameter(<span class="number">1</span>, email).setParameter(<span class="number">2</span>, password)</span><br><span class="line">        .list();</span><br></pre></td></tr></table></figure>
<p>和SQL相比，HQL使用类名和属性名，由Hibernate自动转换为实际的表名和列名。详细的HQL语法可以参考<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/6.1/userguide/html_single/Hibernate_User_Guide.html#query-language">Hibernate文档</a>。</p>
<p>除了可以直接传入HQL字符串外，Hibernate还可以使用一种<code>NamedQuery</code>，它给查询起个名字，然后保存在注解中。使用<code>NamedQuery</code>时，我们要先在<code>User</code>类标注：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NamedQueries(</span></span><br><span class="line"><span class="meta">    @NamedQuery(</span></span><br><span class="line"><span class="meta">        // 查询名称:</span></span><br><span class="line"><span class="meta">        name = &quot;login&quot;,</span></span><br><span class="line"><span class="meta">        // 查询语句:</span></span><br><span class="line"><span class="meta">        query = &quot;SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">AbstractEntity</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到引入的<code>NamedQuery</code>是<code>jakarta.persistence.NamedQuery</code>，它和直接传入HQL有点不同的是，占位符使用<code>:e</code>和<code>:pwd</code>。</p>
<p>使用<code>NamedQuery</code>只需要引入查询名和参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    List&lt;User&gt; list = sessionFactory.getCurrentSession()</span><br><span class="line">        .createNamedQuery(<span class="string">&quot;login&quot;</span>, User.class) <span class="comment">// 创建NamedQuery</span></span><br><span class="line">        .setParameter(<span class="string">&quot;e&quot;</span>, email) <span class="comment">// 绑定e参数</span></span><br><span class="line">        .setParameter(<span class="string">&quot;pwd&quot;</span>, password) <span class="comment">// 绑定pwd参数</span></span><br><span class="line">        .list();</span><br><span class="line">    <span class="keyword">return</span> list.isEmpty() ? <span class="literal">null</span> : list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接写HQL和使用<code>NamedQuery</code>各有优劣。前者可以在代码中直观地看到查询语句，后者可以在<code>User</code>类统一管理所有相关查询。</p>
<h3 id="练习-4">练习</h3>
<p>集成Hibernate操作数据库。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/hibernate/spring-data-hibernate.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>在Spring中集成Hibernate需要配置的Bean如下：</p>
<ul>
<li>DataSource；</li>
<li>LocalSessionFactory；</li>
<li>HibernateTransactionManager。</li>
</ul>
<p>推荐使用Annotation配置所有的Entity Bean。</p>
<p>上一节我们讲了在Spring中集成Hibernate。Hibernate是第一个被广泛使用的ORM框架，但是很多小伙伴还听说过JPA：Java Persistence API，这又是啥？</p>
<p>在讨论JPA之前，我们要注意到JavaEE早在1999年就发布了，并且有Servlet、JMS等诸多标准。和其他平台不同，Java世界早期非常热衷于标准先行，各家跟进：大家先坐下来把接口定了，然后，各自回家干活去实现接口，这样，用户就可以在不同的厂家提供的产品进行选择，还可以随意切换，因为用户编写代码的时候只需要引用接口，并不需要引用具体的底层实现（想想JDBC）。</p>
<p>JPA就是JavaEE的一个ORM标准，它的实现其实和Hibernate没啥本质区别，但是用户如果使用JPA，那么引用的就是<code>jakarta.persistence</code>这个“标准”包，而不是<code>org.hibernate</code>这样的第三方包。因为JPA只是接口，所以，还需要选择一个实现产品，跟JDBC接口和MySQL驱动一个道理。</p>
<p>我们使用JPA时也完全可以选择Hibernate作为底层实现，但也可以选择其它的JPA提供方，比如<a target="_blank" rel="noopener" href="https://www.eclipse.org/eclipselink/">EclipseLink</a>。Spring内置了JPA的集成，并支持选择Hibernate或EclipseLink作为实现。这里我们仍然以主流的Hibernate作为JPA实现为例子，演示JPA的基本用法。</p>
<p>和使用Hibernate一样，我们只需要引入如下依赖：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
<li>org.springframework:spring-orm:6.0.0</li>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
<li>jakarta.persistence:jakarta.persistence-api:3.1.0</li>
<li>org.hibernate:hibernate-core:6.1.4.Final</li>
<li>com.zaxxer:HikariCP:5.0.1</li>
<li>org.hsqldb:hsqldb:2.7.1</li>
</ul>
<p>实际上我们这里引入的依赖和上一节集成Hibernate引入的依赖完全一样，因为Hibernate既提供了它自己的接口，也提供了JPA接口，我们用JPA接口就相当于通过JPA操作Hibernate。</p>
<p>然后，在<code>AppConfig</code>中启用声明式事务管理，创建<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Hibernate时，我们需要创建一个<code>LocalSessionFactoryBean</code>，并让它再自动创建一个<code>SessionFactory</code>。使用JPA也是类似的，我们也创建一个<code>LocalContainerEntityManagerFactoryBean</code>，并让它再自动创建一个<code>EntityManagerFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title function_">createEntityManagerFactory</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">emFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalContainerEntityManagerFactoryBean</span>();</span><br><span class="line">    <span class="comment">// 注入DataSource:</span></span><br><span class="line">    emFactory.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">// 扫描指定的package获取所有entity class:</span></span><br><span class="line">    emFactory.setPackagesToScan(AbstractEntity.class.getPackageName());</span><br><span class="line">    <span class="comment">// 使用Hibernate作为JPA实现:</span></span><br><span class="line">    emFactory.setJpaVendorAdapter(<span class="keyword">new</span> <span class="title class_">HibernateJpaVendorAdapter</span>());</span><br><span class="line">    <span class="comment">// 其他配置项:</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    props.setProperty(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>); <span class="comment">// 生产环境不要使用</span></span><br><span class="line">    props.setProperty(<span class="string">&quot;hibernate.dialect&quot;</span>, <span class="string">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    emFactory.setJpaProperties(props);</span><br><span class="line">    <span class="keyword">return</span> emFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，除了需要注入<code>DataSource</code>和设定自动扫描的<code>package</code>外，还需要指定JPA的提供商，这里使用Spring提供的一个<code>HibernateJpaVendorAdapter</code>，最后，针对Hibernate自己需要的配置，以<code>Properties</code>的形式注入。</p>
<p>最后，我们还需要实例化一个<code>JpaTransactionManager</code>，以实现声明式事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> EntityManagerFactory entityManagerFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JpaTransactionManager</span>(entityManagerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就完成了JPA的全部初始化工作。有些童鞋可能从网上搜索得知JPA需要<code>persistence.xml</code>配置文件，以及复杂的<code>orm.xml</code>文件。这里我们负责地告诉大家，使用Spring+Hibernate作为JPA实现，无需任何配置文件。</p>
<p>所有Entity Bean的配置和上一节完全相同，全部采用Annotation标注。我们现在只需关心具体的业务类如何通过JPA接口操作数据库。</p>
<p>还是以<code>UserService</code>为例，除了标注<code>@Component</code>和<code>@Transactional</code>外，我们需要注入一个<code>EntityManager</code>，但是不要使用<code>Autowired</code>，而是<code>@PersistenceContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    EntityManager em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们回顾一下JDBC、Hibernate和JPA提供的接口，实际上，它们的关系如下：</p>
<table>
<thead>
<tr>
<th>JDBC</th>
<th>Hibernate</th>
<th>JPA</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataSource</td>
<td>SessionFactory</td>
<td>EntityManagerFactory</td>
</tr>
<tr>
<td>Connection</td>
<td>Session</td>
<td>EntityManager</td>
</tr>
</tbody>
</table>
<p><code>SessionFactory</code>和<code>EntityManagerFactory</code>相当于<code>DataSource</code>，<code>Session</code>和<code>EntityManager</code>相当于<code>Connection</code>。每次需要访问数据库的时候，需要获取新的<code>Session</code>和<code>EntityManager</code>，用完后再关闭。</p>
<p>但是，注意到<code>UserService</code>注入的不是<code>EntityManagerFactory</code>，而是<code>EntityManager</code>，并且标注了<code>@PersistenceContext</code>。难道使用JPA可以允许多线程操作同一个<code>EntityManager</code>？</p>
<p>实际上这里注入的并不是真正的<code>EntityManager</code>，而是一个<code>EntityManager</code>的代理类，相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntityManagerProxy</span> <span class="keyword">implements</span> <span class="title class_">EntityManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EntityManagerFactory emf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring遇到标注了<code>@PersistenceContext</code>的<code>EntityManager</code>会自动注入代理，该代理会在必要的时候自动打开<code>EntityManager</code>。换句话说，多线程引用的<code>EntityManager</code>虽然是同一个代理类，但该代理类内部针对不同线程会创建不同的<code>EntityManager</code>实例。</p>
<p>简单总结一下，标注了<code>@PersistenceContext</code>的<code>EntityManager</code>可以被多线程安全地共享。</p>
<p>因此，在<code>UserService</code>的每个业务方法里，直接使用<code>EntityManager</code>就很方便。以主键查询为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.em.find(User.class, id);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User not found by id: &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与HQL查询类似，JPA使用JPQL查询，它的语法和HQL基本差不多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">fetchUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="comment">// JPQL查询:</span></span><br><span class="line">    TypedQuery&lt;User&gt; query = em.createQuery(<span class="string">&quot;SELECT u FROM User u WHERE u.email = :e&quot;</span>, User.class);</span><br><span class="line">    query.setParameter(<span class="string">&quot;e&quot;</span>, email);</span><br><span class="line">    List&lt;User&gt; list = query.getResultList();</span><br><span class="line">    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，JPA也支持<code>NamedQuery</code>，即先给查询起个名字，再按名字创建查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    TypedQuery&lt;User&gt; query = em.createNamedQuery(<span class="string">&quot;login&quot;</span>, User.class);</span><br><span class="line">    query.setParameter(<span class="string">&quot;e&quot;</span>, email);</span><br><span class="line">    query.setParameter(<span class="string">&quot;pwd&quot;</span>, password);</span><br><span class="line">    List&lt;User&gt; list = query.getResultList();</span><br><span class="line">    <span class="keyword">return</span> list.isEmpty() ? <span class="literal">null</span> : list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NamedQuery</code>通过注解标注在<code>User</code>类上，它的定义和上一节的<code>User</code>类一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NamedQueries(</span></span><br><span class="line"><span class="meta">    @NamedQuery(</span></span><br><span class="line"><span class="meta">        name = &quot;login&quot;,</span></span><br><span class="line"><span class="meta">        query = &quot;SELECT u FROM User u WHERE u.email=:e AND u.password=:pwd&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对数据库进行增删改的操作，可以分别使用<code>persist()</code>、<code>remove()</code>和<code>merge()</code>方法，参数均为Entity Bean本身，使用非常简单，这里不再多述。</p>
<h3 id="练习-5">练习</h3>
<p>使用JPA操作数据库。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/jpa/spring-data-jpa.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>在Spring中集成JPA要选择一个实现，可以选择Hibernate或EclipseLink；</p>
<p>使用JPA与Hibernate类似，但注入的核心资源是带有<code>@PersistenceContext</code>注解的<code>EntityManager</code>代理类。</p>
<p>使用Hibernate或JPA操作数据库时，这类ORM干的主要工作就是把ResultSet的每一行变成Java Bean，或者把Java Bean自动转换到INSERT或UPDATE语句的参数中，从而实现ORM。</p>
<p>而ORM框架之所以知道如何把行数据映射到Java Bean，是因为我们在Java Bean的属性上给了足够的注解作为元数据，ORM框架获取Java Bean的注解后，就知道如何进行双向映射。</p>
<p>那么，ORM框架是如何跟踪Java Bean的修改，以便在<code>update()</code>操作中更新必要的属性？</p>
<p>答案是使用<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/structural/proxy/index.html">Proxy模式</a>，从ORM框架读取的User实例实际上并不是User类，而是代理类，代理类继承自User类，但针对每个setter方法做了覆写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> _isNameChanged;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setName(name);</span><br><span class="line">        _isNameChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，代理类可以跟踪到每个属性的变化。</p>
<p>针对一对多或多对一关系时，代理类可以直接通过getter方法查询数据库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    Session _session;</span><br><span class="line">    <span class="type">boolean</span> _isNameChanged;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setName(name);</span><br><span class="line">        _isNameChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取User对象关联的Address对象:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Query</span> <span class="variable">q</span> <span class="operator">=</span> _session.createQuery(<span class="string">&quot;from Address where userId = :userId&quot;</span>);</span><br><span class="line">        q.setParameter(<span class="string">&quot;userId&quot;</span>, <span class="built_in">this</span>.getId());</span><br><span class="line">        List&lt;Address&gt; list = query.list();</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty() ? <span class="literal">null</span> : list(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了实现这样的查询，UserProxy必须保存Hibernate的当前Session。但是，当事务提交后，Session自动关闭，此时再获取<code>getAddress()</code>将无法访问数据库，或者获取的不是事务一致的数据。因此，ORM框架总是引入了Attached/Detached状态，表示当前此Java Bean到底是在Session的范围内，还是脱离了Session变成了一个“游离”对象。很多初学者无法正确理解状态变化和事务边界，就会造成大量的<code>PersistentObjectException</code>异常。这种隐式状态使得普通Java Bean的生命周期变得复杂。</p>
<p>此外，Hibernate和JPA为了实现兼容多种数据库，它使用HQL或JPQL查询，经过一道转换，变成特定数据库的SQL，理论上这样可以做到无缝切换数据库，但这一层自动转换除了少许的性能开销外，给SQL级别的优化带来了麻烦。</p>
<p>最后，ORM框架通常提供了缓存，并且还分为一级缓存和二级缓存。一级缓存是指在一个Session范围内的缓存，常见的情景是根据主键查询时，两次查询可以返回同一实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> session.load(User.class, <span class="number">123</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session.load(User.class, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>二级缓存是指跨Session的缓存，一般默认关闭，需要手动配置。二级缓存极大的增加了数据的不一致性，原因在于SQL非常灵活，常常会导致意外的更新。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1读取:</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> session1.load(User.class, <span class="number">123</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 一段时间后，线程2读取:</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> session2.load(User.class, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>当二级缓存生效的时候，两个线程读取的User实例是一样的，但是，数据库对应的行记录完全可能被修改，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给老用户增加100积分:</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> bonus <span class="operator">=</span> bonus <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> createdAt <span class="operator">&lt;=</span> ?</span><br></pre></td></tr></table></figure>
<p>ORM无法判断<code>id=123</code>的用户是否受该<code>UPDATE</code>语句影响。考虑到数据库通常会支持多个应用程序，此UPDATE语句可能由其他进程执行，ORM框架就更不知道了。</p>
<p>我们把这种ORM框架称之为全自动ORM框架。</p>
<p>对比Spring提供的JdbcTemplate，它和ORM框架相比，主要有几点差别：</p>
<ol>
<li>查询后需要手动提供Mapper实例以便把ResultSet的每一行变为Java对象；</li>
<li>增删改操作所需的参数列表，需要手动传入，即把User实例变为[user.id, <a target="_blank" rel="noopener" href="http://user.name">user.name</a>, user.email]这样的列表，比较麻烦。</li>
</ol>
<p>但是JdbcTemplate的优势在于它的确定性：即每次读取操作一定是数据库操作而不是缓存，所执行的SQL是完全确定的，缺点就是代码比较繁琐，构造<code>INSERT INTO users VALUES (?,?,?)</code>更是复杂。</p>
<p>所以，介于全自动ORM如Hibernate和手写全部如JdbcTemplate之间，还有一种半自动的ORM，它只负责把ResultSet自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL。<a target="_blank" rel="noopener" href="https://mybatis.org/">MyBatis</a>就是这样一种半自动化ORM框架。</p>
<p>我们来看看如何在Spring中集成MyBatis。</p>
<p>首先，我们要引入MyBatis本身，其次，由于Spring并没有像Hibernate那样内置对MyBatis的集成，所以，我们需要再引入MyBatis官方自己开发的一个与Spring集成的库：</p>
<ul>
<li>org.mybatis:mybatis:3.5.11</li>
<li>org.mybatis:mybatis-spring:3.0.0</li>
</ul>
<p>和前面一样，先创建<code>DataSource</code>是必不可少的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回顾一下Hibernate和JPA的<code>SessionFactory</code>与<code>EntityManagerFactory</code>，MyBatis与之对应的是<code>SqlSessionFactory</code>和<code>SqlSession</code>：</p>
<table>
<thead>
<tr>
<th>JDBC</th>
<th>Hibernate</th>
<th>JPA</th>
<th>MyBatis</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataSource</td>
<td>SessionFactory</td>
<td>EntityManagerFactory</td>
<td>SqlSessionFactory</td>
</tr>
<tr>
<td>Connection</td>
<td>Session</td>
<td>EntityManager</td>
<td>SqlSession</td>
</tr>
</tbody>
</table>
<p>可见，ORM的设计套路都是类似的。使用MyBatis的核心就是创建<code>SqlSessionFactory</code>，这里我们需要创建的是<code>SqlSessionFactoryBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SqlSessionFactoryBean <span class="title function_">createSqlSessionFactoryBean</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为MyBatis可以直接使用Spring管理的声明式事务，因此，创建事务管理器和使用JDBC是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和Hibernate不同的是，MyBatis使用Mapper来实现映射，而且Mapper必须是接口。我们以<code>User</code>类为例，在<code>User</code>类和<code>users</code>表之间映射的<code>UserMapper</code>编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">	<span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">	User <span class="title function_">getById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里的Mapper不是<code>JdbcTemplate</code>的<code>RowMapper</code>的概念，它是定义访问<code>users</code>表的接口方法。比如我们定义了一个<code>User getById(long)</code>的主键查询方法，不仅要定义接口方法本身，还要明确写出查询的SQL，这里用注解<code>@Select</code>标记。SQL语句的任何参数，都与方法参数按名称对应。例如，方法参数id的名字通过注解<code>@Param()</code>标记为<code>id</code>，则SQL语句里将来替换的占位符就是<code>#&#123;id&#125;</code>。</p>
<p>如果有多个参数，那么每个参数命名后直接在SQL中写出对应的占位符即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM users LIMIT #&#123;offset&#125;, #&#123;maxResults&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getAll</span><span class="params">(<span class="meta">@Param(&quot;offset&quot;)</span> <span class="type">int</span> offset, <span class="meta">@Param(&quot;maxResults&quot;)</span> <span class="type">int</span> maxResults)</span>;</span><br></pre></td></tr></table></figure>
<p>注意：MyBatis执行查询后，将根据方法的返回类型自动把ResultSet的每一行转换为User实例，转换规则当然是按列名和属性名对应。如果列名和属性名不同，最简单的方式是编写SELECT语句的别名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列名是created_time，属性名是createdAt:</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, email, created_time <span class="keyword">AS</span> createdAt <span class="keyword">FROM</span> users</span><br></pre></td></tr></table></figure>
<p>执行INSERT语句就稍微麻烦点，因为我们希望传入User实例，因此，定义的方法接口与<code>@Insert</code>注解如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user)</span>;</span><br></pre></td></tr></table></figure>
<p>上述方法传入的参数名称是<code>user</code>，参数类型是User类，在SQL中引用的时候，以<code>#&#123;obj.property&#125;</code>的方式写占位符。和Hibernate这样的全自动化ORM相比，MyBatis必须写出完整的INSERT语句。</p>
<p>如果<code>users</code>表的<code>id</code>是自增主键，那么，我们在SQL中不传入<code>id</code>，但希望获取插入后的主键，需要再加一个<code>@Options</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;, keyColumn = &quot;id&quot;)</span></span><br><span class="line"><span class="meta">@Insert(&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user)</span>;</span><br></pre></td></tr></table></figure>
<p><code>keyProperty</code>和<code>keyColumn</code>分别指出JavaBean的属性和数据库的主键列名。</p>
<p>执行<code>UPDATE</code>和<code>DELETE</code>语句相对比较简单，我们定义方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;UPDATE users SET name = #&#123;user.name&#125;, createdAt = #&#123;user.createdAt&#125; WHERE id = #&#123;user.id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete(&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br></pre></td></tr></table></figure>
<p>有了<code>UserMapper</code>接口，还需要对应的实现类才能真正执行这些数据库操作的方法。虽然可以自己写实现类，但我们除了编写<code>UserMapper</code>接口外，还有<code>BookMapper</code>、<code>BonusMapper</code>……一个一个写太麻烦，因此，MyBatis提供了一个<code>MapperFactoryBean</code>来自动创建所有Mapper的实现类。可以用一个简单的注解来启用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.itranswarp.learnjava.mapper&quot;)</span></span><br><span class="line">...其他注解...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>@MapperScan</code>，就可以让MyBatis自动扫描指定包的所有Mapper并创建实现类。在真正的业务逻辑中，我们可以直接注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 注入UserMapper:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Mapper方法:</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getById(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;User not found by id.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，业务逻辑主要就是通过<code>XxxMapper</code>定义的数据库方法来访问数据库。</p>
<h3 id="XML配置">XML配置</h3>
<p>上述在Spring中集成MyBatis的方式，我们只需要用到注解，并没有任何XML配置文件。MyBatis也允许使用XML配置映射关系和SQL语句，例如，更新<code>User</code>时根据属性值构造动态SQL：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">  UPDATE users SET</span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;user.name != null&quot;</span>&gt;</span> name = #&#123;user.name&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;user.hobby != null&quot;</span>&gt;</span> hobby = #&#123;user.hobby&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;user.summary != null&quot;</span>&gt;</span> summary = #&#123;user.summary&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  WHERE id = #&#123;user.id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写XML配置的优点是可以组装出动态SQL，并且把所有SQL操作集中在一起。缺点是配置起来太繁琐，调用方法时如果想查看SQL还需要定位到XML配置中。这里我们不介绍XML的配置方式，需要了解的童鞋请自行阅读<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html">官方文档</a>。</p>
<p>使用MyBatis最大的问题是所有SQL都需要全部手写，优点是执行的SQL就是我们自己写的SQL，对SQL进行优化非常简单，也可以编写任意复杂的SQL，或者使用数据库的特定语法，但切换数据库可能就不太容易。好消息是大部分项目并没有切换数据库的需求，完全可以针对某个数据库编写尽可能优化的SQL。</p>
<h3 id="练习-6">练习</h3>
<p>集成MyBatis操作数据库。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/mybatis/spring-data-mybatis.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>MyBatis是一个半自动化的ORM框架，需要手写SQL语句，没有自动加载一对多或多对一关系的功能。</p>
<p>我们从前几节可以看到，所谓ORM，也是建立在JDBC的基础上，通过ResultSet到JavaBean的映射，实现各种查询。有自动跟踪Entity修改的全自动化ORM如Hibernate和JPA，需要为每个Entity创建代理，也有完全自己映射，连INSERT和UPDATE语句都需要手动编写的MyBatis，但没有任何透明的Proxy。</p>
<p>而查询是涉及到数据库使用最广泛的操作，需要最大的灵活性。各种ORM解决方案各不相同，Hibernate和JPA自己实现了HQL和JPQL查询语法，用以生成最终的SQL，而MyBatis则完全手写，每增加一个查询都需要先编写SQL并增加接口方法。</p>
<p>还有一种Hibernate和JPA支持的Criteria查询，用Hibernate写出来类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DetachedCriteria</span> <span class="variable">criteria</span> <span class="operator">=</span> DetachedCriteria.forClass(User.class);</span><br><span class="line">criteria.add(Restrictions.eq(<span class="string">&quot;email&quot;</span>, email))</span><br><span class="line">        .add(Restrictions.eq(<span class="string">&quot;password&quot;</span>, password));</span><br><span class="line">List&lt;User&gt; list = (List&lt;User&gt;) hibernateTemplate.findByCriteria(criteria);</span><br></pre></td></tr></table></figure>
<p>上述Criteria查询写法复杂，但和JPA相比，还是小巫见大巫了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cb</span> <span class="operator">=</span> em.getCriteriaBuilder();</span><br><span class="line">CriteriaQuery&lt;User&gt; q = cb.createQuery(User.class);</span><br><span class="line">Root&lt;User&gt; r = q.from(User.class);</span><br><span class="line">q.where(cb.equal(r.get(<span class="string">&quot;email&quot;</span>), cb.parameter(String.class, <span class="string">&quot;e&quot;</span>)));</span><br><span class="line">TypedQuery&lt;User&gt; query = em.createQuery(q);</span><br><span class="line">query.setParameter(<span class="string">&quot;e&quot;</span>, email);</span><br><span class="line">List&lt;User&gt; list = query.getResultList();</span><br></pre></td></tr></table></figure>
<p>此外，是否支持自动读取一对多和多对一关系也是全自动化ORM框架的一个重要功能。</p>
<p>如果我们自己来设计并实现一个ORM，应该吸取这些ORM的哪些特色，然后高效实现呢？</p>
<h3 id="设计ORM接口">设计ORM接口</h3>
<p>任何设计，都必须明确设计目标。这里我们准备实现的ORM并不想要全自动ORM那种自动读取一对多和多对一关系的功能，也不想给Entity加上复杂的状态，因此，对于Entity来说，它就是纯粹的JavaBean，没有任何Proxy。</p>
<p>此外，ORM要兼顾易用性和适用性。易用性是指能覆盖95%的应用场景，但总有一些复杂的SQL，很难用ORM去自动生成，因此，也要给出原生的JDBC接口，能支持5%的特殊需求。</p>
<p>最后，我们希望设计的接口要易于编写，并使用流式API便于阅读。为了配合编译器检查，还应该支持泛型，避免强制转型。</p>
<p>以User类为例，我们设计的查询接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按主键查询: SELECT * FROM users WHERE id = ?</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> db.get(User.class, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件查询唯一记录: SELECT * FROM users WHERE email = ? AND password = ?</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> db.from(User.class)</span><br><span class="line">           .where(<span class="string">&quot;email=? AND password=?&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;bob123&quot;</span>)</span><br><span class="line">           .unique();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件查询多条记录: SELECT * FROM users WHERE id &lt; ? ORDER BY email LIMIT ?, ?</span></span><br><span class="line">List&lt;User&gt; us = db.from(User.class)</span><br><span class="line">                  .where(<span class="string">&quot;id &lt; ?&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">                  .orderBy(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">                  .limit(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">                  .list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询特定列: SELECT id, name FROM users WHERE email = ?</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> db.select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">           .from(User.class)</span><br><span class="line">           .where(<span class="string">&quot;email = ?&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>)</span><br><span class="line">           .unique();</span><br></pre></td></tr></table></figure>
<p>这样的流式API便于阅读，也非常容易推导出最终生成的SQL。</p>
<p>对于插入、更新和删除操作，就相对比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入User:</span></span><br><span class="line">db.insert(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按主键更新更新User:</span></span><br><span class="line">db.update(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按主键删除User:</span></span><br><span class="line">db.delete(User.class, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>对于Entity来说，通常一个表对应一个。手动列出所有Entity是非常麻烦的，一定要传入package自动扫描。</p>
<p>最后，ORM总是需要元数据才能知道如何映射。我们不想编写复杂的XML配置，也没必要自己去定义一套规则，直接使用JPA的注解就行。</p>
<h3 id="实现ORM">实现ORM</h3>
<p>我们并不需要从JDBC底层开始编写，并且，还要考虑到事务，最好能直接使用Spring的声明式事务。实际上，我们可以设计一个全局<code>DbTemplate</code>，它注入了Spring的<code>JdbcTemplate</code>，涉及到数据库操作时，全部通过<code>JdbcTemplate</code>完成，自然天生支持Spring的声明式事务，因为这个ORM只是在<code>JdbcTemplate</code>的基础上做了一层封装。</p>
<p>在<code>AppConfig</code>中，我们初始化所有Bean如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JdbcTemplate <span class="title function_">createJdbcTemplate</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DbTemplate <span class="title function_">createDbTemplate</span><span class="params">(<span class="meta">@Autowired</span> JdbcTemplate jdbcTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DbTemplate</span>(jdbcTemplate, <span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PlatformTransactionManager <span class="title function_">createTxManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是我们所需的所有配置。</p>
<p>编写业务逻辑，例如<code>UserService</code>，写出来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DbTemplate db;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> db.get(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> db.from(User.class)</span><br><span class="line">                 .where(<span class="string">&quot;email = ?&quot;</span>, email)</span><br><span class="line">                 .unique();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(<span class="type">int</span> pageIndex)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> db.from(User.class)</span><br><span class="line">                 .orderBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                 .limit((pageIndex - <span class="number">1</span>) * pageSize, pageSize)</span><br><span class="line">                 .list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setEmail(email);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setCreatedAt(System.currentTimeMillis());</span><br><span class="line">        db.insert(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码给出了ORM的接口，以及如何在业务逻辑中使用ORM。下一步，就是如何实现这个<code>DbTemplate</code>。这里我们只给出框架代码，有兴趣的童鞋可以自己实现核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存Entity Class到Mapper的映射:</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Mapper&lt;?&gt;&gt; classMapping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fetch</span><span class="params">(Class&lt;T&gt; clazz, Object id)</span> &#123;</span><br><span class="line">        Mapper&lt;T&gt; mapper = getMapper(clazz);</span><br><span class="line">        List&lt;T&gt; list = (List&lt;T&gt;) jdbcTemplate.query(mapper.selectSQL, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; id &#125;, mapper.rowMapper);</span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(Class&lt;T&gt; clazz, Object id)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T bean)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(T bean)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Class&lt;T&gt; clazz, Object id)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现链式API的核心代码是第一步从<code>DbTemplate</code>调用<code>select()</code>或<code>from()</code>时实例化一个<code>CriteriaQuery</code>实例，并在后续的链式调用中设置它的字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbTemplate</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Select <span class="title function_">select</span><span class="params">(String... selectFields)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Select</span>(<span class="keyword">new</span> <span class="title class_">Criteria</span>(<span class="built_in">this</span>), selectFields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; From&lt;T&gt; <span class="title function_">from</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        Mapper&lt;T&gt; mapper = getMapper(entityClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">From</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Criteria</span>&lt;&gt;(<span class="built_in">this</span>), mapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后以此定义<code>Select</code>、<code>From</code>、<code>Where</code>、<code>OrderBy</code>、<code>Limit</code>等。在<code>From</code>中可以设置Class类型、表名等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">From</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">CriteriaQuery</span>&lt;T&gt; &#123;</span><br><span class="line">    From(Criteria&lt;T&gt; criteria, Mapper&lt;T&gt; mapper) &#123;</span><br><span class="line">        <span class="built_in">super</span>(criteria);</span><br><span class="line">        <span class="comment">// from可以设置class、tableName:</span></span><br><span class="line">        <span class="built_in">this</span>.criteria.mapper = mapper;</span><br><span class="line">        <span class="built_in">this</span>.criteria.clazz = mapper.entityClass;</span><br><span class="line">        <span class="built_in">this</span>.criteria.table = mapper.tableName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Where&lt;T&gt; <span class="title function_">where</span><span class="params">(String clause, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Where</span>&lt;&gt;(<span class="built_in">this</span>.criteria, clause, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Where</code>中可以设置条件参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Where</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">CriteriaQuery</span>&lt;T&gt; &#123;</span><br><span class="line">    Where(Criteria&lt;T&gt; criteria, String clause, Object... params) &#123;</span><br><span class="line">        <span class="built_in">super</span>(criteria);</span><br><span class="line">        <span class="built_in">this</span>.criteria.where = clause;</span><br><span class="line">        <span class="built_in">this</span>.criteria.whereParams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// add:</span></span><br><span class="line">        <span class="keyword">for</span> (Object param : params) &#123;</span><br><span class="line">            <span class="built_in">this</span>.criteria.whereParams.add(param);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，链式调用的尽头是调用<code>list()</code>返回一组结果，调用<code>unique()</code>返回唯一结果，调用<code>first()</code>返回首个结果。</p>
<p>在IDE中，可以非常方便地实现链式调用：</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/database/orm/db.gif" alt="db"></p>
<p>需要复杂查询的时候，总是可以使用<code>JdbcTemplate</code>执行任意复杂的SQL。</p>
<h3 id="练习-7">练习</h3>
<p>设计并实现一个微型ORM。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/database/orm/spring-data-orm.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>ORM框架就是自动映射数据库表结构到JavaBean的工具，设计并实现一个简单高效的ORM框架并不困难。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-AOP/"
                            aria-label=": JAVA-Spring开发-AOP"
                        >
                            JAVA-Spring开发-AOP
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T16:20:21+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>AOP是Aspect Oriented Programming，即面向切面编程。</p>
<p>那什么是AOP？</p>
<p>我们先回顾一下OOP：Object Oriented Programming，OOP作为面向对象编程的模式，获得了巨大的成功，OOP的主要功能是数据封装、继承和多态。</p>
<p>而AOP是一种新的编程方式，它和OOP不同，OOP把系统看作多个对象的交互，AOP把系统分解为不同的关注点，或者称之为切面（Aspect）。</p>
<p>要理解AOP的概念，我们先用OOP举例，比如一个业务组件<code>BookService</code>，它有几个业务方法：</p>
<ul>
<li>createBook：添加新的Book；</li>
<li>updateBook：修改Book；</li>
<li>deleteBook：删除Book。</li>
</ul>
<p>对每个业务方法，例如，<code>createBook()</code>，除了业务逻辑，还需要安全检查、日志记录和事务处理，它的代码像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> startTransaction();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 核心业务逻辑</span></span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;created book: &quot;</span> + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续编写<code>updateBook()</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> startTransaction();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 核心业务逻辑</span></span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            tx.rollback();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;updated book: &quot;</span> + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化。</p>
<p>考察业务模型可以发现，<code>BookService</code>关心的是自身的核心逻辑，但整个系统还要求关注安全检查、日志、事务等功能，这些功能实际上“横跨”多个业务方法，为了实现这些功能，不得不在每个业务方法上重复编写代码。</p>
<p>一种可行的方式是使用<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/structural/proxy/index.html">Proxy模式</a>，将某个功能，例如，权限检查，放入Proxy中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityCheckBookService</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BookService target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityCheckBookService</span><span class="params">(BookService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.createBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.updateBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.deleteBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">securityCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的缺点是比较麻烦，必须先抽取接口，然后，针对每个方法实现Proxy。</p>
<p>另一种方法是，既然<code>SecurityCheckBookService</code>的代码都是标准的Proxy样板代码，不如把权限检查视作一种切面（Aspect），把日志、事务也视为切面，然后，以某种自动化的方式，把切面织入到核心逻辑中，实现Proxy模式。</p>
<p>如果我们以AOP的视角来编写上述业务，可以依次实现：</p>
<ol>
<li>核心逻辑，即BookService；</li>
<li>切面逻辑，即：
<ol>
<li>权限检查的Aspect；</li>
<li>日志的Aspect；</li>
<li>事务的Aspect。</li>
</ol>
</li>
</ol>
<p>然后，以某种方式，让框架来把上述3个Aspect以Proxy的方式“织入”到<code>BookService</code>中，这样一来，就不必编写复杂而冗长的Proxy模式。</p>
<h3 id="AOP原理">AOP原理</h3>
<p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。</p>
<p>在Java平台上，对于AOP的织入，有3种方式：</p>
<ol>
<li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li>
<li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li>
<li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li>
</ol>
<p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>或者<a target="_blank" rel="noopener" href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p>
<p>AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p>
<p>需要特别指出的是，AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，我们只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。</p>
<p>在AOP编程中，我们经常会遇到下面的概念：</p>
<ul>
<li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；</li>
<li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；</li>
<li>Pointcut：切入点，即一组连接点的集合；</li>
<li>Advice：增强，指特定连接点上执行的动作；</li>
<li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li>
<li>Weaving：织入，指将切面整合到程序的执行流程中；</li>
<li>Interceptor：拦截器，是一种实现增强的方式；</li>
<li>Target Object：目标对象，即真正执行业务的核心逻辑对象；</li>
<li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用。</li>
</ul>
<p>看完上述术语，是不是感觉对AOP有了进一步的困惑？其实，我们不用关心AOP创造的“术语”，只需要理解AOP本质上只是一种代理模式的实现方式，在Spring的容器中实现AOP特别方便。</p>
<p>我们以<code>UserService</code>和<code>MailService</code>为例，这两个属于核心业务逻辑，现在，我们准备给<code>UserService</code>的每个业务方法执行前添加日志，给<code>MailService</code>的每个业务方法执行前后添加日志，在Spring中，需要以下步骤：</p>
<p>首先，我们通过Maven引入Spring对AOP的支持：</p>
<ul>
<li>org.springframework:spring-aspects:6.0.0</li>
</ul>
<p>上述依赖会自动引入AspectJ，使用AspectJ实现AOP比较方便，因为它的定义比较简单。</p>
<p>然后，我们定义一个<code>LoggingAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 在执行UserService的每个方法前执行:</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Before] do access check...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行MailService的每个方法前后执行:</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] start &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] done &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察<code>doAccessCheck()</code>方法，我们定义了一个<code>@Before</code>注解，后面的字符串是告诉AspectJ应该在何处执行该方法，这里写的意思是：执行<code>UserService</code>的每个<code>public</code>方法前执行<code>doAccessCheck()</code>代码。</p>
<p>再观察<code>doLogging()</code>方法，我们定义了一个<code>@Around</code>注解，它和<code>@Before</code>不同，<code>@Around</code>可以决定是否执行目标方法，因此，我们在<code>doLogging()</code>内部先打印日志，再调用方法，最后打印日志后返回结果。</p>
<p>在<code>LoggingAspect</code>类的声明处，除了用<code>@Component</code>表示它本身也是一个Bean外，我们再加上<code>@Aspect</code>注解，表示它的<code>@Before</code>标注的方法需要注入到<code>UserService</code>的每个<code>public</code>方法执行前，<code>@Around</code>标注的方法需要注入到<code>MailService</code>的每个<code>public</code>方法执行前后。</p>
<p>紧接着，我们需要给<code>@Configuration</code>类加上一个<code>@EnableAspectJAutoProxy</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring的IoC容器看到这个注解，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。执行代码，我们可以看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">Welcome, test!</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br><span class="line">Hi, Bob! You are logged in at 2020-02-14T23:13:52.167996+08:00[Asia/Shanghai]</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br></pre></td></tr></table></figure>
<p>这说明执行业务逻辑前后，确实执行了我们定义的Aspect（即<code>LoggingAspect</code>的方法）。</p>
<p>有些童鞋会问，<code>LoggingAspect</code>定义的方法，是如何注入到其他Bean的呢？</p>
<p>其实AOP的原理非常简单。我们以<code>LoggingAspect.doAccessCheck()</code>为例，要把它注入到<code>UserService</code>的每个<code>public</code>方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserServiceAopProxy <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceAopProxy</span><span class="params">(UserService target, LoggingAspect aspect)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.aspect = aspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 先执行Aspect的代码:</span></span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="comment">// 再执行UserService的逻辑:</span></span><br><span class="line">        <span class="keyword">return</span> target.login(email, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="keyword">return</span> target.register(email, password, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是Spring容器启动时为我们自动创建的注入了Aspect的子类，它取代了原始的<code>UserService</code>（原始的<code>UserService</code>实例作为内部变量隐藏在<code>UserServiceAopProxy</code>中）。如果我们打印从Spring容器获取的<code>UserService</code>实例类型，它类似<code>UserService$$EnhancerBySpringCGLIB$$1f44e01c</code>，实际上是Spring使用CGLIB动态创建的子类，但对于调用方来说，感觉不到任何区别。</p>
<p>注意</p>
<p>Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</p>
<p>可见，虽然Spring容器内部实现AOP的逻辑比较复杂（需要使用AspectJ解析注解，并通过CGLIB实现代理类），但我们使用AOP非常简单，一共需要三步：</p>
<ol>
<li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li>
<li>标记<code>@Component</code>和<code>@Aspect</code>；</li>
<li>在<code>@Configuration</code>类上标注<code>@EnableAspectJAutoProxy</code>。</li>
</ol>
<p>至于AspectJ的注入语法则比较复杂，请参考<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples">Spring文档</a>。</p>
<p>Spring也提供其他方法来装配AOP，但都没有使用AspectJ注解的方式来得简洁明了，所以我们不再作介绍。</p>
<h3 id="拦截器类型">拦截器类型</h3>
<p>顾名思义，拦截器有以下类型：</p>
<ul>
<li>@Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li>
<li>@After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li>
<li>@AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</li>
<li>@AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</li>
<li>@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</li>
</ul>
<h3 id="练习">练习</h3>
<p>使用AOP实现日志。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/aop/basic/spring-aop-logging.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>在Spring容器中使用AOP非常简单，只需要定义执行方法，并用AspectJ的注解标注应该在何处触发并执行。</p>
<p>Spring通过CGLIB动态创建子类等方式来实现AOP代理模式，大大简化了代码。</p>
<p>上一节我们讲解了使用AspectJ的注解，并配合一个复杂的<code>execution(* xxx.Xyz.*(..))</code>语法来定义应该如何装配AOP。</p>
<p>在实际项目中，这种写法其实很少使用。假设你写了一个<code>SecurityAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SecurityContext.getCurrentUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;check failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本能实现无差别全覆盖，即某个包下面的所有Bean的所有方法都会被这个<code>check()</code>方法拦截。</p>
<p>还有的童鞋喜欢用方法名前缀进行拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(public * update*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 对update开头的方法切换数据源:</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">old</span> <span class="operator">=</span> setCurrentDataSource(<span class="string">&quot;master&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    restoreCurrentDataSource(old);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种非精准打击误伤面更大，因为从方法前缀区分是否是数据库操作是非常不可取的。</p>
<p>我们在使用AOP时，要注意到虽然Spring容器可以把指定的方法通过AOP规则装配到指定的Bean的指定方法前后，但是，如果自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。</p>
<p>使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。例如，Spring提供的<code>@Transactional</code>就是一个非常好的例子。如果我们自己写的Bean希望在一个数据库事务中被调用，就标注上<code>@Transactional</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 有事务:</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无事务:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有事务:</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接在class级别注解，表示“所有public方法都被安排了”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>@Transactional</code>，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。</p>
<p>我们以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，我们定义一个性能监控的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MetricTime &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要被监控的关键方法上标注该注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 监控register()方法性能:</span></span><br><span class="line">    <span class="meta">@MetricTime(&quot;register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们定义<code>MetricAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(metricTime)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">metric</span><span class="params">(ProceedingJoinPoint joinPoint, MetricTime metricTime)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> metricTime.value();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">            <span class="comment">// 写入日志或发送至JMX:</span></span><br><span class="line">            System.err.println(<span class="string">&quot;[Metrics] &quot;</span> + name + <span class="string">&quot;: &quot;</span> + t + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>metric()</code>方法标注了<code>@Around(&quot;@annotation(metricTime)&quot;)</code>，它的意思是，符合条件的目标方法是带有<code>@MetricTime</code>注解的方法，因为<code>metric()</code>方法参数类型是<code>MetricTime</code>（注意参数名是<code>metricTime</code>不是<code>MetricTime</code>），我们通过它获取性能监控的名称。</p>
<p>有了<code>@MetricTime</code>注解，再配合<code>MetricAspect</code>，任何Bean，只要方法标注了<code>@MetricTime</code>注解，就可以自动实现性能监控。运行代码，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome, Bob!</span><br><span class="line">[Metrics] register: 16ms</span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>使用注解+AOP实现性能监控。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/aop/annotation-config/spring-aop-metrics.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>使用注解实现AOP需要先定义注解，然后使用<code>@Around(&quot;@annotation(name)&quot;)</code>实现装配；</p>
<p>使用注解既简单，又能明确标识AOP装配，是使用AOP推荐的方式。</p>
<p>无论是使用AspectJ语法，还是配合Annotation，使用AOP，实际上就是让Spring自动为我们创建一个Proxy，使得调用方能无感知地调用指定方法，但运行期却动态“织入”了其他逻辑，因此，AOP本质上就是一个<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/structural/proxy/index.html">代理模式</a>。</p>
<p>因为Spring使用了CGLIB来实现运行期动态创建Proxy，如果我们没能深入理解其运行原理和实现机制，就极有可能遇到各种诡异的问题。</p>
<p>我们来看一个实际的例子。</p>
<p>假设我们定义了一个<code>UserService</code>的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService(): init...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService(): zoneId = &quot;</span> + <span class="built_in">this</span>.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public方法:</span></span><br><span class="line">    <span class="keyword">public</span> ZoneId <span class="title function_">getZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> zoneId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public final方法:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ZoneId <span class="title function_">getFinalZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> zoneId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写个<code>MailService</code>，并注入<code>UserService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> userService.zoneId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dt</span> <span class="operator">=</span> ZonedDateTime.now(zoneId).toString();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, it is &quot;</span> + dt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后用<code>main()</code>方法测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">MailService</span> <span class="variable">mailService</span> <span class="operator">=</span> context.getBean(MailService.class);</span><br><span class="line">        System.out.println(mailService.sendMail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看输出，一切正常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService(): init...</span><br><span class="line">UserService(): zoneId = Asia/Shanghai</span><br><span class="line">Hello, it is 2020-04-12T10:23:22.917721+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>
<p>下一步，我们给<code>UserService</code>加上AOP支持，就添加一个最简单的<code>LoggingAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com..*.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Before] do access check...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别忘了在<code>AppConfig</code>上加上<code>@EnableAspectJAutoProxy</code>。再次运行，不出意外的话，会得到一个<code>NullPointerException</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: zone</span><br><span class="line">    at java.base/java.util.Objects.requireNonNull(Objects.java:246)</span><br><span class="line">    at java.base/java.time.Clock.system(Clock.java:203)</span><br><span class="line">    at java.base/java.time.ZonedDateTime.now(ZonedDateTime.java:216)</span><br><span class="line">    at com.itranswarp.learnjava.service.MailService.sendMail(MailService.java:19)</span><br><span class="line">    at com.itranswarp.learnjava.AppConfig.main(AppConfig.java:21)</span><br></pre></td></tr></table></figure>
<p>仔细跟踪代码，会发现<code>null</code>值出现在<code>MailService.sendMail()</code>内部的这一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> userService.zoneId;</span><br><span class="line">        System.out.println(zoneId); <span class="comment">// null</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还故意在<code>UserService</code>中特意用<code>final</code>修饰了一下成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>final</code>标注的成员变量为<code>null</code>？逗我呢？</p>
<h3 id="怎么肥四？">怎么肥四？</h3>
<p>为什么加了AOP就报NPE，去了AOP就一切正常？<code>final</code>字段不执行，难道JVM有问题？为了解答这个诡异的问题，我们需要深入理解Spring使用CGLIB生成Proxy的原理：</p>
<p>第一步，正常创建一个<code>UserService</code>的原始实例，这是通过反射调用构造方法实现的，它的行为和我们预期的完全一致；</p>
<p>第二步，通过CGLIB创建一个<code>UserService</code>的子类，并引用了原始实例和<code>LoggingAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserService$$EnhancerBySpringCGLIB <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    UserService target;</span><br><span class="line">    LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserService$$EnhancerBySpringCGLIB() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ZoneId <span class="title function_">getZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="keyword">return</span> target.getZoneId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们观察Spring创建的AOP代理，它的类名总是类似<code>UserService$$EnhancerBySpringCGLIB$$1c76af9d</code>（你没看错，Java的类名实际上允许<code>$</code>字符）。为了让调用方获得<code>UserService</code>的引用，它必须继承自<code>UserService</code>。然后，该代理类会覆写所有<code>public</code>和<code>protected</code>方法，并在内部将调用委托给原始的<code>UserService</code>实例。</p>
<p>这里出现了两个<code>UserService</code>实例：</p>
<p>一个是我们代码中定义的<em>原始实例</em>，它的成员变量已经按照我们预期的方式被初始化完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br></pre></td></tr></table></figure>
<p>第二个<code>UserService</code>实例实际上类型是<code>UserService$$EnhancerBySpringCGLIB</code>，它引用了原始的<code>UserService</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService$$EnhancerBySpringCGLIB</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService$$EnhancerBySpringCGLIB</span>();</span><br><span class="line">proxy.target = original;</span><br><span class="line">proxy.aspect = ...</span><br></pre></td></tr></table></figure>
<p>注意到这种情况仅出现在启用了AOP的情况，此刻，从<code>ApplicationContext</code>中获取的<code>UserService</code>实例是proxy，注入到<code>MailService</code>中的<code>UserService</code>实例也是proxy。</p>
<p>那么最终的问题来了：proxy实例的成员变量，也就是从<code>UserService</code>继承的<code>zoneId</code>，它的值是<code>null</code>。</p>
<p>原因在于，<code>UserService</code>成员变量的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>UserService$$EnhancerBySpringCGLIB</code>中，并未执行。原因是，没必要初始化proxy的成员变量，因为proxy的目的是代理方法。</p>
<p>实际上，成员变量的初始化是在构造方法中完成的。这是我们看到的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是编译器实际编译的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ZoneId zoneId;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 构造方法的第一行代码总是调用super()</span></span><br><span class="line">        zoneId = ZoneId.systemDefault(); <span class="comment">// 继续初始化成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，对于Spring通过CGLIB动态创建的<code>UserService$$EnhancerBySpringCGLIB</code>代理类，它的构造方法中，并未调用<code>super()</code>，因此，从父类继承的成员变量，包括<code>final</code>类型的成员变量，统统都没有初始化。</p>
<p>有的童鞋会问：Java语言规定，任何类的构造方法，第一行必须调用<code>super()</code>，如果没有，编译器会自动加上，怎么Spring的CGLIB就可以搞特殊？</p>
<p>这是因为自动加<code>super()</code>的功能是Java编译器实现的，它发现你没加，就自动给加上，发现你加错了，就报编译错误。但实际上，如果直接构造字节码，一个类的构造方法中，不一定非要调用<code>super()</code>。Spring使用CGLIB构造的Proxy类，是直接生成字节码，并没有源码-编译-字节码这个步骤，因此：</p>
<p>注意</p>
<p>Spring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！</p>
<p>再考察<code>MailService</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> userService.zoneId;</span><br><span class="line">        System.out.println(zoneId); <span class="comment">// null</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有启用AOP，注入的是原始的<code>UserService</code>实例，那么一切正常，因为<code>UserService</code>实例的<code>zoneId</code>字段已经被正确初始化了。</p>
<p>如果启动了AOP，注入的是代理后的<code>UserService$$EnhancerBySpringCGLIB</code>实例，那么问题大了：获取的<code>UserService$$EnhancerBySpringCGLIB</code>实例的<code>zoneId</code>字段，永远为<code>null</code>。</p>
<p>那么问题来了：启用了AOP，如何修复？</p>
<p>修复很简单，只需要把直接访问字段的代码，改为通过方法访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不要直接访问UserService的字段:</span></span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> userService.getZoneId();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论注入的<code>UserService</code>是原始实例还是代理实例，<code>getZoneId()</code>都能正常工作，因为代理类会覆写<code>getZoneId()</code>方法，并将其委托给原始实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserService$$EnhancerBySpringCGLIB <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ZoneId <span class="title function_">getZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target.getZoneId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到我们还给<code>UserService</code>添加了一个<code>public</code>+<code>final</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ZoneId <span class="title function_">getFinalZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> zoneId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在<code>MailService</code>中，调用的不是<code>getZoneId()</code>，而是<code>getFinalZoneId()</code>，又会出现<code>NullPointerException</code>，这是因为，代理类无法覆写<code>final</code>方法（这一点绕不过JVM的ClassLoader检查），该方法返回的是代理类的<code>zoneId</code>字段，即<code>null</code>。</p>
<p>实际上，如果我们加上日志，Spring在启动时会打印一个警告：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10:43:09.929 [main] DEBUG org.springframework.aop.framework.CglibAopProxy - Final method [public final java.time.ZoneId xxx.UserService.getFinalZoneId()] cannot get proxied via CGLIB: Calls to this method will NOT be routed to the target instance and might lead to NPEs against uninitialized fields in the proxy instance.</span><br></pre></td></tr></table></figure>
<p>上面的日志大意就是，因为被代理的<code>UserService</code>有一个<code>final</code>方法<code>getFinalZoneId()</code>，这会导致其他Bean如果调用此方法，无法将其代理到真正的原始实例，从而可能发生NPE异常。</p>
<p>因此，正确使用AOP，我们需要一个避坑指南：</p>
<ol>
<li>访问被注入的Bean时，总是调用方法而非直接访问字段；</li>
<li>编写Bean时，如果可能会被代理，就不要编写<code>public final</code>方法。</li>
</ol>
<p>这样才能保证有没有AOP，代码都能正常工作。</p>
<h3 id="思考">思考</h3>
<p>为什么Spring刻意不初始化Proxy继承的字段？</p>
<p>如果一个Bean不允许任何AOP代理，应该怎么做来“保护”自己在运行期不会被代理？</p>
<h3 id="练习-3">练习</h3>
<p>修复启用AOP导致的NPE。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/aop/notice/spring-aop-field.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>由于Spring通过CGLIB实现代理类，我们要避免直接访问Bean的字段，以及由<code>final</code>方法带来的“未代理”问题。</p>
<p>遇到CglibAopProxy的相关日志，务必要仔细检查，防止因为AOP出现NPE异常。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-AOP/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/"
                            aria-label=": JAVA-Spring开发-IoC"
                        >
                            JAVA-Spring开发-IoC
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T16:16:12+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。</p>
<p>什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p>
<p>通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。</p>
<p>Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</p>
<p>本章我们讨论的IoC容器，主要介绍Spring容器如何对组件进行生命周期管理和配置组装服务。</p>
<p>Spring提供的容器又称为IoC容器，什么是IoC？</p>
<p>IoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。</p>
<p>我们假定一个在线书店，通过<code>BookService</code>获取书籍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBook</span><span class="params">(<span class="type">long</span> bookId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了从数据库查询书籍，<code>BookService</code>持有一个<code>DataSource</code>。为了实例化一个<code>HikariDataSource</code>，又不得不实例化一个<code>HikariConfig</code>。</p>
<p>现在，我们继续编写<code>UserService</code>获取用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>UserService</code>也需要访问数据库，因此，我们不得不也实例化一个<code>HikariDataSource</code>。</p>
<p>在处理用户购买的<code>CartServlet</code>中，我们需要实例化<code>UserService</code>和<code>BookService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentUserId</span> <span class="operator">=</span> getFromCookie(req);</span><br><span class="line">        <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> userService.getUser(currentUserId);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getBook(req.getParameter(<span class="string">&quot;bookId&quot;</span>));</span><br><span class="line">        cartService.addToCart(currentUser, book);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，在购买历史<code>HistoryServlet</code>中，也需要实例化<code>UserService</code>和<code>BookService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HistoryServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述每个组件都采用了一种简单的通过<code>new</code>创建实例并持有的方式。仔细观察，会发现以下缺点：</p>
<ol>
<li>实例化一个组件其实很难，例如，<code>BookService</code>和<code>UserService</code>要创建<code>HikariDataSource</code>，实际上需要读取配置，才能先实例化<code>HikariConfig</code>，再实例化<code>HikariDataSource</code>。</li>
<li>没有必要让<code>BookService</code>和<code>UserService</code>分别创建<code>DataSource</code>实例，完全可以共享同一个<code>DataSource</code>，但谁负责创建<code>DataSource</code>，谁负责获取其他组件已经创建的<code>DataSource</code>，不好处理。类似的，<code>CartServlet</code>和<code>HistoryServlet</code>也应当共享<code>BookService</code>实例和<code>UserService</code>实例，但也不好处理。</li>
<li>很多组件需要销毁以便释放资源，例如<code>DataSource</code>，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？</li>
<li>随着更多的组件被引入，例如，书籍评论，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。</li>
<li>测试某个组件，例如<code>BookService</code>，是复杂的，因为必须要在真实的数据库环境下执行。</li>
</ol>
<p>从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p>
<p>因此，核心问题是：</p>
<ol>
<li>谁负责创建组件？</li>
<li>谁负责根据依赖关系组装组件？</li>
<li>销毁时，如何按依赖顺序正确销毁？</li>
</ol>
<p>解决这一问题的核心方案就是IoC。</p>
<p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：</p>
<p><code>CartServlet</code>创建了<code>BookService</code>，在创建<code>BookService</code>的过程中，又创建了<code>DataSource</code>组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p>
<p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，<code>BookService</code>自己并不会创建<code>DataSource</code>，而是等待外部通过<code>setDataSource()</code>方法来注入一个<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不直接<code>new</code>一个<code>DataSource</code>，而是注入一个<code>DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p>
<ol>
<li><code>BookService</code>不再关心如何创建<code>DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li>
<li><code>DataSource</code>实例被注入到<code>BookService</code>，同样也可以注入到<code>UserService</code>，因此，共享一个组件非常简单；</li>
<li>测试<code>BookService</code>更容易，因为注入的是<code>DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li>
</ol>
<p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p>
<p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;HikariDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;BookService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p>
<p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p>
<h3 id="依赖注入方式">依赖注入方式</h3>
<p>我们从上面的代码可以看到，依赖注入可以通过<code>set()</code>方法实现。但依赖注入也可以通过构造方法实现。</p>
<p>很多Java类都具有带参数的构造方法，如果我们把<code>BookService</code>改造为通过构造方法注入，那么实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookService</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p>
<h3 id="无侵入容器">无侵入容器</h3>
<p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p>
<ol>
<li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li>
<li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li>
</ol>
<p>我们前面讨论了为什么要使用Spring的IoC容器，因为让容器来为我们创建并装配Bean能获得很大的好处，那么到底如何使用IoC容器？装配好的Bean又如何使用？</p>
<p>我们来看一个具体的用户注册登录的例子。整个工程的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-appcontext</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── Main.java</span><br><span class="line">        │               └── service</span><br><span class="line">        │                   ├── MailService.java</span><br><span class="line">        │                   ├── User.java</span><br><span class="line">        │                   └── UserService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── application.xml</span><br></pre></td></tr></table></figure>
<p>首先，我们用Maven创建工程并引入<code>spring-context</code>依赖：</p>
<ul>
<li>org.springframework:spring-context:6.0.0</li>
</ul>
<p>我们先编写一个<code>MailService</code>，用于在用户登录和注册成功后发送邮件通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZoneId</span><span class="params">(ZoneId zoneId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.zoneId = zoneId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZonedDateTime.now(<span class="built_in">this</span>.zoneId).format(DateTimeFormatter.ISO_ZONED_DATE_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLoginMail</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.err.println(String.format(<span class="string">&quot;Hi, %s! You are logged in at %s&quot;</span>, user.getName(), getTime()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRegistrationMail</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.err.println(String.format(<span class="string">&quot;Welcome, %s!&quot;</span>, user.getName()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再编写一个<code>UserService</code>，实现用户注册和登录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMailService</span><span class="params">(MailService mailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of( <span class="comment">// users:</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Bob&quot;</span>), <span class="comment">// bob</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;alice@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Alice&quot;</span>), <span class="comment">// alice</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;tom@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Tom&quot;</span>))); <span class="comment">// tom</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.getEmail().equalsIgnoreCase(email) &amp;&amp; user.getPassword().equals(password)) &#123;</span><br><span class="line">                mailService.sendLoginMail(user);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;login failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.users.stream().filter(user -&gt; user.getId() == id).findFirst().orElseThrow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        users.forEach((user) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.getEmail().equalsIgnoreCase(email)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;email exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(users.stream().mapToLong(u -&gt; u.getId()).max().getAsLong() + <span class="number">1</span>, email, password, name);</span><br><span class="line">        users.add(user);</span><br><span class="line">        mailService.sendRegistrationMail(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>UserService</code>通过<code>setMailService()</code>注入了一个<code>MailService</code>。</p>
<p>然后，我们需要编写一个特定的<code>application.xml</code>配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mailService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.MailService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意观察上述配置文件，其中与XML Schema相关的部分格式是固定的，我们只关注两个<code>&lt;bean ...&gt;</code>的配置：</p>
<ul>
<li>每个<code>&lt;bean ...&gt;</code>都有一个<code>id</code>标识，相当于Bean的唯一ID；</li>
<li>在<code>userService</code>Bean中，通过<code>&lt;property name=&quot;...&quot; ref=&quot;...&quot; /&gt;</code>注入了另一个Bean；</li>
<li>Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。</li>
</ul>
<p>把上述XML配置文件用Java代码写出来，就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"><span class="type">MailService</span> <span class="variable">mailService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MailService</span>();</span><br><span class="line">userService.setMailService(mailService);</span><br></pre></td></tr></table></figure>
<p>只不过Spring容器是通过读取XML文件后使用反射完成的。</p>
<p>如果注入的不是Bean，而是<code>boolean</code>、<code>int</code>、<code>String</code>这样的数据类型，则通过<code>value</code>注入，例如，创建一个<code>HikariDataSource</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maximumPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后一步，我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>接下来，我们就可以从Spring容器中“取出”装配好的Bean然后使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Bean:</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line"><span class="comment">// 正常调用:</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>完整的<code>main()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ApplicationContext">ApplicationContext</h3>
<p>我们从创建Spring容器的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，这里我们选择<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p>
<p>获得了<code>ApplicationContext</code>的实例，就获得了IoC容器的引用。从<code>ApplicationContext</code>中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br></pre></td></tr></table></figure>
<p>Spring还提供另一种IoC容器叫<code>BeanFactory</code>，使用方式和<code>ApplicationContext</code>类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;application.xml&quot;</span>));</span><br><span class="line"><span class="type">MailService</span> <span class="variable">mailService</span> <span class="operator">=</span> factory.getBean(MailService.class);</span><br></pre></td></tr></table></figure>
<p><code>BeanFactory</code>和<code>ApplicationContext</code>的区别在于，<code>BeanFactory</code>的实现是按需创建，即第一次获取Bean时才创建这个Bean，而<code>ApplicationContext</code>会一次性创建所有的Bean。实际上，<code>ApplicationContext</code>接口是从<code>BeanFactory</code>接口继承而来的，并且，<code>ApplicationContext</code>提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用<code>ApplicationContext</code>，很少会考虑使用<code>BeanFactory</code>。</p>
<h3 id="练习">练习</h3>
<p>在上述示例的基础上，继续给<code>UserService</code>注入<code>DataSource</code>，并把注册和登录功能通过数据库实现。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/injection/spring-ioc-appcontext.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>Spring的IoC容器接口是<code>ApplicationContext</code>，并提供了多种实现类；</p>
<p>通过XML配置文件创建IoC容器时，使用<code>ClassPathXmlApplicationContext</code>；</p>
<p>持有IoC容器后，通过<code>getBean()</code>方法获取Bean的引用。</p>
<p>使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把我们自己的Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。</p>
<p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p>
<p>有没有其他更简单的配置方式呢？</p>
<p>有！我们可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。</p>
<p>我们把上一节的示例改造一下，先删除XML配置文件，然后，给<code>UserService</code>和<code>MailService</code>添加几个注解。</p>
<p>首先，我们给<code>MailService</code>添加一个<code>@Component</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。</p>
<p>然后，我们给<code>UserService</code>添加一个<code>@Component</code>注解和一个<code>@Autowired</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MailService mailService;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>@Autowired</code>就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，<code>@Autowired</code>大幅简化了注入，因为它不但可以写在<code>set()</code>方法上，还可以直接写在字段上，甚至可以写在构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(<span class="meta">@Autowired</span> MailService mailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一般把<code>@Autowired</code>写在字段上，通常使用package权限的字段，便于测试。</p>
<p>最后，编写一个<code>AppConfig</code>类启动容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了<code>main()</code>方法外，<code>AppConfig</code>标注了<code>@Configuration</code>，表示它是一个配置类，因为我们创建<code>ApplicationContext</code>时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br></pre></td></tr></table></figure>
<p>使用的实现类是<code>AnnotationConfigApplicationContext</code>，必须传入一个标注了<code>@Configuration</code>的类名。</p>
<p>此外，<code>AppConfig</code>还标注了<code>@ComponentScan</code>，它告诉容器，自动搜索当前类所在的包以及子包，把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p>
<p>整个工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-annoconfig</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── itranswarp</span><br><span class="line">                    └── learnjava</span><br><span class="line">                        ├── AppConfig.java</span><br><span class="line">                        └── service</span><br><span class="line">                            ├── MailService.java</span><br><span class="line">                            ├── User.java</span><br><span class="line">                            └── UserService.java</span><br></pre></td></tr></table></figure>
<p>使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：</p>
<ul>
<li>每个Bean被标注为<code>@Component</code>并正确使用<code>@Autowired</code>注入；</li>
<li>配置类被标注为<code>@Configuration</code>和<code>@ComponentScan</code>；</li>
<li>所有Bean均在指定包以及子包内。</li>
</ul>
<p>使用<code>@ComponentScan</code>非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置<code>AppConfig</code>位于自定义的顶层包（例如<code>com.itranswarp.learnjava</code>），其他Bean按类别放入子包。</p>
<h3 id="思考">思考</h3>
<p>如果我们想给<code>UserService</code>注入<code>HikariDataSource</code>，但是这个类位于<code>com.zaxxer.hikari</code>包中，并且<code>HikariDataSource</code>也不可能有<code>@Component</code>注解，如何告诉IoC容器创建并配置<code>HikariDataSource</code>？或者换个说法，如何创建并配置一个第三方Bean？</p>
<h3 id="练习-2">练习</h3>
<p>使用Annotation配置IoC容器。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/annotation-config/spring-ioc-annoconfig.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>使用Annotation可以大幅简化配置，每个Bean通过<code>@Component</code>和<code>@Autowired</code>注入；</p>
<p>必须合理设计包的层次结构，才能发挥<code>@ComponentScan</code>的威力。</p>
<h3 id="Scope">Scope</h3>
<p>对于Spring容器来说，当我们把一个Bean标记为<code>@Component</code>后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用<code>getBean(Class)</code>获取到的Bean总是同一个实例。</p>
<p>还有一种Bean，我们每次调用<code>getBean(Class)</code>，容器都返回一个新的实例，这种Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的<code>@Scope</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// @Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailSession</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注入List">注入List</h3>
<p>有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，分别使用3个<code>Validator</code>对用户参数进行验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!email.matches(<span class="string">&quot;^[a-z0-9]+\\@[a-z0-9]+\\.[a-z]&#123;2,10&#125;$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid email: &quot;</span> + email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!password.matches(<span class="string">&quot;^.&#123;6,20&#125;$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid password&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span> || name.isBlank() || name.length() &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid name: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们通过一个<code>Validators</code>作为入口进行验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Validators</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;Validator&gt; validators;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> validator : <span class="built_in">this</span>.validators) &#123;</span><br><span class="line">            validator.validate(email, password, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>Validators</code>被注入了一个<code>List&lt;Validator&gt;</code>，Spring会自动把所有类型为<code>Validator</code>的Bean装配为一个<code>List</code>注入进来，这样一来，我们每新增一个<code>Validator</code>类型，就自动被Spring装配到<code>Validators</code>中了，非常方便。</p>
<p>因为Spring是通过扫描classpath获取到所有的Bean，而<code>List</code>是有序的，要指定<code>List</code>中Bean的顺序，可以加上<code>@Order</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可选注入">可选注入</h3>
<p>默认情况下，当我们标记了一个<code>@Autowired</code>后，Spring如果没有找到对应类型的Bean，它会抛出<code>NoSuchBeanDefinitionException</code>异常。</p>
<p>可以给<code>@Autowired</code>增加一个<code>required = false</code>的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个参数告诉Spring容器，如果找到一个类型为<code>ZoneId</code>的Bean，就注入，如果找不到，就忽略。</p>
<p>这种方式非常适合有定义就使用定义，没有就使用默认值的情况。</p>
<h3 id="创建第三方Bean">创建第三方Bean</h3>
<p>如果一个Bean不在我们自己的package管理之内，例如<code>ZoneId</code>，如何创建它？</p>
<p>答案是我们自己在<code>@Configuration</code>类中编写一个Java方法创建并返回它，注意给方法标记一个<code>@Bean</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Bean:</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring对标记为<code>@Bean</code>的方法只调用一次，因此返回的Bean仍然是单例。</p>
<h3 id="初始化和销毁">初始化和销毁</h3>
<p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个<code>init()</code>方法进行初始化，定义一个<code>shutdown()</code>方法进行清理，然后，引入JSR-250定义的Annotation：</p>
<ul>
<li>jakarta.annotation:jakarta.annotation-api:2.1.1</li>
</ul>
<p>在Bean的初始化和清理方法上标记<code>@PostConstruct</code>和<code>@PreDestroy</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init mail service with zoneId = &quot;</span> + <span class="built_in">this</span>.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutdown mail service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring容器会对上述Bean做如下初始化流程：</p>
<ul>
<li>调用构造方法创建<code>MailService</code>实例；</li>
<li>根据<code>@Autowired</code>进行注入；</li>
<li>调用标记有<code>@PostConstruct</code>的<code>init()</code>方法进行初始化。</li>
</ul>
<p>而销毁时，容器会首先调用标记有<code>@PreDestroy</code>的<code>shutdown()</code>方法。</p>
<p>Spring只根据Annotation查找<em>无参数</em>方法，对方法名不作要求。</p>
<h3 id="使用别名">使用别名</h3>
<p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个<code>DataSource</code>实例。</p>
<p>如果我们在<code>@Configuration</code>类中创建了多个同类型的Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfUTC8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring会报<code>NoUniqueBeanDefinitionException</code>异常，意思是出现了重复的Bean定义。</p>
<p>这个时候，需要给每个Bean添加不同的名字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;z&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;utc8&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfUTC8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用<code>@Bean(&quot;name&quot;)</code>指定别名，也可以用<code>@Bean</code>+<code>@Qualifier(&quot;name&quot;)</code>指定别名。</p>
<p>存在多个同类型的Bean时，注入<code>ZoneId</code>又会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException: No qualifying bean of type &#x27;java.time.ZoneId&#x27; available: expected single matching bean but found 2</span><br></pre></td></tr></table></figure>
<p>意思是期待找到唯一的<code>ZoneId</code>类型Bean，但是找到两。因此，注入时，要指定Bean的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired(required = false)</span></span><br><span class="line">	<span class="meta">@Qualifier(&quot;z&quot;)</span> <span class="comment">// 指定注入名称为&quot;z&quot;的ZoneId</span></span><br><span class="line">	<span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法是把其中某个Bean指定为<code>@Primary</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span> <span class="comment">// 指定为主要Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;z&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;utc8&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfUTC8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有<code>@Primary</code>的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为<code>@Primary</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    DataSource <span class="title function_">createMasterDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;slave&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">createSlaveDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。</p>
<h3 id="使用FactoryBean">使用FactoryBean</h3>
<p>我们在设计模式的<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/creational/factory-method/index.html">工厂方法</a>中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。</p>
<p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZoneIdFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;ZoneId&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">zone</span> <span class="operator">=</span> <span class="string">&quot;Z&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ZoneId <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p>
<p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p>
<p>由于可以用<code>@Bean</code>方法创建第三方Bean，本质上<code>@Bean</code>方法就是工厂方法，所以，<code>FactoryBean</code>已经用得越来越少了。</p>
<h3 id="练习-3">练习</h3>
<p>定制Bean。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/customize/spring-ioc-customize.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>Spring默认使用Singleton创建Bean，也可指定Scope为Prototype；</p>
<p>可将相同类型的Bean注入<code>List</code>或数组；</p>
<p>可用<code>@Autowired(required=false)</code>允许可选注入；</p>
<p>可用带<code>@Bean</code>标注的方法创建Bean；</p>
<p>可使用<code>@PostConstruct</code>和<code>@PreDestroy</code>对Bean进行初始化和清理；</p>
<p>相同类型的Bean只能有一个指定为<code>@Primary</code>，其他必须用<code>@Qualifier(&quot;beanName&quot;)</code>指定别名；</p>
<p>注入时，可通过别名<code>@Qualifier(&quot;beanName&quot;)</code>指定某个Bean；</p>
<p>可以定义<code>FactoryBean</code>来使用工厂模式创建Bean。</p>
<h2 id="使用Resource">使用Resource</h2>
<p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p>
<p>例如，AppService需要读取<code>logo.txt</code>这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p>
<p>Spring提供了一个<code>org.springframework.core.io.Resource</code>（注意不是<code>jarkata.annotation.Resource</code>或<code>javax.annotation.Resource</code>），它可以像<code>String</code>、<code>int</code>一样使用<code>@Value</code>注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;classpath:/logo.txt&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String logo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logo = reader.lines().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入<code>Resource</code>最常用的方式是通过classpath，即类似<code>classpath:/logo.txt</code>表示在classpath中搜索<code>logo.txt</code>文件，然后，我们直接调用<code>Resource.getInputStream()</code>就可以获取到输入流，避免了自己搜索文件的代码。</p>
<p>也可以直接指定文件的路径，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;file:/path/to/logo.txt&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Resource resource;</span><br></pre></td></tr></table></figure>
<p>但使用classpath是最简单的方式。上述工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-resource</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java</span><br><span class="line">        │               └── AppService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── logo.txt</span><br></pre></td></tr></table></figure>
<p>使用Maven的标准目录结构，所有资源文件放入<code>src/main/resources</code>即可。</p>
<h3 id="练习-4">练习</h3>
<p>使用Spring的<code>Resource</code>注入<code>app.properties</code>文件，然后读取该配置文件。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/resource/spring-ioc-resource.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>Spring提供了Resource类便于注入资源文件。</p>
<p>最常用的注入是通过classpath以<code>classpath:/path/to/file</code>的形式注入。</p>
<hr>
<hr>
<h2 id="注入配置">注入配置</h2>
<p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以<code>key=value</code>的形式写在<code>.properties</code>文件中。</p>
<p>例如，<code>MailService</code>根据配置的<code>app.zone=Asia/Shanghai</code>来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的<code>Resource</code>来读取位于classpath下的一个<code>app.properties</code>文件。但是，这样仍然比较繁琐。</p>
<p>Spring容器还提供了一个更简单的<code>@PropertySource</code>来自动读取配置文件。我们只需要在<code>@Configuration</code>配置类上再添加一个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;app.properties&quot;)</span> <span class="comment">// 表示读取classpath的app.properties</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span></span><br><span class="line">    String zoneId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zoneId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring容器看到<code>@PropertySource(&quot;app.properties&quot;)</code>注解后，自动读取这个配置文件，然后，我们使用<code>@Value</code>正常注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span></span><br><span class="line">String zoneId;</span><br></pre></td></tr></table></figure>
<p>注意注入的字符串语法，它的格式如下：</p>
<ul>
<li><code>&quot;$&#123;app.zone&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，如果key不存在，启动将报错；</li>
<li><code>&quot;$&#123;app.zone:Z&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，但如果key不存在，就使用默认值<code>Z</code>。</li>
</ul>
<p>这样一来，我们就可以根据<code>app.zone</code>的配置来创建<code>ZoneId</code>。</p>
<p>还可以把注入的注解写到方法参数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ZoneId <span class="title function_">createZoneId</span><span class="params">(<span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span> String zoneId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ZoneId.of(zoneId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，先使用<code>@PropertySource</code>读取配置文件，然后通过<code>@Value</code>以<code>$&#123;key:defaultValue&#125;</code>的形式注入，可以极大地简化读取配置的麻烦。</p>
<p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个<code>SmtpConfig</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmtpConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.port:25&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在需要读取的地方，使用<code>#&#123;smtpConfig.host&#125;</code>注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String smtpHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> smtpPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意观察<code>#&#123;&#125;</code>这种注入语法，它和<code>$&#123;key&#125;</code>不同的是，<code>#&#123;&#125;</code>表示从JavaBean读取属性。<code>&quot;#&#123;smtpConfig.host&#125;&quot;</code>的意思是，从名称为<code>smtpConfig</code>的Bean读取<code>host</code>属性，即调用<code>getHost()</code>方法。一个Class名为<code>SmtpConfig</code>的Bean，它在Spring容器中的默认名称就是<code>smtpConfig</code>，除非用<code>@Qualifier</code>指定了名称。</p>
<p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以<code>#&#123;bean.property&#125;</code>注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果<code>SmtpConfig</code>决定从数据库中读取相关配置项，那么<code>MailService</code>注入的<code>@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</code>仍然可以不修改正常运行。</p>
<h3 id="练习-5">练习</h3>
<p>注入SMTP配置。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/properties/spring-ioc-properties.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>Spring容器可以通过<code>@PropertySource</code>自动读取配置，并以<code>@Value(&quot;$&#123;key&#125;&quot;)</code>的形式注入；</p>
<p>可以通过<code>$&#123;key:defaultValue&#125;</code>指定默认值；</p>
<p>以<code>#&#123;bean.property&#125;</code>形式注入时，Spring容器自动把指定Bean的指定属性值注入。</p>
<hr>
<hr>
<p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p>
<p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p>
<ul>
<li>native</li>
<li>test</li>
<li>production</li>
</ul>
<p>创建某个Bean时，Spring容器可以根据注解<code>@Profile</code>来决定是否创建。例如，以下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;!test&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.systemDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneIdForTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前的Profile设置为<code>test</code>，则Spring容器会调用<code>createZoneIdForTest()</code>创建<code>ZoneId</code>，否则，调用<code>createZoneId()</code>创建<code>ZoneId</code>。注意到<code>@Profile(&quot;!test&quot;)</code>表示非test环境。</p>
<p>在运行程序时，加上JVM参数<code>-Dspring.profiles.active=test</code>就可以指定以<code>test</code>环境启动。</p>
<p>实际上，Spring允许指定多个Profile，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=test,master</span><br></pre></td></tr></table></figure>
<p>可以表示<code>test</code>环境，并使用<code>master</code>分支代码。</p>
<p>要满足多个Profile条件，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123; &quot;test&quot;, &quot;master&quot; &#125;)</span> <span class="comment">// 满足test或master</span></span><br><span class="line">ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Conditional">使用Conditional</h3>
<p>除了根据<code>@Profile</code>条件来决定是否创建某个Bean外，Spring还可以根据<code>@Conditional</code>决定是否创建某个Bean。</p>
<p>例如，我们对<code>SmtpMailService</code>添加如下注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Conditional(OnSmtpEnvCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmtpMailService</span> <span class="keyword">implements</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的意思是，如果满足<code>OnSmtpEnvCondition</code>的条件，才会创建<code>SmtpMailService</code>这个Bean。<code>OnSmtpEnvCondition</code>的条件是什么呢？我们看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnSmtpEnvCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(System.getenv(<span class="string">&quot;smtp&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，<code>OnSmtpEnvCondition</code>的条件是存在环境变量<code>smtp</code>，值为<code>true</code>。这样，我们就可以通过环境变量来控制是否创建<code>SmtpMailService</code>。</p>
<p>Spring只提供了<code>@Conditional</code>注解，具体判断逻辑还需要我们自己实现。Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在<code>app.smtp=true</code>，则创建<code>MailService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前classpath中存在类<code>javax.mail.Transport</code>，则创建<code>MailService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;javax.mail.Transport&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续我们会介绍Spring Boot的条件装配。我们以文件存储为例，假设我们需要保存用户上传的头像，并返回存储路径，在本地开发运行时，我们总是存储到文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;file&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> <span class="keyword">implements</span> <span class="title class_">Uploader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生产环境运行时，我们会把文件存储到类似AWS S3上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;s3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">S3Uploader</span> <span class="keyword">implements</span> <span class="title class_">Uploader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他需要存储的服务则注入<code>Uploader</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserImageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Uploader uploader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当应用程序检测到配置文件存在<code>app.storage=s3</code>时，自动使用<code>S3Uploader</code>，如果存在配置<code>app.storage=file</code>，或者配置<code>app.storage</code>不存在，则使用<code>FileUploader</code>。</p>
<p>可见，使用条件注解，能更灵活地装配Bean。</p>
<h3 id="练习-6">练习</h3>
<p>使用@Profile进行条件装配。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/spring/ioc/conditional/spring-ioc-conditional.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>Spring允许通过<code>@Profile</code>配置不同的Bean；</p>
<p>Spring还提供了<code>@Conditional</code>来进行条件装配，Spring Boot在此基础上进一步提供了基于配置、Class、Bean等条件进行装配。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-IoC/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E4%BB%8B%E7%BB%8D/"
                            aria-label=": JAVA-Spring开发-介绍"
                        >
                            JAVA-Spring开发-介绍
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T15:58:00+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Spring开发">Spring开发</h2>
<p>什么是Spring？</p>
<p>Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。</p>
<p><img src="https://liaoxuefeng.com/books/java/spring/spring.png" alt="java-spring"></p>
<p>Spring最早是由Rod Johnson这哥们在他的《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1426848/">Expert One-on-One J2EE Development without EJB</a>》一书中提出的用来取代EJB的轻量级框架。随后这哥们又开始专心开发这个基础框架，并起名为Spring Framework。</p>
<p>随着Spring越来越受欢迎，在Spring Framework基础上，又诞生了Spring Boot、Spring Cloud、Spring Data、Spring Security等一系列基于Spring Framework的项目。本章我们只介绍Spring Framework，即最核心的Spring框架。后续章节我们还会涉及Spring Boot、Spring Cloud等其他框架。</p>
<h3 id="Spring-Framework">Spring Framework</h3>
<p>Spring Framework主要包括几个模块：</p>
<ul>
<li>支持IoC和AOP的容器；</li>
<li>支持JDBC和ORM的数据访问模块；</li>
<li>支持声明式事务的模块；</li>
<li>支持基于Servlet的MVC开发；</li>
<li>支持基于Reactive的Web开发；</li>
<li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li>
</ul>
<p>我们会依次介绍Spring Framework的主要功能。</p>
<p>本教程使用的Spring版本是6.x版，如果使用Spring 5.x则需注意，两者有以下不同：</p>
<table>
<thead>
<tr>
<th></th>
<th>Spring 5.x</th>
<th>Spring 6.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK版本</td>
<td>&gt;= 1.8</td>
<td>&gt;= 17</td>
</tr>
<tr>
<td>Tomcat版本</td>
<td>9.x</td>
<td>10.x</td>
</tr>
<tr>
<td>Annotation包</td>
<td>javax.annotation</td>
<td>jakarta.annotation</td>
</tr>
<tr>
<td>Servlet包</td>
<td>javax.servlet</td>
<td>jakarta.servlet</td>
</tr>
<tr>
<td>JMS包</td>
<td>javax.jms</td>
<td>jakarta.jms</td>
</tr>
<tr>
<td>JavaMail包</td>
<td>javax.mail</td>
<td>jakarta.mail</td>
</tr>
</tbody>
</table>
<p>如果使用Spring的其他版本，则需要根据需要调整代码。</p>
<p>Spring官网是<a target="_blank" rel="noopener" href="https://spring.io/">spring.io</a>，要注意官网有许多项目，我们这里说的Spring是指Spring Framework，可以直接从这里访问<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework">最新版以及文档</a>，建议添加到浏览器收藏夹。</p>
<hr>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/26/java/JAVA-Spring%E5%BC%80%E5%8F%91-%E4%BB%8B%E7%BB%8D/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/24/java/JAVA-Web%E5%BC%80%E5%8F%91/"
                            aria-label=": JAVA-Web开发"
                        >
                            JAVA-Web开发
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-24T18:45:56+08:00">
	
		    2025 年 5 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Web开发">Web开发</h2>
<p>从本章开始，我们就正式进入到JavaEE的领域。</p>
<p>什么是JavaEE？JavaEE是Java Platform Enterprise Edition的缩写，即Java企业平台。我们前面介绍的所有基于标准JDK的开发都是JavaSE，即Java Platform Standard Edition。此外，还有一个小众不太常用的JavaME：Java Platform Micro Edition，是Java移动开发平台（非Android），它们三者关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────┐</span><br><span class="line">│     JavaEE     │</span><br><span class="line">│┌──────────────┐│</span><br><span class="line">││    JavaSE    ││</span><br><span class="line">││┌────────────┐││</span><br><span class="line">│││   JavaME   │││</span><br><span class="line">││└────────────┘││</span><br><span class="line">│└──────────────┘│</span><br><span class="line">└────────────────┘</span><br></pre></td></tr></table></figure>
<p>JavaME是一个裁剪后的“微型版”JDK，现在使用很少，我们不用管它。JavaEE也不是凭空冒出来的，它实际上是完全基于JavaSE，只是多了一大堆服务器相关的库以及API接口。所有的JavaEE程序，仍然是运行在标准的JavaSE的虚拟机上的。</p>
<p>最早的JavaEE的名称是J2EE：Java 2 Platform Enterprise Edition，后来改名为JavaEE。由于Oracle将JavaEE移交给<a target="_blank" rel="noopener" href="https://www.eclipse.org/">Eclipse</a>开源组织时，不允许他们继续使用Java商标，所以JavaEE再次改名为<a target="_blank" rel="noopener" href="https://jakarta.ee/">Jakarta EE</a>。因为这个拼写比较复杂而且难记，所以我们后面还是用JavaEE这个缩写。</p>
<p>JavaEE并不是一个软件产品，它更多的是一种软件架构和设计思想。我们可以把JavaEE看作是在JavaSE的基础上，开发的一系列基于服务器的组件、API标准和通用架构。</p>
<p>JavaEE最核心的组件就是基于Servlet标准的Web服务器，开发者编写的应用程序是基于Servlet API并运行在Web服务器内部的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│┌───────────┐│</span><br><span class="line">││ User App  ││</span><br><span class="line">│├───────────┤│</span><br><span class="line">││Servlet API││</span><br><span class="line">│└───────────┘│</span><br><span class="line">│ Web Server  │</span><br><span class="line">├─────────────┤</span><br><span class="line">│   JavaSE    │</span><br><span class="line">└─────────────┘</span><br></pre></td></tr></table></figure>
<p>此外，JavaEE还有一系列技术标准：</p>
<ul>
<li>EJB：Enterprise JavaBean，企业级JavaBean，早期经常用于实现应用程序的业务逻辑，现在基本被轻量级框架如Spring所取代；</li>
<li>JAAS：Java Authentication and Authorization Service，一个标准的认证和授权服务，常用于企业内部，Web程序通常使用更轻量级的自定义认证；</li>
<li>JCA：JavaEE Connector Architecture，用于连接企业内部的EIS系统等；</li>
<li>JMS：Java Message Service，用于消息服务；</li>
<li>JTA：Java Transaction API，用于分布式事务；</li>
<li>JAX-WS：Java API for XML Web Services，用于构建基于XML的Web服务；</li>
<li>…</li>
</ul>
<p>目前流行的基于Spring的轻量级JavaEE开发架构，使用最广泛的是Servlet和JMS，以及一系列开源组件。本章我们将详细介绍基于Servlet的Web开发。</p>
<hr>
<hr>
<p>今天我们访问网站，使用App时，都是基于Web这种Browser/Server模式，简称BS架构，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。</p>
<p>Web页面具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构升级非常容易。</p>
<h3 id="HTTP协议">HTTP协议</h3>
<p>在Web应用中，浏览器请求一个URL，服务器就把生成的HTML网页发送给浏览器，而浏览器和服务器之间的传输协议是HTTP，所以：</p>
<ul>
<li>HTML是一种用来定义网页的文本，会HTML，就可以编写网页；</li>
<li>HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信。</li>
</ul>
<p>HTTP协议是一个基于TCP协议之上的请求-响应协议，它非常简单，我们先使用Chrome浏览器查看新浪首页，然后选择View - Developer - Inspect Elements就可以看到HTML：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/basic/html.jpg" alt="html"></p>
<p>切换到Network，重新加载页面，可以看到浏览器发出的每一个请求和响应：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/basic/network.jpg" alt="http"></p>
<p>对于Browser来说，请求页面的流程如下：</p>
<ol>
<li>与服务器建立TCP连接；</li>
<li>发送HTTP请求；</li>
<li>收取HTTP响应，然后把网页在浏览器中显示出来。</li>
</ol>
<p>浏览器发送的HTTP请求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.sina.com.cn</span><br><span class="line">User-Agent: Mozilla/5.0 xxx</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8</span><br></pre></td></tr></table></figure>
<p>其中，第一行表示使用<code>GET</code>请求获取路径为<code>/</code>的资源，并使用<code>HTTP/1.1</code>协议，从第二行开始，每行都是以<code>Header: Value</code>形式表示的HTTP头，比较常用的HTTP Header包括：</p>
<ul>
<li>Host: 表示请求的主机名，因为一个服务器上可能运行着多个网站，因此，Host表示浏览器正在请求的域名；</li>
<li>User-Agent: 标识客户端本身，例如Chrome浏览器的标识类似<code>Mozilla/5.0 ... Chrome/79</code>，IE浏览器的标识类似<code>Mozilla/5.0 (Windows NT ...) like Gecko</code>；</li>
<li>Accept：表示浏览器能接收的资源类型，如<code>text/*</code>，<code>image/*</code>或者<code>*/*</code>表示所有；</li>
<li>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</li>
<li>Accept-Encoding：表示浏览器可以支持的压缩类型，例如<code>gzip, deflate, br</code>。</li>
</ul>
<p>服务器的响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 21932</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Cache-Control: max-age=300</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...网页数据...</span><br></pre></td></tr></table></figure>
<p>服务器响应的第一行总是版本号+空格+数字+空格+文本，数字表示响应代码，其中<code>2xx</code>表示成功，<code>3xx</code>表示重定向，<code>4xx</code>表示客户端引发的错误，<code>5xx</code>表示服务器端引发的错误。数字是给程序识别，文本则是给开发者调试使用的。常见的响应代码有：</p>
<ul>
<li>200 OK：表示成功；</li>
<li>301 Moved Permanently：表示该URL已经永久重定向；</li>
<li>302 Found：表示该URL需要临时重定向；</li>
<li>304 Not Modified：表示该资源没有修改，客户端可以使用本地缓存的版本；</li>
<li>400 Bad Request：表示客户端发送了一个错误的请求，例如参数无效；</li>
<li>401 Unauthorized：表示客户端因为身份未验证而不允许访问该URL；</li>
<li>403 Forbidden：表示服务器因为权限问题拒绝了客户端的请求；</li>
<li>404 Not Found：表示客户端请求了一个不存在的资源；</li>
<li>500 Internal Server Error：表示服务器处理时内部出错，例如因为无法连接数据库；</li>
<li>503 Service Unavailable：表示服务器此刻暂时无法处理请求。</li>
</ul>
<p>从第二行开始，服务器每一行均返回一个HTTP头。服务器经常返回的HTTP Header包括：</p>
<ul>
<li>Content-Type：表示该响应内容的类型，例如<code>text/html</code>，<code>image/jpeg</code>；</li>
<li>Content-Length：表示该响应内容的长度（字节数）；</li>
<li>Content-Encoding：表示该响应压缩算法，例如<code>gzip</code>；</li>
<li>Cache-Control：指示客户端应如何缓存，例如<code>max-age=300</code>表示可以最多缓存300秒。</li>
</ul>
<p>HTTP请求和响应都由HTTP Header和HTTP Body构成，其中HTTP Header每行都以<code>\r\n</code>结束。如果遇到两个连续的<code>\r\n</code>，那么后面就是HTTP Body。浏览器读取HTTP Body，并根据Header信息中指示的<code>Content-Type</code>、<code>Content-Encoding</code>等解压后显示网页、图像或其他内容。</p>
<p>通常浏览器获取的第一个资源是HTML网页，在网页中，如果嵌入了JavaScript、CSS、图片、视频等其他资源，浏览器会根据资源的URL再次向服务器请求对应的资源。</p>
<p>关于HTTP协议的详细内容，请参考<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10746113/">HTTP权威指南</a>一书，或者<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">Mozilla开发者网站</a>。</p>
<p>我们在前面介绍的<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/http/index.html">HTTP编程</a>是以客户端的身份去请求服务器资源。现在，我们需要以服务器的身份响应客户端请求，编写服务器程序来处理客户端请求通常就称之为Web开发。</p>
<h3 id="编写HTTP-Server">编写HTTP Server</h3>
<p>我们来看一下如何编写HTTP Server。一个HTTP Server本质上是一个TCP服务器，我们先用<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/network/tcp/index.html">TCP编程</a>的多线程实现的服务器端框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Socket sock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;client disconnected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">var</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 处理HTTP请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要在<code>handle()</code>方法中，用Reader读取HTTP请求，用Writer发送HTTP响应，即可实现一个最简单的HTTP服务器。编写代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Process new http request...&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">    <span class="type">var</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">    <span class="comment">// 读取HTTP请求:</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">requestOk</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">    <span class="keyword">if</span> (first.startsWith(<span class="string">&quot;GET / HTTP/1.&quot;</span>)) &#123;</span><br><span class="line">        requestOk = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (header.isEmpty()) &#123; <span class="comment">// 读取到空行时, HTTP Header读取完毕</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(header);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(requestOk ? <span class="string">&quot;Response OK&quot;</span> : <span class="string">&quot;Response Error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!requestOk) &#123;</span><br><span class="line">        <span class="comment">// 发送错误响应:</span></span><br><span class="line">        writer.write(<span class="string">&quot;HTTP/1.0 404 Not Found\r\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;Content-Length: 0\r\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送成功响应:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> data.getBytes(StandardCharsets.UTF_8).length;</span><br><span class="line">        writer.write(<span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;Content-Length: &quot;</span> + length + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 空行标识Header和Body的分隔</span></span><br><span class="line">        writer.write(data);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的核心代码是，先读取HTTP请求，这里我们只处理<code>GET /</code>的请求。当读取到空行时，表示已读到连续两个<code>\r\n</code>，说明请求结束，可以发送响应。发送响应的时候，首先发送响应代码<code>HTTP/1.0 200 OK</code>表示一个成功的200响应，使用<code>HTTP/1.0</code>协议，然后，依次发送Header，发送完Header后，再发送一个空行标识Header结束，紧接着发送HTTP Body，在浏览器输入<code>http://local.liaoxuefeng.com:8080/</code>就可以看到响应页面：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/basic/local.jpg" alt="httpserver"></p>
<p>HTTP目前有多个版本，<code>1.0</code>是早期版本，浏览器每次建立TCP连接后，只发送一个HTTP请求并接收一个HTTP响应，然后就关闭TCP连接。由于创建TCP连接本身就需要消耗一定的时间，因此，HTTP 1.1允许浏览器和服务器在同一个TCP连接上反复发送、接收多个HTTP请求和响应，这样就大大提高了传输效率。</p>
<p>我们注意到HTTP协议是一个请求-响应协议，它总是发送一个请求，然后接收一个响应。能不能一次性发送多个请求，然后再接收多个响应呢？HTTP 2.0可以支持浏览器同时发出多个请求，但每个请求需要唯一标识，服务器可以不按请求的顺序返回多个响应，由浏览器自己把收到的响应和请求对应起来。可见，HTTP 2.0进一步提高了传输效率，因为浏览器发出一个请求后，不必等待响应，就可以继续发下一个请求。</p>
<p>HTTP 3.0为了进一步提高速度，将抛弃TCP协议，改为使用无需创建连接的UDP协议，目前HTTP 3.0仍然处于实验阶段。</p>
<h3 id="练习">练习</h3>
<p>编写一个简单的HTTP服务器。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/basic/web-http-server.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>使用B/S架构时，总是通过HTTP协议实现通信；</p>
<p>Web开发通常是指开发服务器端的Web应用程序。</p>
<p>在上一节中，我们看到，编写HTTP服务器其实是非常简单的，只需要先编写基于多线程的TCP服务，然后在一个TCP连接中读取HTTP请求，发送HTTP响应即可。</p>
<p>但是，要编写一个完善的HTTP服务器，以HTTP/1.1为例，需要考虑的包括：</p>
<ul>
<li>识别正确和错误的HTTP请求；</li>
<li>识别正确和错误的HTTP头；</li>
<li>复用TCP连接；</li>
<li>复用线程；</li>
<li>IO异常处理；</li>
<li>…</li>
</ul>
<p>这些基础工作需要耗费大量的时间，并且经过长期测试才能稳定运行。如果我们只需要输出一个简单的HTML页面，就不得不编写上千行底层代码，那就根本无法做到高效而可靠地开发。</p>
<p>因此，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，我们只需要把自己的应用程序跑在Web服务器上。为了实现这一目的，JavaEE提供了Servlet API，我们使用Servlet API编写自己的Servlet来处理HTTP请求，Web服务器实现Servlet API接口，实现底层功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                 ┌───────────┐</span><br><span class="line">                 │My Servlet │</span><br><span class="line">                 ├───────────┤</span><br><span class="line">                 │Servlet API│</span><br><span class="line">┌───────┐  HTTP  ├───────────┤</span><br><span class="line">│Browser│◀──────▶│Web Server │</span><br><span class="line">└───────┘        └───────────┘</span><br></pre></td></tr></table></figure>
<p>我们来实现一个最简单的Servlet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebServlet注解表示这是一个Servlet，并映射到地址/:</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置响应类型:</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取输出流:</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        <span class="comment">// 写入响应:</span></span><br><span class="line">        pw.write(<span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 最后不要忘记flush强制输出:</span></span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Servlet总是继承自<code>HttpServlet</code>，然后覆写<code>doGet()</code>或<code>doPost()</code>方法。注意到<code>doGet()</code>方法传入了<code>HttpServletRequest</code>和<code>HttpServletResponse</code>两个对象，分别代表HTTP请求和响应。我们使用Servlet API时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为<code>HttpServletRequest</code>和<code>HttpServletResponse</code>就已经封装好了请求和响应。以发送响应为例，我们只需要设置正确的响应类型，然后获取<code>PrintWriter</code>，写入响应即可。</p>
<p>现在问题来了：Servlet API是谁提供？</p>
<p>Servlet API是一个jar包，我们需要通过Maven来引入它，才能正常编译。编写<code>pom.xml</code>文件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>web-servlet-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到这个<code>pom.xml</code>与前面我们讲到的普通Java程序有个区别，打包类型不是<code>jar</code>，而是<code>war</code>，表示Java Web Application Archive：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引入的Servlet API如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到<code>&lt;scope&gt;</code>指定为<code>provided</code>，表示编译时使用，但不会打包到<code>.war</code>文件中，因为运行期Web服务器本身已经提供了Servlet API相关的jar包。</p>
<h3 id="Servlet版本">Servlet版本</h3>
<p>要务必注意<code>servlet-api</code>的版本。4.0及之前的<code>servlet-api</code>由Oracle官方维护，引入的依赖项是<code>javax.servlet:javax.servlet-api</code>，编写代码时引入的包名为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br></pre></td></tr></table></figure>
<p>而5.0及以后的<code>servlet-api</code>由Eclipse开源社区维护，引入的依赖项是<code>jakarta.servlet:jakarta.servlet-api</code>，编写代码时引入的包名为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.*;</span><br></pre></td></tr></table></figure>
<p>教程采用最新的<code>jakarta.servlet:5.0.0</code>版本，但对于很多仅支持Servlet 4.0版本的框架来说，例如Spring 5，我们就只能使用<code>javax.servlet:4.0.0</code>版本，这一点针对不同项目要特别注意。</p>
<p>注意</p>
<p>引入不同的Servlet API版本，编写代码时导入的相关API的包名是不同的。</p>
<p>整个工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">web-servlet-hello/</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src/</span><br><span class="line">    └── main/</span><br><span class="line">        ├── java/</span><br><span class="line">        │   └── com/</span><br><span class="line">        │       └── itranswarp/</span><br><span class="line">        │           └── learnjava/</span><br><span class="line">        │               └── servlet/</span><br><span class="line">        │                   └── HelloServlet.java</span><br><span class="line">        ├── resources/</span><br><span class="line">        └── webapp/</span><br></pre></td></tr></table></figure>
<p>目录<code>webapp</code>目前为空，如果我们需要存放一些资源文件，则需要放入该目录。有的同学可能会问，<code>webapp</code>目录下是否需要一个<code>/WEB-INF/web.xml</code>配置文件？这个配置文件是低版本Servlet必须的，但是高版本Servlet已不再需要，所以无需该配置文件。</p>
<p>运行Maven命令<code>mvn clean package</code>，在<code>target</code>目录下得到一个<code>hello.war</code>文件，这个文件就是我们编译打包后的Web应用程序。</p>
<p>注意</p>
<p>如果执行package命令遇到Execution default-war of goal org.apache.maven.plugins:maven-war-plugin:2.2:war failed错误时，可手动指定maven-war-plugin最新版本3.3.2，参考练习工程的pom.xml。</p>
<p>现在问题又来了：我们应该如何运行这个<code>war</code>文件？</p>
<p>普通的Java程序是通过启动JVM，然后执行<code>main()</code>方法开始运行。但是Web应用程序有所不同，我们无法直接运行<code>war</code>文件，必须先启动Web服务器，再由Web服务器加载我们编写的<code>HelloServlet</code>，这样就可以让<code>HelloServlet</code>处理浏览器发送的请求。</p>
<p>因此，我们首先要找一个支持Servlet API的Web服务器。常用的服务器有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Tomcat</a>：由Apache开发的开源免费服务器；</li>
<li><a target="_blank" rel="noopener" href="https://www.eclipse.org/jetty/">Jetty</a>：由Eclipse开发的开源免费服务器；</li>
<li><a target="_blank" rel="noopener" href="https://javaee.github.io/glassfish/">GlassFish</a>：一个开源的全功能JavaEE服务器。</li>
</ul>
<p>还有一些收费的商用服务器，如Oracle的<a target="_blank" rel="noopener" href="https://www.oracle.com/middleware/weblogic/">WebLogic</a>，IBM的<a target="_blank" rel="noopener" href="https://www.ibm.com/cloud/websphere-application-platform/">WebSphere</a>。</p>
<p>无论使用哪个服务器，只要它支持Servlet API 5.0（因为我们引入的Servlet版本是5.0），我们的war包都可以在上面运行。这里我们选择使用最广泛的开源免费的Tomcat服务器。</p>
<p>要运行我们的<code>hello.war</code>，首先要<a target="_blank" rel="noopener" href="https://tomcat.apache.org/download-10.cgi">下载Tomcat服务器</a>，解压后，把<code>hello.war</code>复制到Tomcat的<code>webapps</code>目录下，然后切换到<code>bin</code>目录，执行<code>startup.sh</code>或<code>startup.bat</code>启动Tomcat服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./startup.sh </span><br><span class="line">Using CATALINA_BASE:   .../apache-tomcat-10.1.x</span><br><span class="line">Using CATALINA_HOME:   .../apache-tomcat-10.1.x</span><br><span class="line">Using CATALINA_TMPDIR: .../apache-tomcat-10.1.x/temp</span><br><span class="line">Using JRE_HOME:        .../jdk-17.jdk/Contents/Home</span><br><span class="line">Using CLASSPATH:       .../apache-tomcat-10.1.x/bin/bootstrap.jar:...</span><br><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure>
<p>在浏览器输入<code>http://localhost:8080/hello/</code>即可看到<code>HelloServlet</code>的输出：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/servlet-basic/hello-servlet.jpg" alt="hello-servlet"></p>
<p>细心的童鞋可能会问，为啥路径是<code>/hello/</code>而不是<code>/</code>？因为一个Web服务器允许同时运行多个Web App，而我们的Web App叫<code>hello</code>，因此，第一级目录<code>/hello</code>表示Web App的名字，后面的<code>/</code>才是我们在<code>HelloServlet</code>中映射的路径。</p>
<p>那能不能直接使用<code>/</code>而不是<code>/hello/</code>？毕竟<code>/</code>比较简洁。</p>
<p>答案是肯定的。先关闭Tomcat（执行<code>shutdown.sh</code>或<code>shutdown.bat</code>），然后删除Tomcat的webapps目录下的所有文件夹和文件，最后把我们的<code>hello.war</code>复制过来，改名为<code>ROOT.war</code>，文件名为<code>ROOT</code>的应用程序将作为默认应用，启动后直接访问<code>http://localhost:8080/</code>即可。</p>
<p>实际上，类似Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机，执行Tomcat的<code>main()</code>方法，然后由Tomcat负责加载我们的<code>.war</code>文件，并创建一个<code>HelloServlet</code>实例，最后以多线程的模式来处理HTTP请求。如果Tomcat服务器收到的请求路径是<code>/</code>（假定部署文件为ROOT.war），就转发到<code>HelloServlet</code>并传入<code>HttpServletRequest</code>和<code>HttpServletResponse</code>两个对象。</p>
<p>因为我们编写的Servlet并不是直接运行，而是由Web服务器加载后创建实例运行，所以，类似Tomcat这样的Web服务器也称为Servlet容器。</p>
<h3 id="Tomcat版本">Tomcat版本</h3>
<p>由于Servlet版本分为&lt;=4.0和&gt;=5.0两种，所以，要根据使用的Servlet版本选择正确的Tomcat版本。从<a target="_blank" rel="noopener" href="https://tomcat.apache.org/whichversion.html">Tomcat版本页</a>可知：</p>
<ul>
<li>使用Servlet&lt;=4.0时，选择Tomcat 9.x或更低版本；</li>
<li>使用Servlet&gt;=5.0时，选择Tomcat 10.x或更高版本。</li>
</ul>
<p>运行本节代码需要使用Tomcat&gt;=10.x版本。</p>
<p>在Servlet容器中运行的Servlet具有如下特点：</p>
<ul>
<li>无法在代码中直接通过new创建Servlet实例，必须由Servlet容器自动创建Servlet实例；</li>
<li>Servlet容器只会给每个Servlet类创建唯一实例；</li>
<li>Servlet容器会使用多线程执行<code>doGet()</code>或<code>doPost()</code>方法。</li>
</ul>
<p>复习一下Java<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/threading/index.html">多线程</a>的内容，我们可以得出结论：</p>
<ul>
<li>在Servlet中定义的实例变量会被多个线程同时访问，要注意线程安全；</li>
<li><code>HttpServletRequest</code>和<code>HttpServletResponse</code>实例是由Servlet容器传入的局部变量，它们只能被当前线程访问，不存在多个线程访问的问题；</li>
<li>在<code>doGet()</code>或<code>doPost()</code>方法中，如果使用了<code>ThreadLocal</code>，但没有清理，那么它的状态很可能会影响到下次的某个请求，因为Servlet容器很可能用线程池实现线程复用。</li>
</ul>
<p>因此，正确编写Servlet，要清晰理解Java的多线程模型，需要同步访问的必须同步。</p>
<h3 id="练习-2">练习</h3>
<p>给<code>HelloServlet</code>增加一个URL参数，例如传入<code>http://localhost:8080/?name=Bob</code>，能够输出<code>Hello, Bob!</code>。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/servlet-basic/web-servlet-hello.zip">下载练习</a></p>
<p>提示：根据<a target="_blank" rel="noopener" href="https://jakarta.ee/specifications/servlet/5.0/apidocs/jakarta/servlet/servletrequest">ServletRequest文档</a>，调用合适的方法获取URL参数。</p>
<h3 id="小结-2">小结</h3>
<p>编写Web应用程序就是编写Servlet处理HTTP请求；</p>
<p>Servlet API提供了<code>HttpServletRequest</code>和<code>HttpServletResponse</code>两个高级接口来封装HTTP请求和响应；</p>
<p>Web应用程序必须按固定结构组织并打包为<code>.war</code>文件；</p>
<p>需要启动Web服务器来加载我们的war包来运行Servlet。</p>
<p>在上一节中，我们看到，一个完整的Web应用程序的开发流程如下：</p>
<ol>
<li>编写Servlet；</li>
<li>打包为war文件；</li>
<li>复制到Tomcat的webapps目录下；</li>
<li>启动Tomcat。</li>
</ol>
<p>这个过程是不是很繁琐？如果我们想在IDE中断点调试，还需要打开Tomcat的远程调试端口并且连接上去。</p>
<p><img src="https://liaoxuefeng.com/books/java/web/servlet-dev/laoniao.png" alt="javaee-expert"></p>
<p><img src="https://liaoxuefeng.com/books/java/web/servlet-dev/cainiao.png" alt="javaee-newbee"></p>
<p>许多初学者经常卡在如何在IDE中启动Tomcat并加载webapp，更不要说断点调试了。</p>
<p>我们需要一种简单可靠，能直接在IDE中启动并调试webapp的方法。</p>
<p>因为Tomcat实际上也是一个Java程序，我们看看Tomcat的启动流程：</p>
<ol>
<li>启动JVM并执行Tomcat的<code>main()</code>方法；</li>
<li>加载war并初始化Servlet；</li>
<li>正常服务。</li>
</ol>
<p>启动Tomcat无非就是设置好classpath并执行Tomcat某个jar包的<code>main()</code>方法，我们完全可以把Tomcat的jar包全部引入进来，然后自己编写一个<code>main()</code>方法，先启动Tomcat，然后让它加载我们的webapp就行。</p>
<p>我们新建一个<code>web-servlet-embedded</code>工程，编写<code>pom.xml</code>如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>web-servlet-embedded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tomcat.version</span>&gt;</span>10.1.1<span class="tag">&lt;/<span class="name">tomcat.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;packaging&gt;</code>类型仍然为<code>war</code>，引入依赖<code>tomcat-embed-core</code>和<code>tomcat-embed-jasper</code>，引入的Tomcat版本<code>&lt;tomcat.version&gt;</code>为<code>10.1.1</code>。</p>
<p>不必引入Servlet API，因为引入Tomcat依赖后自动引入了Servlet API。因此，我们可以正常编写Servlet如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            name = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;h1&gt;Hello, &quot;</span> + name + <span class="string">&quot;!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们编写一个<code>main()</code>方法，启动Tomcat服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 启动Tomcat:</span></span><br><span class="line">        <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">        tomcat.setPort(Integer.getInteger(<span class="string">&quot;port&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        tomcat.getConnector();</span><br><span class="line">        <span class="comment">// 创建webapp:</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> tomcat.addWebapp(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/main/webapp&quot;</span>).getAbsolutePath());</span><br><span class="line">        <span class="type">WebResourceRoot</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardRoot</span>(ctx);</span><br><span class="line">        resources.addPreResources(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DirResourceSet</span>(resources, <span class="string">&quot;/WEB-INF/classes&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target/classes&quot;</span>).getAbsolutePath(), <span class="string">&quot;/&quot;</span>));</span><br><span class="line">        ctx.setResources(resources);</span><br><span class="line">        tomcat.start();</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们直接运行<code>main()</code>方法，即可启动嵌入式Tomcat服务器，然后，通过预设的<code>tomcat.addWebapp(&quot;&quot;, new File(&quot;src/main/webapp&quot;)</code>，Tomcat会自动加载当前工程作为根webapp，可直接在浏览器访问<code>http://localhost:8080/</code>：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/servlet-dev/local.png" alt="embedded-tomcat"></p>
<p>通过<code>main()</code>方法启动Tomcat服务器并加载我们自己的webapp有如下好处：</p>
<ol>
<li>启动简单，无需下载Tomcat或安装任何IDE插件；</li>
<li>调试方便，可在IDE中使用断点调试；</li>
<li>使用Maven创建war包后，也可以正常部署到独立的Tomcat服务器中。</li>
</ol>
<h3 id="生成可执行war包">生成可执行war包</h3>
<p>如果要生成可执行的war包，用<code>java -jar xxx.war</code>启动，则需要把Tomcat的依赖项的<code>&lt;scope&gt;</code>去掉，然后配置<code>maven-war-plugin</code>如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">finalName</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- 复制classes到war包根目录 --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">webResources</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;/classes<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">webResources</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">archiveClasses</span>&gt;</span>true<span class="tag">&lt;/<span class="name">archiveClasses</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">							<span class="comment">&lt;!-- 添加Class-Path --&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">							<span class="comment">&lt;!-- Classpath前缀 --&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>tmp-webapp/WEB-INF/lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">							<span class="comment">&lt;!-- main启动类 --&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.itranswarp.learnjava.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>生成的war包结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hello.war</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   └── maven</span><br><span class="line">│       └── ...</span><br><span class="line">├── WEB-INF</span><br><span class="line">│   ├── classes</span><br><span class="line">│   ├── lib</span><br><span class="line">│   │   ├── ecj-3.18.0.jar</span><br><span class="line">│   │   ├── tomcat-annotations-api-10.1.1.jar</span><br><span class="line">│   │   ├── tomcat-embed-core-10.1.1.jar</span><br><span class="line">│   │   ├── tomcat-embed-el-10.1.1.jar</span><br><span class="line">│   │   ├── tomcat-embed-jasper-10.1.1.jar</span><br><span class="line">│   │   └── web-servlet-embedded-1.0-SNAPSHOT.jar</span><br><span class="line">│   └── web.xml</span><br><span class="line">└── com</span><br><span class="line">    └── itranswarp</span><br><span class="line">        └── learnjava</span><br><span class="line">            ├── Main.class</span><br><span class="line">            ├── TomcatRunner.class</span><br><span class="line">            └── servlet</span><br><span class="line">                └── HelloServlet.class</span><br></pre></td></tr></table></figure>
<p>之所以要把编译后的classes复制到war包根目录，是因为用<code>java -jar hello.war</code>启动时，JVM的Class Loader不会查找<code>WEB-INF/lib</code>的jar包，而是直接从<code>hello.war</code>的根目录查找。<code>MANIFEST.MF</code>生成的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Main-Class: com.itranswarp.learnjava.Main</span><br><span class="line">Class-Path: tmp-webapp/WEB-INF/lib/tomcat-embed-core-10.1.1.jar tmp-weba</span><br><span class="line"> pp/WEB-INF/lib/tomcat-annotations-api-10.1.1.jar tmp-webapp/WEB-INF/lib</span><br><span class="line"> /tomcat-embed-jasper-10.1.1.jar tmp-webapp/WEB-INF/lib/tomcat-embed-el-</span><br><span class="line"> 10.1.1.jar tmp-webapp/WEB-INF/lib/ecj-3.18.0.jar</span><br></pre></td></tr></table></figure>
<p>注意到<code>Class-Path</code>的路径，这里定义的<code>Class-Path</code>相当于<code>java -cp</code>指定的Classpath，JVM不会在一个jar包中查找jar包内的jar包，它只会在文件系统中搜索，因此，我们要修改<code>main()</code>方法，在执行<code>main()</code>方法时，先自解压<code>war</code>包，再启动Tomcat：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 判定是否从jar/war启动:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jarFile</span> <span class="operator">=</span> Main.class.getProtectionDomain().getCodeSource().getLocation().getFile();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isJarFile</span> <span class="operator">=</span> jarFile.endsWith(<span class="string">&quot;.war&quot;</span>) || jarFile.endsWith(<span class="string">&quot;.jar&quot;</span>);</span><br><span class="line">        <span class="comment">// 定位webapp根目录:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">webDir</span> <span class="operator">=</span> isJarFile ? <span class="string">&quot;tmp-webapp&quot;</span> : <span class="string">&quot;src/main/webapp&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (isJarFile) &#123;</span><br><span class="line">            <span class="comment">// 解压到tmp-webapp:</span></span><br><span class="line">            <span class="type">Path</span> <span class="variable">baseDir</span> <span class="operator">=</span> Paths.get(webDir).normalize().toAbsolutePath();</span><br><span class="line">            <span class="keyword">if</span> (Files.isDirectory(baseDir)) &#123;</span><br><span class="line">                Files.delete(baseDir);</span><br><span class="line">            &#125;</span><br><span class="line">            Files.createDirectories(baseDir);</span><br><span class="line">            System.out.println(<span class="string">&quot;extract to: &quot;</span> + baseDir);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">JarFile</span> <span class="variable">jar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JarFile</span>(jarFile)) &#123;</span><br><span class="line">                List&lt;JarEntry&gt; entries = jar.stream().sorted(Comparator.comparing(JarEntry::getName))</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">                <span class="keyword">for</span> (JarEntry entry : entries) &#123;</span><br><span class="line">                    <span class="type">Path</span> <span class="variable">res</span> <span class="operator">=</span> baseDir.resolve(entry.getName());</span><br><span class="line">                    <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">                        System.out.println(res);</span><br><span class="line">                        Files.createDirectories(res.getParent());</span><br><span class="line">                        Files.copy(jar.getInputStream(entry), res);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// JVM退出时自动删除tmp-webapp:</span></span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Files.walk(baseDir).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动Tomcat:</span></span><br><span class="line">        TomcatRunner.run(webDir, isJarFile ? <span class="string">&quot;tmp-webapp&quot;</span> : <span class="string">&quot;target/classes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tomcat启动类:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TomcatRunner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String webDir, String baseDir)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">        tomcat.setPort(Integer.getInteger(<span class="string">&quot;port&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        tomcat.getConnector();</span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> tomcat.addWebapp(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(webDir).getAbsolutePath());</span><br><span class="line">        <span class="type">WebResourceRoot</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardRoot</span>(ctx);</span><br><span class="line">        resources.addPreResources(<span class="keyword">new</span> <span class="title class_">DirResourceSet</span>(resources, <span class="string">&quot;/WEB-INF/classes&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(baseDir).getAbsolutePath(), <span class="string">&quot;/&quot;</span>));</span><br><span class="line">        ctx.setResources(resources);</span><br><span class="line">        tomcat.start();</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，执行<code>java -jar hello.war</code>时，JVM先定位<code>hello.war</code>的<code>Main</code>类，运行<code>main()</code>，自动解压后，文件系统目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;work&gt;</span><br><span class="line">├── hello.war</span><br><span class="line">└── tmp-webapp</span><br><span class="line">    └── WEB-INF</span><br><span class="line">        ├── lib</span><br><span class="line">        │   ├── ecj-3.18.0.jar</span><br><span class="line">        │   ├── tomcat-annotations-api-10.1.1.jar</span><br><span class="line">        │   ├── tomcat-embed-core-10.1.1.jar</span><br><span class="line">        │   ├── tomcat-embed-el-10.1.1.jar</span><br><span class="line">        │   ├── tomcat-embed-jasper-10.1.1.jar</span><br><span class="line">        │   └── web-servlet-embedded-1.0-SNAPSHOT.jar</span><br><span class="line">        └── web.xml</span><br></pre></td></tr></table></figure>
<p>解压后的目录结构和我们在<code>MANIFEST.MF</code>中设定的<code>Class-Path</code>一致，因此，JVM能顺利加载Tomcat的jar包，然后运行Tomcat，启动Web App。</p>
<p>编写可执行的jar或者war需要注意的几点：</p>
<ul>
<li>必须在<code>MANIFEST.MF</code>中指定<code>Main-Class</code>和<code>Class-Path</code>；</li>
<li><code>Main</code>必须能在jar/war包的根目录下被JVM的Class Loader加载；</li>
<li><code>Main</code>负责解压jar/war，解压后的目录结构与<code>MANIFEST.MF</code>中设定的<code>Class-Path</code>一致；</li>
<li><code>Main</code>不能引用任何解压后才能被加载的类，例如<code>org.apache.catalina.startup.Tomcat</code>。</li>
</ul>
<p>对SpringBoot有所了解的童鞋可能知道，SpringBoot也支持在<code>main()</code>方法中一行代码直接启动Tomcat，并且还能方便地更换成Jetty等其他服务器。它的启动方式和我们介绍的是基本一样的，后续涉及到SpringBoot的部分我们还会详细讲解。</p>
<h3 id="练习-3">练习</h3>
<p>使用嵌入式Tomcat运行Servlet。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/servlet-dev/web-servlet-embedded.zip">下载练习</a></p>
<p>注意：引入的Tomcat的scope为<code>provided</code>，在Idea下运行时，需要设置<code>Run/Debug Configurations</code>，选择<code>Application - Main</code>，钩上<code>Include dependencies with &quot;Provided&quot; scope</code>，这样才能让Idea在运行时把Tomcat相关依赖包自动添加到classpath中。</p>
<h3 id="小结-3">小结</h3>
<p>开发Servlet时，推荐使用<code>main()</code>方法启动嵌入式Tomcat服务器并加载当前工程的webapp，便于开发调试，且不影响打包部署，能极大地提升开发效率。</p>
<p>一个Web App就是由一个或多个Servlet组成的，每个Servlet通过注解说明自己能处理的路径。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述<code>HelloServlet</code>能处理<code>/hello</code>这个路径的请求。</p>
<p>提示</p>
<p>早期的Servlet需要在web.xml中配置映射路径，但最新Servlet版本只需要通过注解就可以完成映射。</p>
<p>因为浏览器发送请求的时候，还会有请求方法（HTTP Method）：即<code>GET</code>、<code>POST</code>、<code>PUT</code>等不同类型的请求。因此，要处理<code>GET</code>请求，我们要覆写<code>doGet()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，要处理<code>POST</code>请求，就需要覆写<code>doPost()</code>方法。</p>
<p>如果没有覆写<code>doPost()</code>方法，那么<code>HelloServlet</code>能不能处理<code>POST /hello</code>请求呢？</p>
<p>我们查看一下<code>HttpServlet</code>的<code>doPost()</code>方法就一目了然了：它会直接返回405或400错误。因此，一个Servlet如果映射到<code>/hello</code>，那么所有请求方法都会由这个Servlet处理，至于能不能返回200成功响应，要看有没有覆写对应的请求方法。</p>
<p>一个Webapp完全可以有多个Servlet，分别映射不同的路径。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignInServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浏览器发出的HTTP请求总是由Web Server先接收，然后，根据Servlet配置的映射，不同的路径转发到不同的Servlet：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">               ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line"></span><br><span class="line">               │            /hello    ┌───────────────┐│</span><br><span class="line">                          ┌──────────▶│ HelloServlet  │</span><br><span class="line">               │          │           └───────────────┘│</span><br><span class="line">┌───────┐    ┌──────────┐ │ /signin   ┌───────────────┐</span><br><span class="line">│Browser│───▶│Dispatcher│─┼──────────▶│ SignInServlet ││</span><br><span class="line">└───────┘    └──────────┘ │           └───────────────┘</span><br><span class="line">               │          │ /         ┌───────────────┐│</span><br><span class="line">                          └──────────▶│ IndexServlet  │</span><br><span class="line">               │                      └───────────────┘│</span><br><span class="line">                              Web Server</span><br><span class="line">               └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>这种根据路径转发的功能我们一般称为dispatch。映射到<code>/</code>的<code>IndexServlet</code>比较特殊，它实际上会接收所有未匹配的路径，相当于<code>/*</code>，因为Dispatcher的逻辑可以用伪代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="keyword">if</span> (path.equals(<span class="string">&quot;/hello&quot;</span>)) &#123;</span><br><span class="line">    dispatchTo(helloServlet);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.equals(<span class="string">&quot;/signin&quot;</span>)) &#123;</span><br><span class="line">    dispatchTo(signinServlet);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 所有未匹配的路径均转发到&quot;/&quot;</span></span><br><span class="line">    dispatchTo(indexServlet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们在浏览器输入一个<code>http://localhost:8080/abc</code>也会看到<code>IndexServlet</code>生成的页面。</p>
<h3 id="HttpServletRequest">HttpServletRequest</h3>
<p><code>HttpServletRequest</code>封装了一个HTTP请求，它实际上是从<code>ServletRequest</code>继承而来。最早设计Servlet时，设计者希望Servlet不仅能处理HTTP，也能处理类似SMTP等其他协议，因此，单独抽出了<code>ServletRequest</code>接口，但实际上除了HTTP外，并没有其他协议会用Servlet处理，所以这是一个过度设计。</p>
<p>我们通过<code>HttpServletRequest</code>提供的接口方法可以拿到HTTP请求的几乎全部信息，常用的方法有：</p>
<ul>
<li>getMethod()：返回请求方法，例如，<code>&quot;GET&quot;</code>，<code>&quot;POST&quot;</code>；</li>
<li>getRequestURI()：返回请求路径，但不包括请求参数，例如，<code>&quot;/hello&quot;</code>；</li>
<li>getQueryString()：返回请求参数，例如，<code>&quot;name=Bob&amp;a=1&amp;b=2&quot;</code>；</li>
<li>getParameter(name)：返回请求参数，GET请求从URL读取参数，POST请求从Body中读取参数；</li>
<li>getContentType()：获取请求Body的类型，例如，<code>&quot;application/x-www-form-urlencoded&quot;</code>；</li>
<li>getContextPath()：获取当前Webapp挂载的路径，对于ROOT来说，总是返回空字符串<code>&quot;&quot;</code>；</li>
<li>getCookies()：返回请求携带的所有Cookie；</li>
<li>getHeader(name)：获取指定的Header，对Header名称不区分大小写；</li>
<li>getHeaderNames()：返回所有Header名称；</li>
<li>getInputStream()：如果该请求带有HTTP Body，该方法将打开一个输入流用于读取Body；</li>
<li>getReader()：和getInputStream()类似，但打开的是Reader；</li>
<li>getRemoteAddr()：返回客户端的IP地址；</li>
<li>getScheme()：返回协议类型，例如，<code>&quot;http&quot;</code>，<code>&quot;https&quot;</code>；</li>
</ul>
<p>此外，<code>HttpServletRequest</code>还有两个方法：<code>setAttribute()</code>和<code>getAttribute()</code>，可以给当前<code>HttpServletRequest</code>对象附加多个Key-Value，相当于把<code>HttpServletRequest</code>当作一个<code>Map&lt;String, Object&gt;</code>使用。</p>
<p>调用<code>HttpServletRequest</code>的方法时，注意务必阅读接口方法的文档说明，因为有的方法会返回<code>null</code>，例如<code>getQueryString()</code>的文档就写了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... This method returns null if the URL does not have a query string...</span><br></pre></td></tr></table></figure>
<h3 id="HttpServletResponse">HttpServletResponse</h3>
<p><code>HttpServletResponse</code>封装了一个HTTP响应。由于HTTP响应必须先发送Header，再发送Body，所以，操作<code>HttpServletResponse</code>对象时，必须先调用设置Header的方法，最后调用发送Body的方法。</p>
<p>常用的设置Header的方法有：</p>
<ul>
<li>setStatus(sc)：设置响应代码，默认是<code>200</code>；</li>
<li>setContentType(type)：设置Body的类型，例如，<code>&quot;text/html&quot;</code>；</li>
<li>setCharacterEncoding(charset)：设置字符编码，例如，<code>&quot;UTF-8&quot;</code>；</li>
<li>setHeader(name, value)：设置一个Header的值；</li>
<li>addCookie(cookie)：给响应添加一个Cookie；</li>
<li>addHeader(name, value)：给响应添加一个Header，因为HTTP协议允许有多个相同的Header；</li>
</ul>
<p>写入响应时，需要通过<code>getOutputStream()</code>获取写入流，或者通过<code>getWriter()</code>获取字符流，二者只能获取其中一个。</p>
<p>写入响应前，无需设置<code>setContentLength()</code>，因为底层服务器会根据写入的字节数自动设置，如果写入的数据量很小，实际上会先写入缓冲区，如果写入的数据量很大，服务器会自动采用Chunked编码让浏览器能识别数据结束符而不需要设置Content-Length头。</p>
<p>但是，写入完毕后调用<code>flush()</code>却是必须的，因为大部分Web服务器都基于HTTP/1.1协议，会复用TCP连接。如果没有调用<code>flush()</code>，将导致缓冲区的内容无法及时发送到客户端。此外，写入完毕后千万不要调用<code>close()</code>，原因同样是因为会复用TCP连接，如果关闭写入流，将关闭TCP连接，使得Web服务器无法复用此TCP连接。</p>
<p>注意</p>
<p>写入完毕后对输出流调用flush()而不是close()方法！</p>
<p>有了<code>HttpServletRequest</code>和<code>HttpServletResponse</code>这两个高级接口，我们就不需要直接处理HTTP协议。注意到具体的实现类是由各服务器提供的，而我们编写的Web应用程序只关心接口方法，并不需要关心具体实现的子类。</p>
<h3 id="Servlet多线程模型">Servlet多线程模型</h3>
<p>一个Servlet类在服务器中只有一个实例，但对于每个HTTP请求，Web服务器会使用多线程执行请求。因此，一个Servlet的<code>doGet()</code>、<code>doPost()</code>等处理请求的方法是多线程并发执行的。如果Servlet中定义了字段，要注意多线程并发访问的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 注意读写map字段是多线程并发的:</span></span><br><span class="line">        <span class="built_in">this</span>.map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每个请求，Web服务器会创建唯一的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>实例，因此，<code>HttpServletRequest</code>和<code>HttpServletResponse</code>实例只有在当前处理线程中有效，它们总是局部变量，不存在多线程共享的问题。</p>
<h3 id="小结-4">小结</h3>
<p>一个Webapp中的多个Servlet依靠路径映射来处理不同的请求；</p>
<p>映射为<code>/</code>的Servlet可处理所有“未匹配”的请求；</p>
<p>如何处理请求取决于Servlet覆写的对应方法；</p>
<p>Web服务器通过多线程处理HTTP请求，一个Servlet的处理方法可以由多线程并发执行。</p>
<h3 id="Redirect">Redirect</h3>
<p>重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。</p>
<p>例如，我们已经编写了一个能处理<code>/hello</code>的<code>HelloServlet</code>，如果收到的路径为<code>/hi</code>，希望能重定向到<code>/hello</code>，可以再编写一个<code>RedirectServlet</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/hi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedirectServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 构造重定向的路径:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">redirectToUrl</span> <span class="operator">=</span> <span class="string">&quot;/hello&quot;</span> + (name == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;?name=&quot;</span> + name);</span><br><span class="line">        <span class="comment">// 发送重定向响应:</span></span><br><span class="line">        resp.sendRedirect(redirectToUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果浏览器发送<code>GET /hi</code>请求，<code>RedirectServlet</code>将处理此请求。由于<code>RedirectServlet</code>在内部又发送了重定向响应，因此，浏览器会收到如下响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: /hello</span><br></pre></td></tr></table></figure>
<p>当浏览器收到302响应后，它会立刻根据<code>Location</code>的指示发送一个新的<code>GET /hello</code>请求，这个过程就是重定向：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐   GET /hi     ┌───────────────┐</span><br><span class="line">│Browser│ ────────────▶ │RedirectServlet│</span><br><span class="line">│       │ ◀──────────── │               │</span><br><span class="line">└───────┘   302         └───────────────┘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">┌───────┐  GET /hello   ┌───────────────┐</span><br><span class="line">│Browser│ ────────────▶ │ HelloServlet  │</span><br><span class="line">│       │ ◀──────────── │               │</span><br><span class="line">└───────┘   200 &lt;html&gt;  └───────────────┘</span><br></pre></td></tr></table></figure>
<p>观察Chrome浏览器的网络请求，可以看到两次HTTP请求：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/servlet-adv/redirect-forward/redirect.jpg" alt="redirect"></p>
<p>并且浏览器的地址栏路径自动更新为<code>/hello</code>。</p>
<p>重定向有两种：一种是302响应，称为临时重定向，一种是301响应，称为永久重定向。两者的区别是，如果服务器发送301永久重定向响应，浏览器会缓存<code>/hi</code>到<code>/hello</code>这个重定向的关联，下次请求<code>/hi</code>的时候，浏览器就直接发送<code>/hello</code>请求了。</p>
<p>重定向有什么作用？重定向的目的是当Web应用升级后，如果请求路径发生了变化，可以将原来的路径重定向到新路径，从而避免浏览器请求原路径找不到资源。</p>
<p><code>HttpServletResponse</code>提供了快捷的<code>redirect()</code>方法实现302重定向。如果要实现301永久重定向，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); <span class="comment">// 301</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;/hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Forward">Forward</h3>
<p>Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。</p>
<p>例如，我们已经编写了一个能处理<code>/hello</code>的<code>HelloServlet</code>，继续编写一个能处理<code>/morning</code>的<code>ForwardServlet</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/morning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForwardServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/hello&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ForwardServlet</code>在收到请求后，它并不自己发送响应，而是把请求和响应都转发给路径为<code>/hello</code>的Servlet，即下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;/hello&quot;</span>).forward(req, resp);</span><br></pre></td></tr></table></figure>
<p>后续请求的处理实际上是由<code>HelloServlet</code>完成的。这种处理方式称为转发（Forward），我们用流程图画出来如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                          ┌────────────────────────┐</span><br><span class="line">                          │      ┌───────────────┐ │</span><br><span class="line">                          │ ────▶│ForwardServlet │ │</span><br><span class="line">┌───────┐  GET /morning   │      └───────────────┘ │</span><br><span class="line">│Browser│ ──────────────▶ │              │         │</span><br><span class="line">│       │ ◀────────────── │              ▼         │</span><br><span class="line">└───────┘    200 &lt;html&gt;   │      ┌───────────────┐ │</span><br><span class="line">                          │ ◀────│ HelloServlet  │ │</span><br><span class="line">                          │      └───────────────┘ │</span><br><span class="line">                          │       Web Server       │</span><br><span class="line">                          └────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>转发和重定向的区别在于，转发是在Web服务器内部完成的，对浏览器来说，它只发出了一个HTTP请求：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/servlet-adv/redirect-forward/forward.jpg" alt="forward"></p>
<p>注意到使用转发的时候，浏览器的地址栏路径仍然是<code>/morning</code>，浏览器并不知道该请求在Web服务器内部实际上做了一次转发。</p>
<h3 id="练习-4">练习</h3>
<p>在Servlet中使用重定向和转发。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/servlet-adv/redirect-forward/web-servlet-redirect-forward.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>使用重定向时，浏览器知道重定向规则，并且会自动发起新的HTTP请求；</p>
<p>使用转发时，浏览器并不知道服务器内部的转发逻辑。</p>
<p>在Web应用程序中，我们经常要跟踪用户身份。当一个用户登录成功后，如果他继续访问其他页面，Web程序如何才能识别出该用户身份？</p>
<p>因为HTTP协议是一个无状态协议，即Web应用程序无法区分收到的两个HTTP请求是否是同一个浏览器发出的。为了跟踪用户状态，服务器可以向浏览器分配一个唯一ID，并以Cookie的形式发送到浏览器，浏览器在后续访问时总是附带此Cookie，这样，服务器就可以识别用户身份。</p>
<h3 id="Session">Session</h3>
<p>我们把这种基于唯一ID识别用户身份的机制称为Session。每个用户第一次访问服务器后，会自动获得一个Session ID。如果用户在一段时间内没有访问服务器，那么Session会自动失效，下次即使带着上次分配的Session ID访问，服务器也认为这是一个新用户，会分配新的Session ID。</p>
<p>JavaEE的Servlet机制内建了对Session的支持。我们以登录为例，当一个用户登录成功后，我们就可以把这个用户的名字放入一个<code>HttpSession</code>对象，以便后续访问其他页面的时候，能直接从<code>HttpSession</code>取出用户名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignInServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟一个数据库:</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; users = Map.of(<span class="string">&quot;bob&quot;</span>, <span class="string">&quot;bob123&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;alice123&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GET请求时显示登录页:</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;h1&gt;Sign In&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;form action=\&quot;/signin\&quot; method=\&quot;post\&quot;&gt;&quot;</span>);</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;p&gt;Username: &lt;input name=\&quot;username\&quot;&gt;&lt;/p&gt;&quot;</span>);</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;p&gt;Password: &lt;input name=\&quot;password\&quot; type=\&quot;password\&quot;&gt;&lt;/p&gt;&quot;</span>);</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;p&gt;&lt;button type=\&quot;submit\&quot;&gt;Sign In&lt;/button&gt; &lt;a href=\&quot;/\&quot;&gt;Cancel&lt;/a&gt;&lt;/p&gt;&quot;</span>);</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// POST请求时处理用户登录:</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">expectedPassword</span> <span class="operator">=</span> users.get(name.toLowerCase());</span><br><span class="line">        <span class="keyword">if</span> (expectedPassword != <span class="literal">null</span> &amp;&amp; expectedPassword.equals(password)) &#123;</span><br><span class="line">            <span class="comment">// 登录成功:</span></span><br><span class="line">            req.getSession().setAttribute(<span class="string">&quot;user&quot;</span>, name);</span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述<code>SignInServlet</code>在判断用户登录成功后，立刻将用户名放入当前<code>HttpSession</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, name);</span><br></pre></td></tr></table></figure>
<p>在<code>IndexServlet</code>中，可以从<code>HttpSession</code>取出用户名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 从HttpSession获取当前用户名:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> (String) req.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;X-Powered-By&quot;</span>, <span class="string">&quot;JavaEE Servlet&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;h1&gt;Welcome, &quot;</span> + (user != <span class="literal">null</span> ? user : <span class="string">&quot;Guest&quot;</span>) + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 未登录，显示登录链接:</span></span><br><span class="line">            pw.write(<span class="string">&quot;&lt;p&gt;&lt;a href=\&quot;/signin\&quot;&gt;Sign In&lt;/a&gt;&lt;/p&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已登录，显示登出链接:</span></span><br><span class="line">            pw.write(<span class="string">&quot;&lt;p&gt;&lt;a href=\&quot;/signout\&quot;&gt;Sign Out&lt;/a&gt;&lt;/p&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户已登录，可以通过访问<code>/signout</code>登出。登出逻辑就是从<code>HttpSession</code>中移除用户相关信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/signout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignOutServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 从HttpSession移除用户名:</span></span><br><span class="line">        req.getSession().removeAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Web应用程序来说，我们总是通过<code>HttpSession</code>这个高级接口访问当前Session。如果要深入理解Session原理，可以认为Web服务器在内存中自动维护了一个ID到<code>HttpSession</code>的映射表，我们可以用下图表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">           ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line"></span><br><span class="line">           │      ┌───────────────┐                │</span><br><span class="line">             ┌───▶│ IndexServlet  │◀──────────┐</span><br><span class="line">           │ │    └───────────────┘           ▼    │</span><br><span class="line">┌───────┐    │    ┌───────────────┐      ┌────────┐</span><br><span class="line">│Browser│──┼─┼───▶│ SignInServlet │◀────▶│Sessions││</span><br><span class="line">└───────┘    │    └───────────────┘      └────────┘</span><br><span class="line">           │ │    ┌───────────────┐           ▲    │</span><br><span class="line">             └───▶│SignOutServlet │◀──────────┘</span><br><span class="line">           │      └───────────────┘                │</span><br><span class="line"></span><br><span class="line">           └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>而服务器识别Session的关键就是依靠一个名为<code>JSESSIONID</code>的Cookie。在Servlet中第一次调用<code>req.getSession()</code>时，Servlet容器自动创建一个Session ID，然后通过一个名为<code>JSESSIONID</code>的Cookie发送给浏览器：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/servlet-adv/session-cookie/cookie.jpg" alt="session"></p>
<p>这里要注意的几点是：</p>
<ul>
<li><code>JSESSIONID</code>是由Servlet容器自动创建的，目的是维护一个浏览器会话，它和我们的登录逻辑没有关系；</li>
<li>登录和登出的业务逻辑是我们自己根据<code>HttpSession</code>是否存在一个<code>&quot;user&quot;</code>的Key判断的，登出后，Session ID并不会改变；</li>
<li>即使没有登录功能，仍然可以使用<code>HttpSession</code>追踪用户，例如，放入一些用户配置信息等。</li>
</ul>
<p>除了使用Cookie机制可以实现Session外，还可以通过隐藏表单、URL末尾附加ID来追踪Session。这些机制很少使用，最常用的Session机制仍然是Cookie。</p>
<p>使用Session时，由于服务器把所有用户的Session都存储在内存中，如果遇到内存不足的情况，就需要把部分不活动的Session序列化到磁盘上，这会大大降低服务器的运行效率，因此，放入Session的对象要小，通常我们放入一个简单的<code>User</code>对象就足够了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> id; <span class="comment">// 唯一标识</span></span><br><span class="line">    <span class="keyword">public</span> String email;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用多台服务器构成集群时，使用Session会遇到一些额外的问题。通常，多台服务器集群使用反向代理作为网站入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                     ┌────────────┐</span><br><span class="line">                                ┌───▶│Web Server 1│</span><br><span class="line">                                │    └────────────┘</span><br><span class="line">┌───────┐     ┌─────────────┐   │    ┌────────────┐</span><br><span class="line">│Browser│────▶│Reverse Proxy│───┼───▶│Web Server 2│</span><br><span class="line">└───────┘     └─────────────┘   │    └────────────┘</span><br><span class="line">                                │    ┌────────────┐</span><br><span class="line">                                └───▶│Web Server 3│</span><br><span class="line">                                     └────────────┘</span><br></pre></td></tr></table></figure>
<p>如果多台Web Server采用无状态集群，那么反向代理总是以轮询方式将请求依次转发给每台Web Server，这会造成一个用户在Web Server 1存储的Session信息，在Web Server 2和3上并不存在，即从Web Server 1登录后，如果后续请求被转发到Web Server 2或3，那么用户看到的仍然是未登录状态。</p>
<p>要解决这个问题，方案一是在所有Web Server之间进行Session复制，但这样会严重消耗网络带宽，并且，每个Web Server的内存均存储所有用户的Session，内存使用率很低。</p>
<p>另一个方案是采用粘滞会话（Sticky Session）机制，即反向代理在转发请求的时候，总是根据JSESSIONID的值判断，相同的JSESSIONID总是转发到固定的Web Server，但这需要反向代理的支持。</p>
<p>无论采用何种方案，使用Session机制，会使得Web Server的集群很难扩展，因此，Session适用于中小型Web应用程序。对于大型Web应用程序来说，通常需要避免使用Session机制。</p>
<h3 id="Cookie">Cookie</h3>
<p>实际上，Servlet提供的<code>HttpSession</code>本质上就是通过一个名为<code>JSESSIONID</code>的Cookie来跟踪用户会话的。除了这个名称外，其他名称的Cookie我们可以任意使用。</p>
<p>如果我们想要设置一个Cookie，例如，记录用户选择的语言，可以编写一个<code>LanguageServlet</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/pref&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LanguageServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; LANGUAGES = Set.of(<span class="string">&quot;en&quot;</span>, <span class="string">&quot;zh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lang</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (LANGUAGES.contains(lang)) &#123;</span><br><span class="line">            <span class="comment">// 创建一个新的Cookie:</span></span><br><span class="line">            <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;lang&quot;</span>, lang);</span><br><span class="line">            <span class="comment">// 该Cookie生效的路径范围:</span></span><br><span class="line">            cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="comment">// 该Cookie有效期:</span></span><br><span class="line">            cookie.setMaxAge(<span class="number">8640000</span>); <span class="comment">// 8640000秒=100天</span></span><br><span class="line">            <span class="comment">// 将该Cookie添加到响应:</span></span><br><span class="line">            resp.addCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个新Cookie时，除了指定名称和值以外，通常需要设置<code>setPath(&quot;/&quot;)</code>，浏览器根据此前缀决定是否发送Cookie。如果一个Cookie调用了<code>setPath(&quot;/user/&quot;)</code>，那么浏览器只有在请求以<code>/user/</code>开头的路径时才会附加此Cookie。通过<code>setMaxAge()</code>设置Cookie的有效期，单位为秒，最后通过<code>resp.addCookie()</code>把它添加到响应。</p>
<p>如果访问的是https网页，还需要调用<code>setSecure(true)</code>，否则浏览器不会发送该Cookie。</p>
<p>因此，务必注意：浏览器在请求某个URL时，是否携带指定的Cookie，取决于Cookie是否满足以下所有要求：</p>
<ul>
<li>URL前缀是设置Cookie时的Path；</li>
<li>Cookie在有效期内；</li>
<li>Cookie设置了secure时必须以https访问。</li>
</ul>
<p>我们可以在浏览器看到服务器发送的Cookie：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/servlet-adv/session-cookie/set-cookie.jpg" alt="cookie"></p>
<p>如果我们要读取Cookie，例如，在<code>IndexServlet</code>中，读取名为<code>lang</code>的Cookie以获取用户设置的语言，可以写一个方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">parseLanguageFromCookie</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取请求附带的所有Cookie:</span></span><br><span class="line">    Cookie[] cookies = req.getCookies();</span><br><span class="line">    <span class="comment">// 如果获取到Cookie:</span></span><br><span class="line">    <span class="keyword">if</span> (cookies != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环每个Cookie:</span></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="comment">// 如果Cookie名称为lang:</span></span><br><span class="line">            <span class="keyword">if</span> (cookie.getName().equals(<span class="string">&quot;lang&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 返回Cookie的值:</span></span><br><span class="line">                <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回默认值:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;en&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，读取Cookie主要依靠遍历<code>HttpServletRequest</code>附带的所有Cookie。</p>
<h3 id="练习-5">练习</h3>
<p>在Servlet中使用Session和Cookie。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/servlet-adv/session-cookie/web-servlet-session-cookie.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>Servlet容器提供了Session机制以跟踪用户；</p>
<p>默认的Session机制是以Cookie形式实现的，Cookie名称为<code>JSESSIONID</code>；</p>
<p>通过读写Cookie可以在客户端设置用户偏好等。</p>
<p>我们从前面的章节可以看到，Servlet就是一个能处理HTTP请求，发送HTTP响应的小程序，而发送响应无非就是获取<code>PrintWriter</code>，然后输出HTML：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">pw.write(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">pw.write(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">pw.write(<span class="string">&quot;&lt;h1&gt;Welcome, &quot;</span> + name + <span class="string">&quot;!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">pw.write(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">pw.write(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">pw.flush();</span><br></pre></td></tr></table></figure>
<p>只不过，用PrintWriter输出HTML比较痛苦，因为不但要正确编写HTML，还需要插入各种变量。如果想在Servlet中输出一个类似新浪首页的HTML，写对HTML基本上不太可能。</p>
<p>那有没有更简单的输出HTML的办法？</p>
<h3 id="有！">有！</h3>
<p>我们可以使用JSP。</p>
<p>JSP是Java Server Pages的缩写，它的文件必须放到<code>/src/main/webapp</code>下，文件名必须以<code>.jsp</code>结尾，整个文件与HTML并无太大区别，但需要插入变量，或者动态输出的地方，使用特殊指令<code>&lt;% ... %&gt;</code>。</p>
<p>我们来编写一个<code>hello.jsp</code>，内容如下：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hello World - JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%-- JSP Comment --%&gt;</span><br><span class="line">    &lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">         out.println(<span class="string">&quot;Your IP address is &quot;</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;span style=<span class="string">&quot;color:red&quot;</span>&gt;</span><br><span class="line">        &lt;%= request.getRemoteAddr() %&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>整个JSP的内容实际上是一个HTML，但是稍有不同：</p>
<ul>
<li>包含在<code>&lt;%--</code>和<code>--%&gt;</code>之间的是JSP的注释，它们会被完全忽略；</li>
<li>包含在<code>&lt;%</code>和<code>%&gt;</code>之间的是Java代码，可以编写任意Java代码；</li>
<li>如果使用<code>&lt;%= xxx %&gt;</code>则可以快捷输出一个变量的值。</li>
</ul>
<p>JSP页面内置了几个变量：</p>
<ul>
<li>out：表示HttpServletResponse的PrintWriter；</li>
<li>session：表示当前HttpSession对象；</li>
<li>request：表示HttpServletRequest对象。</li>
</ul>
<p>这几个变量可以直接使用。</p>
<p>访问JSP页面时，直接指定完整路径。例如，<code>http://localhost:8080/hello.jsp</code>，浏览器显示如下：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/jsp/jsp.jpg" alt="jsp"></p>
<p>JSP和Servlet有什么区别？其实它们没有任何区别，因为JSP在执行前首先被编译成一个Servlet。在Tomcat的临时目录下，可以找到一个<code>hello_jsp.java</code>的源文件，这个文件就是Tomcat把JSP自动转换成的Servlet源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.jsp;</span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">hello_jsp</span> <span class="keyword">extends</span> <span class="title class_">org</span>.apache.jasper.runtime.HttpJspBase</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">org</span>.apache.jasper.runtime.JspSourceDependent,</span><br><span class="line">               org.apache.jasper.runtime.JspSourceImports &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException &#123;</span><br><span class="line">        ...</span><br><span class="line">        out.write(<span class="string">&quot;&lt;html&gt;\n&quot;</span>);</span><br><span class="line">        out.write(<span class="string">&quot;&lt;head&gt;\n&quot;</span>);</span><br><span class="line">        out.write(<span class="string">&quot;    &lt;title&gt;Hello World - JSP&lt;/title&gt;\n&quot;</span>);</span><br><span class="line">        out.write(<span class="string">&quot;&lt;/head&gt;\n&quot;</span>);</span><br><span class="line">        out.write(<span class="string">&quot;&lt;body&gt;\n&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见JSP本质上就是一个Servlet，只不过无需配置映射路径，Web Server会根据路径查找对应的<code>.jsp</code>文件，如果找到了，就自动编译成Servlet再执行。在服务器运行过程中，如果修改了JSP的内容，那么服务器会自动重新编译。</p>
<h3 id="JSP高级功能">JSP高级功能</h3>
<p>JSP的指令非常复杂，除了<code>&lt;% ... %&gt;</code>外，JSP页面本身可以通过<code>page</code>指令引入Java类：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>
<p>这样后续的Java代码才能引用简单类名而不是完整类名。</p>
<p>使用<code>include</code>指令可以引入另一个JSP文件：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%@ include file=<span class="string">&quot;header.jsp&quot;</span>%&gt;</span><br><span class="line">    &lt;h1&gt;Index Page&lt;/h1&gt;</span><br><span class="line">    &lt;%@ include file=<span class="string">&quot;footer.jsp&quot;</span>%&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="JSP-Tag">JSP Tag</h3>
<p>JSP还允许自定义输出的tag，例如：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="type">out</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;$&#123;sessionScope.user.name&#125;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>JSP Tag需要正确引入taglib的jar包，并且还需要正确声明，使用起来非常复杂，对于页面开发来说，<em>不推荐</em>使用JSP Tag，因为我们后续会介绍更简单的模板引擎，这里我们不再介绍如何使用taglib。</p>
<h3 id="练习-6">练习</h3>
<p>编写一个简单的JSP文件，输出当前日期和时间。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/jsp/web-jsp-hello.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>JSP是一种在HTML中嵌入动态输出的文件，它和Servlet正好相反，Servlet是在Java代码中嵌入输出HTML；</p>
<p>JSP可以引入并使用JSP Tag，但由于其语法复杂，不推荐使用；</p>
<p>JSP本身目前已经很少使用，我们只需要了解其基本用法即可。</p>
<h2 id="MVC开发">MVC开发</h2>
<p>我们通过前面的章节可以看到：</p>
<ul>
<li>Servlet适合编写Java代码，实现各种复杂的业务逻辑，但不适合输出复杂的HTML；</li>
<li>JSP适合编写HTML，并在其中插入动态内容，但不适合编写复杂的Java代码。</li>
</ul>
<p>能否将两者结合起来，发挥各自的优点，避免各自的缺点？</p>
<p>答案是肯定的。我们来看一个具体的例子。</p>
<p>假设我们已经编写了几个JavaBean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> School school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">School</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>UserServlet</code>中，我们可以从数据库读取<code>User</code>、<code>School</code>等信息，然后，把读取到的JavaBean先放到HttpServletRequest中，再通过<code>forward()</code>传给<code>user.jsp</code>处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 假装从数据库读取:</span></span><br><span class="line">        <span class="type">School</span> <span class="variable">school</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">School</span>(<span class="string">&quot;No.1 Middle School&quot;</span>, <span class="string">&quot;101 South Street&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>, <span class="string">&quot;Bob&quot;</span>, school);</span><br><span class="line">        <span class="comment">// 放入Request中:</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="comment">// forward给user.jsp:</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/user.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>user.jsp</code>中，我们只负责展示相关JavaBean的信息，不需要编写访问数据库等复杂逻辑：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;com.itranswarp.learnjava.bean.*&quot;</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) request.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hello World - JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello &lt;%= user.name %&gt;!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;School Name:</span><br><span class="line">    &lt;span style=<span class="string">&quot;color:red&quot;</span>&gt;</span><br><span class="line">        &lt;%= user.school.name %&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;School Address:</span><br><span class="line">    &lt;span style=<span class="string">&quot;color:red&quot;</span>&gt;</span><br><span class="line">        &lt;%= user.school.address %&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>请注意几点：</p>
<ul>
<li>需要展示的<code>User</code>被放入<code>HttpServletRequest</code>中以便传递给JSP，因为一个请求对应一个<code>HttpServletRequest</code>，我们也无需清理它，处理完该请求后<code>HttpServletRequest</code>实例将被丢弃；</li>
<li>把<code>user.jsp</code>放到<code>/WEB-INF/</code>目录下，是因为<code>WEB-INF</code>是一个特殊目录，Web Server会阻止浏览器对<code>WEB-INF</code>目录下任何资源的访问，这样就防止用户通过<code>/user.jsp</code>路径直接访问到JSP页面；</li>
<li>JSP页面首先从<code>request</code>变量获取<code>User</code>实例，然后在页面中直接输出，此处未考虑HTML的转义问题，有潜在安全风险。</li>
</ul>
<p>我们在浏览器访问<code>http://localhost:8080/user</code>，请求首先由<code>UserServlet</code>处理，然后交给<code>user.jsp</code>渲染：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/mvc/mvc.jpg" alt="mvc"></p>
<p>我们把<code>UserServlet</code>看作业务逻辑处理，把<code>User</code>看作模型，把<code>user.jsp</code>看作渲染，这种设计模式通常被称为MVC：Model-View-Controller，即<code>UserServlet</code>作为控制器（Controller），<code>User</code>作为模型（Model），<code>user.jsp</code>作为视图（View），整个MVC架构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                   ┌───────────────────────┐</span><br><span class="line">             ┌────▶│Controller: UserServlet│</span><br><span class="line">             │     └───────────────────────┘</span><br><span class="line">             │                 │</span><br><span class="line">┌───────┐    │           ┌─────┴─────┐</span><br><span class="line">│Browser│────┘           │Model: User│</span><br><span class="line">│       │◀───┐           └─────┬─────┘</span><br><span class="line">└───────┘    │                 │</span><br><span class="line">             │                 ▼</span><br><span class="line">             │     ┌───────────────────────┐</span><br><span class="line">             └─────│    View: user.jsp     │</span><br><span class="line">                   └───────────────────────┘</span><br></pre></td></tr></table></figure>
<p>使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。</p>
<p>MVC模式广泛地应用在Web页面和传统的桌面程序中，我们在这里通过Servlet和JSP实现了一个简单的MVC模型，但它还不够简洁和灵活，后续我们会介绍更简单的Spring MVC开发。</p>
<h3 id="练习-7">练习</h3>
<p>使用MVC开发。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/mvc/web-servlet-jsp.zip">下载练习</a></p>
<h3 id="小结-8">小结</h3>
<p>MVC模式是一种分离业务逻辑和显示逻辑的设计模式，广泛应用在Web和桌面应用程序。</p>
<hr>
<hr>
<p>通过结合Servlet和JSP的MVC模式，我们可以发挥二者各自的优点：</p>
<ul>
<li>Servlet实现业务逻辑；</li>
<li>JSP实现展示逻辑。</li>
</ul>
<p>但是，直接把MVC搭在Servlet和JSP之上还是不太好，原因如下：</p>
<ul>
<li>Servlet提供的接口仍然偏底层，需要实现Servlet调用相关接口；</li>
<li>JSP对页面开发不友好，更好的替代品是模板引擎；</li>
<li>业务逻辑最好由纯粹的Java类实现，而不是强迫继承自Servlet。</li>
</ul>
<p>能不能通过普通的Java类实现MVC的Controller？类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/signin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">signin</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">doSignin</span><span class="params">(SignInBean bean)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/signout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">signout</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这个Java类每个方法都对应一个GET或POST请求，方法返回值是<code>ModelAndView</code>，它包含一个View的路径以及一个Model，这样，再由MVC框架处理后返回给浏览器。</p>
<p>如果是GET请求，我们希望MVC框架能直接把URL参数按方法参数对应起来然后传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">hello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是POST请求，我们希望MVC框架能直接把Post参数变成一个JavaBean后通过方法参数传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/signin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">doSignin</span><span class="params">(SignInBean bean)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了增加灵活性，如果Controller的方法在处理请求时需要访问<code>HttpServletRequest</code>、<code>HttpServletResponse</code>、<code>HttpSession</code>这些实例时，只要方法参数有定义，就可以自动传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/signout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">signout</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是我们在设计MVC框架时，上层代码所需要的一切信息。</p>
<h3 id="设计MVC框架">设计MVC框架</h3>
<p>如何设计一个MVC框架？在上文中，我们已经定义了上层代码编写Controller的一切接口信息，并且并不要求实现特定接口，只需返回<code>ModelAndView</code>对象，该对象包含一个<code>View</code>和一个<code>Model</code>。实际上<code>View</code>就是模板的路径，而<code>Model</code>可以用一个<code>Map&lt;String, Object&gt;</code>表示，因此，<code>ModelAndView</code>定义非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelAndView</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; model;</span><br><span class="line">    String view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较复杂的是我们需要在MVC框架中创建一个接收所有请求的<code>Servlet</code>，通常我们把它命名为<code>DispatcherServlet</code>，它总是映射到<code>/</code>，然后，根据不同的Controller的方法定义的<code>@Get</code>或<code>@Post</code>的Path决定调用哪个方法，最后，获得方法返回的<code>ModelAndView</code>后，渲染模板，写入<code>HttpServletResponse</code>，即完成了整个MVC的处理。</p>
<p>这个MVC的架构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   HTTP Request    ┌─────────────────┐</span><br><span class="line">──────────────────▶│DispatcherServlet│</span><br><span class="line">                   └─────────────────┘</span><br><span class="line">                            │</span><br><span class="line">               ┌────────────┼────────────┐</span><br><span class="line">               ▼            ▼            ▼</span><br><span class="line">         ┌───────────┐┌───────────┐┌───────────┐</span><br><span class="line">         │Controller1││Controller2││Controller3│</span><br><span class="line">         └───────────┘└───────────┘└───────────┘</span><br><span class="line">               │            │            │</span><br><span class="line">               └────────────┼────────────┘</span><br><span class="line">                            ▼</span><br><span class="line">   HTTP Response ┌────────────────────┐</span><br><span class="line">◀────────────────│render(ModelAndView)│</span><br><span class="line">                 └────────────────────┘</span><br></pre></td></tr></table></figure>
<p>其中，<code>DispatcherServlet</code>以及如何渲染均由MVC框架实现，在MVC框架之上只需要编写每一个Controller。</p>
<p>我们来看看如何编写最复杂的<code>DispatcherServlet</code>。首先，我们需要存储请求路径到某个具体方法的映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, GetDispatcher&gt; getMappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, PostDispatcher&gt; postMappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理一个GET请求是通过<code>GetDispatcher</code>对象完成的，它需要如下信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GetDispatcher</span> &#123;</span><br><span class="line">    Object instance; <span class="comment">// Controller实例</span></span><br><span class="line">    Method method; <span class="comment">// Controller方法</span></span><br><span class="line">    String[] parameterNames; <span class="comment">// 方法参数名称</span></span><br><span class="line">    Class&lt;?&gt;[] parameterClasses; <span class="comment">// 方法参数类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了以上信息，就可以定义<code>invoke()</code>来处理真正的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GetDispatcher</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">invoke</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        Object[] arguments = <span class="keyword">new</span> <span class="title class_">Object</span>[parameterClasses.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterClasses.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> parameterNames[i];</span><br><span class="line">            Class&lt;?&gt; parameterClass = parameterClasses[i];</span><br><span class="line">            <span class="keyword">if</span> (parameterClass == HttpServletRequest.class) &#123;</span><br><span class="line">                arguments[i] = request;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterClass == HttpServletResponse.class) &#123;</span><br><span class="line">                arguments[i] = response;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterClass == HttpSession.class) &#123;</span><br><span class="line">                arguments[i] = request.getSession();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterClass == <span class="type">int</span>.class) &#123;</span><br><span class="line">                arguments[i] = Integer.valueOf(getOrDefault(request, parameterName, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterClass == <span class="type">long</span>.class) &#123;</span><br><span class="line">                arguments[i] = Long.valueOf(getOrDefault(request, parameterName, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterClass == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">                arguments[i] = Boolean.valueOf(getOrDefault(request, parameterName, <span class="string">&quot;false&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterClass == String.class) &#123;</span><br><span class="line">                arguments[i] = getOrDefault(request, parameterName, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Missing handler for type: &quot;</span> + parameterClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ModelAndView) <span class="built_in">this</span>.method.invoke(<span class="built_in">this</span>.instance, arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getOrDefault</span><span class="params">(HttpServletRequest request, String name, String defaultValue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> request.getParameter(name);</span><br><span class="line">        <span class="keyword">return</span> s == <span class="literal">null</span> ? defaultValue : s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码比较繁琐，但逻辑非常简单，即通过构造某个方法需要的所有参数列表，使用反射调用该方法后返回结果。</p>
<p>类似的，<code>PostDispatcher</code>需要如下信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostDispatcher</span> &#123;</span><br><span class="line">    Object instance; <span class="comment">// Controller实例</span></span><br><span class="line">    Method method; <span class="comment">// Controller方法</span></span><br><span class="line">    Class&lt;?&gt;[] parameterClasses; <span class="comment">// 方法参数类型</span></span><br><span class="line">    ObjectMapper objectMapper; <span class="comment">// JSON映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和GET请求不同，POST请求严格地来说不能有URL参数，所有数据都应当从Post Body中读取。这里我们为了简化处理，<em>只支持</em>JSON格式的POST请求，这样，把Post数据转化为JavaBean就非常容易。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostDispatcher</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">invoke</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        Object[] arguments = <span class="keyword">new</span> <span class="title class_">Object</span>[parameterClasses.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterClasses.length; i++) &#123;</span><br><span class="line">            Class&lt;?&gt; parameterClass = parameterClasses[i];</span><br><span class="line">            <span class="keyword">if</span> (parameterClass == HttpServletRequest.class) &#123;</span><br><span class="line">                arguments[i] = request;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterClass == HttpServletResponse.class) &#123;</span><br><span class="line">                arguments[i] = response;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterClass == HttpSession.class) &#123;</span><br><span class="line">                arguments[i] = request.getSession();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 读取JSON并解析为JavaBean:</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> request.getReader();</span><br><span class="line">                arguments[i] = <span class="built_in">this</span>.objectMapper.readValue(reader, parameterClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ModelAndView) <span class="built_in">this</span>.method.invoke(instance, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来实现整个<code>DispatcherServlet</code>的处理流程，以<code>doGet()</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> req.getRequestURI().substring(req.getContextPath().length());</span><br><span class="line">        <span class="comment">// 根据路径查找GetDispatcher:</span></span><br><span class="line">        <span class="type">GetDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> <span class="built_in">this</span>.getMappings.get(path);</span><br><span class="line">        <span class="keyword">if</span> (dispatcher == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 未找到返回404:</span></span><br><span class="line">            resp.sendError(<span class="number">404</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用Controller方法获得返回值:</span></span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> dispatcher.invoke(req, resp);</span><br><span class="line">        <span class="comment">// 允许返回null:</span></span><br><span class="line">        <span class="keyword">if</span> (mv == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 允许返回`redirect:`开头的view表示重定向:</span></span><br><span class="line">        <span class="keyword">if</span> (mv.view.startsWith(<span class="string">&quot;redirect:&quot;</span>)) &#123;</span><br><span class="line">            resp.sendRedirect(mv.view.substring(<span class="number">9</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将模板引擎渲染的内容写入响应:</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        <span class="built_in">this</span>.viewEngine.render(mv, pw);</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个小改进：</p>
<ul>
<li>允许Controller方法返回<code>null</code>，表示内部已自行处理完毕；</li>
<li>允许Controller方法返回以<code>redirect:</code>开头的view名称，表示一个重定向。</li>
</ul>
<p>这样使得上层代码编写更灵活。例如，一个显示用户资料的请求可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">profile</span><span class="params">(HttpServletResponse response, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 未登录，跳转到登录页:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;redirect:/signin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!user.isManager()) &#123;</span><br><span class="line">        <span class="comment">// 权限不够，返回403:</span></span><br><span class="line">        response.sendError(<span class="number">403</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;/profile.html&quot;</span>, Map.of(<span class="string">&quot;user&quot;</span>, user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步是在<code>DispatcherServlet</code>的<code>init()</code>方法中初始化所有Get和Post的映射，以及用于渲染的模板引擎：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, GetDispatcher&gt; getMappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, PostDispatcher&gt; postMappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ViewEngine viewEngine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.getMappings = scanGetInControllers();</span><br><span class="line">        <span class="built_in">this</span>.postMappings = scanPostInControllers();</span><br><span class="line">        <span class="built_in">this</span>.viewEngine = <span class="keyword">new</span> <span class="title class_">ViewEngine</span>(getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何扫描所有Controller以获取所有标记有<code>@GetMapping</code>和<code>@PostMapping</code>的方法？当然是使用反射了。虽然代码比较繁琐，但我们相信各位童鞋可以轻松实现。</p>
<p>这样，整个MVC框架就搭建完毕。</p>
<h3 id="实现渲染">实现渲染</h3>
<p>有的童鞋对如何使用模板引擎进行渲染有疑问，即如何实现上述的<code>ViewEngine</code>？其实<code>ViewEngine</code>非常简单，只需要实现一个简单的<code>render()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewEngine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(ModelAndView mv, Writer writer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">view</span> <span class="operator">=</span> mv.view;</span><br><span class="line">        Map&lt;String, Object&gt; model = mv.model;</span><br><span class="line">        <span class="comment">// 根据view找到模板文件:</span></span><br><span class="line">        <span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> getTemplateByPath(view);</span><br><span class="line">        <span class="comment">// 渲染并写入Writer:</span></span><br><span class="line">        template.write(writer, model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java有很多开源的模板引擎，常用的有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/">Thymeleaf</a></li>
<li><a target="_blank" rel="noopener" href="https://freemarker.apache.org/">FreeMarker</a></li>
<li><a target="_blank" rel="noopener" href="https://velocity.apache.org/">Velocity</a></li>
</ul>
<p>他们的用法都大同小异。这里我们推荐一个使用<a target="_blank" rel="noopener" href="https://palletsprojects.com/p/jinja/">Jinja</a>语法的模板引擎<a target="_blank" rel="noopener" href="https://pebbletemplates.io/">Pebble</a>，它的特点是语法简单，支持模板继承，编写出来的模板类似：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  &#123;% for user in users %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; user.url &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; user.username &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即变量用<code>&#123;&#123; xxx &#125;&#125;</code>表示，控制语句用<code>&#123;% xxx %&#125;</code>表示。</p>
<p>使用Pebble渲染只需要如下几行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewEngine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PebbleEngine engine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewEngine</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个ServletLoader用于加载模板:</span></span><br><span class="line">        <span class="type">ServletLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletLoader</span>(servletContext);</span><br><span class="line">        <span class="comment">// 模板编码:</span></span><br><span class="line">        loader.setCharset(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 模板前缀，这里默认模板必须放在`/WEB-INF/templates`目录:</span></span><br><span class="line">        loader.setPrefix(<span class="string">&quot;/WEB-INF/templates&quot;</span>);</span><br><span class="line">        <span class="comment">// 模板后缀:</span></span><br><span class="line">        loader.setSuffix(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Pebble实例:</span></span><br><span class="line">        <span class="built_in">this</span>.engine = <span class="keyword">new</span> <span class="title class_">PebbleEngine</span>.Builder()</span><br><span class="line">            .autoEscaping(<span class="literal">true</span>) <span class="comment">// 默认打开HTML字符转义，防止XSS攻击</span></span><br><span class="line">            .cacheActive(<span class="literal">false</span>) <span class="comment">// 禁用缓存使得每次修改模板可以立刻看到效果</span></span><br><span class="line">            .loader(loader).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(ModelAndView mv, Writer writer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 查找模板:</span></span><br><span class="line">        <span class="type">PebbleTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="built_in">this</span>.engine.getTemplate(mv.view);</span><br><span class="line">        <span class="comment">// 渲染:</span></span><br><span class="line">        template.evaluate(writer, mv.model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们来看看整个工程的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">web-mvc</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── Main.java</span><br><span class="line">        │               ├── bean</span><br><span class="line">        │               │   ├── SignInBean.java</span><br><span class="line">        │               │   └── User.java</span><br><span class="line">        │               ├── controller</span><br><span class="line">        │               │   ├── IndexController.java</span><br><span class="line">        │               │   └── UserController.java</span><br><span class="line">        │               └── framework</span><br><span class="line">        │                   ├── DispatcherServlet.java</span><br><span class="line">        │                   ├── FileServlet.java</span><br><span class="line">        │                   ├── GetMapping.java</span><br><span class="line">        │                   ├── ModelAndView.java</span><br><span class="line">        │                   ├── PostMapping.java</span><br><span class="line">        │                   └── ViewEngine.java</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   ├── templates</span><br><span class="line">            │   │   ├── _base.html</span><br><span class="line">            │   │   ├── hello.html</span><br><span class="line">            │   │   ├── index.html</span><br><span class="line">            │   │   ├── profile.html</span><br><span class="line">            │   │   └── signin.html</span><br><span class="line">            │   └── web.xml</span><br><span class="line">            └── static</span><br><span class="line">                ├── css</span><br><span class="line">                │   └── bootstrap.css</span><br><span class="line">                └── js</span><br><span class="line">                    ├── bootstrap.js</span><br><span class="line">                    └── jquery.js</span><br></pre></td></tr></table></figure>
<p>其中，<code>framework</code>包是MVC的框架，完全可以单独编译后作为一个Maven依赖引入，<code>controller</code>包才是我们需要编写的业务逻辑。</p>
<p>我们还硬性规定模板必须放在<code>webapp/WEB-INF/templates</code>目录下，静态文件必须放在<code>webapp/static</code>目录下，因此，为了便于开发，我们还顺带实现一个<code>FileServlet</code>来处理静态文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123; &quot;/favicon.ico&quot;, &quot;/static/*&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 读取当前请求路径:</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">ctx</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">        <span class="comment">// RequestURI包含ContextPath,需要去掉:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> req.getRequestURI().substring(ctx.getContextPath().length());</span><br><span class="line">        <span class="comment">// 获取真实文件路径:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> ctx.getRealPath(urlPath);</span><br><span class="line">        <span class="keyword">if</span> (filepath == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法获取到路径:</span></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(filepath);</span><br><span class="line">        <span class="keyword">if</span> (!path.toFile().isFile()) &#123;</span><br><span class="line">            <span class="comment">// 文件不存在:</span></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据文件名猜测Content-Type:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mime</span> <span class="operator">=</span> Files.probeContentType(path);</span><br><span class="line">        <span class="keyword">if</span> (mime == <span class="literal">null</span>) &#123;</span><br><span class="line">            mime = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resp.setContentType(mime);</span><br><span class="line">        <span class="comment">// 读取文件并写入Response:</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filepath))) &#123;</span><br><span class="line">            input.transferTo(output);</span><br><span class="line">        &#125;</span><br><span class="line">        output.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，在浏览器中输入URL<code>http://localhost:8080/hello?name=Bob</code>可以看到如下页面：</p>
<p><img src="https://liaoxuefeng.com/books/java/web/mvc-adv/mvc.png" alt="mvc"></p>
<p>为了把方法参数的名称编译到class文件中，以便处理<code>@GetMapping</code>时使用，我们需要打开编译器的一个参数，在Eclipse中勾选<code>Preferences</code>-<code>Java</code>-<code>Compiler</code>-<code>Store information about method parameters (usable via reflection)</code>；在Idea中选择<code>Preferences</code>-<code>Build, Execution, Deployment</code>-<code>Compiler</code>-<code>Java Compiler</code>-<code>Additional command line parameters</code>，填入<code>-parameters</code>；在Maven的<code>pom.xml</code>添加一段配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">arg</span>&gt;</span>-parameters<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有些用过Spring MVC的童鞋会发现，本节实现的这个MVC框架，上层代码使用的公共类如<code>GetMapping</code>、<code>PostMapping</code>和<code>ModelAndView</code>都和Spring MVC非常类似。实际上，我们这个MVC框架主要参考就是Spring MVC，通过实现一个“简化版”MVC，可以掌握Java Web MVC开发的核心思想与原理，对将来直接使用Spring MVC是非常有帮助的。</p>
<h3 id="练习-8">练习</h3>
<p>实现一个MVC框架。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/mvc-adv/web-mvc.zip">下载练习</a></p>
<h3 id="小结-9">小结</h3>
<p>一个MVC框架是基于Servlet基础抽象出更高级的接口，使得上层基于MVC框架的开发可以不涉及Servlet相关的<code>HttpServletRequest</code>等接口，处理多个请求更加灵活，并且可以使用任意模板引擎，不必使用JSP。</p>
<p>在一个比较复杂的Web应用程序中，通常都有很多URL映射，对应的，也会有多个Servlet来处理URL。</p>
<p>我们考察这样一个论坛应用程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">            ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">               /             ┌──────────────┐</span><br><span class="line">            │ ┌─────────────▶│ IndexServlet │ │</span><br><span class="line">              │              └──────────────┘</span><br><span class="line">            │ │/signin       ┌──────────────┐ │</span><br><span class="line">              ├─────────────▶│SignInServlet │</span><br><span class="line">            │ │              └──────────────┘ │</span><br><span class="line">              │/signout      ┌──────────────┐</span><br><span class="line">┌───────┐   │ ├─────────────▶│SignOutServlet│ │</span><br><span class="line">│Browser├─────┤              └──────────────┘</span><br><span class="line">└───────┘   │ │/user/profile ┌──────────────┐ │</span><br><span class="line">              ├─────────────▶│ProfileServlet│</span><br><span class="line">            │ │              └──────────────┘ │</span><br><span class="line">              │/user/post    ┌──────────────┐</span><br><span class="line">            │ ├─────────────▶│ PostServlet  │ │</span><br><span class="line">              │              └──────────────┘</span><br><span class="line">            │ │/user/reply   ┌──────────────┐ │</span><br><span class="line">              └─────────────▶│ ReplyServlet │</span><br><span class="line">            │                └──────────────┘ │</span><br><span class="line">             ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br></pre></td></tr></table></figure>
<p>各个Servlet设计功能如下：</p>
<ul>
<li>IndexServlet：浏览帖子；</li>
<li>SignInServlet：登录；</li>
<li>SignOutServlet：登出；</li>
<li>ProfileServlet：修改用户资料；</li>
<li>PostServlet：发帖；</li>
<li>ReplyServlet：回复。</li>
</ul>
<p>其中，ProfileServlet、PostServlet和ReplyServlet都需要用户登录后才能操作，否则，应当直接跳转到登录页面。</p>
<p>我们可以直接把判断登录的逻辑写到这3个Servlet中，但是，同样的逻辑重复3次没有必要，并且，如果后续继续加Servlet并且也需要验证登录时，还需要继续重复这个检查逻辑。</p>
<p>为了把一些公用逻辑从各个Servlet中抽离出来，JavaEE的Servlet规范还提供了一种Filter组件，即过滤器，它的作用是，在HTTP请求到达Servlet之前，可以被一个或多个Filter预处理，类似打印日志、登录检查等逻辑，完全可以放到Filter中。</p>
<p>例如，我们编写一个最简单的EncodingFilter，它强制把输入和输出的编码设置为UTF-8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EncodingFilter:doFilter&quot;</span>);</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写Filter时，必须实现<code>Filter</code>接口，在<code>doFilter()</code>方法内部，要继续处理请求，必须调用<code>chain.doFilter()</code>。最后，用<code>@WebFilter</code>注解标注该Filter需要过滤的URL。这里的<code>/*</code>表示所有路径。</p>
<p>添加了Filter之后，整个请求的处理架构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">            ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">                                   /             ┌──────────────┐</span><br><span class="line">            │                     ┌─────────────▶│ IndexServlet │ │</span><br><span class="line">                                  │              └──────────────┘</span><br><span class="line">            │                     │/signin       ┌──────────────┐ │</span><br><span class="line">                                  ├─────────────▶│SignInServlet │</span><br><span class="line">            │                     │              └──────────────┘ │</span><br><span class="line">                                  │/signout      ┌──────────────┐</span><br><span class="line">┌───────┐   │   ┌──────────────┐  ├─────────────▶│SignOutServlet│ │</span><br><span class="line">│Browser│──────▶│EncodingFilter├──┤              └──────────────┘</span><br><span class="line">└───────┘   │   └──────────────┘  │/user/profile ┌──────────────┐ │</span><br><span class="line">                                  ├─────────────▶│ProfileServlet│</span><br><span class="line">            │                     │              └──────────────┘ │</span><br><span class="line">                                  │/user/post    ┌──────────────┐</span><br><span class="line">            │                     ├─────────────▶│ PostServlet  │ │</span><br><span class="line">                                  │              └──────────────┘</span><br><span class="line">            │                     │/user/reply   ┌──────────────┐ │</span><br><span class="line">                                  └─────────────▶│ ReplyServlet │</span><br><span class="line">            │                                    └──────────────┘ │</span><br><span class="line">             ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br></pre></td></tr></table></figure>
<p>还可以继续添加其他Filter，例如LogFilter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LogFilter: process &quot;</span> + ((HttpServletRequest) request).getRequestURI());</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个Filter会组成一个链，每个请求都被链上的Filter依次处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                        ┌────────┐</span><br><span class="line">                                     ┌─▶│ServletA│</span><br><span class="line">                                     │  └────────┘</span><br><span class="line">    ┌──────────────┐    ┌─────────┐  │  ┌────────┐</span><br><span class="line">───▶│EncodingFilter│───▶│LogFilter│──┼─▶│ServletB│</span><br><span class="line">    └──────────────┘    └─────────┘  │  └────────┘</span><br><span class="line">                                     │  ┌────────┐</span><br><span class="line">                                     └─▶│ServletC│</span><br><span class="line">                                        └────────┘</span><br></pre></td></tr></table></figure>
<p>有些细心的童鞋会问，有多个Filter的时候，Filter的顺序如何指定？多个Filter按不同顺序处理会造成处理结果不同吗？</p>
<p>答案是Filter的顺序确实对处理的结果有影响。但遗憾的是，Servlet规范并没有对<code>@WebFilter</code>注解标注的Filter规定顺序。如果一定要给每个Filter指定顺序，就必须在<code>web.xml</code>文件中对这些Filter再配置一遍。</p>
<p>注意到上述两个Filter的过滤路径都是<code>/*</code>，即它们会对所有请求进行过滤。也可以编写只对特定路径进行过滤的Filter，例如<code>AuthFilter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/user/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AuthFilter: check authentication&quot;</span>);</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">        <span class="keyword">if</span> (req.getSession().getAttribute(<span class="string">&quot;user&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 未登录，自动跳转到登录页:</span></span><br><span class="line">            System.out.println(<span class="string">&quot;AuthFilter: not signin!&quot;</span>);</span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;/signin&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已登录，继续处理:</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>AuthFilter</code>只过滤以<code>/user/</code>开头的路径，因此：</p>
<ul>
<li>如果一个请求路径类似<code>/user/profile</code>，那么它会被上述3个Filter依次处理；</li>
<li>如果一个请求路径类似<code>/test</code>，那么它会被上述2个Filter依次处理（不会被AuthFilter处理）。</li>
</ul>
<p>再注意观察<code>AuthFilter</code>，当用户没有登录时，在<code>AuthFilter</code>内部，直接调用<code>resp.sendRedirect()</code>发送重定向，且没有调用<code>chain.doFilter()</code>，因此，当用户没有登录时，请求到达<code>AuthFilter</code>后，不再继续处理，即后续的Filter和任何Servlet都没有机会处理该请求了。</p>
<p>可见，Filter可以有针对性地拦截或者放行HTTP请求。</p>
<p>如果一个Filter在当前请求中生效，但什么都没有做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，用户将看到一个空白页，因为请求没有继续处理，默认响应是200+空白输出。</p>
<p>注意</p>
<p>如果Filter要使请求继续被处理，就一定要调用chain.doFilter()！</p>
<p>如果我们使用上一节介绍的MVC模式，即一个统一的<code>DispatcherServlet</code>入口，加上多个Controller，这种模式下Filter仍然是正常工作的。例如，一个处理<code>/user/*</code>的Filter实际上作用于那些处理<code>/user/</code>开头的Controller方法之前。</p>
<h3 id="小结-10">小结</h3>
<p>Filter是一种对HTTP请求进行预处理的组件，它可以构成一个处理链，使得公共处理代码能集中到一起；</p>
<p>Filter适用于日志、登录检查、全局设置等；</p>
<p>设计合理的URL映射可以让Filter链更清晰。</p>
<p>Filter可以对请求进行预处理，因此，我们可以把很多公共预处理逻辑放到Filter中完成。</p>
<p>考察这样一种需求：我们在Web应用中经常需要处理用户上传文件，例如，一个UploadServlet可以简单地编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/upload/file&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 读取Request Body:</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> req.getInputStream();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> input.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            output.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 写入文件:</span></span><br><span class="line">        <span class="comment">// 显示上传结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uploadedText</span> <span class="operator">=</span> output.toString(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;h1&gt;Uploaded:&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;pre&gt;&lt;code&gt;&quot;</span>);</span><br><span class="line">        pw.write(uploadedText);</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;/code&gt;&lt;/pre&gt;&quot;</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是要保证文件上传的完整性怎么办？在<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/security/hash/index.html">哈希算法</a>一节中，我们知道，如果在上传文件的同时，把文件的哈希也传过来，服务器端做一个验证，就可以确保用户上传的文件一定是完整的。</p>
<p>这个验证逻辑非常适合写在<code>ValidateUploadFilter</code>中，因为它可以复用。</p>
<p>我们先写一个简单的版本，快速实现<code>ValidateUploadFilter</code>的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/upload/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateUploadFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">        <span class="comment">// 获取客户端传入的签名方法和签名:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">digest</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;Signature-Method&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;Signature&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (digest == <span class="literal">null</span> || digest.isEmpty() || signature == <span class="literal">null</span> || signature.isEmpty()) &#123;</span><br><span class="line">            sendErrorPage(resp, <span class="string">&quot;Missing signature.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取Request的Body并验证签名:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> getMessageDigest(digest);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DigestInputStream</span>(request.getInputStream(), md);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> input.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">actual</span> <span class="operator">=</span> toHexString(md.digest());</span><br><span class="line">        <span class="keyword">if</span> (!signature.equals(actual)) &#123;</span><br><span class="line">            sendErrorPage(resp, <span class="string">&quot;Invalid signature.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证成功后继续处理:</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将byte[]转换为hex string:</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">toHexString</span><span class="params">(<span class="type">byte</span>[] digest)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : digest) &#123;</span><br><span class="line">            sb.append(String.format(<span class="string">&quot;%02x&quot;</span>, b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称创建MessageDigest:</span></span><br><span class="line">    <span class="keyword">private</span> MessageDigest <span class="title function_">getMessageDigest</span><span class="params">(String name)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDigest.getInstance(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送一个错误响应:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendErrorPage</span><span class="params">(HttpServletResponse resp, String errorMessage)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;&quot;</span>);</span><br><span class="line">        pw.write(errorMessage);</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>ValidateUploadFilter</code>的逻辑似乎没有问题，我们可以用curl命令测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost:8080/upload/file -v -d &#x27;test-data&#x27; \</span><br><span class="line">  -H &#x27;Signature-Method: SHA-1&#x27; \</span><br><span class="line">  -H &#x27;Signature: 7115e9890f5b5cc6914bdfa3b7c011db1cdafedb&#x27; \</span><br><span class="line">  -H &#x27;Content-Type: application/octet-stream&#x27;</span><br><span class="line">*   Trying ::1...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to localhost (::1) port 8080 (#0)</span><br><span class="line">&gt; POST /upload/file HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Signature-Method: SHA-1</span><br><span class="line">&gt; Signature: 7115e9890f5b5cc6914bdfa3b7c011db1cdafedb</span><br><span class="line">&gt; Content-Type: application/octet-stream</span><br><span class="line">&gt; Content-Length: 9</span><br><span class="line">&gt; </span><br><span class="line">* upload completely sent off: 9 out of 9 bytes</span><br><span class="line">&lt; HTTP/1.1 200 </span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Date: Thu, 30 Jan 2020 13:56:39 GMT</span><br><span class="line">&lt; </span><br><span class="line">* Connection #0 to host localhost left intact</span><br><span class="line">&lt;h1&gt;Uploaded:&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">* Closing connection 0</span><br></pre></td></tr></table></figure>
<p><code>ValidateUploadFilter</code>对签名进行验证的逻辑是没有问题的，但是，细心的童鞋注意到，<code>UploadServlet</code>并未读取到任何数据！</p>
<p>这里的原因是对<code>HttpServletRequest</code>进行读取时，只能读取一次。如果Filter调用<code>getInputStream()</code>读取了一次数据，后续Servlet处理时，再次读取，将无法读到任何数据。怎么办？</p>
<p>这个时候，我们需要一个“伪造”的<code>HttpServletRequest</code>，具体做法是使用<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/structural/proxy/index.html">代理模式</a>，对<code>getInputStream()</code>和<code>getReader()</code>返回一个新的流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReReadableHttpServletRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] body;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">open</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReReadableHttpServletRequest</span><span class="params">(HttpServletRequest request, <span class="type">byte</span>[] body)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">        <span class="built_in">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回InputStream:</span></span><br><span class="line">    <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (open) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot re-open input stream!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        open = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletInputStream</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> offset &gt;= body.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener listener)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">if</span> (offset &gt;= body.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> body[offset] &amp; <span class="number">0xff</span>;</span><br><span class="line">                offset++;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Reader:</span></span><br><span class="line">    <span class="keyword">public</span> BufferedReader <span class="title function_">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (open) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot re-open reader!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        open = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意观察<code>ReReadableHttpServletRequest</code>的构造方法，它保存了<code>ValidateUploadFilter</code>读取的<code>byte[]</code>内容，并在调用<code>getInputStream()</code>时通过<code>byte[]</code>构造了一个新的<code>ServletInputStream</code>。</p>
<p>然后，我们在<code>ValidateUploadFilter</code>中，把<code>doFilter()</code>调用时传给下一个处理者的<code>HttpServletRequest</code>替换为我们自己“伪造”的<code>ReReadableHttpServletRequest</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    ...</span><br><span class="line">    chain.doFilter(<span class="keyword">new</span> <span class="title class_">ReReadableHttpServletRequest</span>(req, output.toByteArray()), response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再注意到我们编写<code>ReReadableHttpServletRequest</code>时，是从<code>HttpServletRequestWrapper</code>继承，而不是直接实现<code>HttpServletRequest</code>接口。这是因为，Servlet的每个新版本都会对接口增加一些新方法，从<code>HttpServletRequestWrapper</code>继承可以确保新方法被正确地覆写了，因为<code>HttpServletRequestWrapper</code>是由Servlet的jar包提供的，目的就是为了让我们方便地实现对<code>HttpServletRequest</code>接口的代理。</p>
<p>我们总结一下对<code>HttpServletRequest</code>接口进行代理的步骤：</p>
<ol>
<li>从<code>HttpServletRequestWrapper</code>继承一个<code>XxxHttpServletRequest</code>，需要传入原始的<code>HttpServletRequest</code>实例；</li>
<li>覆写某些方法，使得新的<code>XxxHttpServletRequest</code>实例看上去“改变”了原始的<code>HttpServletRequest</code>实例；</li>
<li>在<code>doFilter()</code>中传入新的<code>XxxHttpServletRequest</code>实例。</li>
</ol>
<p>虽然整个Filter的代码比较复杂，但它的好处在于：这个Filter在整个处理链中实现了灵活的“可插拔”特性，即是否启用对Web应用程序的其他组件（Filter、Servlet）完全没有影响。</p>
<h3 id="练习-9">练习</h3>
<p>使用Filter修改<code>HttpServletRequest</code>请求。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/filter/request/web-filter-signature.zip">下载练习</a></p>
<h3 id="小结-11">小结</h3>
<p>借助<code>HttpServletRequestWrapper</code>，我们可以在Filter中实现对原始<code>HttpServletRequest</code>的修改。</p>
<p>既然我们能通过Filter修改<code>HttpServletRequest</code>，自然也能修改<code>HttpServletResponse</code>，因为这两者都是接口。</p>
<p>我们来看一下在什么情况下我们需要修改<code>HttpServletResponse</code>。</p>
<p>假设我们编写了一个Servlet，但由于业务逻辑比较复杂，处理该请求需要耗费很长的时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/slow/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟耗时1秒:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好消息是每次返回的响应内容是固定的，因此，如果我们能使用缓存将结果缓存起来，就可以大大提高Web应用程序的运行效率。</p>
<p>缓存逻辑最好不要在Servlet内部实现，因为我们希望能复用缓存逻辑，所以，编写一个<code>CacheFilter</code>最合适：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/slow/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">// Path到byte[]的缓存:</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, <span class="type">byte</span>[]&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">        <span class="comment">// 获取Path:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">        <span class="comment">// 获取缓存内容:</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="built_in">this</span>.cache.get(url);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;X-Cache-Hit&quot;</span>, data == <span class="literal">null</span> ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓存未找到,构造一个伪造的Response:</span></span><br><span class="line">            <span class="type">CachedHttpServletResponse</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachedHttpServletResponse</span>(resp);</span><br><span class="line">            <span class="comment">// 让下游组件写入数据到伪造的Response:</span></span><br><span class="line">            chain.doFilter(request, wrapper);</span><br><span class="line">            <span class="comment">// 从伪造的Response中读取写入的内容并放入缓存:</span></span><br><span class="line">            data = wrapper.getContent();</span><br><span class="line">            cache.put(url, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入到原始的Response:</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">        output.write(data);</span><br><span class="line">        output.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现缓存的关键在于，调用<code>doFilter()</code>时，我们不能传入原始的<code>HttpServletResponse</code>，因为这样就会写入Socket，我们也就无法获取下游组件写入的内容。如果我们传入的是“伪造”的<code>HttpServletResponse</code>，让下游组件写入到我们预设的<code>ByteArrayOutputStream</code>，我们就“截获”了下游组件写入的内容，于是，就可以把内容缓存起来，再通过原始的<code>HttpServletResponse</code>实例写入到网络。</p>
<p>这个<code>CachedHttpServletResponse</code>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedHttpServletResponse</span> <span class="keyword">extends</span> <span class="title class_">HttpServletResponseWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">open</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CachedHttpServletResponse</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Writer:</span></span><br><span class="line">    <span class="keyword">public</span> PrintWriter <span class="title function_">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (open) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot re-open writer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        open = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(output, <span class="literal">false</span>, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取OutputStream:</span></span><br><span class="line">    <span class="keyword">public</span> ServletOutputStream <span class="title function_">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (open) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot re-open output stream!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        open = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletOutputStream</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWriteListener</span><span class="params">(WriteListener listener)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实际写入ByteArrayOutputStream:</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                output.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回写入的byte[]:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] getContent() &#123;</span><br><span class="line">        <span class="keyword">return</span> output.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，如果我们想要修改响应，就可以通过<code>HttpServletResponseWrapper</code>构造一个“伪造”的<code>HttpServletResponse</code>，这样就能拦截到写入的数据。</p>
<p>修改响应时，最后不要忘记把数据写入原始的<code>HttpServletResponse</code>实例。</p>
<p>这个<code>CacheFilter</code>同样是一个“可插拔”组件，它是否启用不影响Web应用程序的其他组件（Filter、Servlet）。</p>
<h3 id="练习-10">练习</h3>
<p>通过Filter修改响应。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/filter/response/web-filter-cache.zip">下载练习</a></p>
<h3 id="小结-12">小结</h3>
<p>借助<code>HttpServletResponseWrapper</code>，我们可以在Filter中实现对原始<code>HttpServletResponse</code>的修改。</p>
<h2 id="使用Listener">使用Listener</h2>
<p>除了Servlet和Filter外，JavaEE的Servlet规范还提供了第三种组件：Listener。</p>
<p>Listener顾名思义就是监听器，有好几种Listener，其中最常用的是<code>ServletContextListener</code>，我们编写一个实现了<code>ServletContextListener</code>接口的类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="comment">// 在此初始化WebApp,例如打开数据库连接池等:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebApp initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此清理WebApp,例如关闭数据库连接池等:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebApp destroyed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何标注为<code>@WebListener</code>，且实现了特定接口的类会被Web服务器自动初始化。上述<code>AppListener</code>实现了<code>ServletContextListener</code>接口，它会在整个Web应用程序初始化完成后，以及Web应用程序关闭后获得回调通知。我们可以把初始化数据库连接池等工作放到<code>contextInitialized()</code>回调方法中，把清理资源的工作放到<code>contextDestroyed()</code>回调方法中，因为Web服务器保证在<code>contextInitialized()</code>执行后，才会接受用户的HTTP请求。</p>
<p>很多第三方Web框架都会通过一个<code>ServletContextListener</code>接口初始化自己。</p>
<p>除了<code>ServletContextListener</code>外，还有几种Listener：</p>
<ul>
<li>HttpSessionListener：监听HttpSession的创建和销毁事件；</li>
<li>ServletRequestListener：监听ServletRequest请求的创建和销毁事件；</li>
<li>ServletRequestAttributeListener：监听ServletRequest请求的属性变化事件（即调用<code>ServletRequest.setAttribute()</code>方法）；</li>
<li>ServletContextAttributeListener：监听ServletContext的属性变化事件（即调用<code>ServletContext.setAttribute()</code>方法）；</li>
</ul>
<h3 id="ServletContext">ServletContext</h3>
<p>一个Web服务器可以运行一个或多个WebApp，对于每个WebApp，Web服务器都会为其创建一个全局唯一的<code>ServletContext</code>实例，我们在<code>AppListener</code>里面编写的两个回调方法实际上对应的就是<code>ServletContext</code>实例的创建和销毁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;WebApp initialized: ServletContext = &quot;</span> + sce.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServletRequest</code>、<code>HttpSession</code>等很多对象也提供<code>getServletContext()</code>方法获取到同一个<code>ServletContext</code>实例。<code>ServletContext</code>实例最大的作用就是设置和共享全局信息。</p>
<p>此外，<code>ServletContext</code>还提供了动态添加Servlet、Filter、Listener等功能，它允许应用程序在运行期间动态添加一个组件，虽然这个功能不是很常用。</p>
<h3 id="练习-11">练习</h3>
<p>使用Listener监听WebApp。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/listener/web-listener.zip">下载练习</a></p>
<h3 id="小结-13">小结</h3>
<p>通过Listener我们可以监听Web应用程序的生命周期，获取<code>HttpSession</code>等创建和销毁的事件；</p>
<p><code>ServletContext</code>是一个WebApp运行期的全局唯一实例，可用于设置和共享配置信息。</p>
<hr>
<hr>
<h2 id="部署">部署</h2>
<p>对一个Web应用程序来说，除了Servlet、Filter这些逻辑组件，还需要JSP这样的视图文件，外加一堆静态资源文件，如CSS、JS等。</p>
<p>合理组织文件结构非常重要。我们以一个具体的Web应用程序为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">webapp</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── Main.java</span><br><span class="line">        │               ├── filter</span><br><span class="line">        │               │   └── EncodingFilter.java</span><br><span class="line">        │               └── servlet</span><br><span class="line">        │                   ├── FileServlet.java</span><br><span class="line">        │                   └── HelloServlet.java</span><br><span class="line">        ├── resources</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   └── web.xml</span><br><span class="line">            ├── favicon.ico</span><br><span class="line">            └── static</span><br><span class="line">                └── bootstrap.css</span><br></pre></td></tr></table></figure>
<p>我们把所有的静态资源文件放入<code>/static/</code>目录，在开发阶段，有些Web服务器会自动为我们加一个专门负责处理静态文件的Servlet，但如果<code>IndexServlet</code>映射路径为<code>/</code>，会屏蔽掉处理静态文件的Servlet映射。因此，我们需要自己编写一个处理静态文件的<code>FileServlet</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/static/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">ctx</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">        <span class="comment">// RequestURI包含ContextPath,需要去掉:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> req.getRequestURI().substring(ctx.getContextPath().length());</span><br><span class="line">        <span class="comment">// 获取真实文件路径:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> ctx.getRealPath(urlPath);</span><br><span class="line">        <span class="keyword">if</span> (filepath == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法获取到路径:</span></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(filepath);</span><br><span class="line">        <span class="keyword">if</span> (!path.toFile().isFile()) &#123;</span><br><span class="line">            <span class="comment">// 文件不存在:</span></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据文件名猜测Content-Type:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mime</span> <span class="operator">=</span> Files.probeContentType(path);</span><br><span class="line">        <span class="keyword">if</span> (mime == <span class="literal">null</span>) &#123;</span><br><span class="line">            mime = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resp.setContentType(mime);</span><br><span class="line">        <span class="comment">// 读取文件并写入Response:</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filepath))) &#123;</span><br><span class="line">            input.transferTo(output);</span><br><span class="line">        &#125;</span><br><span class="line">        output.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，在开发阶段，我们就可以方便地高效开发。</p>
<p>类似Tomcat这样的Web服务器，运行的Web应用程序通常都是业务系统，因此，这类服务器也被称为应用服务器。应用服务器并不擅长处理静态文件，也不适合直接暴露给用户。通常，我们在生产环境部署时，总是使用类似Nginx这样的服务器充当反向代理和静态服务器，只有动态请求才会放行给应用服务器，所以，部署架构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">             ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line"></span><br><span class="line">             │  /static/*            │</span><br><span class="line">┌───────┐      ┌──────────▶ file</span><br><span class="line">│Browser├────┼─┤                     │    ┌ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">└───────┘      │/          proxy_pass</span><br><span class="line">             │ └─────────────────────┼───▶│  Web Server │</span><br><span class="line">                       Nginx</span><br><span class="line">             └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘    └ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>实现上述功能的Nginx配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    server_name www.local.liaoxuefeng.com;</span><br><span class="line"></span><br><span class="line">    # 静态文件根目录:</span><br><span class="line">    root /path/to/src/main/webapp;</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/webapp_access_log;</span><br><span class="line">    error_log  /var/log/nginx/webapp_error_log;</span><br><span class="line"></span><br><span class="line">    # 处理静态文件请求:</span><br><span class="line">    location /static &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 处理静态文件请求:</span><br><span class="line">    location /favicon.ico &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 不允许请求/WEB-INF:</span><br><span class="line">    location /WEB-INF &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 其他请求转发给Tomcat:</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass       http://127.0.0.1:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Nginx配合Tomcat服务器，可以充分发挥Nginx作为网关的优势，既可以高效处理静态文件，也可以把https、防火墙、限速、反爬虫等功能放到Nginx中，使得我们自己的WebApp能专注于业务逻辑。</p>
<h3 id="练习-12">练习</h3>
<p>使用Nginx+Tomcat部署一个Java Webapp。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/web/deploy/web-servlet-deploy.zip">下载练习</a></p>
<h3 id="小结-14">小结</h3>
<p>部署Web应用程序时，要设计合理的目录结构，同时考虑开发模式需要便捷性，生产模式需要高性能。</p>
<hr>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/24/java/JAVA-Web%E5%BC%80%E5%8F%91/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/24/java/JAVA-Spring%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/"
                            aria-label=": JAVA-Spring主从数据库的配置和动态数据源切换原理"
                        >
                            JAVA-Spring主从数据库的配置和动态数据源切换原理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-24T18:44:46+08:00">
	
		    2025 年 5 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在大型应用程序中，配置主从数据库并使用读写分离是常见的设计模式。在Spring应用程序中，要实现读写分离，最好不要对现有代码进行改动，而是在底层透明地支持。</p>
<p>Spring内置了一个<code>AbstractRoutingDataSource</code>，它可以把多个数据源配置成一个Map，然后，根据不同的key返回不同的数据源。因为<code>AbstractRoutingDataSource</code>也是一个DataSource接口，因此，应用程序可以先设置好key， 访问数据库的代码就可以从<code>AbstractRoutingDataSource</code>拿到对应的一个真实的数据源，从而访问指定的数据库。它的结构看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">   │        controller         │</span><br><span class="line">   │  set routing-key = &quot;xxx&quot;  │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">                 ▼</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">   │        logic code         │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">                 ▼</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">   │    routing datasource     │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">       ┌─────────┴─────────┐</span><br><span class="line">       │                   │</span><br><span class="line">       ▼                   ▼</span><br><span class="line">┌─────────────┐     ┌─────────────┐</span><br><span class="line">│ read-write  │     │  read-only  │</span><br><span class="line">│ datasource  │     │ datasource  │</span><br><span class="line">└─────────────┘     └─────────────┘</span><br><span class="line">       │                   │</span><br><span class="line">       ▼                   ▼</span><br><span class="line">┌─────────────┐     ┌─────────────┐</span><br><span class="line">│  Master DB  │────▶│  Slave DB   │</span><br><span class="line">└─────────────┘     └─────────────┘</span><br></pre></td></tr></table></figure>
<h3 id="第一步：配置多数据源">第一步：配置多数据源</h3>
<p>首先，我们在SpringBoot中配置两个数据源，其中第二个数据源是<code>ro-datasource</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">rw</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">rw_password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">HikariCP</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="string">...</span></span><br><span class="line">  <span class="attr">ro-datasource:</span></span><br><span class="line">    <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ro</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ro_password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">HikariCP</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>在开发环境下，没有必要配置主从数据库。只需要给数据库设置两个用户，一个<code>rw</code>具有读写权限，一个<code>ro</code>只有SELECT权限，这样就模拟了生产环境下对主从数据库的读写分离。</p>
<p>在SpringBoot的配置代码中，我们初始化两个数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringBootApplication</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Master data source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;masterDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">masterDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">       logger.info(<span class="string">&quot;create master datasource...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Slave (read only) data source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;slaveDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.ro-datasource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">slaveDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;create slave datasource...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二步：编写RoutingDataSource">第二步：编写RoutingDataSource</h3>
<p>然后，我们用Spring内置的RoutingDataSource，把两个真实的数据源代理为一个动态数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;masterDataSource&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这个<code>RoutingDataSource</code>，需要在SpringBoot中配置好并设置为主数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringBootApplication</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    DataSource <span class="title function_">primaryDataSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource,</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;create routing datasource...&quot;</span>);</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;masterDataSource&quot;</span>, masterDataSource);</span><br><span class="line">        map.put(<span class="string">&quot;slaveDataSource&quot;</span>, slaveDataSource);</span><br><span class="line">        <span class="type">RoutingDataSource</span> <span class="variable">routing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSource</span>();</span><br><span class="line">        routing.setTargetDataSources(map);</span><br><span class="line">        routing.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">        <span class="keyword">return</span> routing;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，RoutingDataSource配置好了，但是，路由的选择是写死的，即永远返回<code>&quot;masterDataSource&quot;</code>，</p>
<p>现在问题来了：如何存储动态选择的key以及在哪设置key？</p>
<p>在Servlet的线程模型中，使用ThreadLocal存储key最合适，因此，我们编写一个RoutingDataSourceContext，来设置并动态存储key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSourceContext</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// holds data source key in thread local:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocalDataSourceKey = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDataSourceRoutingKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> threadLocalDataSourceKey.get();</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="string">&quot;masterDataSource&quot;</span> : key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoutingDataSourceContext</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        threadLocalDataSourceKey.set(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocalDataSourceKey.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，修改RoutingDataSource，获取key的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RoutingDataSourceContext.getDataSourceRoutingKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在某个地方，例如一个Controller的方法内部，就可以动态设置DataSource的Key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Get(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;slaveDataSource&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RoutingDataSourceContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSourceContext</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;html... www.liaoxuefeng.com&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，我们已经成功实现了数据库的动态路由访问。</p>
<p>这个方法是可行的，但是，需要读从数据库的地方，就需要加上一大段<code>try (RoutingDataSourceContext ctx = ...) &#123;&#125;</code>代码，使用起来十分不便。有没有方法可以简化呢？</p>
<p>有！</p>
<p>我们仔细想想，Spring提供的声明式事务管理，就只需要一个<code>@Transactional()</code>注解，放在某个Java方法上，这个方法就自动具有了事务。</p>
<p>我们也可以编写一个类似的<code>@RoutingWith(&quot;slaveDataSource&quot;)</code>注解，放到某个Controller的方法上，这个方法内部就自动选择了对应的数据源。代码看起来应该像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Get(&quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@RoutingWith(&quot;slaveDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;html... www.liaoxuefeng.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，完全不修改应用程序的逻辑，只在必要的地方加上注解，自动实现动态数据源切换，这个方法是最简单的。</p>
<p>想要在应用程序中少写代码，我们就得多做一点底层工作：必须使用类似Spring实现声明式事务的机制，即用AOP实现动态数据源切换。</p>
<p>实现这个功能也非常简单，编写一个<code>RoutingAspect</code>，利用AspectJ实现一个<code>Around</code>拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(routingWith)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">routingWithDataSource</span><span class="params">(ProceedingJoinPoint joinPoint, RoutingWith routingWith)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> routingWith.value();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RoutingDataSourceContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSourceContext</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意方法的第二个参数<code>RoutingWith</code>是Spring传入的注解实例，我们根据注解的<code>value()</code>获取配置的key。编译前需要添加一个Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到此为止，我们就实现了用注解动态选择数据源的功能。最后一步重构是用字符串常量替换散落在各处的<code>&quot;masterDataSource&quot;</code>和<code>&quot;slaveDataSource&quot;</code>。</p>
<h3 id="使用限制">使用限制</h3>
<p>受Servlet线程模型的局限，动态数据源不能在一个请求内设定后再修改，也就是<code>@RoutingWith</code>不能嵌套。此外，<code>@RoutingWith</code>和<code>@Transactional</code>混用时，要设定AOP的优先级。</p>
<p>本文代码需要SpringBoot支持，JDK 1.8编译并打开<code>-parameters</code>编译参数。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/24/java/JAVA-Spring%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/24/java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
                            aria-label=": JAVA-设计模式-行为型模式"
                        >
                            JAVA-设计模式-行为型模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-24T18:29:15+08:00">
	
		    2025 年 5 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">编程语言</a>, <a class="category-link" href="">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p>
<p>行为型模式有：</p>
<ul>
<li>责任链</li>
<li>命令</li>
<li>解释器</li>
<li>迭代器</li>
<li>中介</li>
<li>备忘录</li>
<li>观察者</li>
<li>状态</li>
<li>策略</li>
<li>模板方法</li>
<li>访问者</li>
</ul>
<blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</blockquote>
<p>责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">     ┌─────────┐</span><br><span class="line">     │ Request │</span><br><span class="line">     └─────────┘</span><br><span class="line">          │</span><br><span class="line">┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorA  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">          │</span><br><span class="line">│         ▼         │</span><br><span class="line">   ┌─────────────┐</span><br><span class="line">│  │ ProcessorB  │  │</span><br><span class="line">   └─────────────┘</span><br><span class="line">│         │         │</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorC  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">          │</span><br><span class="line">└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘</span><br><span class="line">          │</span><br><span class="line">          ▼</span><br></pre></td></tr></table></figure>
<p>在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为：</p>
<ul>
<li>Manager：只能审核1000元以下的报销；</li>
<li>Director：只能审核10000元以下的报销；</li>
<li>CEO：可以审核任意额度。</li>
</ul>
<p>用责任链模式设计此报销流程时，每个审核者只关心自己责任范围内的请求，并且处理它。对于超出自己责任范围的，扔给下一个审核者处理，这样，将来继续添加审核者的时候，不用改动现有逻辑。</p>
<p>我们来看看如何实现责任链模式。</p>
<p>首先，我们要抽象出请求对象，它将在责任链上传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Request</span><span class="params">(String name, BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，我们要抽象出处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">// 返回Boolean.TRUE = 成功</span></span><br><span class="line">    <span class="comment">// 返回Boolean.FALSE = 拒绝</span></span><br><span class="line">    <span class="comment">// 返回null = 交下一个处理</span></span><br><span class="line">	Boolean <span class="title function_">process</span><span class="params">(Request request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且做好约定：如果返回<code>Boolean.TRUE</code>，表示处理成功，如果返回<code>Boolean.FALSE</code>，表示处理失败（请求被拒绝），如果返回<code>null</code>，则交由下一个<code>Handler</code>处理。</p>
<p>然后，依次编写ManagerHandler、DirectorHandler和CEOHandler。以ManagerHandler为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManagerHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">process</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果超过1000元，处理不了，交下一个处理:</span></span><br><span class="line">        <span class="keyword">if</span> (request.getAmount().compareTo(BigDecimal.valueOf(<span class="number">1000</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对Bob有偏见:</span></span><br><span class="line">        <span class="keyword">return</span> !request.getName().equalsIgnoreCase(<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了不同的<code>Handler</code>后，我们还要把这些<code>Handler</code>组合起来，变成一个链，并通过一个统一入口处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">    <span class="comment">// 持有所有Handler:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">// 依次调用每个Handler:</span></span><br><span class="line">        <span class="keyword">for</span> (Handler handler : handlers) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">r</span> <span class="operator">=</span> handler.process(request);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果返回TRUE或FALSE，处理结束:</span></span><br><span class="line">                System.out.println(request + <span class="string">&quot; &quot;</span> + (r ? <span class="string">&quot;Approved by &quot;</span> : <span class="string">&quot;Denied by &quot;</span>) + handler.getClass().getSimpleName());</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Could not handle request: &quot;</span> + request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们就可以在客户端组装出责任链，然后用责任链来处理请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造责任链:</span></span><br><span class="line"><span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> <span class="title class_">ManagerHandler</span>());</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> <span class="title class_">DirectorHandler</span>());</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> <span class="title class_">CEOHandler</span>());</span><br><span class="line"><span class="comment">// 处理请求:</span></span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;Bob&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.45&quot;</span>)));</span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;Alice&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234.56&quot;</span>)));</span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;Bill&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12345.67&quot;</span>)));</span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;John&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123456.78&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>责任链模式本身很容易理解，需要注意的是，<code>Handler</code>添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。</p>
<p>此外，责任链模式有很多变种。有些责任链的实现方式是通过某个<code>Handler</code>手动调用下一个<code>Handler</code>来传递<code>Request</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!canProcess(request)) &#123;</span><br><span class="line">            <span class="comment">// 手动交给下一个Handler处理:</span></span><br><span class="line">            next.process(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一些责任链模式，每个<code>Handler</code>都有机会处理<code>Request</code>，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter），它的目的不是找到某个<code>Handler</code>处理掉<code>Request</code>，而是每个<code>Handler</code>都做一些工作，比如：</p>
<ul>
<li>记录日志；</li>
<li>检查权限；</li>
<li>准备相关资源；</li>
<li>…</li>
</ul>
<p>例如，JavaEE的Servlet规范定义的<code>Filter</code>就是一种责任链模式，它不但允许每个<code>Filter</code>都有机会处理请求，还允许每个<code>Filter</code>决定是否将请求“放行”给下一个<code>Filter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuditFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        log(req);</span><br><span class="line">        <span class="keyword">if</span> (check(req)) &#123;</span><br><span class="line">            <span class="comment">// 放行:</span></span><br><span class="line">            chain.doFilter(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拒绝:</span></span><br><span class="line">            sendError(resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式不但允许一个<code>Filter</code>自行决定处理<code>ServletRequest</code>和<code>ServletResponse</code>，还可以“伪造”<code>ServletRequest</code>和<code>ServletResponse</code>以便让下一个<code>Filter</code>处理，能实现非常复杂的功能。</p>
<h3 id="练习">练习</h3>
<p>使用责任链模式实现审批。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/chain-of-responsibility/pattern-chain-of-responsibility.zip">下载练习</a></p>
<h3 id="小结">小结</h3>
<p>责任链模式是一种把多个处理器组合在一起，依次处理请求的模式；</p>
<p>责任链模式的好处是添加新的处理器或者重新排列处理器非常容易；</p>
<p>责任链模式经常用在拦截、预处理请求等。</p>
<blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。</p>
<p>在使用命令模式前，我们先以一个编辑器为例子，看看如何实现简单的编辑操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paste</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> getFromClipBoard();</span><br><span class="line">        add(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        buffer.append(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.deleteCharAt(buffer.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用一个<code>StringBuilder</code>模拟一个文本编辑器，它支持<code>copy()</code>、<code>paste()</code>、<code>add()</code>、<code>delete()</code>等方法。</p>
<p>正常情况，我们像这样调用<code>TextEditor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>);</span><br><span class="line">editor.copy();</span><br><span class="line">editor.paste();</span><br><span class="line">System.out.println(editor.getState());</span><br></pre></td></tr></table></figure>
<p>这是直接调用方法，调用方需要了解<code>TextEditor</code>的所有接口信息。</p>
<p>如果改用命令模式，我们就要把调用方发送命令和执行方执行命令分开。怎么分？</p>
<p>解决方案是引入一个<code>Command</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方创建一个对应的<code>Command</code>，然后执行，并不关心内部是如何具体执行的。</p>
<p>为了支持<code>CopyCommand</code>和<code>PasteCommand</code>这两个命令，我们从<code>Command</code>接口派生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="comment">// 持有执行者对象:</span></span><br><span class="line">    <span class="keyword">private</span> TextEditor receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyCommand</span><span class="params">(TextEditor receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.copy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextEditor receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PasteCommand</span><span class="params">(TextEditor receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.paste();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们把<code>Command</code>和<code>TextEditor</code>组装一下，客户端这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>);</span><br><span class="line"><span class="comment">// 执行一个CopyCommand:</span></span><br><span class="line"><span class="type">Command</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyCommand</span>(editor);</span><br><span class="line">copy.execute();</span><br><span class="line">editor.add(<span class="string">&quot;----\n&quot;</span>);</span><br><span class="line"><span class="comment">// 执行一个PasteCommand:</span></span><br><span class="line"><span class="type">Command</span> <span class="variable">paste</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PasteCommand</span>(editor);</span><br><span class="line">paste.execute();</span><br><span class="line">System.out.println(editor.getState());</span><br></pre></td></tr></table></figure>
<p>这就是命令模式的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──────┐      ┌───────┐</span><br><span class="line">│Client│─ ─ ─▶│Command│</span><br><span class="line">└──────┘      └───────┘</span><br><span class="line">                  │  ┌──────────────┐</span><br><span class="line">                  ├─▶│ CopyCommand  │</span><br><span class="line">                  │  ├──────────────┤</span><br><span class="line">                  │  │editor.copy() │─ ┐</span><br><span class="line">                  │  └──────────────┘</span><br><span class="line">                  │                    │  ┌────────────┐</span><br><span class="line">                  │  ┌──────────────┐   ─▶│ TextEditor │</span><br><span class="line">                  └─▶│ PasteCommand │  │  └────────────┘</span><br><span class="line">                     ├──────────────┤</span><br><span class="line">                     │editor.paste()│─ ┘</span><br><span class="line">                     └──────────────┘</span><br></pre></td></tr></table></figure>
<p>有的童鞋会有疑问：搞了一大堆<code>Command</code>，多了好几个类，还不如直接这么写简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>);</span><br><span class="line">editor.copy();</span><br><span class="line">editor.paste();</span><br></pre></td></tr></table></figure>
<p>实际上，使用命令模式，确实增加了系统的复杂度。如果需求很简单，那么直接调用显然更直观而且更简单。</p>
<p>那么我们还需要命令模式吗？</p>
<p>答案是视需求而定。如果<code>TextEditor</code>复杂到一定程度，并且需要支持Undo、Redo的功能时，就需要使用命令模式，因为我们可以给每个命令增加<code>undo()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把执行的一系列命令用<code>List</code>保存起来，就既能支持Undo，又能支持Redo。这个时候，我们又需要一个<code>Invoker</code>对象，负责执行命令并保存历史命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│   Client    │</span><br><span class="line">└─────────────┘</span><br><span class="line">       │</span><br><span class="line"></span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">┌─────────────┐</span><br><span class="line">│   Invoker   │</span><br><span class="line">├─────────────┤    ┌───────┐</span><br><span class="line">│List commands│─ ─▶│Command│</span><br><span class="line">│invoke(c)    │    └───────┘</span><br><span class="line">│undo()       │        │  ┌──────────────┐</span><br><span class="line">└─────────────┘        ├─▶│ CopyCommand  │</span><br><span class="line">                       │  ├──────────────┤</span><br><span class="line">                       │  │editor.copy() │─ ┐</span><br><span class="line">                       │  └──────────────┘</span><br><span class="line">                       │                    │  ┌────────────┐</span><br><span class="line">                       │  ┌──────────────┐   ─▶│ TextEditor │</span><br><span class="line">                       └─▶│ PasteCommand │  │  └────────────┘</span><br><span class="line">                          ├──────────────┤</span><br><span class="line">                          │editor.paste()│─ ┘</span><br><span class="line">                          └──────────────┘</span><br></pre></td></tr></table></figure>
<p>可见，模式带来的设计复杂度的增加是随着需求而增加的，它减少的是系统各组件的耦合度。</p>
<h3 id="练习-2">练习</h3>
<p>给命令模式新增Add和Delete命令并支持Undo、Redo操作。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/command/pattern-command.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p>命令模式的设计思想是把命令的创建和执行分离，使得调用者无需关心具体的执行过程。</p>
<p>通过封装<code>Command</code>对象，命令模式可以保存已执行的命令，从而支持撤销、重做等操作。</p>
<h2 id="解释器">解释器</h2>
<blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
</blockquote>
<p>解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。举个例子，针对以下的匹配条件：</p>
<ul>
<li>以<code>+</code>开头的数字表示的区号和电话号码，如<code>+861012345678</code>；</li>
<li>以英文开头，后接英文和数字，并以.分隔的域名，如<code>www.liaoxuefeng.com</code>；</li>
<li>以<code>/</code>开头的文件路径，如<code>/path/to/file.txt</code>；</li>
<li>…</li>
</ul>
<p>因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p>
<p>实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;+861012345678&quot;</span>;</span><br><span class="line">System.out.println(s.matches(<span class="string">&quot;^\\+\\d+$&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p>
<h3 id="练习-3">练习</h3>
<p>请实现一个简单的解释器，它可以以SLF4J的日志格式输出字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="string">&quot;[&#123;&#125;] start &#123;&#125; at &#123;&#125;...&quot;</span>, LocalTime.now().withNano(<span class="number">0</span>), <span class="string">&quot;engine&quot;</span>, LocalDate.now());</span><br><span class="line"><span class="comment">// [11:02:18] start engine at 2020-02-21...</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/interpreter/pattern-interpreter.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>解释器模式通过抽象语法树实现对用户输入的解释执行。</p>
<p>解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。</p>
<hr>
<hr>
<h2 id="迭代器">迭代器</h2>
<blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
</blockquote>
<p>迭代器模式（Iterator）实际上在Java的集合类中已经广泛使用了。我们以<code>List</code>为例，要遍历<code>ArrayList</code>，即使我们知道它的内部存储了一个<code>Object[]</code>数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。如果使用<code>Iterator</code>遍历，那么，<code>ArrayList</code>和<code>LinkedList</code>都可以以一种统一的接口来遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = ...</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，因为Iterator模式十分有用，因此，Java允许我们直接把任何支持<code>Iterator</code>的集合对象用<code>foreach</code>循环写出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = ...</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后由Java编译器完成Iterator模式的所有循环代码。</p>
<p>虽然我们对如何使用Iterator有了一定了解，但如何实现一个Iterator模式呢？我们以一个自定义的集合为例，通过Iterator模式实现倒序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseArrayCollection</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 以数组形式持有集合:</span></span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReverseArrayCollection</span><span class="params">(T... objs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = Arrays.copyOfRange(objs, <span class="number">0</span>, objs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ???;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现Iterator模式的关键是返回一个<code>Iterator</code>对象，该对象知道集合的内部结构，因为它可以实现倒序遍历。我们使用Java的内部类实现这个<code>Iterator</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseArrayCollection</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReverseArrayCollection</span><span class="params">(T... objs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = Arrays.copyOfRange(objs, <span class="number">0</span>, objs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReverseIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ReverseIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">// 索引位置:</span></span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReverseIterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Iterator时,索引在数组末尾:</span></span><br><span class="line">            <span class="built_in">this</span>.index = ReverseArrayCollection.<span class="built_in">this</span>.array.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):</span></span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 将索引移动到下一个元素并返回(倒序往前移动):</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> array[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用内部类的好处是内部类隐含地持有一个它所在对象的<code>this</code>引用，可以通过<code>ReverseArrayCollection.this</code>引用到它所在的集合。上述代码实现的逻辑非常简单，但是实际应用时，如果考虑到多线程访问，当一个线程正在迭代某个集合，而另一个线程修改了集合的内容时，是否能继续安全地迭代，还是抛出<code>ConcurrentModificationException</code>，就需要更仔细地设计。</p>
<h3 id="练习-4">练习</h3>
<p>使用Iterator模式实现集合的倒序遍历。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/iterator/pattern-iterator.zip">下载练习</a></p>
<h3 id="小结-4">小结</h3>
<p>Iterator模式常用于遍历集合，它允许集合提供一个统一的<code>Iterator</code>接口来遍历元素，同时保证调用者对集合内部的数据结构一无所知，从而使得调用者总是以相同的接口遍历各种不同类型的集合。</p>
<hr>
<hr>
<h2 id="中介">中介</h2>
<blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p>中介模式（Mediator）又称调停者模式，它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。</p>
<p>有些童鞋听到中介立刻想到房产中介，立刻气不打一处来。这个中介模式与房产中介还真有点像，所以消消气，先看例子。</p>
<p>考虑一个简单的点餐输入：</p>
<p><img src="https://liaoxuefeng.com/books/java/design-patterns/behavioral/mediator/order.png" alt="order"></p>
<p>这个小系统有4个参与对象：</p>
<ul>
<li>多选框；</li>
<li>“选择全部”按钮；</li>
<li>“取消所有”按钮；</li>
<li>“反选”按钮。</li>
</ul>
<p>它的复杂性在于，当多选框变化时，它会影响“选择全部”和“取消所有”按钮的状态（是否可点击），当用户点击某个按钮时，例如“反选”，除了会影响多选框的状态，它又可能影响“选择全部”和“取消所有”按钮的状态。</p>
<p>所以这是一个多方会谈，逻辑写起来很复杂：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────┐     ┌─────────────────┐</span><br><span class="line">│  CheckBox List  │◀───▶│SelectAll Button │</span><br><span class="line">└─────────────────┘     └─────────────────┘</span><br><span class="line">         ▲ ▲                     ▲</span><br><span class="line">         │ └─────────────────────┤</span><br><span class="line">         ▼                       │</span><br><span class="line">┌─────────────────┐     ┌────────┴────────┐</span><br><span class="line">│SelectNone Button│◀────│ Inverse Button  │</span><br><span class="line">└─────────────────┘     └─────────────────┘</span><br></pre></td></tr></table></figure>
<p>如果我们引入一个中介，把多方会谈变成多个双方会谈，虽然多了一个对象，但对象之间的关系就变简单了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            ┌─────────────────┐</span><br><span class="line">     ┌─────▶│  CheckBox List  │</span><br><span class="line">     │      └─────────────────┘</span><br><span class="line">     │      ┌─────────────────┐</span><br><span class="line">     │ ┌───▶│SelectAll Button │</span><br><span class="line">     ▼ ▼    └─────────────────┘</span><br><span class="line">┌─────────┐</span><br><span class="line">│Mediator │</span><br><span class="line">└─────────┘</span><br><span class="line">     ▲ ▲    ┌─────────────────┐</span><br><span class="line">     │ └───▶│SelectNone Button│</span><br><span class="line">     │      └─────────────────┘</span><br><span class="line">     │      ┌─────────────────┐</span><br><span class="line">     └─────▶│ Inverse Button  │</span><br><span class="line">            └─────────────────┘</span><br></pre></td></tr></table></figure>
<p>下面我们用中介模式来实现各个UI组件的交互。首先把UI组件给画出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">OrderFrame</span>(<span class="string">&quot;Hanburger&quot;</span>, <span class="string">&quot;Nugget&quot;</span>, <span class="string">&quot;Chip&quot;</span>, <span class="string">&quot;Coffee&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderFrame</span><span class="params">(String... names)</span> &#123;</span><br><span class="line">        setTitle(<span class="string">&quot;Order&quot;</span>);</span><br><span class="line">        setSize(<span class="number">460</span>, <span class="number">200</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="type">Container</span> <span class="variable">c</span> <span class="operator">=</span> getContentPane();</span><br><span class="line">        c.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.LEADING, <span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">        c.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Use Mediator Pattern&quot;</span>));</span><br><span class="line">        List&lt;JCheckBox&gt; checkboxList = addCheckBox(names);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">selectAll</span> <span class="operator">=</span> addButton(<span class="string">&quot;Select All&quot;</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">selectNone</span> <span class="operator">=</span> addButton(<span class="string">&quot;Select None&quot;</span>);</span><br><span class="line">        selectNone.setEnabled(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">selectInverse</span> <span class="operator">=</span> addButton(<span class="string">&quot;Inverse Select&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mediator</span>(checkBoxList, selectAll, selectNone, selectInverse);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;JCheckBox&gt; <span class="title function_">addCheckBox</span><span class="params">(String... names)</span> &#123;</span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Menu:&quot;</span>));</span><br><span class="line">        List&lt;JCheckBox&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="type">JCheckBox</span> <span class="variable">checkbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JCheckBox</span>(name);</span><br><span class="line">            list.add(checkbox);</span><br><span class="line">            panel.add(checkbox);</span><br><span class="line">        &#125;</span><br><span class="line">        getContentPane().add(panel);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JButton <span class="title function_">addButton</span><span class="params">(String label)</span> &#123;</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(label);</span><br><span class="line">        getContentPane().add(button);</span><br><span class="line">        <span class="keyword">return</span> button;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们设计一个Mediator类，它引用4个UI组件，并负责跟它们交互：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">// 引用UI组件:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;JCheckBox&gt; checkBoxList;</span><br><span class="line">    <span class="keyword">private</span> JButton selectAll;</span><br><span class="line">    <span class="keyword">private</span> JButton selectNone;</span><br><span class="line">    <span class="keyword">private</span> JButton selectInverse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mediator</span><span class="params">(List&lt;JCheckBox&gt; checkBoxList, JButton selectAll, JButton selectNone, JButton selectInverse)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.checkBoxList = checkBoxList;</span><br><span class="line">        <span class="built_in">this</span>.selectAll = selectAll;</span><br><span class="line">        <span class="built_in">this</span>.selectNone = selectNone;</span><br><span class="line">        <span class="built_in">this</span>.selectInverse = selectInverse;</span><br><span class="line">        <span class="comment">// 绑定事件:</span></span><br><span class="line">        <span class="built_in">this</span>.checkBoxList.forEach(checkBox -&gt; &#123;</span><br><span class="line">            checkBox.addChangeListener(<span class="built_in">this</span>::onCheckBoxChanged);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.selectAll.addActionListener(<span class="built_in">this</span>::onSelectAllClicked);</span><br><span class="line">        <span class="built_in">this</span>.selectNone.addActionListener(<span class="built_in">this</span>::onSelectNoneClicked);</span><br><span class="line">        <span class="built_in">this</span>.selectInverse.addActionListener(<span class="built_in">this</span>::onSelectInverseClicked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当checkbox有变化时:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckBoxChanged</span><span class="params">(ChangeEvent event)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allChecked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allUnchecked</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> checkBox : checkBoxList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkBox.isSelected()) &#123;</span><br><span class="line">                allUnchecked = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                allChecked = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selectAll.setEnabled(!allChecked);</span><br><span class="line">        selectNone.setEnabled(!allUnchecked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当点击select all:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSelectAllClicked</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="literal">true</span>));</span><br><span class="line">        selectAll.setEnabled(<span class="literal">false</span>);</span><br><span class="line">        selectNone.setEnabled(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当点击select none:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSelectNoneClicked</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="literal">false</span>));</span><br><span class="line">        selectAll.setEnabled(<span class="literal">true</span>);</span><br><span class="line">        selectNone.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当点击select inverse:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSelectInverseClicked</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(!checkBox.isSelected()));</span><br><span class="line">        onCheckBoxChanged(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下看看效果：</p>
<p><img src="https://liaoxuefeng.com/books/java/design-patterns/behavioral/mediator/mediator.png" alt="mediator"></p>
<p>使用Mediator模式后，我们得到了以下好处：</p>
<ul>
<li>各个UI组件互不引用，这样就减少了组件之间的耦合关系；</li>
<li>Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件；</li>
<li>如果新增一个UI组件，我们只需要修改Mediator更新状态的逻辑，现有的其他UI组件代码不变。</li>
</ul>
<p>Mediator模式经常用在有众多交互组件的UI上。为了简化UI程序，MVC模式以及MVVM模式都可以看作是Mediator模式的扩展。</p>
<h3 id="练习-5">练习</h3>
<p>使用Mediator模式。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/mediator/pattern-mediator.zip">下载练习</a></p>
<h3 id="小结-5">小结</h3>
<p>中介模式是通过引入一个中介对象，把多边关系变成多个双边关系，从而简化系统组件的交互耦合度。</p>
<hr>
<hr>
<h2 id="备忘录">备忘录</h2>
<blockquote>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
</blockquote>
<p>备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p>
<p>其实我们使用的几乎所有软件都用到了备忘录模式。最简单的备忘录模式就是保存到文件，打开文件。对于文本编辑器来说，保存就是把<code>TextEditor</code>类的字符串存储到文件，打开就是恢复<code>TextEditor</code>类的状态。对于图像编辑器来说，原理是一样的，只是保存和恢复的数据格式比较复杂而已。Java的序列化也可以看作是备忘录模式。</p>
<p>在使用文本编辑器的时候，我们还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把<code>TextEditor</code>类的字符串复制一份存起来，这样就可以Undo或Redo。</p>
<p>标准的备忘录模式有这么几种角色：</p>
<ul>
<li>Memento：存储的内部状态；</li>
<li>Originator：创建一个备忘录并设置其状态；</li>
<li>Caretaker：负责保存备忘录。</li>
</ul>
<p>实际上我们在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似<code>TextEditor</code>的类，增加<code>getState()</code>和<code>setState()</code>就可以了。</p>
<p>我们以一个文本编辑器<code>TextEditor</code>为例，它内部使用<code>StringBuilder</code>允许用户增删字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        buffer.append(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        buffer.append(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.deleteCharAt(buffer.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了支持这个<code>TextEditor</code>能保存和恢复状态，我们增加<code>getState()</code>和<code>setState()</code>两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态:</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复状态:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buffer.delete(<span class="number">0</span>, <span class="built_in">this</span>.buffer.length());</span><br><span class="line">        <span class="built_in">this</span>.buffer.append(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这个简单的文本编辑器，用一个<code>String</code>就可以表示其状态，对于复杂的对象模型，通常我们会使用JSON、XML等复杂格式。</p>
<h3 id="练习-6">练习</h3>
<p>给TextEditor添加备忘录模式。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/memento/pattern-memento.zip">下载练习</a></p>
<h3 id="小结-6">小结</h3>
<p>备忘录模式是为了保存对象的内部状态，并在将来恢复，大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。</p>
<hr>
<hr>
<blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</p>
<p>要理解观察者模式，我们还是看例子。</p>
<p>假设一个电商网站，有多种<code>Product</code>（商品），同时，<code>Customer</code>（消费者）和<code>Admin</code>（管理员）对商品上架、价格改变都感兴趣，希望能第一时间获得通知。于是，<code>Store</code>（商场）可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    Customer customer;</span><br><span class="line">    Admin admin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Product&gt; products = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNewProduct</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(name, price);</span><br><span class="line">        products.put(p.getName(), p);</span><br><span class="line">        <span class="comment">// 通知用户:</span></span><br><span class="line">        customer.onPublished(p);</span><br><span class="line">        <span class="comment">// 通知管理员:</span></span><br><span class="line">        admin.onPublished(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductPrice</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> products.get(name);</span><br><span class="line">        p.setPrice(price);</span><br><span class="line">        <span class="comment">// 通知用户:</span></span><br><span class="line">        customer.onPriceChanged(p);</span><br><span class="line">        <span class="comment">// 通知管理员:</span></span><br><span class="line">        admin.onPriceChanged(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们观察上述<code>Store</code>类的问题：它直接引用了<code>Customer</code>和<code>Admin</code>。先不考虑多个<code>Customer</code>或多个<code>Admin</code>的问题，上述<code>Store</code>类最大的问题是，如果要加一个新的观察者类型，例如工商局管理员，<code>Store</code>类就必须继续改动。</p>
<p>因此，上述问题的本质是<code>Store</code>希望发送通知给那些关心<code>Product</code>的对象，但<code>Store</code>并不想知道这些人是谁。观察者模式就是要分离被观察者和观察者之间的耦合关系。</p>
<p>要实现这一目标也很简单，<code>Store</code>不能直接引用<code>Customer</code>和<code>Admin</code>，相反，它引用一个<code>ProductObserver</code>接口，任何人想要观察<code>Store</code>，只要实现该接口，并且把自己注册到<code>Store</code>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ProductObserver&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Product&gt; products = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(ProductObserver observer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消注册:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(ProductObserver observer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNewProduct</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(name, price);</span><br><span class="line">        products.put(p.getName(), p);</span><br><span class="line">        <span class="comment">// 通知观察者:</span></span><br><span class="line">        observers.forEach(o -&gt; o.onPublished(p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductPrice</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> products.get(name);</span><br><span class="line">        p.setPrice(price);</span><br><span class="line">        <span class="comment">// 通知观察者:</span></span><br><span class="line">        observers.forEach(o -&gt; o.onPriceChanged(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这么一个小小的改动，使得观察者类型就可以无限扩充，而且，观察者的定义可以放到客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer:</span></span><br><span class="line"><span class="type">Admin</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br><span class="line"><span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line"><span class="comment">// store:</span></span><br><span class="line"><span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Store</span>();</span><br><span class="line"><span class="comment">// 注册观察者:</span></span><br><span class="line">store.addObserver(a);</span><br><span class="line">store.addObserver(c);</span><br></pre></td></tr></table></figure>
<p>甚至可以注册匿名观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">store.addObserver(<span class="keyword">new</span> <span class="title class_">ProductObserver</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPublished</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Log] on product published: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPriceChanged</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Log] on product price changed: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用一张图画出观察者模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┐      ┌───────────────┐</span><br><span class="line">│  Store  │─ ─ ─▶│ProductObserver│</span><br><span class="line">└─────────┘      └───────────────┘</span><br><span class="line">     │                   ▲</span><br><span class="line">                         │</span><br><span class="line">     │             ┌─────┴─────┐</span><br><span class="line">     ▼             │           │</span><br><span class="line">┌─────────┐   ┌─────────┐ ┌─────────┐</span><br><span class="line">│ Product │   │  Admin  │ │Customer │ ...</span><br><span class="line">└─────────┘   └─────────┘ └─────────┘</span><br></pre></td></tr></table></figure>
<p>观察者模式也有很多变体形式。有的观察者模式把被观察者也抽象出接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductObservable</span> &#123; <span class="comment">// 注意此处拼写是Observable不是Observer!</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(ProductObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(ProductObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的实体被观察者就要实现该接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Store</span> <span class="keyword">implements</span> <span class="title class_">ProductObservable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些观察者模式把通知变成一个Event对象，从而不再有多种方法通知，而是统一成一种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductObserver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(ProductEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让观察者自己从Event对象中读取通知类型和通知数据。</p>
<p>广义的观察者模式包括所有消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                 ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">                   Messaging System</span><br><span class="line">                 │                       │</span><br><span class="line">                    ┌──────────────────┐</span><br><span class="line">              ┌──┼─▶│Topic:newProduct  │─┼─┐   ┌─────────┐</span><br><span class="line">              │     └──────────────────┘   ├──▶│ConsumerA│</span><br><span class="line">┌─────────┐   │  │  ┌──────────────────┐ │ │   └─────────┘</span><br><span class="line">│Producer │───┼────▶│Topic:priceChanged│───┘</span><br><span class="line">└─────────┘   │  │  └──────────────────┘ │</span><br><span class="line">              │     ┌──────────────────┐       ┌─────────┐</span><br><span class="line">              └──┼─▶│Topic:soldOut     │─┼────▶│ConsumerB│</span><br><span class="line">                    └──────────────────┘       └─────────┘</span><br><span class="line">                 └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>
<p>消息发送方称为Producer，消息接收方称为Consumer，Producer发送消息的时候，必须选择发送到哪个Topic。Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。</p>
<p>使用消息系统实现观察者模式时，Producer和Consumer甚至经常不在同一台机器上，并且双方对对方完全一无所知，因为注册观察者这个动作本身都在消息系统中完成，而不是在Producer内部完成。</p>
<p>此外，注意到我们在编写观察者模式的时候，通知Observer是依靠语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observers.forEach(o -&gt; o.onPublished(p));</span><br></pre></td></tr></table></figure>
<p>这说明各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。</p>
<p>思考：如何改成异步通知，使得所有观察者可以并发同时处理？</p>
<p>有的童鞋可能发现Java标准库有个<code>java.util.Observable</code>类和一个<code>Observer</code>接口，用来帮助我们实现观察者模式。但是，这个类非常不！好！用！实现观察者模式的时候，也不推荐借助这两个东东。</p>
<h3 id="练习-7">练习</h3>
<p>给<code>Store</code>增加一种类型的观察者，并把通知改为异步。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/observer/pattern-observer.zip">下载练习</a></p>
<h3 id="小结-7">小结</h3>
<p>观察者模式，又称发布-订阅模式，是一种一对多的通知机制，使得双方无需关心对方，只关心通知本身。</p>
<h2 id="状态">状态</h2>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>状态模式（State）经常用在带有状态的对象中。</p>
<p>什么是状态？我们以QQ聊天为例，一个用户的QQ有几种状态：</p>
<ul>
<li>离线状态（尚未登录）；</li>
<li>正在登录状态；</li>
<li>在线状态；</li>
<li>忙状态（暂时离开）。</li>
</ul>
<p>如何表示状态？我们定义一个<code>enum</code>就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state == ONLINE) &#123;</span><br><span class="line">    <span class="comment">// 闪烁图标</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == BUSY) &#123;</span><br><span class="line">    reply(<span class="string">&quot;现在忙，稍后回复&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br></pre></td></tr></table></figure>
<p>状态模式的目的是为了把上述一大串<code>if...else...</code>的逻辑给分拆到不同的状态类中，使得将来增加状态比较容易。</p>
<p>例如，我们设计一个聊天机器人，它有两个状态：</p>
<ul>
<li>未连线；</li>
<li>已连线。</li>
</ul>
<p>对于未连线状态，我们收到消息也不回复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisconnectedState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reply</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于已连线状态，我们回应收到的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectedState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, I&#x27;m Bob.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reply</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input.endsWith(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Yes. &quot;</span> + input.substring(<span class="number">0</span>, input.length() - <span class="number">1</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (input.endsWith(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> input.substring(<span class="number">0</span>, input.length() - <span class="number">1</span>) + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> input.substring(<span class="number">0</span>, input.length() - <span class="number">1</span>) + <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态模式的关键设计思想在于状态切换，我们引入一个<code>BotContext</code>完成状态切换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BotContext</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisconnectedState</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">chat</span><span class="params">(String input)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;hello&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class="line">            <span class="comment">// 收到hello切换到在线状态:</span></span><br><span class="line">			state = <span class="keyword">new</span> <span class="title class_">ConnectedState</span>();</span><br><span class="line">			<span class="keyword">return</span> state.init();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class="line">            /  收到bye切换到离线状态:</span><br><span class="line">			state = <span class="keyword">new</span> <span class="title class_">DisconnectedState</span>();</span><br><span class="line">			<span class="keyword">return</span> state.init();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> state.reply(input);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，一个价值千万的AI聊天机器人就诞生了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">BotContext</span> <span class="variable">bot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BotContext</span>();</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> bot.chat(input);</span><br><span class="line">    System.out.println(output.isEmpty() ? <span class="string">&quot;(no reply)&quot;</span> : <span class="string">&quot;&lt; &quot;</span> + output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试试效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello</span><br><span class="line">&lt; Hello, I&#x27;m Bob.</span><br><span class="line">&gt; Nice to meet you.</span><br><span class="line">&lt; Nice to meet you!</span><br><span class="line">&gt; Today is cold?</span><br><span class="line">&lt; Yes. Today is cold!</span><br><span class="line">&gt; bye</span><br><span class="line">&lt; Bye!</span><br></pre></td></tr></table></figure>
<h3 id="练习-8">练习</h3>
<p>新增BusyState状态表示忙碌。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/state/pattern-state.zip">下载练习</a></p>
<h3 id="小结-8">小结</h3>
<p>状态模式的设计思想是把不同状态的逻辑分离到不同的状态类中，从而使得增加新状态更容易；</p>
<p>状态模式的实现关键在于状态转换。简单的状态转换可以直接由调用方指定，复杂的状态转换可以在内部根据条件触发完成。</p>
<hr>
<hr>
<blockquote>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</blockquote>
<p>策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。</p>
<p>策略模式在Java标准库中应用非常广泛，我们以排序为例，看看如何通过<code>Arrays.sort()</code>实现忽略大小写排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        String[] array = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;orange&quot;</span> &#125;;</span><br><span class="line">        Arrays.sort(array, String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想忽略大小写排序，就传入<code>String::compareToIgnoreCase</code>，如果我们想倒序排序，就传入<code>(s1, s2) -&gt; -s1.compareTo(s2)</code>，这个比较两个元素大小的算法就是策略。</p>
<p>我们观察<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>这个排序方法，它在内部实现了TimSort排序，但是，排序算法在比较两个元素大小的时候，需要借助我们传入的<code>Comparator</code>对象，才能完成比较。因此，这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。</p>
<p>因此，上述排序使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。</p>
<p>如果我们自己实现策略模式的排序，用冒泡法编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        String[] array = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;orange&quot;</span> &#125;;</span><br><span class="line">        sort(array, String::compareToIgnoreCase);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(a[j], a[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123; <span class="comment">// 注意这里比较两个元素的大小依赖传入的策略</span></span><br><span class="line">                    <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个完整的策略模式要定义策略以及使用策略的上下文。我们以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。先定义打折策略接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">    <span class="comment">// 计算折扣额度:</span></span><br><span class="line">    BigDecimal <span class="title function_">getDiscount</span><span class="params">(BigDecimal total)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是实现各种策略。普通用户策略如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDiscountStrategy</span> <span class="keyword">implements</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getDiscount</span><span class="params">(BigDecimal total)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通会员打九折:</span></span><br><span class="line">        <span class="keyword">return</span> total.multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>)).setScale(<span class="number">2</span>, RoundingMode.DOWN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>满减策略如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverDiscountStrategy</span> <span class="keyword">implements</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getDiscount</span><span class="params">(BigDecimal total)</span> &#123;</span><br><span class="line">        <span class="comment">// 满100减20优惠:</span></span><br><span class="line">        <span class="keyword">return</span> total.compareTo(BigDecimal.valueOf(<span class="number">100</span>)) &gt;= <span class="number">0</span> ? BigDecimal.valueOf(<span class="number">20</span>) : BigDecimal.ZERO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，要应用策略，我们需要一个<code>DiscountContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountContext</span> &#123;</span><br><span class="line">    <span class="comment">// 持有某个策略:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DiscountStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDiscountStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许客户端设置新策略:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(DiscountStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">calculatePrice</span><span class="params">(BigDecimal total)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> total.subtract(<span class="built_in">this</span>.strategy.getDiscount(total)).setScale(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方必须首先创建一个DiscountContext，并指定一个策略（或者使用默认策略），即可获得折扣后的价格：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DiscountContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiscountContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认使用普通会员折扣:</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">pay1</span> <span class="operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="number">105</span>));</span><br><span class="line">System.out.println(pay1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用满减折扣:</span></span><br><span class="line">ctx.setStrategy(<span class="keyword">new</span> <span class="title class_">OverDiscountStrategy</span>());</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">pay2</span> <span class="operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="number">105</span>));</span><br><span class="line">System.out.println(pay2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Prime会员折扣:</span></span><br><span class="line">ctx.setStrategy(<span class="keyword">new</span> <span class="title class_">PrimeDiscountStrategy</span>());</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">pay3</span> <span class="operator">=</span> ctx.calculatePrice(BigDecimal.valueOf(<span class="number">105</span>));</span><br><span class="line">System.out.println(pay3);</span><br></pre></td></tr></table></figure>
<p>上述完整的策略模式如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐      ┌─────────────────┐</span><br><span class="line">│DiscountContext│─ ─ ─▶│DiscountStrategy │</span><br><span class="line">└───────────────┘      └─────────────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                ├─│UserDiscountStrategy │</span><br><span class="line">                                │ └─────────────────────┘</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                ├─│PrimeDiscountStrategy│</span><br><span class="line">                                │ └─────────────────────┘</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                └─│OverDiscountStrategy │</span><br><span class="line">                                  └─────────────────────┘</span><br></pre></td></tr></table></figure>
<p>策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。</p>
<h3 id="练习-9">练习</h3>
<p>使用策略模式新增一种策略，允许在满100减20的基础上对Prime会员再打七折。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/strategy/pattern-strategy.zip">下载练习</a></p>
<h3 id="小结-9">小结</h3>
<p>策略模式是为了允许调用方选择一个算法，从而通过不同策略实现不同的计算结果。</p>
<p>通过扩展策略，不必修改主逻辑，即可获得新策略的结果。</p>
<blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<p>模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。</p>
<p>因此，模板方法的核心在于定义一个“骨架”。我们还是举例说明。</p>
<p>假设我们开发了一个从数据库读取设置的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Setting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> readFromDatabase(key);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">readFromDatabase</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库读取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于从数据库读取数据较慢，我们可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库了。但是怎么实现缓存，暂时没想好，但不妨碍我们先写出使用缓存的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Setting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 先从缓存读取:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lookupCache(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在缓存中未找到,从数据库读取:</span></span><br><span class="line">            value = readFromDatabase(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;[DEBUG] load from db: &quot;</span> + key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">            <span class="comment">// 放入缓存:</span></span><br><span class="line">            putIntoCache(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[DEBUG] load from cache: &quot;</span> + key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程没有问题，但是，<code>lookupCache(key)</code>和<code>putIntoCache(key, value)</code>这两个方法还根本没实现，怎么编译通过？这个不要紧，我们声明抽象方法就可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lookupCache(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            value = readFromDatabase(key);</span><br><span class="line">            putIntoCache(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为声明了抽象方法，自然整个类也必须是抽象类。如何实现<code>lookupCache(key)</code>和<code>putIntoCache(key, value)</code>这两个方法就交给子类了。子类其实并不关心核心代码<code>getSetting(key)</code>的逻辑，它只需要关心如何完成两个小小的子任务就可以了。</p>
<p>假设我们希望用一个<code>Map</code>做缓存，那么可以写一个<code>LocalSetting</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalSetting</span> <span class="keyword">extends</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要使用Redis做缓存，那么可以再写一个<code>RedisSetting</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSetting</span> <span class="keyword">extends</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisClient</span> <span class="variable">client</span> <span class="operator">=</span> RedisClient.create(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            <span class="keyword">return</span> commands.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            commands.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码使用本地缓存的代码这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractSetting</span> <span class="variable">setting1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalSetting</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;test = &quot;</span> + setting1.getSetting(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;test = &quot;</span> + setting1.getSetting(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>要改成Redis缓存，只需要把<code>LocalSetting</code>替换为<code>RedisSetting</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractSetting</span> <span class="variable">setting2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisSetting</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="string">&quot;autosave&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;autosave = &quot;</span> + setting2.getSetting(<span class="string">&quot;autosave&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>可见，模板方法的核心思想是：父类定义骨架，子类实现某些细节。</p>
<p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用<code>final</code>。对于需要子类实现的抽象方法，一般声明为<code>protected</code>，使得这些方法对外部客户端不可见。</p>
<p>Java标准库也有很多模板方法的应用。在集合类中，<code>AbstractList</code>和<code>AbstractQueuedSynchronizer</code>都定义了很多通用操作，子类只需要实现某些必要方法。</p>
<h3 id="练习-10">练习</h3>
<p>使用模板方法增加一个使用Guava Cache的子类。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/template-method/pattern-template-method.zip">下载练习</a></p>
<p>思考：能否将<code>readFromDatabase()</code>作为模板方法，使得子类可以选择从数据库读取还是从文件读取。</p>
<p>再思考如果既可以扩展缓存，又可以扩展底层存储，会不会出现子类数量爆炸的情况？如何解决？</p>
<h3 id="小结-10">小结</h3>
<p>模板方法是一种高层定义骨架，底层实现细节的设计模式，适用于流程固定，但某些步骤不确定或可替换的情况。</p>
<blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p>访问者模式（Visitor）是一种操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p>
<p>访问者模式的设计比较复杂，如果我们查看GoF原始的访问者模式，它是这么设计的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   ┌─────────┐       ┌───────────────────────┐</span><br><span class="line">   │ Client  │─ ─ ─ ▶│        Visitor        │</span><br><span class="line">   └─────────┘       ├───────────────────────┤</span><br><span class="line">        │            │visitElementA(ElementA)│</span><br><span class="line">                     │visitElementB(ElementB)│</span><br><span class="line">        │            └───────────────────────┘</span><br><span class="line">                                 ▲</span><br><span class="line">        │                ┌───────┴───────┐</span><br><span class="line">                         │               │</span><br><span class="line">        │         ┌─────────────┐ ┌─────────────┐</span><br><span class="line">                  │  VisitorA   │ │  VisitorB   │</span><br><span class="line">        │         └─────────────┘ └─────────────┘</span><br><span class="line">        ▼</span><br><span class="line">┌───────────────┐        ┌───────────────┐</span><br><span class="line">│ObjectStructure│─ ─ ─ ─▶│    Element    │</span><br><span class="line">├───────────────┤        ├───────────────┤</span><br><span class="line">│handle(Visitor)│        │accept(Visitor)│</span><br><span class="line">└───────────────┘        └───────────────┘</span><br><span class="line">                                 ▲</span><br><span class="line">                        ┌────────┴────────┐</span><br><span class="line">                        │                 │</span><br><span class="line">                ┌───────────────┐ ┌───────────────┐</span><br><span class="line">                │   ElementA    │ │   ElementB    │</span><br><span class="line">                ├───────────────┤ ├───────────────┤</span><br><span class="line">                │accept(Visitor)│ │accept(Visitor)│</span><br><span class="line">                │doA()          │ │doB()          │</span><br><span class="line">                └───────────────┘ └───────────────┘</span><br></pre></td></tr></table></figure>
<p>上述模式的复杂之处在于上述访问者模式为了实现所谓的“双重分派”，设计了一个回调再回调的机制。因为Java只支持基于多态的单分派模式，这里强行模拟出“双重分派”反而加大了代码的复杂性。</p>
<p>这里我们只介绍简化的访问者模式。假设我们要递归遍历某个文件夹的所有子文件夹和文件，然后找出<code>.java</code>文件，正常的做法是写个递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(File dir, List&lt;File&gt; collector)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">            collector.add(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isDir()) &#123;</span><br><span class="line">            <span class="comment">// 递归调用:</span></span><br><span class="line">            scan(file, collector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的问题在于，扫描目录的逻辑和处理.java文件的逻辑混在了一起。如果下次需要增加一个清理<code>.class</code>文件的功能，就必须再重复写扫描逻辑。</p>
<p>因此，访问者模式先把数据结构（这里是文件夹和文件构成的树型结构）和对其的操作（查找文件）分离开，以后如果要新增操作（例如清理<code>.class</code>文件），只需要新增访问者，不需要改变现有逻辑。</p>
<p>用访问者模式改写上述代码步骤如下：</p>
<p>首先，我们需要定义访问者接口，即该访问者能够干的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="comment">// 访问文件夹:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitDir</span><span class="params">(File dir)</span>;</span><br><span class="line">    <span class="comment">// 访问文件:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitFile</span><span class="params">(File file)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，我们要定义能持有文件夹和文件的数据结构<code>FileStructure</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileStructure</span> &#123;</span><br><span class="line">    <span class="comment">// 根目录:</span></span><br><span class="line">    <span class="keyword">private</span> File path;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileStructure</span><span class="params">(File path)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们给<code>FileStructure</code>增加一个<code>handle()</code>方法，传入一个访问者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileStructure</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">		scan(<span class="built_in">this</span>.path, visitor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(File file, Visitor visitor)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 让访问者处理文件夹:</span></span><br><span class="line">			visitor.visitDir(file);</span><br><span class="line">			<span class="keyword">for</span> (File sub : file.listFiles()) &#123;</span><br><span class="line">                <span class="comment">// 递归处理子文件夹:</span></span><br><span class="line">				scan(sub, visitor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 让访问者处理文件:</span></span><br><span class="line">			visitor.visitFile(file);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就把访问者的行为抽象出来了。如果我们要实现一种操作，例如，查找<code>.java</code>文件，就传入<code>JavaFileVisitor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileStructure</span> <span class="variable">fs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileStructure</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">fs.handle(<span class="keyword">new</span> <span class="title class_">JavaFileVisitor</span>());</span><br></pre></td></tr></table></figure>
<p>这个<code>JavaFileVisitor</code>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaFileVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Visit dir: &quot;</span> + dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Found java file: &quot;</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，如果要清理<code>.class</code>文件，可以再写一个<code>ClassFileClearnerVisitor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassFileCleanerVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Will clean class file: &quot;</span> + file);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。</p>
<p>实际上，Java标准库提供的<code>Files.walkFileTree()</code>已经实现了一个访问者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Files.walkFileTree(Paths.get(<span class="string">&quot;.&quot;</span>), <span class="keyword">new</span> <span class="title class_">MyFileVisitor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个FileVisitor:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFileVisitor</span> <span class="keyword">extends</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理Directory:</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pre visit dir: &quot;</span> + dir);</span><br><span class="line">        <span class="comment">// 返回CONTINUE表示继续访问:</span></span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理File:</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;visit file: &quot;</span> + file);</span><br><span class="line">        <span class="comment">// 返回CONTINUE表示继续访问:</span></span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Files.walkFileTree()</code>允许访问者返回<code>FileVisitResult.CONTINUE</code>以便继续访问，或者返回<code>FileVisitResult.TERMINATE</code>停止访问。</p>
<p>类似的，对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Handler作为访问者处理XML的各个节点。</p>
<h3 id="练习-11">练习</h3>
<p>使用访问者模式递归遍历文件夹。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/design-patterns/behavioral/visitor/pattern-visitor.zip">下载练习</a></p>
<h3 id="小结-11">小结</h3>
<p>访问者模式是为了抽象出作用于一组复杂对象的操作，并且后续可以新增操作而不必对现有的对象结构做任何改动。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/24/java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="page/2/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 1 頁 共 4 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 137 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
