
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>分類: swift - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://keinchan.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/page/2/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/07/04/Swift/swift%E5%8F%AF%E9%80%89%E9%93%BE/"
                            aria-label=": swift可选链"
                        >
                            swift可选链
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-04T10:13:17+08:00">
	
		    2023 年 7 月 4 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="可选链式调用">可选链式调用</h2>
<p><em>可选链式调用</em>是一种可以在当前值可能为 <code>nil</code> 的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是 <code>nil</code>，那么调用将返回 <code>nil</code>。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为 <code>nil</code>，整个调用链都会失败，即返回 <code>nil</code>。</p>
<blockquote>
<p>注意</p>
<p>Swift 的可选链式调用和 Objective-C 中向 <code>nil</code> 发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。</p>
</blockquote>
<h2 id="使用可选链式调用代替强制展开">使用可选链式调用代替强制展开</h2>
<p>通过在想调用的属性、方法，或下标的可选值后面放一个问号（<code>?</code>），可以定义一个可选链。这一点很像在可选值后面放一个叹号（<code>!</code>）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p>
<p>为了反映可选链式调用可以在空值（<code>nil</code>）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回 <code>nil</code> 则说明调用失败。</p>
<p>这里需要特别指出，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是 <code>Int</code> 类型，则会变为 <code>Int?</code> 类型。</p>
<p>下面几段代码将解释可选链式调用和强制展开的不同。</p>
<p>首先定义两个类 <code>Person</code> 和 <code>Residence</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residence</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Residence</code> 有一个 <code>Int</code> 类型的属性 <code>numberOfRooms</code>，其默认值为 <code>1</code>。<code>Person</code> 具有一个可选的 <code>residence</code> 属性，其类型为 <code>Residence?</code>。</p>
<p>假如你创建了一个新的 <code>Person</code> 实例，它的 <code>residence</code> 属性由于是可选类型而将被初始化为 <code>nil</code>，在下面的代码中，<code>john</code> 有一个值为 <code>nil</code> 的 <code>residence</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>()</span><br></pre></td></tr></table></figure>
<p>如果使用叹号（<code>!</code>）强制展开获得这个 <code>john</code> 的 <code>residence</code> 属性中的 <code>numberOfRooms</code> 值，会触发运行时错误，因为这时 <code>residence</code> 没有可以展开的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">!</span>.numberOfRooms</span><br><span class="line"><span class="comment">// 这会引发运行时错误</span></span><br></pre></td></tr></table></figure>
<p><code>john.residence</code> 为非 <code>nil</code> 值的时候，上面的调用会成功，并且把 <code>roomCount</code> 设置为 <code>Int</code> 类型的房间数量。正如上面提到的，当 <code>residence</code> 为 <code>nil</code> 的时候，上面这段代码会触发运行时错误。</p>
<p>可选链式调用提供了另一种访问 <code>numberOfRooms</code> 的方式，使用问号（<code>?</code>）来替代原来的叹号（<code>!</code>）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">?</span>.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s residence has <span class="subst">\(roomCount)</span> room(s).&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>在 <code>residence</code> 后面添加问号之后，Swift 就会在 <code>residence</code> 不为 <code>nil</code> 的情况下访问 <code>numberOfRooms</code>。</p>
<p>因为访问 <code>numberOfRooms</code> 有可能失败，可选链式调用会返回 <code>Int?</code> 类型，或称为“可选的 <code>Int</code>”。如上例所示，当 <code>residence</code> 为 <code>nil</code> 的时候，可选的 <code>Int</code> 将会为 <code>nil</code>，表明无法访问 <code>numberOfRooms</code>。访问成功时，可选的 <code>Int</code> 值会通过可选绑定展开，并赋值给非可选类型的 <code>roomCount</code> 常量。</p>
<p>要注意的是，即使 <code>numberOfRooms</code> 是非可选的 <code>Int</code> 时，这一点也成立。只要使用可选链式调用就意味着 <code>numberOfRooms</code> 会返回一个 <code>Int?</code> 而不是 <code>Int</code>。</p>
<p>可以将一个 <code>Residence</code> 的实例赋给 <code>john.residence</code>，这样它就不再是 <code>nil</code> 了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence <span class="operator">=</span> <span class="type">Residence</span>()</span><br></pre></td></tr></table></figure>
<p><code>john.residence</code> 现在包含一个实际的 <code>Residence</code> 实例，而不再是 <code>nil</code>。如果你试图使用先前的可选链式调用访问 <code>numberOfRooms</code>，它现在将返回值为 <code>1</code> 的 <code>Int?</code> 类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">?</span>.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s residence has <span class="subst">\(roomCount)</span> room(s).&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“John&#x27;s residence has 1 room(s).”</span></span><br></pre></td></tr></table></figure>
<h2 id="为可选链式调用定义模型类">为可选链式调用定义模型类</h2>
<p>通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法和下标。</p>
<p>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在 <code>Person</code> 和 <code>Residence</code> 的基础上增加了 <code>Room</code> 类和 <code>Address</code> 类，以及相关的属性、方法以及下标。</p>
<p><code>Person</code> 类的定义基本保持不变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Residence</code> 类比之前复杂些，增加了一个名为 <code>rooms</code> 的变量属性，该属性被初始化为 <code>[Room]</code> 类型的空数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Residence</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> rooms <span class="operator">=</span> [<span class="type">Room</span>]()</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rooms.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Room</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rooms[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            rooms[i] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printNumberOfRooms</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The number of rooms is <span class="subst">\(numberOfRooms)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>Residence</code> 有了一个存储 <code>Room</code> 实例的数组，<code>numberOfRooms</code> 属性被实现为计算型属性，而不是存储型属性。<code>numberOfRooms</code> 属性简单地返回 <code>rooms</code> 数组的 <code>count</code> 属性的值。</p>
<p><code>Residence</code> 还提供了访问 <code>rooms</code> 数组的快捷方式，即提供可读写的下标来访问 <code>rooms</code> 数组中指定位置的元素。</p>
<p>此外，<code>Residence</code> 还提供了 <code>printNumberOfRooms</code> 方法，这个方法的作用是打印 <code>numberOfRooms</code> 的值。</p>
<p>最后，<code>Residence</code> 还定义了一个可选属性 <code>address</code>，其类型为 <code>Address?</code>。<code>Address</code> 类的定义在下面会说明。</p>
<p><code>Room</code> 类是一个简单类，其实例被存储在 <code>rooms</code> 数组中。该类只包含一个属性 <code>name</code>，以及一个用于将该属性设置为适当的房间名的初始化函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name <span class="operator">=</span> name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个类是 <code>Address</code>，这个类有三个 <code>String?</code> 类型的可选属性。<code>buildingName</code> 以及 <code>buildingNumber</code> 属性分别表示大厦的名称和号码，第三个属性 <code>street</code> 表示大厦所在街道的名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buildingName: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> buildingNumber: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">buildingIdentifier</span>() -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> buildingName <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> buildingName</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> buildingNumber <span class="operator">=</span> buildingNumber, <span class="keyword">let</span> street <span class="operator">=</span> street &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(buildingNumber)</span> <span class="subst">\(street)</span>&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Address</code> 类提供了 <code>buildingIdentifier()</code> 方法，返回值为 <code>String?</code>。 如果 <code>buildingName</code> 有值则返回 <code>buildingName</code>。或者，如果 <code>buildingNumber</code> 和 <code>street</code> 均有值，则返回两者拼接得到的字符串。否则，返回 <code>nil</code>。</p>
<h2 id="通过可选链式调用访问属性">通过可选链式调用访问属性</h2>
<p>正如 <a href="#optional_chaining_as_an_alternative_to_forced_unwrapping">使用可选链式调用代替强制展开</a> 中所述，可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。</p>
<p>使用前面定义过的类，创建一个 <code>Person</code> 实例，然后像之前一样，尝试访问 <code>numberOfRooms</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">?</span>.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s residence has <span class="subst">\(roomCount)</span> room(s).&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>john.residence</code> 为 <code>nil</code>，所以这个可选链式调用依旧会像先前一样失败。</p>
<p>还可以通过可选链式调用来设置属性值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someAddress <span class="operator">=</span> <span class="type">Address</span>()</span><br><span class="line">someAddress.buildingNumber <span class="operator">=</span> <span class="string">&quot;29&quot;</span></span><br><span class="line">someAddress.street <span class="operator">=</span> <span class="string">&quot;Acacia Road&quot;</span></span><br><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> someAddress</span><br></pre></td></tr></table></figure>
<p>在这个例子中，通过 <code>john.residence</code> 来设定 <code>address</code> 属性也会失败，因为 <code>john.residence</code> 当前为 <code>nil</code>。</p>
<p>上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建 <code>Address</code> 实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">createAddress</span>() -&gt; <span class="type">Address</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Function was called.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> someAddress <span class="operator">=</span> <span class="type">Address</span>()</span><br><span class="line">    someAddress.buildingNumber <span class="operator">=</span> <span class="string">&quot;29&quot;</span></span><br><span class="line">    someAddress.street <span class="operator">=</span> <span class="string">&quot;Acacia Road&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> someAddress</span><br><span class="line">&#125;</span><br><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> createAddress()</span><br></pre></td></tr></table></figure>
<p>没有任何打印消息，可以看出 <code>createAddress()</code> 函数并未被执行。</p>
<h2 id="通过可选链式调用来调用方法">通过可选链式调用来调用方法</h2>
<p>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。</p>
<p><code>Residence</code> 类中的 <code>printNumberOfRooms()</code> 方法打印当前的 <code>numberOfRooms</code> 值，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printNumberOfRooms</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The number of rooms is <span class="subst">\(numberOfRooms)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型 <code>Void</code>，如 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#functions_without_return_values">无返回值函数</a> 中所述。这意味着没有返回值的方法也会返回 <code>()</code>，或者说空的元组。</p>
<p>如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是 <code>Void?</code>，而不是 <code>Void</code>，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用 <code>if</code> 语句来判断能否成功调用 <code>printNumberOfRooms()</code> 方法，即使方法本身没有定义返回值。通过判断返回值是否为 <code>nil</code> 可以判断调用是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> john.residence<span class="operator">?</span>.printNumberOfRooms() <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“It was not possible to print the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的 <a href="#accessing_properties_through_optional_chaining">通过可选链式调用访问属性</a> 的例子中，我们尝试给 <code>john.residence</code> 中的 <code>address</code> 属性赋值，即使 <code>residence</code> 为 <code>nil</code>。通过可选链式调用给属性赋值会返回 <code>Void?</code>，通过判断返回值是否为 <code>nil</code> 就可以知道赋值是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (john.residence<span class="operator">?</span>.address <span class="operator">=</span> someAddress) <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to set the address.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to set the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“It was not possible to set the address.”</span></span><br></pre></td></tr></table></figure>
<h2 id="通过可选链式调用访问下标">通过可选链式调用访问下标</h2>
<p>通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。</p>
<blockquote>
<p>注意</p>
<p>通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。</p>
</blockquote>
<p>下面这个例子用下标访问 <code>john.residence</code> 属性存储的 <code>Residence</code> 实例的 <code>rooms</code> 数组中的第一个房间的名称，因为 <code>john.residence</code> 为 <code>nil</code>，所以下标调用失败了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName <span class="operator">=</span> john.residence<span class="operator">?</span>[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first room name is <span class="subst">\(firstRoomName)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the first room name.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to retrieve the first room name.”</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，问号直接放在 <code>john.residence</code> 的后面，并且在方括号的前面，因为 <code>john.residence</code> 是可选值。</p>
<p>类似的，可以通过下标，用可选链式调用来赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="type">Room</span>(name: <span class="string">&quot;Bathroom&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这次赋值同样会失败，因为 <code>residence</code> 目前是 <code>nil</code>。</p>
<p>如果你创建一个 <code>Residence</code> 实例，并为其 <code>rooms</code> 数组添加一些 <code>Room</code> 实例，然后将 <code>Residence</code> 实例赋值给 <code>john.residence</code>，那就可以通过可选链和下标来访问数组中的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> johnsHouse <span class="operator">=</span> <span class="type">Residence</span>()</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">&quot;Living Room&quot;</span>))</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">&quot;Kitchen&quot;</span>))</span><br><span class="line">john.residence <span class="operator">=</span> johnsHouse</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName <span class="operator">=</span> john.residence<span class="operator">?</span>[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first room name is <span class="subst">\(firstRoomName)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the first room name.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The first room name is Living Room.”</span></span><br></pre></td></tr></table></figure>
<h3 id="访问可选类型的下标">访问可选类型的下标</h3>
<p>如果下标返回可选类型值，比如 Swift 中 <code>Dictionary</code> 类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testScores <span class="operator">=</span> [<span class="string">&quot;Dave&quot;</span>: [<span class="number">86</span>, <span class="number">82</span>, <span class="number">84</span>], <span class="string">&quot;Bev&quot;</span>: [<span class="number">79</span>, <span class="number">94</span>, <span class="number">81</span>]]</span><br><span class="line">testScores[<span class="string">&quot;Dave&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="number">91</span></span><br><span class="line">testScores[<span class="string">&quot;Bev&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">testScores[<span class="string">&quot;Brian&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="number">72</span></span><br><span class="line"><span class="comment">// &quot;Dave&quot; 数组现在是 [91, 82, 84]，&quot;Bev&quot; 数组现在是 [80, 94, 81]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中定义了一个 <code>testScores</code> 数组，包含了两个键值对，分别把 <code>String</code> 类型的键映射到一个 <code>Int</code> 值的数组。这个例子用可选链式调用把 <code>&quot;Dave&quot;</code> 数组中第一个元素设为 <code>91</code>，把 <code>&quot;Bev&quot;</code> 数组的第一个元素 <code>+1</code>，然后尝试把 <code>&quot;Brian&quot;</code> 数组中的第一个元素设为 <code>72</code>。前两个调用成功，因为 <code>testScores</code> 字典中包含 <code>&quot;Dave&quot;</code> 和 <code>&quot;Bev&quot;</code> 这两个键。但是 <code>testScores</code> 字典中没有 <code>&quot;Brian&quot;</code> 这个键，所以第三个调用失败。</p>
<h2 id="连接多层可选链式调用">连接多层可选链式调用</h2>
<p>可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。</p>
<p>也就是说：</p>
<ul>
<li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li>
<li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li>
</ul>
<p>因此：</p>
<ul>
<li>通过可选链式调用访问一个 <code>Int</code> 值，将会返回 <code>Int?</code>，无论使用了多少层可选链式调用。</li>
<li>类似的，通过可选链式调用访问 <code>Int?</code> 值，依旧会返回 <code>Int?</code> 值，并不会返回 <code>Int??</code>。</li>
</ul>
<p>下面的例子尝试访问 <code>john</code> 中的 <code>residence</code> 属性中的 <code>address</code> 属性中的 <code>street</code> 属性。这里使用了两层可选链式调用，<code>residence</code> 以及 <code>address</code> 都是可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s street name is <span class="subst">\(johnsStreet)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to retrieve the address.”</span></span><br></pre></td></tr></table></figure>
<p><code>john.residence</code> 现在包含一个有效的 <code>Residence</code> 实例。然而，<code>john.residence.address</code> 的值当前为 <code>nil</code>。因此，调用 <code>john.residence?.address?.street</code> 会失败。</p>
<p>需要注意的是，上面的例子中，<code>street</code> 的属性为 <code>String?</code>。<code>john.residence?.address?.street</code> 的返回值也依然是 <code>String?</code>，即使已经使用了两层可选链式调用。</p>
<p>如果为 <code>john.residence.address</code> 赋值一个 <code>Address</code> 实例，并且为 <code>address</code> 中的 <code>street</code> 属性设置一个有效值，我们就能过通过可选链式调用来访问 <code>street</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> johnsAddress <span class="operator">=</span> <span class="type">Address</span>()</span><br><span class="line">johnsAddress.buildingName <span class="operator">=</span> <span class="string">&quot;The Larches&quot;</span></span><br><span class="line">johnsAddress.street <span class="operator">=</span> <span class="string">&quot;Laurel Street&quot;</span></span><br><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> johnsAddress</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s street name is <span class="subst">\(johnsStreet)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“John&#x27;s street name is Laurel Street.”</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，因为 <code>john.residence</code> 包含一个有效的 <code>Address</code> 实例，所以对 <code>john.residence</code> 的 <code>address</code> 属性赋值将会成功。</p>
<h2 id="在方法的可选返回值上进行可选链式调用">在方法的可选返回值上进行可选链式调用</h2>
<p>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。</p>
<p>在下面的例子中，通过可选链式调用来调用 <code>Address</code> 的 <code>buildingIdentifier()</code> 方法。这个方法返回 <code>String?</code> 类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是 <code>String?</code> 类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> buildingIdentifier <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.buildingIdentifier() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s building identifier is <span class="subst">\(buildingIdentifier)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“John&#x27;s building identifier is The Larches.”</span></span><br></pre></td></tr></table></figure>
<p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> beginsWithThe <span class="operator">=</span></span><br><span class="line">    john.residence<span class="operator">?</span>.address<span class="operator">?</span>.buildingIdentifier()<span class="operator">?</span>.hasPrefix(<span class="string">&quot;The&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> beginsWithThe &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s building identifier begins with <span class="subst">\&quot;</span>The<span class="subst">\&quot;</span>.&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s building identifier does not begin with <span class="subst">\&quot;</span>The<span class="subst">\&quot;</span>.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“John&#x27;s building identifier begins with &quot;The&quot;.”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>在上面的例子中，在方法的圆括号后面加上问号是因为你要在 <code>buildingIdentifier()</code> 方法的可选返回值上进行可选链式调用，而不是 <code>buildingIdentifier()</code> 方法本身。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/07/04/Swift/swift%E5%8F%AF%E9%80%89%E9%93%BE/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/07/03/Swift/swift%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B/"
                            aria-label=": swift析构过程"
                        >
                            swift析构过程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-03T10:13:17+08:00">
	
		    2023 年 7 月 3 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="析构过程">析构过程</h2>
<p><em>析构器</em>只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字 <code>deinit</code> 来标示，类似于构造器要用 <code>init</code> 来标示。</p>
<h2 id="析构过程原理">析构过程原理</h2>
<p>Swift 会自动释放不再需要的实例以释放资源。如 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/23_Automatic_Reference_Counting.html">自动引用计数</a> 章节中所讲述，Swift 通过<em>自动引用计数（ARC)</em> 处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。</p>
<p>在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数和圆括号，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">// 执行析构过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构器是在实例释放发生前被自动调用的。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</p>
<p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。</p>
<h2 id="析构器实践">析构器实践</h2>
<p>这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是 <code>Bank</code> 和 <code>Player</code>。<code>Bank</code> 类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个 <code>Bank</code> 存在，因此 <code>Bank</code> 用类来实现，并使用类型属性和类型方法来存储和管理其当前状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> coinsInBank <span class="operator">=</span> <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">distribute</span>(<span class="params">coins</span> <span class="params">numberOfCoinsRequested</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> numberOfCoinsToVend <span class="operator">=</span> <span class="built_in">min</span>(numberOfCoinsRequested, coinsInBank)</span><br><span class="line">        coinsInBank <span class="operator">-=</span> numberOfCoinsToVend</span><br><span class="line">        <span class="keyword">return</span> numberOfCoinsToVend</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">receive</span>(<span class="params">coins</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInBank <span class="operator">+=</span> coins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bank</code> 使用 <code>coinsInBank</code> 属性来跟踪它当前拥有的硬币数量。<code>Bank</code> 还提供了两个方法，<code>distribute(coins:)</code> 和 <code>receive(coins:)</code>，分别用来处理硬币的分发和收集。</p>
<p><code>distribute(coins:)</code> 方法在 <code>Bank</code> 对象分发硬币之前检查是否有足够的硬币。如果硬币不足，<code>Bank</code> 对象会返回一个比请求时小的数字（如果 <code>Bank</code> 对象中没有硬币了就返回 <code>0</code>）。此方法返回一个整型值，表示提供的硬币的实际数量。</p>
<p><code>receive(coins:)</code> 方法只是将 <code>Bank</code> 实例接收到的硬币数目加回硬币存储中。</p>
<p><code>Player</code> 类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的 <code>coinsInPurse</code> 属性来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> coinsInPurse: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">coins</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInPurse <span class="operator">=</span> <span class="type">Bank</span>.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">win</span>(<span class="params">coins</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInPurse <span class="operator">+=</span> <span class="type">Bank</span>.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="type">Bank</span>.receive(coins: coinsInPurse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 <code>Player</code> 实例在初始化的过程中，都从 <code>Bank</code> 对象获取指定数量的硬币。如果没有足够的硬币可用，<code>Player</code> 实例可能会收到比指定数量少的硬币。</p>
<p><code>Player</code> 类定义了一个 <code>win(coins:)</code> 方法，该方法从 <code>Bank</code> 对象获取一定数量的硬币，并把它们添加到玩家的钱包。<code>Player</code> 类还实现了一个析构器，这个析构器在 <code>Player</code> 实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给 <code>Bank</code> 对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerOne: <span class="type">Player</span>? <span class="operator">=</span> <span class="type">Player</span>(coins: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A new player has joined the game with <span class="subst">\(playerOne<span class="operator">!</span>.coinsInPurse)</span> coins&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“A new player has joined the game with 100 coins”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are now <span class="subst">\(Bank.coinsInBank)</span> coins left in the bank&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“There are now 9900 coins left in the bank”</span></span><br></pre></td></tr></table></figure>
<p>创建一个 <code>Player</code> 实例的时候，会向 <code>Bank</code> 对象申请得到 100 个硬币，前提是有足够的硬币可用。这个 <code>Player</code> 实例存储在一个名为 <code>playerOne</code> 的可选类型的变量中。这里使用了一个可选类型的变量，是因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。</p>
<p>因为 <code>playerOne</code> 是可选的，所以在访问其 <code>coinsInPurse</code> 属性来打印钱包中的硬币数量和调用 <code>win(coins:)</code> 方法时，使用感叹号（<code>!</code>）强制解包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne<span class="operator">!</span>.win(coins: <span class="number">2_000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PlayerOne won 2000 coins &amp; now has <span class="subst">\(playerOne<span class="operator">!</span>.coinsInPurse)</span> coins&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“PlayerOne won 2000 coins &amp; now has 2100 coins”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The bank now only has <span class="subst">\(Bank.coinsInBank)</span> coins left&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“The bank now only has 7900 coins left”</span></span><br></pre></td></tr></table></figure>
<p>在这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而 <code>Bank</code> 对象只剩余 7,900 枚硬币。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PlayerOne has left the game&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“PlayerOne has left the game”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The bank now has <span class="subst">\(Bank.coinsInBank)</span> coins&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“The bank now has 10000 coins”</span></span><br></pre></td></tr></table></figure>
<p>玩家现在已经离开了游戏。这通过将可选类型的 <code>playerOne</code> 变量设置为 <code>nil</code> 来表示，意味着“没有 <code>Player</code> 实例”。当这一切发生时，<code>playerOne</code> 变量对 <code>Player</code> 实例的引用被破坏了。没有其它属性或者变量引用 <code>Player</code> 实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/07/03/Swift/swift%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/07/02/Swift/swift%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B/"
                            aria-label=": swift构造过程"
                        >
                            swift构造过程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-02T10:13:17+08:00">
	
		    2023 年 7 月 2 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="构造过程">构造过程</h2>
<p><em>构造过程</em>是使用类、结构体或枚举类型的实例之前的准备过程。在新实例使用前有个过程是必须的，它包括设置实例中每个存储属性的初始值和执行其他必须的设置或构造过程。</p>
<p>你要通过定义<em>构造器</em>来实现构造过程，它就像用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器没有返回值。它们的主要任务是保证某种类型的新实例在第一次使用前完成正确的初始化。</p>
<p>类的实例也可以通过实现<em>析构器</em>来执行它释放之前自定义的清理工作。想了解更多关于析构器的内容，请参 考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/15_Deinitialization.html">析构过程</a>。</p>
<h2 id="存储属性的初始赋值">存储属性的初始赋值</h2>
<p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>
<p>你可以在构造器中为存储型属性设置初始值，也可以在定义属性时分配默认值。以下小节将详细介绍这两种方法。</p>
<blockquote>
<p>注意</p>
<p>当你为存储型属性分配默认值或者在构造器中为设置初始值时，它们的值是被直接设置的，不会触发任何属性观察者。</p>
</blockquote>
<h3 id="构造器">构造器</h3>
<p>构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何形参的实例方法，以关键字 <code>init</code> 命名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="comment">// 在此处执行构造过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面例子中定义了一个用来保存华氏温度的结构体 <code>Fahrenheit</code>，它拥有一个 <code>Double</code> 类型的存储型属性 <code>temperature</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fahrenheit</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        temperature <span class="operator">=</span> <span class="number">32.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f <span class="operator">=</span> <span class="type">Fahrenheit</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The default temperature is <span class="subst">\(f.temperature)</span>° Fahrenheit&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“The default temperature is 32.0° Fahrenheit”</span></span><br></pre></td></tr></table></figure>
<p>这个结构体定义了一个不带形参的构造器 <code>init</code>，并在里面将存储型属性 <code>temperature</code> 的值初始化为 <code>32.0</code>（华氏温度下水的冰点）。</p>
<h3 id="默认属性值">默认属性值</h3>
<p>如前所述，你可以在构造器中为存储型属性设置初始值。同样，你也可以在属性声明时为其设置默认值。</p>
<blockquote>
<p>注意</p>
<p>如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的最终结果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。它能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承等特性，后续章节将讲到。</p>
</blockquote>
<p>你可以通过在属性声明时为 <code>temperature</code> 提供默认值来使用更简单的方式定义结构体 <code>Fahrenheit</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fahrenheit</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperature <span class="operator">=</span> <span class="number">32.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义构造过程">自定义构造过程</h2>
<p>你可以通过输入形参和可选属性类型来自定义构造过程，也可以在构造过程中分配常量属性。这些都将在后面章节中提到。</p>
<h3 id="形参的构造过程">形参的构造过程</h3>
<p>自定义构造过程时，可以在定义中提供<em>构造形参</em>，指定其值的类型和名字。构造形参的功能和语法跟函数和方法的形参相同。</p>
<p>下面例子中定义了一个用来保存摄氏温度的结构体 <code>Celsius</code>。它定义了两个不同的构造器：<code>init(fromFahrenheit:)</code> 和 <code>init(fromKelvin:)</code>，二者分别通过接受不同温标下的温度值来创建新的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Celsius</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boilingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>)</span><br><span class="line"><span class="comment">// boilingPointOfWater.temperatureInCelsius 是 100.0</span></span><br><span class="line"><span class="keyword">let</span> freezingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromKelvin: <span class="number">273.15</span>)</span><br><span class="line"><span class="comment">// freezingPointOfWater.temperatureInCelsius 是 0.0</span></span><br></pre></td></tr></table></figure>
<p>第一个构造器拥有一个构造形参，其实参标签为 <code>fromFahrenheit</code>，形参命名为 <code>fahrenheit</code>；第二个构造器也拥有一个构造形参，其实参标签为 <code>fromKelvin</code>，形参命名为 <code>kelvin</code>。这两个构造器都将单一的实参转换成摄氏温度值，并保存在属性 <code>temperatureInCelsius</code> 中。</p>
<h3 id="形参命名和实参标签">形参命名和实参标签</h3>
<p>跟函数和方法形参相同，构造形参可以同时使用在构造器里使用的形参命名和一个外部调用构造器时使用的实参标签。</p>
<p>然而，构造器并不像函数和方法那样在括号前有一个可辨别的方法名。因此在调用构造器时，主要通过构造器中形参命名和类型来确定应该被调用的构造器。正因如此，如果你在定义构造器时没有提供实参标签，Swift 会为构造器的<em>每个</em>形参自动生成一个实参标签。</p>
<p>以下例子中定义了一个结构体 <code>Color</code>，它包含了三个常量：<code>red</code>、<code>green</code> 和 <code>blue</code>。这些属性可以存储 <code>0.0</code> 到 <code>1.0</code> 之间的值，用来表明颜色中红、绿、蓝成分的含量。</p>
<p><code>Color</code> 提供了一个构造器，为红蓝绿提供三个合适 <code>Double</code> 类型的形参命名。<code>Color</code> 也提供了第二个构造器，它只包含名为 <code>white</code> 的 <code>Double</code> 类型的形参，它为三个颜色的属性提供相同的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> red, green, blue: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">red</span>: <span class="type">Double</span>, <span class="params">green</span>: <span class="type">Double</span>, <span class="params">blue</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.red   <span class="operator">=</span> red</span><br><span class="line">        <span class="keyword">self</span>.green <span class="operator">=</span> green</span><br><span class="line">        <span class="keyword">self</span>.blue  <span class="operator">=</span> blue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">white</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        red   <span class="operator">=</span> white</span><br><span class="line">        green <span class="operator">=</span> white</span><br><span class="line">        blue  <span class="operator">=</span> white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种构造器都能通过为每一个构造器形参提供命名值来创建一个新的 <code>Color</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> magenta <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">1.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> halfGray <span class="operator">=</span> <span class="type">Color</span>(white: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>注意，如果不通过实参标签传值，这个构造器是没法调用的。如果构造器定义了某个实参标签，就必须使用它，忽略它将导致编译期错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> veryGreen <span class="operator">=</span> <span class="type">Color</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// 报编译期错误-需要实参标签</span></span><br></pre></td></tr></table></figure>
<h3 id="不带实参标签的构造器形参">不带实参标签的构造器形参</h3>
<p>如果你不希望构造器的某个形参使用实参标签，可以使用下划线（<code>_</code>）来代替显式的实参标签来重写默认行为。</p>
<p>下面是之前 <a href="#initialization_parameters">形参的构造过程</a> 中 <code>Celsius</code> 例子的扩展，多了一个用已经的摄氏表示的 <code>Double</code> 类型值来创建新的 <code>Celsius</code> 实例的额外构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Celsius</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">celsius</span>: <span class="type">Double</span>)&#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> celsius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bodyTemperature <span class="operator">=</span> <span class="type">Celsius</span>(<span class="number">37.0</span>)</span><br><span class="line"><span class="comment">// bodyTemperature.temperatureInCelsius 为 37.0</span></span><br></pre></td></tr></table></figure>
<p>构造器调用 <code>Celsius(37.0)</code> 意图明确，不需要实参标签。因此适合使用 <code>init(_ celsius: Double)</code> 这样的构造器，从而可以通过提供未命名的 <code>Double</code> 值来调用构造器。</p>
<h3 id="可选属性类型">可选属性类型</h3>
<p>如果你自定义的类型有一个逻辑上允许值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时机可以赋值为空——都需要将它声明为 <code>可选类型</code>。可选类型的属性将自动初始化为 <code>nil</code>，表示这个属性是特意在构造过程设置为空。</p>
<p>下面例子中定义了类 <code>SurveyQuestion</code>，它包含一个可选 <code>String</code> 属性 <code>response</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SurveyQuestion</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">text</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ask</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cheeseQuestion <span class="operator">=</span> <span class="type">SurveyQuestion</span>(text: <span class="string">&quot;Do you like cheese?&quot;</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line"><span class="comment">// 打印“Do you like cheese?”</span></span><br><span class="line">cheeseQuestion.response <span class="operator">=</span> <span class="string">&quot;Yes, I do like cheese.&quot;</span></span><br></pre></td></tr></table></figure>
<p>调查问题的答案在询问前是无法确定的，因此我们将属性 <code>response</code> 声明为 <code>String?</code> 类型，或者说是 “可选类型 <code>String</code>“。当 <code>SurveyQuestion</code> 的实例初始化时，它将自动赋值为 <code>nil</code>，表明“暂时还没有字符“。</p>
<h3 id="构造过程中常量属性的赋值">构造过程中常量属性的赋值</h3>
<p>你可以在构造过程中的任意时间点给常量属性赋值，只要在构造过程结束时它设置成确定的值。一旦常量属性被赋值，它将永远不可更改。</p>
<blockquote>
<p>注意</p>
<p>对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>
</blockquote>
<p>你可以修改上面的 <code>SurveyQuestion</code> 示例，用常量属性替代变量属性 <code>text</code>，表示问题内容 <code>text</code> 在 <code>SurveyQuestion</code> 的实例被创建之后不会再被修改。尽管 <code>text</code> 属性现在是常量，我们仍然可以在类的构造器中设置它的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SurveyQuestion</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">text</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ask</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> beetsQuestion <span class="operator">=</span> <span class="type">SurveyQuestion</span>(text: <span class="string">&quot;How about beets?&quot;</span>)</span><br><span class="line">beetsQuestion.ask()</span><br><span class="line"><span class="comment">// 打印“How about beets?”</span></span><br><span class="line">beetsQuestion.response <span class="operator">=</span> <span class="string">&quot;I also like beets. (But not with cheese.)&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="默认构造器">默认构造器</h2>
<p>如果结构体或类为所有属性提供了默认值，又没有提供任何自定义的构造器，那么 Swift 会给这些结构体或类提供一个<em>默认构造器</em>。这个默认构造器将简单地创建一个所有属性值都设置为它们默认值的实例。</p>
<p>下面例子中定义了一个类 <code>ShoppingListItem</code>，它封装了购物清单中的某一物品的名字（<code>name</code>）、数量（<code>quantity</code>）和购买状态 <code>purchase state</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingListItem</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> quantity <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> item <span class="operator">=</span> <span class="type">ShoppingListItem</span>()</span><br></pre></td></tr></table></figure>
<p>由于 <code>ShoppingListItem</code> 类中的所有属性都有默认值，且它是没有父类的基类，它将自动获得一个将为所有属性设置默认值的并创建实例的默认构造器（由于 <code>name</code> 属性是可选 <code>String</code> 类型，它将接收一个默认 <code>nil</code> 的默认值，尽管代码中没有写出这个值）。上面例子中使用默认构造器创造了一个 <code>ShoppingListItem</code> 类的实例（使用 <code>ShoppingListItem()</code> 形式的构造器语法），并将其赋值给变量 <code>item</code>。</p>
<h3 id="结构体的逐一成员构造器">结构体的逐一成员构造器</h3>
<p>结构体如果没有定义任何自定义构造器，它们将自动获得一个<em>逐一成员构造器（memberwise initializer）</em>。不像默认构造器，即使存储型属性没有默认值，结构体也能会获得逐一成员构造器。</p>
<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。新实例的属性初始值可以通过名字传入逐一成员构造器中。</p>
<p>下面例子中定义了一个结构体 <code>Size</code>，它包含两个属性 <code>width</code> 和 <code>height</code>。根据这两个属性默认赋值为 <code>0.0</code> ，它们的类型被推断出来为 <code>Double</code>。</p>
<p>结构体 <code>Size</code> 自动获得了一个逐一成员构造器 <code>init(width:height:)</code>。你可以用它来创建新的 Size 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> twoByTwo <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p>当你调用一个逐一成员构造器（memberwise initializer）时，可以省略任何一个有默认值的属性。在上面这个例子中，<code>Size</code> 结构体的 <code>height</code> 和 <code>width</code> 属性各有一个默认值。你可以省略两者或两者之一，对于被省略的属性，构造器会使用默认值。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let zeroByTwo = Size(height: 2.0)</span><br><span class="line">print(zeroByTwo.width, zeroByTwo.height)</span><br><span class="line">// 打印 &quot;0.0 2.0&quot;</span><br><span class="line"></span><br><span class="line">let zeroByZero = Size()</span><br><span class="line">print(zeroByZero.width, zeroByZero.height)</span><br><span class="line">// 打印 &quot;0.0 0.0&quot;</span><br></pre></td></tr></table></figure>
<h2 id="值类型的构造器代理">值类型的构造器代理</h2>
<p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为<em>构造器代理</em>，它能避免多个构造器间的代码重复。</p>
<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类（请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/13_Inheritance.html">继承</a>）。这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。这些责任将在后续章节 <a href="#class_inheritance_and_initialization">类的继承和构造过程</a> 中介绍。</p>
<p>对于值类型，你可以使用 <code>self.init</code> 在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用 <code>self.init</code>。</p>
<p>请注意，如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。这种限制避免了在一个更复杂的构造器中做了额外的重要设置，但有人不小心使用自动生成的构造器而导致错误的情况。</p>
<blockquote>
<p>注意</p>
<p>假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（<code>extension</code>）中，而不是写在值类型的原始定义中。想查看更多内容，请查看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/20_Extensions.html">扩展</a> 章节。</p>
</blockquote>
<p>下面例子定义一个自定义结构体 <code>Rect</code>，用来代表几何矩形。这个例子需要两个辅助的结构体 <code>Size</code> 和 <code>Point</code>，它们各自为其所有的属性提供了默认初始值 <code>0.0</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过以下三种方式为 <code>Rect</code> 创建实例——使用含有默认值的 <code>origin</code> 和 <code>size</code> 属性来初始化；提供指定的 <code>origin</code> 和 <code>size</code> 实例来初始化；提供指定的 <code>center</code> 和 <code>size</code> 来初始化。在下面 <code>Rect</code> 结构体定义中，我们为这三种方式提供了三个自定义的构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个 <code>Rect</code> 构造器 <code>init()</code>，在功能上跟没有自定义构造器时自动获得的默认构造器是一样的。这个构造器是函数体是空的，使用一对大括号 <code>&#123;&#125;</code> 来表示。调用这个构造器将返回一个 <code>Rect</code> 实例，它的 <code>origin</code> 和 <code>size</code> 属性都使用定义时的默认值 <code>Point(x: 0.0, y: 0.0)</code> 和 <code>Size(width: 0.0, height: 0.0)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> basicRect <span class="operator">=</span> <span class="type">Rect</span>()</span><br><span class="line"><span class="comment">// basicRect 的 origin 是 (0.0, 0.0)，size 是 (0.0, 0.0)</span></span><br></pre></td></tr></table></figure>
<p>第二个 <code>Rect</code> 构造器 <code>init(origin:size:)</code>，在功能上跟结构体在没有自定义构造器时获得的逐一成员构造器是一样的。这个构造器只是简单地将 <code>origin</code> 和 <code>size</code> 的实参值赋给对应的存储型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> originRect <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br><span class="line"><span class="comment">// originRect 的 origin 是 (2.0, 2.0)，size 是 (5.0, 5.0)</span></span><br></pre></td></tr></table></figure>
<p>第三个 <code>Rect</code> 构造器 <code>init(center:size:)</code> 稍微复杂一点。它先通过 <code>center</code> 和 <code>size</code> 的值计算出 <code>origin</code> 的坐标，然后再调用（或者说代理给）<code>init(origin:size:)</code> 构造器来将新的 <code>origin</code> 和 <code>size</code> 值赋值到对应的属性中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect <span class="operator">=</span> <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect 的 origin 是 (2.5, 2.5)，size 是 (3.0, 3.0)</span></span><br></pre></td></tr></table></figure>
<p>构造器 <code>init(center:size:)</code> 可以直接将 <code>origin</code> 和 <code>size</code> 的新值赋值到对应的属性中。然而，构造器 <code>init(center:size:)</code> 通过使用提供了相关功能的现有构造器将会更加便捷（而且意图更清晰）。</p>
<blockquote>
<p>注意</p>
<p>如果你想用另外一种不需要自己定义 <code>init()</code> 和 <code>init(origin:size:)</code> 的方式来实现这个例子，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/21_Extensions.md">扩展</a>。</p>
</blockquote>
<h2 id="类的继承和构造过程">类的继承和构造过程</h2>
<p>类里面的所有存储型属性——包括所有继承自父类的属性——都<em>必须</em>在构造过程中设置初始值。</p>
<p>Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们被称为指定构造器和便利构造器。</p>
<h3 id="指定构造器和便利构造器">指定构造器和便利构造器</h3>
<p><em>指定构造器</em>是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并调用合适的父类构造器让构造过程沿着父类链继续往上进行。</p>
<p>类倾向于拥有极少的指定构造器，普遍的是一个类只拥有一个指定构造器。指定构造器像一个个“漏斗”放在构造过程发生的地方，让构造过程沿着父类链继续往上进行。</p>
<p>每一个类都必须至少拥有一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。具体内容请参考后续章节 <a href="#automatic_initializer_inheritance">构造器的自动继承</a>。</p>
<p><em>便利构造器</em>是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为部分形参提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</p>
<p>你应当只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。</p>
<h3 id="指定构造器和便利构造器的语法">指定构造器和便利构造器的语法</h3>
<p>类的指定构造器的写法跟值类型简单构造器一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>便利构造器也采用相同样式的写法，但需要在 <code>init</code> 关键字之前放置 <code>convenience</code> 关键字，并使用空格将它们俩分开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类类型的构造器代理">类类型的构造器代理</h3>
<p>为了简化指定构造器和便利构造器之间的调用关系，Swift 构造器之间的代理调用遵循以下三条规则：</p>
<h5 id="规则-1">规则 1</h5>
<p>指定构造器必须调用其直接父类的的指定构造器。</p>
<h5 id="规则-2">规则 2</h5>
<p>便利构造器必须调用<em>同</em>类中定义的其它构造器。</p>
<h5 id="规则-3">规则 3</h5>
<p>便利构造器最后必须调用指定构造器。</p>
<p>一个更方便记忆的方法是：</p>
<ul>
<li>指定构造器必须总是<em>向上</em>代理</li>
<li>便利构造器必须总是<em>横向</em>代理</li>
</ul>
<p>这些规则可以通过下面图例来说明：</p>
<p><img src="https://docs.swift.org/swift-book/_images/initializerDelegation01_2x.png" alt="构造器代理图"></p>
<p>如图所示，父类中包含一个指定构造器和两个便利构造器。其中一个便利构造器调用了另外一个便利构造器，而后者又调用了唯一的指定构造器。这满足了上面提到的规则 2 和 3。这个父类没有自己的父类，所以规则 1 没有用到。</p>
<p>子类中包含两个指定构造器和一个便利构造器。便利构造器必须调用两个指定构造器中的任意一个，因为它只能调用同一个类里的其他构造器。这满足了上面提到的规则 2 和 3。而两个指定构造器必须调用父类中唯一的指定构造器，这满足了规则 1。</p>
<blockquote>
<p>注意</p>
<p>这些规则不会影响类的实例如何创建。任何上图中展示的构造器都可以用来创建完全初始化的实例。这些规则只影响类的构造器如何实现。</p>
</blockquote>
<p>下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“漏斗”的作用，在类的构造器链上简化了类之间的相互关系。</p>
<p><img src="https://docs.swift.org/swift-book/_images/initializerDelegation02_2x.png" alt="复杂构造器代理图"></p>
<h3 id="两段式构造过程">两段式构造过程</h3>
<p>Swift 中类的构造过程包含两个阶段。第一个阶段，类中的每个存储型属性赋一个初始值。当每个存储型属性的初始值被赋值后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步自定义它们的存储型属性。</p>
<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>
<blockquote>
<p>注意</p>
<p>Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值 <code>0</code> 或空值（比如说 <code>0</code> 或 <code>nil</code>）。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以 <code>0</code> 或 <code>nil</code> 作为合法默认值的情况。</p>
</blockquote>
<p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程不出错地完成：</p>
<h5 id="安全检查-1">安全检查 1</h5>
<p>指定构造器必须保证它所在类的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</p>
<p>如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类的属性在它往上代理之前先完成初始化。</p>
<h5 id="安全检查-2">安全检查 2</h5>
<p>指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</p>
<h5 id="安全检查-3">安全检查 3</h5>
<p>便利构造器必须为任意属性（包括所有同类中定义的）赋新值之前代理调用其它构造器。如果没这么做，便利构造器赋予的新值将被该类的指定构造器所覆盖。</p>
<h5 id="安全检查-4">安全检查 4</h5>
<p>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 <code>self</code> 作为一个值。</p>
<p>类的实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，类的实例才是有效的，才能访问属性和调用方法。</p>
<p>以下是基于上述安全检查的两段式构造过程展示：</p>
<h5 id="阶段-1">阶段 1</h5>
<ul>
<li>类的某个指定构造器或便利构造器被调用。</li>
<li>完成类的新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器切换到父类的构造器，对其存储属性完成相同的任务。</li>
<li>这个过程沿着类的继承链一直往上执行，直到到达继承链的最顶部。</li>
<li>当到达了继承链最顶部，而且继承链的最后一个类已确保所有的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li>
</ul>
<h5 id="阶段-2">阶段 2</h5>
<ul>
<li>从继承链顶部往下，继承链中每个类的指定构造器都有机会进一步自定义实例。构造器此时可以访问 <code>self</code>、修改它的属性并调用实例方法等等。</li>
<li>最终，继承链中任意的便利构造器有机会自定义实例和使用 <code>self</code>。</li>
</ul>
<p>下图展示了在假定的子类和父类之间的构造阶段 1：</p>
<p><img src="https://docs.swift.org/swift-book/_images/twoPhaseInitialization01_2x.png" alt="构建过程阶段1"></p>
<p>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时还不能修改任何属性，它会代理到该类中的指定构造器。</p>
<p>如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着继承链一直往上完成父类的构造过程。</p>
<p>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。</p>
<p>一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，阶段 1 完成。</p>
<p>以下展示了相同构造过程的阶段 2：</p>
<p><img src="https://docs.swift.org/swift-book/_images/twoPhaseInitialization02_2x.png" alt="构建过程阶段2"></p>
<p>父类中的指定构造器现在有机会进一步自定义实例（尽管这不是必须的）。</p>
<p>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的自定义操作（这也不是必须的）。</p>
<p>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的自定义操作。</p>
<h3 id="构造器的继承和重写">构造器的继承和重写</h3>
<p>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，而在用来创建子类时的新实例时没有完全或错误被初始化。</p>
<blockquote>
<p>注意</p>
<p>父类的构造器仅会在安全和适当的某些情况下被继承。具体内容请参考后续章节 <a href="#automatic_initializer_inheritance">构造器的自动继承</a>。</p>
</blockquote>
<p>假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>
<p>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 <code>override</code> 修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上 <code>override</code> 修饰符，具体内容请参考 <a href="#default_initializers">默认构造器</a>。</p>
<p>正如重写属性，方法或者是下标，<code>override</code> 修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否被按预想中被指定。</p>
<blockquote>
<p>注意</p>
<p>当你重写一个父类的指定构造器时，你总是需要写 <code>override</code> 修饰符，即使是为了实现子类的便利构造器。</p>
</blockquote>
<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文 <a href="#initializer_delegation_for_class_types">类的构造器代理规则</a> 有所描述），因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加 <code>override</code> 修饰符。</p>
<p>在下面的例子中定义了一个叫 <code>Vehicle</code> 的基类。基类中声明了一个存储型属性 <code>numberOfWheels</code>，它是默认值为 <code>Int</code> 类型的 <code>0</code>。<code>numberOfWheels</code> 属性用在一个描述车辆特征 <code>String</code> 类型为 <code>descrpiption</code> 的计算型属性中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(numberOfWheels)</span> wheel(s)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vehicle</code> 类只为存储型属性提供默认值，也没有提供自定义构造器。因此，它会自动获得一个默认构造器，具体内容请参考 <a href="#default_initializers">默认构造器</a>。默认构造器（如果有的话）总是类中的指定构造器，可以用于创建 <code>numberOfWheels</code> 为 <code>0</code> 的 <code>Vehicle</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vehicle <span class="operator">=</span> <span class="type">Vehicle</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Vehicle: <span class="subst">\(vehicle.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Vehicle: 0 wheel(s)</span></span><br></pre></td></tr></table></figure>
<p>下面例子中定义了一个 <code>Vehicle</code> 的子类 <code>Bicycle</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span>: <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        numberOfWheels <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类 <code>Bicycle</code> 定义了一个自定义指定构造器 <code>init()</code>。这个指定构造器和父类的指定构造器相匹配，所以 <code>Bicycle</code> 中这个版本的构造器需要带上 <code>override</code> 修饰符。</p>
<p><code>Bicycle</code> 的构造器 <code>init()</code> 以调用 <code>super.init()</code> 方法开始，这个方法的作用是调用 <code>Bicycle</code> 的父类 <code>Vehicle</code> 的默认构造器。这样可以确保 <code>Bicycle</code> 在修改属性之前，它所继承的属性 <code>numberOfWheels</code> 能被 <code>Vehicle</code> 类初始化。在调用 <code>super.init()</code> 之后，属性 <code>numberOfWheels</code> 的原值被新值 <code>2</code> 替换。</p>
<p>如果你创建一个 <code>Bicycle</code> 实例，你可以调用继承的 <code>description</code> 计算型属性去查看属性 <code>numberOfWheels</code> 是否有改变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bicycle <span class="operator">=</span> <span class="type">Bicycle</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Bicycle: <span class="subst">\(bicycle.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Bicycle: 2 wheel(s)”</span></span><br></pre></td></tr></table></figure>
<p>如果子类的构造器没有在阶段 2 过程中做自定义操作，并且父类有一个无参数的自定义构造器。你可以在所有父类的存储属性赋值之后省略 <code>super.init()</code> 的调用。</p>
<p>这个例子定义了另一个 <code>Vehicle</code> 的子类 <code>Hoverboard</code> ，只设置它的 <code>color</code> 属性。这个构造器依赖隐式调用父类的构造器来完成，而不是显示调用 <code>super.init()</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hoverboard</span>: <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">color</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.color <span class="operator">=</span> color</span><br><span class="line">        <span class="comment">// super.init() 在这里被隐式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(<span class="keyword">super</span>.description)</span> in a beautiful <span class="subst">\(color)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Hoverboard</code> 的实例用 <code>Vehicle</code> 构造器里默认的轮子数量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hoverboard <span class="operator">=</span> <span class="type">Hoverboard</span>(color: <span class="string">&quot;silver&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hoverboard: <span class="subst">\(hoverboard.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Hoverboard: 0 wheel(s) in a beautiful silver</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>子类可以在构造过程修改继承来的变量属性，但是不能修改继承来的常量属性。</p>
</blockquote>
<h3 id="构造器的自动继承">构造器的自动继承</h3>
<p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。事实上，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>
<p>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则将适用：</p>
<h5 id="规则-1-2">规则 1</h5>
<p>如果子类没有定义任何指定构造器，它将自动继承父类所有的指定构造器。</p>
<h5 id="规则-2-2">规则 2</h5>
<p>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承父类所有的便利构造器。</p>
<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</p>
<blockquote>
<p>注意</p>
<p>子类可以将父类的指定构造器实现为便利构造器来满足规则 2。</p>
</blockquote>
<h3 id="指定构造器和便利构造器实践">指定构造器和便利构造器实践</h3>
<p>接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类 <code>Food</code>、<code>RecipeIngredient</code> 以及 <code>ShoppingListItem</code> 的层级结构，并将演示它们的构造器是如何相互作用的。</p>
<p>类层次中的基类是 <code>Food</code>，它是一个简单的用来封装食物名字的类。<code>Food</code> 类引入了一个叫做 <code>name</code> 的 <code>String</code> 类型的属性，并且提供了两个构造器来创建 <code>Food</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">&quot;[Unnamed]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图中展示了 <code>Food</code> 的构造器链：</p>
<p><img src="https://docs.swift.org/swift-book/_images/initializersExample01_2x.png" alt="Food 构造器链"></p>
<p>类类型没有默认的逐一成员构造器，所以 <code>Food</code> 类提供了一个接受单一参数 <code>name</code> 的指定构造器。这个构造器可以使用一个特定的名字来创建新的 <code>Food</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> namedMeat <span class="operator">=</span> <span class="type">Food</span>(name: <span class="string">&quot;Bacon&quot;</span>)</span><br><span class="line"><span class="comment">// namedMeat 的名字是 &quot;Bacon&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Food</code> 类中的构造器 <code>init(name: String)</code> 被定义为一个指定构造器，因为它能确保 <code>Food</code> 实例的所有存储型属性都被初始化。<code>Food</code> 类没有父类，所以 <code>init(name: String)</code> 构造器不需要调用 <code>super.init()</code> 来完成构造过程。</p>
<p><code>Food</code> 类同样提供了一个没有参数的便利构造器 <code>init()</code>。这个 <code>init()</code> 构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器 <code>init(name: String)</code> 并给参数 <code>name</code> 赋值为 <code>[Unnamed]</code> 来实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mysteryMeat <span class="operator">=</span> <span class="type">Food</span>()</span><br><span class="line"><span class="comment">// mysteryMeat 的名字是 [Unnamed]</span></span><br></pre></td></tr></table></figure>
<p>层级中的第二个类是 <code>Food</code> 的子类 <code>RecipeIngredient</code>。<code>RecipeIngredient</code> 类用来表示食谱中的一项原料。它引入了 <code>Int</code> 类型的属性 <code>quantity</code>（以及从 <code>Food</code> 继承过来的 <code>name</code> 属性），并且定义了两个构造器来创建 <code>RecipeIngredient</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecipeIngredient</span>: <span class="title class_ inherited__">Food</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图中展示了 <code>RecipeIngredient</code> 类的构造器链：</p>
<p><img src="https://docs.swift.org/swift-book/_images/initializersExample02_2x.png" alt="RecipeIngredient 构造器"></p>
<p><code>RecipeIngredient</code> 类拥有一个指定构造器 <code>init(name: String, quantity: Int)</code>，它可以用来填充 <code>RecipeIngredient</code> 实例的所有属性值。这个构造器一开始先将传入的 <code>quantity</code> 实参赋值给 <code>quantity</code> 属性，这个属性也是唯一在 <code>RecipeIngredient</code> 中新引入的属性。随后，构造器向上代理到父类 <code>Food</code> 的 <code>init(name: String)</code>。这个过程满足 <a href="#two_phase_initialization">两段式构造过程</a> 中的安全检查 1。</p>
<p><code>RecipeIngredient</code> 也定义了一个便利构造器 <code>init(name: String)</code>，它只通过 <code>name</code> 来创建 <code>RecipeIngredient</code> 的实例。这个便利构造器假设任意 <code>RecipeIngredient</code> 实例的 <code>quantity</code> 为 <code>1</code>，所以不需要显式的质量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个 <code>quantity</code> 为 <code>1</code> 的 <code>RecipeIngredient</code> 实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为 <code>quantity</code> 参数传递 <code>1</code>。</p>
<p><code>RecipeIngredient</code> 的便利构造器 <code>init(name: String)</code> 使用了跟 <code>Food</code> 中指定构造器 <code>init(name: String)</code> 相同的形参。由于这个便利构造器重写了父类的指定构造器 <code>init(name: String)</code>，因此必须在前面使用 <code>override</code> 修饰符（参见 <a href="#initializer_inheritance_and_overriding">构造器的继承和重写</a>）。</p>
<p>尽管 <code>RecipeIngredient</code> 将父类的指定构造器重写为了便利构造器，但是它依然提供了父类的所有指定构造器的实现。因此，<code>RecipeIngredient</code> 会自动继承父类的所有便利构造器。</p>
<p>在这个例子中，<code>RecipeIngredient</code> 的父类是 <code>Food</code>，它有一个便利构造器 <code>init()</code>。这个便利构造器会被 <code>RecipeIngredient</code> 继承。这个继承版本的 <code>init()</code> 在功能上跟 <code>Food</code> 提供的版本是一样的，只是它会代理到 <code>RecipeIngredient</code> 版本的 <code>init(name: String)</code> 而不是 <code>Food</code> 提供的版本。</p>
<p>所有的这三种构造器都可以用来创建新的 <code>RecipeIngredient</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneMysteryItem <span class="operator">=</span> <span class="type">RecipeIngredient</span>()</span><br><span class="line"><span class="keyword">let</span> oneBacon <span class="operator">=</span> <span class="type">RecipeIngredient</span>(name: <span class="string">&quot;Bacon&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> sixEggs <span class="operator">=</span> <span class="type">RecipeIngredient</span>(name: <span class="string">&quot;Eggs&quot;</span>, quantity: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>类层级中第三个也是最后一个类是 <code>RecipeIngredient</code> 的子类，叫做 <code>ShoppingListItem</code>。这个类构建了购物单中出现的某一种食谱原料。</p>
<p>购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，<code>ShoppingListItem</code> 引入了一个 Boolean（布尔类型） 的属性 <code>purchased</code>，它的默认值是 <code>false</code>。<code>ShoppingListItem</code> 还添加了一个计算型属性 <code>description</code>，它提供了关于 <code>ShoppingListItem</code> 实例的一些文字描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingListItem</span>: <span class="title class_ inherited__">RecipeIngredient</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(quantity)</span> x <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">        output <span class="operator">+=</span> purchased <span class="operator">?</span> <span class="string">&quot; ✔&quot;</span> : <span class="string">&quot; ✘&quot;</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p><code>ShoppingListItem</code> 没有定义构造器来为 <code>purchased</code> 提供初始值，因为添加到购物单的物品的初始状态总是未购买。</p>
</blockquote>
<p>因为它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，<code>ShoppingListItem</code> 将自动继承所有父类中的指定构造器和便利构造器。</p>
<p>下图展示了这三个类的构造器链：</p>
<p><img src="https://docs.swift.org/swift-book/_images/initializersExample03_2x.png" alt="三类构造器图"></p>
<p>你可以使用三个继承来的构造器来创建 <code>ShoppingListItem</code> 的新实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> breakfastList <span class="operator">=</span> [</span><br><span class="line">    <span class="type">ShoppingListItem</span>(),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">&quot;Bacon&quot;</span>),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">&quot;Eggs&quot;</span>, quantity: <span class="number">6</span>),</span><br><span class="line">]</span><br><span class="line">breakfastList[<span class="number">0</span>].name <span class="operator">=</span> <span class="string">&quot;Orange juice&quot;</span></span><br><span class="line">breakfastList[<span class="number">0</span>].purchased <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> breakfastList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 x orange juice ✔</span></span><br><span class="line"><span class="comment">// 1 x bacon ✘</span></span><br><span class="line"><span class="comment">// 6 x eggs ✘</span></span><br></pre></td></tr></table></figure>
<p>如上所述，例子中通过字面量方式创建了一个数组 <code>breakfastList</code>，它包含了三个 <code>ShoppingListItem</code> 实例，因此数组的类型也能被自动推导为 <code>[ShoppingListItem]</code>。在数组创建完之后，数组中第一个 <code>ShoppingListItem</code> 实例的名字从 <code>[Unnamed]</code> 更改为 <code>Orange juice</code>，并标记状态为已购买。打印数组中每个元素的描述显示了它们都已按照预期被赋值。</p>
<h2 id="可失败构造器">可失败构造器</h2>
<p>有时，定义一个构造器可失败的类，结构体或者枚举是很有用的。这里所指的“失败” 指的是，如给构造器传入无效的形参，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。</p>
<p>为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 <code>init</code> 关键字后面添加问号（<code>init?</code>）。</p>
<blockquote>
<p>注意</p>
<p>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p>
</blockquote>
<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过 <code>return nil</code> 语句来表明可失败构造器在何种情况下应该 “失败”。</p>
<blockquote>
<p>注意</p>
<p>严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用 <code>return nil</code> 表明可失败构造器构造失败，而不要用关键字 <code>return</code> 来表明构造成功。</p>
</blockquote>
<p>例如，实现针对数字类型转换的可失败构造器。确保数字类型之间的转换能保持精确的值，使用这个 <code>init(exactly:)</code> 构造器。如果类型转换不能保持值不变，则这个构造器构造失败。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wholeNumber: <span class="type">Double</span> <span class="operator">=</span> <span class="number">12345.0</span></span><br><span class="line"><span class="keyword">let</span> pi <span class="operator">=</span> <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> valueMaintained <span class="operator">=</span> <span class="type">Int</span>(exactly: wholeNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(wholeNumber)</span> conversion to Int maintains value of <span class="subst">\(valueMaintained)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“12345.0 conversion to Int maintains value of 12345”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> valueChanged <span class="operator">=</span> <span class="type">Int</span>(exactly: pi)</span><br><span class="line"><span class="comment">// valueChanged 是 Int? 类型，不是 Int 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> valueChanged <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(pi)</span> conversion to Int does not maintain value&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“3.14159 conversion to Int does not maintain value”</span></span><br></pre></td></tr></table></figure>
<p>下例中，定义了一个名为 <code>Animal</code> 的结构体，其中有一个名为 <code>species</code> 的 <code>String</code> 类型的常量属性。同时该结构体还定义了一个接受一个名为 <code>species</code> 的 <code>String</code> 类型形参的可失败构造器。这个可失败构造器检查传入的<code>species</code> 值是否为一个空字符串。如果为空字符串，则构造失败。否则，<code>species</code> 属性被赋值，构造成功。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">species</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> species.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.species <span class="operator">=</span> species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过该可失败构造器来尝试构建一个 <code>Animal</code> 的实例，并检查构造过程是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCreature <span class="operator">=</span> <span class="type">Animal</span>(species: <span class="string">&quot;Giraffe&quot;</span>)</span><br><span class="line"><span class="comment">// someCreature 的类型是 Animal? 而不是 Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> giraffe <span class="operator">=</span> someCreature &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;An animal was initialized with a species of <span class="subst">\(giraffe.species)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“An animal was initialized with a species of Giraffe”</span></span><br></pre></td></tr></table></figure>
<p>如果你给该可失败构造器传入一个空字符串到形参 <code>species</code>，则会导致构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anonymousCreature <span class="operator">=</span> <span class="type">Animal</span>(species: <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// anonymousCreature 的类型是 Animal?, 而不是 Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> anonymousCreature <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The anonymous creature could not be initialized&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The anonymous creature could not be initialized”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>检查空字符串的值（如 <code>&quot;&quot;</code>，而不是 <code>&quot;Giraffe&quot;</code> ）和检查值为 <code>nil</code> 的可选类型的字符串是两个完全不同的概念。上例中的空字符串（<code>&quot;&quot;</code>）其实是一个有效的，非可选类型的字符串。这里我们之所以让 <code>Animal</code> 的可失败构造器构造失败，只是因为对于 <code>Animal</code> 这个类的 <code>species</code> 属性来说，它更适合有一个具体的值，而不是空字符串。</p>
</blockquote>
<h3 id="枚举类型的可失败构造器">枚举类型的可失败构造器</h3>
<p>你可以通过一个带一个或多个形参的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的形参无法匹配任何枚举成员，则构造失败。</p>
<p>下例中，定义了一个名为 <code>TemperatureUnit</code> 的枚举类型。其中包含了三个可能的枚举状态（<code>Kelvin</code>、<code>Celsius</code> 和 <code>Fahrenheit</code>），以及一个根据表示温度单位的 <code>Character</code> 值找出合适的枚举成员的可失败构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TemperatureUnit</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span>, <span class="type">Celsius</span>, <span class="type">Fahrenheit</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">symbol</span>: <span class="type">Character</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> symbol &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;K&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Kelvin</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Celsius</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;F&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Fahrenheit</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以利用该可失败构造器在三个枚举成员中选择合适的枚举成员，当形参不能和任何枚举成员相匹配时，则构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fahrenheitUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(symbol: <span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“This is a defined temperature unit, so initialization succeeded.”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(symbol: <span class="string">&quot;X&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“This is not a defined temperature unit, so initialization failed.”</span></span><br></pre></td></tr></table></figure>
<h3 id="带原始值的枚举类型的可失败构造器">带原始值的枚举类型的可失败构造器</h3>
<p>带原始值的枚举类型会自带一个可失败构造器 <code>init?(rawValue:)</code>，该可失败构造器有一个合适的原始值类型的 <code>rawValue</code> 形参，选择找到的相匹配的枚举成员，找不到则构造失败。</p>
<p>因此上面的 <code>TemperatureUnit</code> 的例子可以用原始值类型的 <code>Character</code> 和进阶的 <code>init?(rawValue:)</code> 构造器重写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TemperatureUnit</span>: <span class="title class_ inherited__">Character</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span> <span class="operator">=</span> <span class="string">&quot;K&quot;</span>, <span class="type">Celsius</span> <span class="operator">=</span> <span class="string">&quot;C&quot;</span>, <span class="type">Fahrenheit</span> <span class="operator">=</span> <span class="string">&quot;F&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(rawValue: <span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“This is a defined temperature unit, so initialization succeeded.”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(rawValue: <span class="string">&quot;X&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“This is not a defined temperature unit, so initialization failed.”</span></span><br></pre></td></tr></table></figure>
<h3 id="构造失败的传递">构造失败的传递</h3>
<p>类、结构体、枚举的可失败构造器可以横向代理到它们自己其他的可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>
<p>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</p>
<blockquote>
<p>注意</p>
<p>可失败构造器也可以代理到其它的不可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。</p>
</blockquote>
<p>下面这个例子，定义了一个名为 <code>CartItem</code> 的 <code>Product</code> 类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为 <code>quantity</code> 的常量存储型属性，并确保该属性的值至少为 <code>1</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CartItem</span>: <span class="title class_ inherited__">Product</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> quantity <span class="operator">&lt;</span> <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CartItem</code> 可失败构造器首先验证接收的 <code>quantity</code> 值是否大于等于 1 。倘若 <code>quantity</code> 值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样地，<code>Product</code> 的可失败构造器首先检查 <code>name</code> 值，假如 <code>name</code> 值为空字符串，则构造器立即执行失败。</p>
<p>如果你通过传入一个非空字符串 <code>name</code> 以及一个值大于等于 1 的 <code>quantity</code> 来创建一个 <code>CartItem</code> 实例，那么构造方法能够成功被执行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> twoSocks <span class="operator">=</span> <span class="type">CartItem</span>(name: <span class="string">&quot;sock&quot;</span>, quantity: <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item: <span class="subst">\(twoSocks.name)</span>, quantity: <span class="subst">\(twoSocks.quantity)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Item: sock, quantity: 2”</span></span><br></pre></td></tr></table></figure>
<p>倘若你以一个值为 0 的 <code>quantity</code> 来创建一个 <code>CartItem</code> 实例，那么将导致 <code>CartItem</code> 构造器失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> zeroShirts <span class="operator">=</span> <span class="type">CartItem</span>(name: <span class="string">&quot;shirt&quot;</span>, quantity: <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item: <span class="subst">\(zeroShirts.name)</span>, quantity: <span class="subst">\(zeroShirts.quantity)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to initialize zero shirts&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to initialize zero shirts”</span></span><br></pre></td></tr></table></figure>
<p>同样地，如果你尝试传入一个值为空字符串的 <code>name</code> 来创建一个 <code>CartItem</code> 实例，那么将导致父类 <code>Product</code> 的构造过程失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oneUnnamed <span class="operator">=</span> <span class="type">CartItem</span>(name: <span class="string">&quot;&quot;</span>, quantity: <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item: <span class="subst">\(oneUnnamed.name)</span>, quantity: <span class="subst">\(oneUnnamed.quantity)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to initialize one unnamed product&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to initialize one unnamed product”</span></span><br></pre></td></tr></table></figure>
<h3 id="重写一个可失败构造器">重写一个可失败构造器</h3>
<p>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>
<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。</p>
<blockquote>
<p>注意</p>
<p>你可以用非可失败构造器重写可失败构造器，但反过来却不行。</p>
</blockquote>
<p>下例定义了一个名为 <code>Document</code> 的类。这个类模拟一个文档并可以用 <code>name</code> 属性来构造，属性的值必须为一个非空字符串或 <code>nil</code>，但不能是一个空字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="comment">// 该构造器创建了一个 name 属性的值为 nil 的 document 实例</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 该构造器创建了一个 name 属性的值为非空字符串的 document 实例</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个例子，定义了一个 <code>Document</code> 类的子类 <code>AutomaticallyNamedDocument</code>。这个子类重写了所有父类引入的指定构造器。这些重写确保了无论是使用 <code>init()</code> 构造器，还是使用 <code>init(name:)</code> 构造器，在没有名字或者形参传入空字符串时，生成的实例中的 <code>name</code> 属性总有初始值 <code>&quot;[Untitled]&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutomaticallyNamedDocument</span>: <span class="title class_ inherited__">Document</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;[Untitled]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;[Untitled]&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutomaticallyNamedDocument</code> 用一个不可失败构造器 <code>init(name:)</code> 重写了父类的可失败构造器 <code>init?(name:)</code>。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个不可失败构造器代替了父类的可失败构造器。</p>
<p>你可以在子类的不可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的 <code>UntitledDocument</code> 子类的 <code>name</code> 属性的值总是 <code>&quot;[Untitled]&quot;</code>，它在构造过程中使用了父类的可失败构造器 <code>init?(name:)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UntitledDocument</span>: <span class="title class_ inherited__">Document</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">&quot;[Untitled]&quot;</span>)<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果在调用父类的可失败构造器 <code>init?(name:)</code> 时传入的是空字符串，那么强制解包操作会引发运行时错误。不过，因为这里是通过字符串常量来调用它，构造器不会失败，所以并不会发生运行时错误。</p>
<h3 id="init-可失败构造器">init! 可失败构造器</h3>
<p>通常来说我们通过在 <code>init</code> 关键字后添加问号的方式（<code>init?</code>）来定义一个可失败构造器，但你也可以通过在 <code>init</code> 后面添加感叹号的方式来定义一个可失败构造器（<code>init!</code>），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>
<p>你可以在 <code>init?</code> 中代理到 <code>init!</code>，反之亦然。你也可以用 <code>init?</code> 重写 <code>init!</code>，反之亦然。你还可以用 <code>init</code> 代理到 <code>init!</code>，不过，一旦 <code>init!</code> 构造失败，则会触发一个断言。</p>
<h2 id="必要构造器">必要构造器</h2>
<p>在类的构造器前添加 <code>required</code> 修饰符表明所有该类的子类都必须实现该构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加 <code>required</code> 修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 <code>override</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubclass</span>: <span class="title class_ inherited__">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。</p>
</blockquote>
<h2 id="通过闭包或函数设置属性的默认值">通过闭包或函数设置属性的默认值</h2>
<p>如果某个存储型属性的默认值需要一些自定义或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被构造时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>
<p>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>
<p>下面模板介绍了如何用闭包为属性提供默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="comment">// 在这个闭包中给 someProperty 创建一个默认值</span></span><br><span class="line">        <span class="comment">// someValue 必须和 SomeType 类型相同</span></span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意闭包结尾的花括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>
<blockquote>
<p>注意</p>
<p>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的 <code>self</code> 属性，或者调用任何实例方法。</p>
</blockquote>
<p>下面例子中定义了一个结构体 <code>Chessboard</code>，它构建了西洋跳棋游戏的棋盘，西洋跳棋游戏在一副黑白格交替的 8 x 8 的棋盘中进行的：</p>
<p><img src="https://docs.swift.org/swift-book/_images/chessBoard_2x.png" alt="西洋跳棋棋盘"></p>
<p>为了呈现这副游戏棋盘，<code>Chessboard</code> 结构体定义了一个属性 <code>boardColors</code>，它是一个包含 <code>64</code> 个 <code>Bool</code> 值的数组。在数组中，值为 <code>true</code> 的元素表示一个黑格，值为 <code>false</code> 的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。</p>
<p><code>boardColors</code> 数组是通过一个闭包来初始化并设置颜色值的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Chessboard</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> boardColors: [<span class="type">Bool</span>] <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> temporaryBoard <span class="operator">=</span> [<span class="type">Bool</span>]()</span><br><span class="line">        <span class="keyword">var</span> isBlack <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">8</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">8</span> &#123;</span><br><span class="line">                temporaryBoard.append(isBlack)</span><br><span class="line">                isBlack <span class="operator">=</span> <span class="operator">!</span>isBlack</span><br><span class="line">            &#125;</span><br><span class="line">            isBlack <span class="operator">=</span> <span class="operator">!</span>isBlack</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temporaryBoard</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">squareIsBlackAt</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boardColors[(row <span class="operator">*</span> <span class="number">8</span>) <span class="operator">+</span> column]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个新的 <code>Chessboard</code> 实例被创建时，赋值闭包则会被执行，<code>boardColors</code> 的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组 <code>temporaryBoard</code> 中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到 <code>boardColors</code> 中，并可以通过工具函数 <code>squareIsBlackAtRow</code> 来查询：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> board <span class="operator">=</span> <span class="type">Chessboard</span>()</span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAt(row: <span class="number">0</span>, column: <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 打印“true”</span></span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAt(row: <span class="number">7</span>, column: <span class="number">7</span>))</span><br><span class="line"><span class="comment">// 打印“false”</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/07/02/Swift/swift%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/07/01/Swift/swift%E7%BB%A7%E6%89%BF/"
                            aria-label=": swift继承"
                        >
                            swift继承
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-01T10:13:17+08:00">
	
		    2023 年 7 月 1 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="继承">继承</h2>
<p>一个类可以<em>继承</em>另一个类的方法，属性和其它特性。当一个类继承其它类时，继承类叫<em>子类</em>，被继承类叫<em>超类（或父类）</em>。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。</p>
<p>在 Swift 中，类可以调用和访问超类的方法、属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>
<p>可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。</p>
<h2 id="定义一个基类">定义一个基类</h2>
<p>不继承于其它类的类，称之为<em>基类</em>。</p>
<blockquote>
<p>注意</p>
<p>Swift 中的类并不是从一个通用的基类继承而来的。如果你不为自己定义的类指定一个超类的话，这个类就会自动成为基类。</p>
</blockquote>
<p>下面的例子定义了一个叫 <code>Vehicle</code> 的基类。这个基类声明了一个名为 <code>currentSpeed</code>，默认值是 <code>0.0</code> 的存储型属性（属性类型推断为 <code>Double</code>）。<code>currentSpeed</code> 属性的值被一个 <code>String</code> 类型的只读计算型属性 <code>description</code> 使用，用来创建对于车辆的描述。</p>
<p><code>Vehicle</code> 基类还定义了一个名为 <code>makeNoise</code> 的方法。这个方法实际上不为 <code>Vehicle</code> 实例做任何事，但之后将会被 <code>Vehicle</code> 的子类定制：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentSpeed <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;traveling at <span class="subst">\(currentSpeed)</span> miles per hour&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeNoise</span>() &#123;</span><br><span class="line">        <span class="comment">// 什么也不做——因为车辆不一定会有噪音</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用初始化语法创建一个 <code>Vehicle</code> 的新实例，即类名后面跟一个空括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someVehicle <span class="operator">=</span> <span class="type">Vehicle</span>()</span><br></pre></td></tr></table></figure>
<p>现在已经创建了一个 <code>Vehicle</code> 的新实例，你可以访问它的 <code>description</code> 属性来打印车辆的当前速度：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Vehicle: <span class="subst">\(someVehicle.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Vehicle: traveling at 0.0 miles per hour”</span></span><br></pre></td></tr></table></figure>
<p><code>Vehicle</code> 类定义了一个具有通用特性的车辆类，但实际上对于它本身来说没什么用处。为了让它变得更加有用，还需要进一步完善它，从而能够描述一个具体类型的车辆。</p>
<h2 id="子类生成">子类生成</h2>
<p><em>子类生成</em>指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以进一步完善。你还可以为子类添加新的特性。</p>
<p>为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_ inherited__">SomeSuperclass</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是子类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个例子，定义了一个叫 <code>Bicycle</code> 的子类，继承自父类 <code>Vehicle</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span>: <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hasBasket <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的 <code>Bicycle</code> 类自动继承 <code>Vehicle</code> 类的所有特性，比如 <code>currentSpeed</code> 和 <code>description</code> 属性，还有 <code>makeNoise()</code> 方法。</p>
<p>除了所继承的特性，<code>Bicycle</code> 类还定义了一个默认值为 <code>false</code> 的存储型属性 <code>hasBasket</code>（属性推断为 <code>Bool</code>）。</p>
<p>默认情况下，你创建的所有新的 <code>Bicycle</code> 实例不会有一个篮子（即 <code>hasBasket</code> 属性默认为 <code>false</code>）。创建该实例之后，你可以为 <code>Bicycle</code> 实例设置 <code>hasBasket</code> 属性为 <code>ture</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bicycle <span class="operator">=</span> <span class="type">Bicycle</span>()</span><br><span class="line">bicycle.hasBasket <span class="operator">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>你还可以修改 <code>Bicycle</code> 实例所继承的 <code>currentSpeed</code> 属性，和查询实例所继承的 <code>description</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bicycle.currentSpeed <span class="operator">=</span> <span class="number">15.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Bicycle: <span class="subst">\(bicycle.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Bicycle: traveling at 15.0 miles per hour”</span></span><br></pre></td></tr></table></figure>
<p>子类还可以继续被其它类继承，下面的示例为 <code>Bicycle</code> 创建了一个名为 <code>Tandem</code>（双人自行车）的子类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tandem</span>: <span class="title class_ inherited__">Bicycle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentNumberOfPassengers <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Tandem</code> 从 <code>Bicycle</code> 继承了所有的属性与方法，这又使它同时继承了 <code>Vehicle</code> 的所有属性与方法。<code>Tandem</code> 也增加了一个新的叫做 <code>currentNumberOfPassengers</code> 的存储型属性，默认值为 <code>0</code>。</p>
<p>如果你创建了一个 <code>Tandem</code> 的实例，你可以使用它所有的新属性和继承的属性，还能查询从 <code>Vehicle</code> 继承来的只读属性 <code>description</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tandem <span class="operator">=</span> <span class="type">Tandem</span>()</span><br><span class="line">tandem.hasBasket <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">tandem.currentNumberOfPassengers <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">tandem.currentSpeed <span class="operator">=</span> <span class="number">22.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Tandem: <span class="subst">\(tandem.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印：“Tandem: traveling at 22.0 miles per hour”</span></span><br></pre></td></tr></table></figure>
<h2 id="重写">重写</h2>
<p>子类可以为继承来的实例方法，类方法，实例属性，类属性，或下标提供自己定制的实现。我们把这种行为叫<em>重写</em>。</p>
<p>如果要重写某个特性，你需要在重写定义的前面加上 <code>override</code> 关键字。这么做，就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。意外的重写行为可能会导致不可预知的错误，任何缺少 <code>override</code> 关键字的重写都会在编译时被认定为错误。</p>
<p><code>override</code> 关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>
<h3 id="访问超类的方法，属性及下标">访问超类的方法，属性及下标</h3>
<p>当你在子类中重写超类的方法，属性或下标时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。</p>
<p>在合适的地方，你可以通过使用 <code>super</code> 前缀来访问超类版本的方法，属性或下标：</p>
<ul>
<li>在方法 <code>someMethod()</code> 的重写实现中，可以通过 <code>super.someMethod()</code> 来调用超类版本的 <code>someMethod()</code> 方法。</li>
<li>在属性 <code>someProperty</code> 的 getter 或 setter 的重写实现中，可以通过 <code>super.someProperty</code> 来访问超类版本的 <code>someProperty</code> 属性。</li>
<li>在下标的重写实现中，可以通过 <code>super[someIndex]</code> 来访问超类版本中的相同下标。</li>
</ul>
<h3 id="重写方法">重写方法</h3>
<p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。</p>
<p>下面的例子定义了 <code>Vehicle</code> 的一个新的子类，叫 <code>Train</code>，它重写了从 <code>Vehicle</code> 类继承来的 <code>makeNoise()</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Train</span>: <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">makeNoise</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Choo Choo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你创建一个 <code>Train</code> 的新实例，并调用了它的 <code>makeNoise()</code> 方法，你就会发现 <code>Train</code> 版本的方法被调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> train <span class="operator">=</span> <span class="type">Train</span>()</span><br><span class="line">train.makeNoise()</span><br><span class="line"><span class="comment">// 打印“Choo Choo”</span></span><br></pre></td></tr></table></figure>
<h3 id="重写属性">重写属性</h3>
<p>你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器，使重写的属性可以观察到底层的属性值什么时候发生改变。</p>
<h4 id="重写属性的-Getters-和-Setters">重写属性的 Getters 和 Setters</h4>
<p>你可以提供定制的 getter（或 setter）来重写任何一个继承来的属性，无论这个属性是存储型还是计算型属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必须将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。</p>
<p>你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。</p>
<blockquote>
<p>注意</p>
<p>如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过 <code>super.someProperty</code> 来返回继承来的值，其中 <code>someProperty</code> 是你要重写的属性的名字。</p>
</blockquote>
<p>以下的例子定义了一个新类，叫 <code>Car</code>，它是 <code>Vehicle</code> 的子类。这个类引入了一个新的存储型属性叫做 <code>gear</code>，默认值为整数 <code>1</code>。<code>Car</code> 类重写了继承自 <code>Vehicle</code> 的 <code>description</code> 属性，提供包含当前档位的自定义描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> gear <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.description <span class="operator">+</span> <span class="string">&quot; in gear <span class="subst">\(gear)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的 <code>description</code> 属性首先要调用 <code>super.description</code> 返回 <code>Vehicle</code> 类的 <code>description</code> 属性。之后，<code>Car</code> 类版本的 <code>description</code> 在末尾增加了一些额外的文本来提供关于当前档位的信息。</p>
<p>如果你创建了 <code>Car</code> 的实例并且设置了它的 <code>gear</code> 和 <code>currentSpeed</code> 属性，你可以看到它的 <code>description</code> 返回了 <code>Car</code> 中的自定义描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car <span class="operator">=</span> <span class="type">Car</span>()</span><br><span class="line">car.currentSpeed <span class="operator">=</span> <span class="number">25.0</span></span><br><span class="line">car.gear <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Car: <span class="subst">\(car.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Car: traveling at 25.0 miles per hour in gear 3”</span></span><br></pre></td></tr></table></figure>
<h4 id="重写属性观察器">重写属性观察器</h4>
<p>你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，无论被继承属性原本是如何实现的，当其属性值发生改变时，你就会被通知到。关于属性观察器的更多内容，请看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/10_Properties.html#property_observers">属性观察器</a>。</p>
<blockquote>
<p>注意</p>
<p>你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供 <code>willSet</code> 或 <code>didSet</code> 实现也是不恰当。 此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>
</blockquote>
<p>下面的例子定义了一个新类叫 <code>AutomaticCar</code>，它是 <code>Car</code> 的子类。<code>AutomaticCar</code> 表示自动档汽车，它可以根据当前的速度自动选择合适的档位:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutomaticCar</span>: <span class="title class_ inherited__">Car</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> currentSpeed: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            gear <span class="operator">=</span> <span class="type">Int</span>(currentSpeed <span class="operator">/</span> <span class="number">10.0</span>) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你设置 <code>AutomaticCar</code> 的 <code>currentSpeed</code> 属性，属性的 <code>didSet</code> 观察器就会自动地设置 <code>gear</code> 属性，为新的速度选择一个合适的档位。具体来说就是，属性观察器将新的速度值除以 <code>10</code>，然后向下取得最接近的整数值，最后加 <code>1</code> 来得到档位 <code>gear</code> 的值。例如，速度为 <code>35.0</code> 时，档位为 <code>4</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> automatic <span class="operator">=</span> <span class="type">AutomaticCar</span>()</span><br><span class="line">automatic.currentSpeed <span class="operator">=</span> <span class="number">35.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AutomaticCar: <span class="subst">\(automatic.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“AutomaticCar: traveling at 35.0 miles per hour in gear 4”</span></span><br></pre></td></tr></table></figure>
<h2 id="防止重写">防止重写</h2>
<p>你可以通过把方法，属性或下标标记为 <em><code>final</code></em> 来防止它们被重写，只需要在声明关键字前加上 <code>final</code> 修饰符即可（例如：<code>final var</code>、<code>final func</code>、<code>final class func</code> 以及 <code>final subscript</code>）。</p>
<p>任何试图对带有 <code>final</code> 标记的方法、属性或下标进行重写的代码，都会在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 <code>final</code>。</p>
<p>可以通过在关键字 <code>class</code> 前添加 <code>final</code> 修饰符（<code>final class</code>）来将整个类标记为 final 。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/07/01/Swift/swift%E7%BB%A7%E6%89%BF/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/06/30/Swift/swift%E4%B8%8B%E6%A0%87/"
                            aria-label=": swift下标"
                        >
                            swift下标
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-30T10:13:17+08:00">
	
		    2023 年 6 月 30 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="下标">下标</h2>
<p><em>下标</em>可以定义在类、结构体和枚举中，是访问集合、列表或序列中元素的快捷方式。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。举例来说，用下标访问一个 <code>Array</code> 实例中的元素可以写作 <code>someArray[index]</code>，访问 <code>Dictionary</code> 实例中的元素可以写作 <code>someDictionary[key]</code>。</p>
<p>一个类型可以定义多个下标，通过不同索引类型进行重载。下标不限于一维，你可以定义具有多个入参的下标满足自定义类型的需求。</p>
<h2 id="下标语法">下标语法</h2>
<p>下标允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。与定义实例方法类似，定义下标使用 <code>subscript</code> 关键字，指定一个或多个输入参数和返回类型；与实例方法不同的是，下标可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类似计算型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="comment">// 返回一个适当的 Int 类型的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="comment">// 执行适当的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newValue</code> 的类型和下标的返回类型相同。如同计算型属性，可以不指定 setter 的参数（<code>newValue</code>）。如果不指定参数，setter 会提供一个名为 <code>newValue</code> 的默认参数。</p>
<p>如同只读计算型属性，可以省略只读下标的 <code>get</code> 关键字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个适当的 Int 类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面代码演示了只读下标的实现，这里定义了一个 <code>TimesTable</code> 结构体，用来表示传入整数的乘法表：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TimesTable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> multiplier: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplier <span class="operator">*</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeTimesTable <span class="operator">=</span> <span class="type">TimesTable</span>(multiplier: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;six times three is <span class="subst">\(threeTimesTable[<span class="number">6</span>])</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“six times three is 18”</span></span><br></pre></td></tr></table></figure>
<p>在上例中，创建了一个 <code>TimesTable</code> 实例，用来表示整数 <code>3</code> 的乘法表。数值 <code>3</code> 被传递给结构体的构造函数，作为实例成员 <code>multiplier</code> 的值。</p>
<p>你可以通过下标访问 <code>threeTimesTable</code> 实例，例如上面演示的 <code>threeTimesTable[6]</code>。这条语句查询了 <code>3</code> 的乘法表中的第六个元素，返回 <code>3</code> 的 <code>6</code> 倍即 <code>18</code>。</p>
<blockquote>
<p>注意</p>
<p><code>TimesTable</code> 例子基于一个固定的数学公式，对 <code>threeTimesTable[someIndex]</code> 进行赋值操作并不合适，因此下标定义为只读的。</p>
</blockquote>
<h2 id="下标用法">下标用法</h2>
<p>下标的确切含义取决于使用场景。下标通常作为访问集合，列表或序列中元素的快捷方式。你可以针对自己特定的类或结构体的功能来自由地以最恰当的方式实现下标。</p>
<p>例如，Swift 的 <code>Dictionary</code> 类型实现下标用于对其实例中储存的值进行存取操作。为字典设值时，在下标中使用和字典的键类型相同的键，并把一个和字典的值类型相同的值赋给这个下标：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberOfLegs <span class="operator">=</span> [<span class="string">&quot;spider&quot;</span>: <span class="number">8</span>, <span class="string">&quot;ant&quot;</span>: <span class="number">6</span>, <span class="string">&quot;cat&quot;</span>: <span class="number">4</span>]</span><br><span class="line">numberOfLegs[<span class="string">&quot;bird&quot;</span>] <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上例定义一个名为 <code>numberOfLegs</code> 的变量，并用一个包含三对键值的字典字面量初始化它。<code>numberOfLegs</code> 字典的类型被推断为 <code>[String: Int]</code>。字典创建完成后，该例子通过下标将 <code>String</code> 类型的键 <code>bird</code> 和 <code>Int</code> 类型的值 <code>2</code> 添加到字典中。</p>
<p>更多关于 <code>Dictionary</code> 下标的信息请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/04_Collection_Types.html#accessing_and_modifying_a_dictionary">读取和修改字典</a>。</p>
<blockquote>
<p>注意</p>
<p>Swift 的 <code>Dictionary</code> 类型的下标接受并返回可选类型的值。上例中的 <code>numberOfLegs</code> 字典通过下标返回的是一个 <code>Int?</code> 或者说“可选的 int”。<code>Dictionary</code> 类型之所以如此实现下标，是因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为 <code>nil</code> 即可。</p>
</blockquote>
<h2 id="下标选项">下标选项</h2>
<p>下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用可变参数，并且可以提供默认参数数值，但是不能使用输入输出参数。</p>
<p>一个类或结构体可以根据自身需要提供多个下标实现，使用下标时将通过入参的数量和类型进行区分，自动匹配合适的下标，这就是<em>下标的重载</em>。</p>
<p>虽然接受单一入参的下标是最常见的，但也可以根据情况定义接受多个入参的下标。例如下例定义了一个 <code>Matrix</code> 结构体，用于表示一个 <code>Double</code> 类型的二维矩阵。<code>Matrix</code> 结构体的下标接受两个整型参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">rows</span>: <span class="type">Int</span>, <span class="params">columns</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows <span class="operator">=</span> rows</span><br><span class="line">        <span class="keyword">self</span>.columns <span class="operator">=</span> columns</span><br><span class="line">        grid <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.0</span>, count: rows <span class="operator">*</span> columns)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">indexIsValid</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> row <span class="operator">&lt;</span> rows <span class="operator">&amp;&amp;</span> column <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> column <span class="operator">&lt;</span> columns</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValid(row: row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValid(row: row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Matrix</code> 提供了一个接受两个入参的构造方法，入参分别是 <code>rows</code> 和 <code>columns</code>，创建了一个足够容纳 <code>rows * columns</code> 个 <code>Double</code> 类型的值的数组。通过传入数组长度和初始值 <code>0.0</code> 到数组的构造器，将矩阵中每个位置的值初始化为 <code>0.0</code>。关于数组的这种构造方法请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/04_Collection_Types.html#creating_an_array_with_a_default_value">创建一个带有默认值的数组</a>。</p>
<p>你可以通过传入合适的 <code>row</code> 和 <code>column</code> 的数量来构造一个新的 <code>Matrix</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix <span class="operator">=</span> <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上例中创建了一个 <code>Matrix</code> 实例来表示两行两列的矩阵。该 <code>Matrix</code> 实例的 <code>grid</code> 数组按照从左上到右下的阅读顺序将矩阵扁平化存储：</p>
<p><img src="https://docs.swift.org/swift-book/_images/subscriptMatrix01_2x.png" alt=""></p>
<p>将 <code>row</code> 和 <code>column</code> 的值传入下标来为矩阵设值，下标的入参使用逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] <span class="operator">=</span> <span class="number">1.5</span></span><br><span class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] <span class="operator">=</span> <span class="number">3.2</span></span><br></pre></td></tr></table></figure>
<p>上面两条语句分别调用下标的 setter 将矩阵右上角位置（即 <code>row</code> 为 <code>0</code>、<code>column</code> 为 <code>1</code> 的位置）的值设置为 <code>1.5</code>，将矩阵左下角位置（即 <code>row</code> 为 <code>1</code>、<code>column</code> 为 <code>0</code> 的位置）的值设置为 <code>3.2</code>：</p>
<p><img src="https://docs.swift.org/swift-book/_images/subscriptMatrix02_2x.png" alt=""></p>
<p><code>Matrix</code> 下标的 getter 和 setter 中都含有断言，用来检查下标入参 <code>row</code> 和 <code>column</code> 的值是否有效。为了方便进行断言，<code>Matrix</code> 包含了一个名为 <code>indexIsValid(row:column:)</code> 的便利方法，用来检查入参 <code>row</code> 和 <code>column</code> 的值是否在矩阵范围内：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">indexIsValid</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> row <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> row <span class="operator">&lt;</span> rows <span class="operator">&amp;&amp;</span> column <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> column <span class="operator">&lt;</span> columns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>断言在下标越界时触发：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue <span class="operator">=</span> matrix[<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// 断言将会触发，因为 [2, 2] 已经超过了 matrix 的范围</span></span><br></pre></td></tr></table></figure>
<h2 id="类型下标">类型下标</h2>
<p>正如上节所述，实例下标是在特定类型的一个实例上调用的下标。你也可以定义一种在这个类型本身上调用的下标。这种下标的类型被称作类型下标。你可以通过在 <code>subscript</code> 关键字之前写下 <code>static</code> 关键字的方式来表示一个类型下标。类可以使用 <code>class</code> 关键字来允许子类重写父类中对那个下标的实现。下面的例子展示了如何定义和调用一个类型下标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Planet: Int &#123;</span><br><span class="line">    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">    static subscript(n: Int) -&gt; Planet &#123;</span><br><span class="line">        return Planet(rawValue: n)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mars = Planet[4]</span><br><span class="line">print(mars)</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/06/30/Swift/swift%E4%B8%8B%E6%A0%87/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/06/29/Swift/swift%E6%96%B9%E6%B3%95/"
                            aria-label=": swift方法"
                        >
                            swift方法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-29T10:13:17+08:00">
	
		    2023 年 6 月 29 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="方法">方法</h2>
<p><em>方法</em>是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。</p>
<p>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在你创建的类型（类/结构体/枚举）上定义方法。</p>
<h2 id="实例方法（Instance-Methods）">实例方法（Instance Methods）</h2>
<p><em>实例方法</em>是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致，详情参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html">函数</a>。</p>
<p>实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法不能脱离于现存的实例而被调用。</p>
<p>下面的例子，定义一个很简单的 <code>Counter</code> 类，<code>Counter</code> 能被用来对一个动作发生的次数进行计数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">        count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>(<span class="params">by</span> <span class="params">amount</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        count <span class="operator">+=</span> amount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">reset</span>() &#123;</span><br><span class="line">        count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Counter</code> 类定义了三个实例方法：</p>
<ul>
<li><code>increment</code> 让计数器按一递增；</li>
<li><code>increment(by: Int)</code> 让计数器按一个指定的整数值递增；</li>
<li><code>reset</code> 将计数器重置为0。</li>
</ul>
<p><code>Counter</code> 这个类还声明了一个可变属性 <code>count</code>，用它来保持对当前计数器值的追踪。</p>
<p>和调用属性一样，用点语法（dot syntax）调用实例方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter <span class="operator">=</span> <span class="type">Counter</span>()</span><br><span class="line"><span class="comment">// 初始计数值是0</span></span><br><span class="line">counter.increment()</span><br><span class="line"><span class="comment">// 计数值现在是1</span></span><br><span class="line">counter.increment(by: <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 计数值现在是6</span></span><br><span class="line">counter.reset()</span><br><span class="line"><span class="comment">// 计数值现在是0</span></span><br></pre></td></tr></table></figure>
<p>函数参数可以同时有一个局部名称（在函数体内部使用）和一个外部名称（在调用函数时使用），详情参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#specifying_external_parameter_names">指定外部参数名</a>。方法参数也一样，因为方法就是函数，只是这个函数与某个类型相关联了。</p>
<h3 id="self-属性">self 属性</h3>
<p>类型的每一个实例都有一个隐含属性叫做 <code>self</code>，<code>self</code> 完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的 <code>self</code> 属性来引用当前实例。</p>
<p>上面例子中的 <code>increment</code> 方法还可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，你不必在你的代码里面经常写 <code>self</code>。不论何时，只要在一个方法中使用一个已知的属性或者方法名称，如果你没有明确地写 <code>self</code>，Swift 假定你是指当前实例的属性或者方法。这种假定在上面的 <code>Counter</code> 中已经示范了：<code>Counter</code> 中的三个实例方法中都使用的是 <code>count</code>（而不是 <code>self.count</code>）。</p>
<p>使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用 <code>self</code> 属性来区分参数名称和属性名称。</p>
<p>下面的例子中，<code>self</code> 消除方法参数 <code>x</code> 和实例属性 <code>x</code> 之间的歧义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isToTheRightOf</span>(<span class="params">x</span>: <span class="type">Double</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.x <span class="operator">&gt;</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> somePoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">if</span> somePoint.isToTheRightOf(x: <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This point is to the right of the line where x == 1.0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“This point is to the right of the line where x == 1.0”</span></span><br></pre></td></tr></table></figure>
<p>如果不使用 <code>self</code> 前缀，Swift会认为 <code>x</code> 的两个用法都引用了名为 <code>x</code> 的方法参数。</p>
<h3 id="在实例方法中修改值类型">在实例方法中修改值类型</h3>
<p>结构体和枚举是<em>值类型</em>。默认情况下，值类型的属性不能在它的实例方法中被修改。</p>
<p>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择 <code>可变（mutating）</code>行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的 <code>self</code> 属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。</p>
<p>要使用 <code>可变</code>方法，将关键字 <code>mutating</code> 放到方法的 <code>func</code> 关键字之前就可以了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        x <span class="operator">+=</span> deltaX</span><br><span class="line">        y <span class="operator">+=</span> deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> somePoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“The point is now at (3.0, 4.0)”</span></span><br></pre></td></tr></table></figure>
<p>上面的 <code>Point</code> 结构体定义了一个可变方法 <code>moveBy（x：y :)</code> 来移动 <code>Point</code> 实例到给定的位置。该方法被调用时修改了这个点，而不是返回一个新的点。方法定义时加上了 <code>mutating</code> 关键字，从而允许修改属性。</p>
<p>注意，不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性，详情参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/10_Properties.html#stored_properties_of_constant_structure_instances">常量结构体的存储属性</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fixedPoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">3.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line">fixedPoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="comment">// 这里将会报告一个错误</span></span><br></pre></td></tr></table></figure>
<h3 id="在可变方法中给-self-赋值">在可变方法中给 self 赋值</h3>
<p>可变方法能够赋给隐含属性 <code>self</code> 一个全新的实例。上面 <code>Point</code> 的例子可以用下面的方式改写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="type">Point</span>(x: x <span class="operator">+</span> deltaX, y: y <span class="operator">+</span> deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版的可变方法 <code>moveBy(x:y:)</code> 创建了一个新的结构体实例，它的 x 和 y 的值都被设定为目标值。调用这个版本的方法和调用上个版本的最终结果是一样的。</p>
<p>枚举的可变方法可以把 <code>self</code> 设置为同一枚举类型中不同的成员：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TriStateSwitch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> off, low, high</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .low</span><br><span class="line">        <span class="keyword">case</span> .low:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .high</span><br><span class="line">        <span class="keyword">case</span> .high:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight <span class="operator">=</span> <span class="type">TriStateSwitch</span>.low</span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .high</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .off</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中定义了一个三态切换的枚举。每次调用 <code>next()</code> 方法时，开关在不同的电源状态（<code>off</code>, <code>low</code>, <code>high</code>）之间循环切换。</p>
<h2 id="类型方法">类型方法</h2>
<p>实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做<em>类型方法</em>。在方法的 <code>func</code> 关键字之前加上关键字 <code>static</code>，来指定类型方法。类还可以用关键字 <code>class</code> 来指定，从而允许子类重写父类该方法的实现。</p>
<blockquote>
<p>注意</p>
<p>在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。</p>
</blockquote>
<p>类型方法和实例方法一样用点语法调用。但是，你是在类型上调用这个方法，而不是在实例上调用。下面是如何在 <code>SomeClass</code> 类上调用类型方法的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="keyword">func</span> <span class="title function_">someTypeMethod</span>() &#123;</span><br><span class="line">        <span class="comment">// 在这里实现类型方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SomeClass</span>.someTypeMethod()</span><br></pre></td></tr></table></figure>
<p>在类型方法的方法体（body）中，<code>self</code> 属性指向这个类型本身，而不是类型的某个实例。这意味着你可以用 <code>self</code> 来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。</p>
<p>一般来说，在类型方法的方法体中，任何未限定的方法和属性名称，可以被本类中其他的类型方法和类型属性引用。一个类型方法可以直接通过类型方法的名称调用本类中的其它类型方法，而无需在方法名称前面加上类型名称。类似地，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。</p>
<p>下面的例子定义了一个名为 <code>LevelTracker</code> 结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。</p>
<p>游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。<code>LevelTracker</code> 结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LevelTracker</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">unlock</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> level <span class="operator">&gt;</span> highestUnlockedLevel &#123; highestUnlockedLevel <span class="operator">=</span> level &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">isUnlocked</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level <span class="operator">&lt;=</span> highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">advance</span>(<span class="params">to</span> <span class="params">level</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">LevelTracker</span>.isUnlocked(level) &#123;</span><br><span class="line">            currentLevel <span class="operator">=</span> level</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LevelTracker</code> 监测玩家已解锁的最高等级。这个值被存储在类型属性 <code>highestUnlockedLevel</code> 中。</p>
<p><code>LevelTracker</code> 还定义了两个类型方法与 <code>highestUnlockedLevel</code> 配合工作。第一个类型方法是 <code>unlock(_:)</code>，一旦新等级被解锁，它会更新 <code>highestUnlockedLevel</code> 的值。第二个类型方法是 <code>isUnlocked(_:)</code>，如果某个给定的等级已经被解锁，它将返回 <code>true</code>。（注意，尽管我们没有使用类似 <code>LevelTracker.highestUnlockedLevel</code> 的写法，这个类型方法还是能够访问类型属性 <code>highestUnlockedLevel</code>）</p>
<p>除了类型属性和类型方法，<code>LevelTracker</code> 还监测每个玩家的进度。它用实例属性 <code>currentLevel</code> 来监测每个玩家当前的等级。</p>
<p>为了便于管理 <code>currentLevel</code> 属性，<code>LevelTracker</code> 定义了实例方法 <code>advance(to:)</code>。这个方法会在更新 <code>currentLevel</code> 之前检查所请求的新等级是否已经解锁。<code>advance(to:)</code> 方法返回布尔值以指示是否能够设置 <code>currentLevel</code>。因为允许在调用 <code>advance(to:)</code> 时候忽略返回值，不会产生编译警告，所以函数被标注为 <code>@discardableResult</code> 属性，更多关于属性信息，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter3/07_Attributes.html">特性</a>章节。</p>
<p>下面，<code>Player</code> 类使用 <code>LevelTracker</code> 来监测和更新每个玩家的发展进度：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tracker <span class="operator">=</span> <span class="type">LevelTracker</span>()</span><br><span class="line">    <span class="keyword">let</span> playerName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">complete</span>(<span class="params">level</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="type">LevelTracker</span>.unlock(level <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">        tracker.advance(to: level <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        playerName <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Player</code> 类创建一个新的 <code>LevelTracker</code> 实例来监测这个用户的进度。它提供了 <code>complete(level:)</code> 方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了 <code>advance(to:)</code> 返回的布尔值，因为之前调用 <code>LevelTracker.unlock(_:)</code> 时就知道了这个等级已经被解锁了）。</p>
<p>你还可以为一个新的玩家创建一个 <code>Player</code> 的实例，然后看这个玩家完成等级一时发生了什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Argyrios&quot;</span>)</span><br><span class="line">player.complete(level: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;highest unlocked level is now <span class="subst">\(LevelTracker.highestUnlockedLevel)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“highest unlocked level is now 2”</span></span><br></pre></td></tr></table></figure>
<p>如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">player <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Beto&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> player.tracker.advance(to: <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;player is now on level 6&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;level 6 has not yet been unlocked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“level 6 has not yet been unlocked”</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/06/29/Swift/swift%E6%96%B9%E6%B3%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/06/28/Swift/swift%E5%B1%9E%E6%80%A7/"
                            aria-label=": swift属性"
                        >
                            swift属性
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-28T10:13:17+08:00">
	
		    2023 年 6 月 28 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="属性">属性</h2>
<p><em>属性</em>将值与特定的类、结构体或枚举关联。存储属性会将常量和变量存储为实例的一部分，而计算属性则是直接计算（而不是存储）值。计算属性可以用于类、结构体和枚举，而存储属性只能用于类和结构体。</p>
<p>存储属性和计算属性通常与特定类型的实例关联。但是，属性也可以直接与类型本身关联，这种属性称为类型属性。</p>
<p>另外，还可以定义属性观察器来监控属性值的变化，以此来触发自定义的操作。属性观察器可以添加到类本身定义的存储属性上，也可以添加到从父类继承的属性上。</p>
<h2 id="存储属性">存储属性</h2>
<p>简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量或变量。存储属性可以是<em>变量存储属性</em>（用关键字 <code>var</code> 定义），也可以是<em>常量存储属性</em>（用关键字 <code>let</code> 定义）。</p>
<p>可以在定义存储属性的时候指定默认值，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#default_initializers">默认构造器</a> 一节。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#assigning_constant_properties_during_initialization">构造过程中常量属性的修改</a> 一节。</p>
<p>下面的例子定义了一个名为 <code>FixedLengthRange</code> 的结构体，该结构体用于描述整数的区间，且这个范围值在被创建后不能被修改。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FixedLengthRange</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> firstValue: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> length: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rangeOfThreeItems <span class="operator">=</span> <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 该区间表示整数 0，1，2</span></span><br><span class="line">rangeOfThreeItems.firstValue <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"><span class="comment">// 该区间现在表示整数 6，7，8</span></span><br></pre></td></tr></table></figure>
<p><code>FixedLengthRange</code> 的实例包含一个名为 <code>firstValue</code> 的变量存储属性和一个名为 <code>length</code> 的常量存储属性。在上面的例子中，<code>length</code> 在创建实例的时候被初始化，且之后无法修改它的值，因为它是一个常量存储属性。</p>
<h3 id="常量结构体实例的存储属性">常量结构体实例的存储属性</h3>
<p>如果创建了一个结构体实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使被声明为可变属性也不行:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rangeOfFourItems <span class="operator">=</span> <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 该区间表示整数 0，1，2，3</span></span><br><span class="line">rangeOfFourItems.firstValue <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"><span class="comment">// 尽管 firstValue 是个可变属性，但这里还是会报错</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>rangeOfFourItems</code> 被声明成了常量（用 <code>let</code> 关键字），所以即使 <code>firstValue</code> 是一个可变属性，也无法再修改它了。</p>
<p>这种行为是由于结构体属于<em>值类型</em>。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>
<p>属于<em>引用类型</em>的类则不一样。把一个引用类型的实例赋给一个常量后，依然可以修改该实例的可变属性。</p>
<h3 id="延时加载存储属性">延时加载存储属性</h3>
<p><em>延时加载存储属性</em>是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 <code>lazy</code> 来标示一个延时加载存储属性。</p>
<blockquote>
<p>注意</p>
<p>必须将延时加载属性声明成变量（使用 <code>var</code> 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延时加载。</p>
</blockquote>
<p>当属性的值依赖于一些外部因素且这些外部因素只有在构造过程结束之后才会知道的时候，延时加载属性就会很有用。或者当获得属性的值因为需要复杂或者大量的计算，而需要采用需要的时候再计算的方式，延时加载属性也会很有用。</p>
<p>下面的例子使用了延时加载存储属性来避免复杂类中不必要的初始化工作。例子中定义了 <code>DataImporter</code> 和 <code>DataManager</code> 两个类，下面是部分代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataImporter</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DataImporter 是一个负责将外部文件中的数据导入的类。</span></span><br><span class="line"><span class="comment">    这个类的初始化会消耗不少时间。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> fileName <span class="operator">=</span> <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="comment">// 这里会提供数据导入功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> importer <span class="operator">=</span> <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">    <span class="comment">// 这里会提供数据管理功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">&quot;Some data&quot;</span>)</span><br><span class="line">manager.data.append(<span class="string">&quot;Some more data&quot;</span>)</span><br><span class="line"><span class="comment">// DataImporter 实例的 importer 属性还没有被创建</span></span><br></pre></td></tr></table></figure>
<p><code>DataManager</code> 类包含一个名为 <code>data</code> 的存储属性，初始值是一个空的字符串数组。这里没有给出全部代码，只需知道 <code>DataManager</code> 类的目的是管理和提供对这个字符串数组的访问即可。</p>
<p><code>DataManager</code> 的一个功能是从文件中导入数据。这个功能由 <code>DataImporter</code> 类提供，<code>DataImporter</code> 完成初始化需要消耗不少时间：因为它的实例在初始化时可能需要打开文件并读取文件中的内容到内存中。</p>
<p><code>DataManager</code> 管理数据时也可能不从文件中导入数据。所以当 <code>DataManager</code> 的实例被创建时，没必要创建一个 <code>DataImporter</code> 的实例，更明智的做法是第一次用到 <code>DataImporter</code> 的时候才去创建它。</p>
<p>由于使用了 <code>lazy</code>，<code>DataImporter</code> 的实例 <code>importer</code> 属性只有在第一次被访问的时候才被创建。比如访问它的属性 <code>fileName</code> 时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(manager.importer.fileName)</span><br><span class="line"><span class="comment">// DataImporter 实例的 importer 属性现在被创建了</span></span><br><span class="line"><span class="comment">// 输出“data.txt”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>如果一个被标记为 <code>lazy</code> 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。</p>
</blockquote>
<h3 id="存储属性和实例变量">存储属性和实例变量</h3>
<p>如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量作为一个备份存储将变量值赋值给属性。</p>
<p>Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的备份存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。属性的全部信息——包括命名、类型和内存管理特征——作为类型定义的一部分，都定义在一个地方。</p>
<h2 id="计算属性">计算属性</h2>
<p>除存储属性外，类、结构体和枚举可以定义<em>计算属性</em>。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX <span class="operator">=</span> origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY <span class="operator">=</span> origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newCenter.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newCenter.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter <span class="operator">=</span> square.center</span><br><span class="line">square.center <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;square.origin is now at (<span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“square.origin is now at (10.0, 10.0)”</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了 3 个结构体来描述几何形状：</p>
<ul>
<li><code>Point</code> 封装了一个 <code>(x, y)</code> 的坐标</li>
<li><code>Size</code> 封装了一个 <code>width</code> 和一个 <code>height</code></li>
<li><code>Rect</code> 表示一个有原点和尺寸的矩形</li>
</ul>
<p><code>Rect</code> 也提供了一个名为 <code>center</code> 的计算属性。一个 <code>Rect</code> 的中心点可以从 <code>origin</code>（原点）和 <code>size</code>（大小）算出，所以不需要将中心点以 <code>Point</code> 类型的值来保存。<code>Rect</code> 的计算属性 <code>center</code> 提供了自定义的 getter 和 setter 来获取和设置矩形的中心点，就像它有一个存储属性一样。</p>
<p>上述例子中创建了一个名为 <code>square</code> 的 <code>Rect</code> 实例，初始值原点是 <code>(0, 0)</code>，宽度高度都是 <code>10</code>。如下图中蓝色正方形所示。</p>
<p><code>square</code> 的 <code>center</code> 属性可以通过点运算符（<code>square.center</code>）来访问，这会调用该属性的 getter 来获取它的值。跟直接返回已经存在的值不同，getter 实际上通过计算然后返回一个新的 <code>Point</code> 来表示 <code>square</code> 的中心点。如代码所示，它正确返回了中心点 <code>(5, 5)</code>。</p>
<p><code>center</code> 属性之后被设置了一个新的值 <code>(15, 15)</code>，表示向右上方移动正方形到如下图橙色正方形所示的位置。设置属性 <code>center</code> 的值会调用它的 setter 来修改属性 <code>origin</code> 的 <code>x</code> 和 <code>y</code> 的值，从而实现移动正方形到新的位置。</p>
<p><img src="https://docs.swift.org/swift-book/_images/computedProperties_2x.png" alt="Computed Properties sample"></p>
<h3 id="简化-Setter-声明">简化 Setter 声明</h3>
<p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 <code>newValue</code>。下面是使用了简化 setter 声明的 <code>Rect</code> 结构体代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlternativeRect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX <span class="operator">=</span> origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY <span class="operator">=</span> origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简化-Getter-声明">简化 Getter 声明</h3>
<p>如果整个 getter 是单一表达式，getter 会隐式地返回这个表达式结果。下面是另一个版本的 <code>Rect</code> 结构体，用到了简化的 getter 和 setter 声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CompactRect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="type">Point</span>(x: origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>),</span><br><span class="line">                  y: origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 getter 中忽略 <code>return</code> 与在函数中忽略 <code>return</code> 的规则相同，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#functions-with-an-implicit-return">隐式返回的函数</a>。</p>
<h3 id="只读计算属性">只读计算属性</h3>
<p>只有 getter 没有 setter 的计算属性叫<em>只读计算属性</em>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>
<blockquote>
<p>注意</p>
<p>必须使用 <code>var</code> 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。<code>let</code> 关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>
</blockquote>
<p>只读计算属性的声明可以去掉 <code>get</code> 关键字和花括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cuboid</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span>, depth <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width <span class="operator">*</span> height <span class="operator">*</span> depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo <span class="operator">=</span> <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“the volume of fourByFiveByTwo is 40.0”</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个名为 <code>Cuboid</code> 的结构体，表示三维空间的立方体，包含 <code>width</code>、<code>height</code> 和 <code>depth</code> 属性。结构体还有一个名为 <code>volume</code> 的只读计算属性用来返回立方体的体积。为 <code>volume</code> 提供 setter 毫无意义，因为无法确定如何修改 <code>width</code>、<code>height</code> 和 <code>depth</code> 三者的值来匹配新的 <code>volume</code>。然而，<code>Cuboid</code> 提供一个只读计算属性来让外部用户直接获取体积是很有用的。</p>
<h2 id="属性观察器">属性观察器</h2>
<p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p>
<p>你可以为除了延时加载存储属性之外的其他存储属性添加属性观察器，你也可以在子类中通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为你可以直接通过它的 setter 监控和响应值的变化。属性重写请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/13_Inheritance.html#overriding">重写</a>。</p>
<p>可以为属性添加其中一个或两个观察器：</p>
<ul>
<li><code>willSet</code> 在新的值被设置之前调用</li>
<li><code>didSet</code> 在新的值被设置之后调用</li>
</ul>
<p><code>willSet</code> 观察器会将新的属性值作为常量参数传入，在 <code>willSet</code> 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 <code>newValue</code> 表示。</p>
<p>同样，<code>didSet</code> 观察器会将旧的属性值作为参数传入，可以为该参数指定一个名称或者使用默认参数名 <code>oldValue</code>。如果在 <code>didSet</code> 方法中再次对该属性赋值，那么新值会覆盖旧的值。</p>
<blockquote>
<p>注意</p>
<p>在父类初始化方法调用之后，在子类构造器中给父类的属性赋值时，会调用父类属性的 <code>willSet</code> 和 <code>didSet</code> 观察器。而在父类初始化方法调用之前，给子类的属性赋值时不会调用子类属性的观察器。</p>
<p>有关构造器代理的更多信息，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#initializer_delegation_for_value_types">值类型的构造器代理</a> 和 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#initializer_delegation_for_class_types">类的构造器代理</a>。</p>
</blockquote>
<p>下面是一个 <code>willSet</code> 和 <code>didSet</code> 实际运用的例子，其中定义了一个名为 <code>StepCounter</code> 的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StepCounter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;将 totalSteps 的值设置为 <span class="subst">\(newTotalSteps)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps <span class="operator">&gt;</span> oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;增加了 <span class="subst">\(totalSteps <span class="operator">-</span> oldValue)</span> 步&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stepCounter <span class="operator">=</span> <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">200</span></span><br><span class="line"><span class="comment">// 将 totalSteps 的值设置为 200</span></span><br><span class="line"><span class="comment">// 增加了 200 步</span></span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">360</span></span><br><span class="line"><span class="comment">// 将 totalSteps 的值设置为 360</span></span><br><span class="line"><span class="comment">// 增加了 160 步</span></span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">896</span></span><br><span class="line"><span class="comment">// 将 totalSteps 的值设置为 896</span></span><br><span class="line"><span class="comment">// 增加了 536 步</span></span><br></pre></td></tr></table></figure>
<p><code>StepCounter</code> 类定义了一个叫 <code>totalSteps</code> 的 <code>Int</code> 类型的属性。它是一个存储属性，包含 <code>willSet</code> 和 <code>didSet</code> 观察器。</p>
<p>当 <code>totalSteps</code> 被设置新值的时候，它的 <code>willSet</code> 和 <code>didSet</code> 观察器都会被调用，即使新值和当前值完全相同时也会被调用。</p>
<p>例子中的 <code>willSet</code> 观察器将表示新值的参数自定义为 <code>newTotalSteps</code>，这个观察器只是简单的将新的值输出。</p>
<p><code>didSet</code> 观察器在 <code>totalSteps</code> 的值改变后被调用，它把新值和旧值进行对比，如果总步数增加了，就输出一个消息表示增加了多少步。<code>didSet</code> 没有为旧值提供自定义名称，所以默认值 <code>oldValue</code> 表示旧值的参数名。</p>
<blockquote>
<p>注意</p>
<p>如果将带有观察器的属性通过 in-out 方式传入函数，<code>willSet</code> 和 <code>didSet</code> 也会调用。这是因为 in-out 参数采用了拷入拷出内存模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。关于 in-out 参数详细的介绍，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter3/05_Declarations.html#in-out_parameters">输入输出参数</a></p>
</blockquote>
<h2 id="全局变量和局部变量">全局变量和局部变量</h2>
<p>计算属性和观察属性所描述的功能也可以用于<em>全局变量</em>和<em>局部变量</em>。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>
<p>前面章节提到的全局或局部变量都属于<em>存储型变量</em>，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。</p>
<p>另外，在全局或局部范围都可以定义<em>计算型变量</em>和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。</p>
<blockquote>
<p>注意</p>
<p>全局的常量或变量都是延迟计算的，跟 <a href="#lazy_stored_properties">延时加载存储属性</a> 相似，不同的地方在于，全局的常量或变量不需要标记 <code>lazy</code> 修饰符。</p>
<p>局部范围的常量和变量从不延迟计算。</p>
</blockquote>
<h2 id="类型属性">类型属性</h2>
<p>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</p>
<p>你也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是<em>类型属性</em>。</p>
<p>类型属性用于定义某个类型所有实例共享的数据，比如<em>所有</em>实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</p>
<p>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</p>
<blockquote>
<p>注意</p>
<p>跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。</p>
<p>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 <code>lazy</code> 修饰符。</p>
</blockquote>
<h3 id="类型属性语法">类型属性语法</h3>
<p>在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为 <em>global</em>（全局）静态变量定义的。但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。</p>
<p>使用关键字 <code>static</code> 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 <code>class</code> 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SomeEnumeration</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="keyword">var</span> overrideableComputedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟计算型实例属性的语法相同。</p>
</blockquote>
<h3 id="获取和设置类型属性的值">获取和设置类型属性的值</h3>
<p>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过<em>类型</em>本身来访问，而不是通过实例。比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 打印“Some value.”</span></span><br><span class="line"><span class="type">SomeStructure</span>.storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Another value.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 打印“Another value.”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeEnumeration</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 打印“6”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeClass</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 打印“27”</span></span><br></pre></td></tr></table></figure>
<p>下面的例子定义了一个结构体，使用两个存储型类型属性来表示两个声道的音量，每个声道具有 <code>0</code> 到 <code>10</code> 之间的整数音量。</p>
<p>下图展示了如何把两个声道结合来模拟立体声的音量。当声道的音量是 <code>0</code>，没有一个灯会亮；当声道的音量是 <code>10</code>，所有灯点亮。本图中，左声道的音量是 <code>9</code>，右声道的音量是 <code>7</code>：</p>
<p><img src="https://docs.swift.org/swift-book/_images/staticPropertiesVUMeter_2x.png" alt="Static Properties VUMeter"></p>
<p>上面所描述的声道模型使用 <code>AudioChannel</code> 结构体的实例来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AudioChannel</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> thresholdLevel <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> maxInputLevelForAllChannels <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> currentLevel <span class="operator">&gt;</span> <span class="type">AudioChannel</span>.thresholdLevel &#123;</span><br><span class="line">                <span class="comment">// 将当前音量限制在阈值之内</span></span><br><span class="line">                currentLevel <span class="operator">=</span> <span class="type">AudioChannel</span>.thresholdLevel</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> currentLevel <span class="operator">&gt;</span> <span class="type">AudioChannel</span>.maxInputLevelForAllChannels &#123;</span><br><span class="line">                <span class="comment">// 存储当前音量作为新的最大输入音量</span></span><br><span class="line">                <span class="type">AudioChannel</span>.maxInputLevelForAllChannels <span class="operator">=</span> currentLevel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AudioChannel</code> 结构定义了 2 个存储型类型属性来实现上述功能。第一个是 <code>thresholdLevel</code>，表示音量的最大上限阈值，它是一个值为 <code>10</code> 的常量，对所有实例都可见，如果音量高于 <code>10</code>，则取最大上限值 <code>10</code>（见后面描述）。</p>
<p>第二个类型属性是变量存储型属性 <code>maxInputLevelForAllChannels</code>，它用来表示所有 <code>AudioChannel</code> 实例的最大输入音量，初始值是 <code>0</code>。</p>
<p><code>AudioChannel</code> 也定义了一个名为 <code>currentLevel</code> 的存储型实例属性，表示当前声道现在的音量，取值为 <code>0</code> 到 <code>10</code>。</p>
<p>属性 <code>currentLevel</code> 包含 <code>didSet</code> 属性观察器来检查每次设置后的属性值，它做如下两个检查：</p>
<ul>
<li>如果 <code>currentLevel</code> 的新值大于允许的阈值 <code>thresholdLevel</code>，属性观察器将 <code>currentLevel</code> 的值限定为阈值 <code>thresholdLevel</code>。</li>
<li>如果修正后的 <code>currentLevel</code> 值大于静态类型属性 <code>maxInputLevelForAllChannels</code> 的值，属性观察器就将新值保存在 <code>maxInputLevelForAllChannels</code> 中。</li>
</ul>
<blockquote>
<p>注意</p>
<p>在第一个检查过程中，<code>didSet</code> 属性观察器将 <code>currentLevel</code> 设置成了不同的值，但这不会造成属性观察器被再次调用。</p>
</blockquote>
<p>可以使用结构体 <code>AudioChannel</code> 创建两个声道 <code>leftChannel</code> 和 <code>rightChannel</code>，用以表示立体声系统的音量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftChannel <span class="operator">=</span> <span class="type">AudioChannel</span>()</span><br><span class="line"><span class="keyword">var</span> rightChannel <span class="operator">=</span> <span class="type">AudioChannel</span>()</span><br></pre></td></tr></table></figure>
<p>如果将左声道的 <code>currentLevel</code> 设置成 <code>7</code>，类型属性 <code>maxInputLevelForAllChannels</code> 也会更新成 <code>7</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leftChannel.currentLevel <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(leftChannel.currentLevel)</span><br><span class="line"><span class="comment">// 输出“7”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// 输出“7”</span></span><br></pre></td></tr></table></figure>
<p>如果试图将右声道的 <code>currentLevel</code> 设置成 <code>11</code>，它会被修正到最大值 <code>10</code>，同时 <code>maxInputLevelForAllChannels</code> 的值也会更新到 <code>10</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rightChannel.currentLevel <span class="operator">=</span> <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(rightChannel.currentLevel)</span><br><span class="line"><span class="comment">// 输出“10”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// 输出“10”</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/06/28/Swift/swift%E5%B1%9E%E6%80%A7/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/06/26/Swift/swift%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84/"
                            aria-label=": swift类和结构"
                        >
                            swift类和结构
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-26T10:13:17+08:00">
	
		    2023 年 6 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="结构体和类">结构体和类</h2>
<p><em>结构体</em>和<em>类</em>作为一种通用而又灵活的结构，成为了人们构建代码的基础。你可以使用定义常量、变量和函数的语法，为你的结构体和类定义属性、添加方法。</p>
<p>与其他编程语言所不同的是，Swift 并不要求你为自定义的结构体和类的接口与实现代码分别创建文件。你只需在单一的文件中定义一个结构体或者类，系统将会自动生成面向其它代码的外部接口。</p>
<blockquote>
<p>注意</p>
<p>通常一个<em>类</em>的实例被称为<em>对象</em>。然而相比其他语言，Swift 中结构体和类的功能更加相近，本章中所讨论的大部分功能都可以用在结构体或者类上。因此，这里会使用<em>实例</em>这个更通用的术语。</p>
</blockquote>
<h2 id="结构体和类对比">结构体和类对比</h2>
<p>Swift 中结构体和类有很多共同点。两者都可以：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义下标操作用于通过下标语法访问它们的值</li>
<li>定义构造器用于设置初始值</li>
<li>通过扩展以增加默认实现之外的功能</li>
<li>遵循协议以提供某种标准功能</li>
</ul>
<p>更多信息请参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/10_Properties.html">属性</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/11_Methods.html">方法</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/12_Subscripts.html">下标</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html">构造过程</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/20_Extensions.html">扩展</a> 和 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/21_Protocols.html">协议</a>。</p>
<p>与结构体相比，类还有如下的附加功能：</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>析构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用</li>
</ul>
<p>更多信息请参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/13_Inheritance.html">继承</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/18_Type_Casting.html">类型转换</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/15_Deinitialization.html">析构过程</a> 和 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/23_Automatic_Reference_Counting.html">自动引用计数</a>。</p>
<p>类支持的附加功能是以增加复杂性为代价的。作为一般准则，优先使用结构体，因为它们更容易理解，仅在适当或必要时才使用类。实际上，这意味着你的大多数自定义数据类型都会是结构体和枚举。更多详细的比较参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes">在结构和类之间进行选择</a>。</p>
<h3 id="类型定义的语法">类型定义的语法</h3>
<p>结构体和类有着相似的定义方式。你通过 <code>struct</code> 关键字引入结构体，通过 <code>class</code> 关键字引入类，并将它们的具体定义放在一对大括号中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里定义结构体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里定义类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>每当你定义一个新的结构体或者类时，你都是定义了一个新的 Swift 类型。请使用 <code>UpperCamelCase</code> 这种方式来命名类型（如这里的 <code>SomeClass</code> 和 <code>SomeStructure</code>），以便符合标准 Swift 类型的大写命名风格（如 <code>String</code>，<code>Int</code> 和 <code>Bool</code>）。请使用 <code>lowerCamelCase</code> 这种方式来命名属性和方法（如 <code>framerate</code> 和 <code>incrementCount</code>），以便和类型名区分。</p>
</blockquote>
<p>以下是定义结构体和定义类的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Resolution</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoMode</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中定义了一个名为 <code>Resolution</code> 的结构体，用来描述基于像素的分辨率。这个结构体包含了名为 <code>width</code> 和 <code>height</code> 的两个存储属性。存储属性是与结构体或者类绑定的，并存储在其中的常量或变量。当这两个属性被初始化为整数 <code>0</code> 的时候，它们会被推断为 <code>Int</code> 类型。</p>
<p>在上面的示例还定义了一个名为 <code>VideoMode</code> 的类，用来描述视频显示器的某个特定视频模式。这个类包含了四个可变的存储属性。第一个， <code>resolution</code>，被初始化为一个新的 <code>Resolution</code> 结构体的实例，属性类型被推断为 <code>Resolution</code>。新 <code>VideoMode</code> 实例同时还会初始化其它三个属性，它们分别是初始值为 <code>false</code> 的 <code>interlaced</code>（意为“非隔行视频”），初始值为 <code>0.0</code> 的 <code>frameRate</code>，以及值为可选 <code>String</code> 的 <code>name</code>。因为 <code>name</code> 是一个可选类型，它会被自动赋予一个默认值 <code>nil</code>，意为“没有 <code>name</code> 值”。</p>
<h3 id="结构体和类的实例">结构体和类的实例</h3>
<p><code>Resolution</code> 结构体和 <code>VideoMode</code> 类的定义仅描述了什么是 <code>Resolution</code> 和 <code>VideoMode</code>。它们并没有描述一个特定的分辨率（resolution）或者视频模式（video mode）。为此，你需要创建结构体或者类的一个实例。</p>
<p>创建结构体和类实例的语法非常相似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode <span class="operator">=</span> <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure>
<p>结构体和类都使用构造器语法来创建新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如 <code>Resolution()</code> 或 <code>VideoMode()</code>。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html">构造过程</a> 章节会对类和结构体的初始化进行更详细的讨论。</p>
<h3 id="属性访问">属性访问</h3>
<p>你可以通过使用<em>点语法</em>访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者以点号（<code>.</code>）分隔，不带空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The width of someResolution is <span class="subst">\(someResolution.width)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;The width of someResolution is 0&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>someResolution.width</code> 引用 <code>someResolution</code> 的 <code>width</code> 属性，返回 <code>width</code> 的初始值 <code>0</code>。</p>
<p>你也可以访问子属性，如 <code>VideoMode</code> 中 <code>resolution</code> 属性的 <code>width</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The width of someVideoMode is <span class="subst">\(someVideoMode.resolution.width)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;The width of someVideoMode is 0&quot;</span></span><br></pre></td></tr></table></figure>
<p>你也可以使用点语法为可变属性赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someVideoMode.resolution.width <span class="operator">=</span> <span class="number">1280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The width of someVideoMode is now <span class="subst">\(someVideoMode.resolution.width)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;The width of someVideoMode is now 1280&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="结构体类型的成员逐一构造器">结构体类型的成员逐一构造器</h3>
<p>所有结构体都有一个自动生成的<em>成员逐一构造器</em>，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga <span class="operator">=</span> <span class="type">Resolution</span>(width: <span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure>
<p>与结构体不同，类实例没有默认的成员逐一构造器。<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html">构造过程</a> 章节会对构造器进行更详细的讨论。</p>
<h2 id="结构体和枚举是值类型">结构体和枚举是值类型</h2>
<p><em>值类型</em>是这样一种类型，当它被赋值给一个变量、常量或者被传递给一个函数的时候，其值会被<em>拷贝</em>。</p>
<p>在之前的章节中，你已经大量使用了值类型。实际上，Swift 中所有的基本类型：整数（integer）、浮点数（floating-point number）、布尔值（boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，其底层也是使用结构体实现的。</p>
<p>Swift 中所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型的属性，在代码中传递的时候都会被复制。</p>
<blockquote>
<p>注意</p>
<p>标准库定义的集合，例如数组，字典和字符串，都对复制进行了优化以降低性能成本。新集合不会立即复制，而是跟原集合共享同一份内存，共享同样的元素。在集合的某个副本要被修改前，才会复制它的元素。而你在代码中看起来就像是立即发生了复制。</p>
</blockquote>
<p>请看下面这个示例，其使用了上一个示例中的 <code>Resolution</code> 结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hd <span class="operator">=</span> <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"><span class="keyword">var</span> cinema <span class="operator">=</span> hd</span><br></pre></td></tr></table></figure>
<p>在以上示例中，声明了一个名为 <code>hd</code> 的常量，其值为一个初始化为全高清视频分辨率（<code>1920</code> 像素宽，<code>1080</code> 像素高）的 <code>Resolution</code> 实例。</p>
<p>然后示例中又声明了一个名为 <code>cinema</code> 的变量，并将 <code>hd</code> 赋值给它。因为 <code>Resolution</code> 是一个结构体，所以会先创建一个现有实例的副本，然后将副本赋值给 <code>cinema</code> 。尽管 <code>hd</code> 和 <code>cinema</code> 有着相同的宽（width）和高（height），但是在幕后它们是两个完全不同的实例。</p>
<p>下面，为了符合数码影院放映的需求（<code>2048</code> 像素宽，<code>1080</code> 像素高），<code>cinema</code> 的 <code>width</code> 属性被修改为稍微宽一点的 2K 标准：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cinema.width <span class="operator">=</span> <span class="number">2048</span></span><br></pre></td></tr></table></figure>
<p>查看 <code>cinema</code> 的 <code>width</code> 属性，它的值确实改为了 <code>2048</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cinema is now  <span class="subst">\(cinema.width)</span> pixels wide&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;cinema is now 2048 pixels wide&quot;</span></span><br></pre></td></tr></table></figure>
<p>然而，初始的 <code>hd</code> 实例中 <code>width</code> 属性还是 <code>1920</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hd is still <span class="subst">\(hd.width)</span> pixels wide&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;hd is still 1920 pixels wide&quot;</span></span><br></pre></td></tr></table></figure>
<p>将 <code>hd</code> 赋值给 <code>cinema</code> 时，<code>hd</code> 中所存储的<em>值</em>会拷贝到新的 <code>cinema</code> 实例中。结果就是两个完全独立的实例包含了相同的数值。由于两者相互独立，因此将 <code>cinema</code> 的 <code>width</code> 修改为 <code>2048</code> 并不会影响 <code>hd</code> 中的 <code>width</code> 的值，如下图所示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/sharedStateStruct_2x.png" alt="sharedStateStruct_2x"></p>
<p>枚举也遵循相同的行为准则：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">turnNorth</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> .north</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentDirection <span class="operator">=</span> <span class="type">CompassPoint</span>.west</span><br><span class="line"><span class="keyword">let</span> rememberedDirection <span class="operator">=</span> currentDirection</span><br><span class="line">currentDirection.turnNorth()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The current direction is <span class="subst">\(currentDirection)</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The remembered direction is <span class="subst">\(rememberedDirection)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;The current direction is north&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;The remembered direction is west&quot;</span></span><br></pre></td></tr></table></figure>
<p>当 <code>rememberedDirection</code> 被赋予了 <code>currentDirection</code> 的值，实际上它被赋予的是值的一个拷贝。赋值过程结束后再修改 <code>currentDirection</code> 的值并不影响 <code>rememberedDirection</code> 所储存的原始值的拷贝。</p>
<h2 id="类是引用类型">类是引用类型</h2>
<p>与值类型不同，<em>引用类型</em>在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，使用的是已存在实例的引用，而不是其拷贝。</p>
<p>请看下面这个示例，其使用了之前定义的 <code>VideoMode</code> 类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tenEighty <span class="operator">=</span> <span class="type">VideoMode</span>()</span><br><span class="line">tenEighty.resolution <span class="operator">=</span> hd</span><br><span class="line">tenEighty.interlaced <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">tenEighty.name <span class="operator">=</span> <span class="string">&quot;1080i&quot;</span></span><br><span class="line">tenEighty.frameRate <span class="operator">=</span> <span class="number">25.0</span></span><br></pre></td></tr></table></figure>
<p>以上示例中，声明了一个名为 <code>tenEighty</code> 的常量，并让其引用一个 <code>VideoMode</code> 类的新实例。它的视频模式（video mode）被赋值为之前创建的 HD 分辨率（<code>1920</code>*<code>1080</code>）的一个拷贝。然后将它设置为隔行视频，名字设为 <code>“1080i”</code>，并将帧率设置为 <code>25.0</code> 帧每秒。</p>
<p>接下来，将 <code>tenEighty</code> 赋值给一个名为 <code>alsoTenEighty</code> 的新常量，并修改 <code>alsoTenEighty</code> 的帧率：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoTenEighty <span class="operator">=</span> tenEighty</span><br><span class="line">alsoTenEighty.frameRate <span class="operator">=</span> <span class="number">30.0</span></span><br></pre></td></tr></table></figure>
<p>因为类是引用类型，所以 <code>tenEight</code> 和 <code>alsoTenEight</code> 实际上引用的是同一个 <code>VideoMode</code> 实例。换句话说，它们是同一个实例的两种叫法，如下图所示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/sharedStateClass_2x.png" alt="sharedStateClass_2x"></p>
<p>通过查看 <code>tenEighty</code> 的 <code>frameRate</code> 属性，可以看到它正确地显示了底层的 <code>VideoMode</code> 实例的新帧率 <code>30.0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The frameRate property of tenEighty is now <span class="subst">\(tenEighty.frameRate)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;The frameRate property of theEighty is now 30.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个例子也显示了为何引用类型更加难以理解。如果 <code>tenEighty</code> 和 <code>alsoTenEighty</code> 在你代码中的位置相距很远，那么就很难找到所有修改视频模式的地方。无论在哪使用 <code>tenEighty</code>，你都要考虑使用 <code>alsoTenEighty</code> 的代码，反之亦然。相反，值类型就更容易理解了，因为你的源码中与同一个值交互的代码都很近。</p>
<p>需要注意的是 <code>tenEighty</code> 和 <code>alsoTenEighty</code> 被声明为常量而不是变量。然而你依然可以改变 <code>tenEighty.frameRate</code> 和 <code>alsoTenEighty.frameRate</code>，这是因为 <code>tenEighty</code> 和 <code>alsoTenEighty</code> 这两个常量的值并未改变。它们并不“存储”这个 <code>VideoMode</code> 实例，而仅仅是对 <code>VideoMode</code> 实例的引用。所以，改变的是底层 <code>VideoMode</code> 实例的 <code>frameRate</code> 属性，而不是指向 <code>VideoMode</code> 的常量引用的值。</p>
<h3 id="恒等运算符">恒等运算符</h3>
<p>因为类是引用类型，所以多个常量和变量可能在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）</p>
<p>判定两个常量或者变量是否引用同一个类实例有时很有用。为了达到这个目的，Swift 提供了两个恒等运算符：</p>
<ul>
<li>相同（<code>===</code>）</li>
<li>不相同（<code>!==</code>）</li>
</ul>
<p>使用这两个运算符检测两个常量或者变量是否引用了同一个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty <span class="operator">===</span> alsoTenEighty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</span></span><br></pre></td></tr></table></figure>
<p>请注意，“相同”（用三个等号表示，<code>===</code>）与“等于”（用两个等号表示，<code>==</code>）的不同。“相同”表示两个类类型（class type）的常量或者变量引用同一个类实例。“等于”表示两个实例的值“相等”或“等价”，判定时要遵照设计者定义的评判标准。</p>
<p>当在定义你的自定义结构体和类的时候，你有义务来决定判定两个实例“相等”的标准。在章节 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/26_Advanced_Operators.html#equivalence_operators">等价操作符</a> 中将会详细介绍实现自定义 == 和 !== 运算符的流程。</p>
<h3 id="指针">指针</h3>
<p>如果你有 C，C++ 或者 Objective-C 语言的经验，那么你也许会知道这些语言使用<em>指针</em>来引用内存中的地址。Swift 中引用了某个引用类型实例的常量或变量，与 C 语言中的指针类似，不过它并不直接指向某个内存地址，也不要求你使用星号（<code>*</code>）来表明你在创建一个引用。相反，Swift 中引用的定义方式与其它的常量或变量的一样。如果需要直接与指针交互，你可以使用标准库提供的指针和缓冲区类型 —— 参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management">手动管理内存</a>。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/06/26/Swift/swift%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/06/25/Swift/swift%E6%9E%9A%E4%B8%BE/"
                            aria-label=": swift枚举"
                        >
                            swift枚举
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-25T10:13:17+08:00">
	
		    2023 年 6 月 25 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="枚举">枚举</h2>
<p><em>枚举</em>为一组相关的值定义了一个共同的类型，使你可以在你的代码中以类型安全的方式来使用这些值。</p>
<p>如果你熟悉 C 语言，你会知道在 C 语言中，枚举会为一组整型值分配相关联的名称。Swift 中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值（称为原始值），则该值的类型可以是字符串、字符，或是一个整型值或浮点数。</p>
<p>此外，枚举成员可以指定<em>任意</em>类型的关联值存储到枚举成员中，就像其他语言中的联合体（unions）和变体（variants）。你可以在一个枚举中定义一组相关的枚举成员，每一个枚举成员都可以有适当类型的关联值。</p>
<p>在 Swift 中，枚举类型是一等（first-class）类型。它们采用了很多在传统上只被类（class）所支持的特性，例如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p>
<p>想了解更多相关信息，请参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/10_Properties.html">属性</a>，<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/11_Methods.html">方法</a>，<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html">构造过程</a>，<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/20_Extensions.html">扩展</a> 和 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/21_Protocols.html">协议</a>。</p>
<h2 id="枚举语法">枚举语法</h2>
<p>使用 <code>enum</code> 关键词来创建枚举并且把它们的整个定义放在一对大括号内：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SomeEnumeration</span> &#123;</span><br><span class="line">    <span class="comment">// 枚举定义放在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是用枚举表示指南针四个方向的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举中定义的值（如 <code>north</code>，<code>south</code>，<code>east</code> 和 <code>west</code>）是这个枚举的<em>成员值</em>（或<em>成员</em>）。你可以使用 <code>case</code> 关键字来定义一个新的枚举成员值。</p>
<blockquote>
<p>注意</p>
<p>与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的 <code>CompassPoint</code> 例子中，<code>north</code>，<code>south</code>，<code>east</code> 和 <code>west</code> 不会被隐式地赋值为 <code>0</code>，<code>1</code>，<code>2</code> 和 <code>3</code>。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的 <code>CompassPoint</code> 类型。</p>
</blockquote>
<p>多个成员值可以出现在同一行上，用逗号隔开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如 <code>CompassPoint</code> 和 <code>Planet</code>）以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionToHead <span class="operator">=</span> <span class="type">CompassPoint</span>.west</span><br></pre></td></tr></table></figure>
<p><code>directionToHead</code> 的类型可以在它被 <code>CompassPoint</code> 的某个值初始化时推断出来。一旦 <code>directionToHead</code> 被声明为 <code>CompassPoint</code> 类型，你可以使用更简短的点语法将其设置为另一个 <code>CompassPoint</code> 的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directionToHead <span class="operator">=</span> .east</span><br></pre></td></tr></table></figure>
<p>当 <code>directionToHead</code> 的类型已知时，再次为其赋值可以省略枚举类型名。在使用具有显式类型的枚举值时，这种写法让代码具有更好的可读性。</p>
<h2 id="使用-Switch-语句匹配枚举值">使用 Switch 语句匹配枚举值</h2>
<p>你可以使用 <code>switch</code> 语句匹配单个枚举值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">directionToHead <span class="operator">=</span> .south</span><br><span class="line"><span class="keyword">switch</span> directionToHead &#123;</span><br><span class="line"><span class="keyword">case</span> .north:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Lots of planets have a north&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .south:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Watch out for penguins&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .east:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Where the sun rises&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .west:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Where the skies are blue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Watch out for penguins”</span></span><br></pre></td></tr></table></figure>
<p>你可以这样理解这段代码：</p>
<p>“判断 <code>directionToHead</code> 的值。当它等于 <code>.north</code>，打印 <code>“Lots of planets have a north”</code>。当它等于 <code>.south</code>，打印 <code>“Watch out for penguins”</code>。”</p>
<p>……以此类推。</p>
<p>正如在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html">控制流</a> 中介绍的那样，在判断一个枚举类型的值时，<code>switch</code> 语句必须穷举所有情况。如果忽略了 <code>.west</code> 这种情况，上面那段代码将无法通过编译，因为它没有考虑到 <code>CompassPoint</code> 的全部成员。强制穷举确保了枚举成员不会被意外遗漏。</p>
<p>当不需要匹配每个枚举成员的时候，你可以提供一个 <code>default</code> 分支来涵盖所有未明确处理的枚举成员：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somePlanet <span class="operator">=</span> <span class="type">Planet</span>.earth</span><br><span class="line"><span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line"><span class="keyword">case</span> .earth:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Mostly harmless&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not a safe place for humans&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Mostly harmless”</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举成员的遍历">枚举成员的遍历</h2>
<p>在一些情况下，你会需要得到一个包含枚举所有成员的集合。可以通过如下代码实现：</p>
<p>令枚举遵循 <code>CaseIterable</code> 协议。Swift 会生成一个 <code>allCases</code> 属性，用于表示一个包含枚举所有成员的集合。下面是一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Beverage</span>: <span class="title class_ inherited__">CaseIterable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> coffee, tea, juice</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numberOfChoices <span class="operator">=</span> <span class="type">Beverage</span>.allCases.count</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(numberOfChoices)</span> beverages available&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“3 beverages available”</span></span><br></pre></td></tr></table></figure>
<p>在前面的例子中，通过 <code>Beverage.allCases</code> 可以访问到包含 <code>Beverage</code> 枚举所有成员的集合。<code>allCases</code> 的使用方法和其它一般集合一样——集合中的元素是枚举类型的实例，所以在上面的情况中，这些元素是 <code>Beverage</code> 值。在前面的例子中，统计了总共有多少个枚举成员。而在下面的例子中，则使用 <code>for</code> 循环来遍历所有枚举成员。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> beverage <span class="keyword">in</span> <span class="type">Beverage</span>.allCases &#123;</span><br><span class="line">    <span class="built_in">print</span>(beverage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// coffee</span></span><br><span class="line"><span class="comment">// tea</span></span><br><span class="line"><span class="comment">// juice</span></span><br></pre></td></tr></table></figure>
<p>在前面的例子中，使用的语法表明这个枚举遵循 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/caseiterable">CaseIterable</a> 协议。想了解 protocols 相关信息，请参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/21_Protocols.html">协议</a>。</p>
<h2 id="关联值">关联值</h2>
<p>枚举语法那一小节的例子演示了如何定义和分类枚举的成员。你可以为 <code>Planet.earth</code> 设置一个常量或者变量，并在赋值之后查看这个值。然而，有时候把其他类型的值和成员值一起存储起来会很有用。这额外的信息称为<em>关联值</em>，并且你每次在代码中使用该枚举成员时，还可以修改这个关联值。</p>
<p>你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。</p>
<p>例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用 <code>0</code> 到 <code>9</code> 的数字的 UPC 格式的一维条形码。每一个条形码都有一个代表数字系统的数字，该数字后接五位代表厂商代码的数字，接下来是五位代表“产品代码”的数字。最后一个数字是检查位，用来验证代码是否被正确扫描：</p>
<p><img src="https://docs.swift.org/swift-book/_images/barcode_UPC_2x.png" alt=""></p>
<p>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串：</p>
<p><img src="https://docs.swift.org/swift-book/_images/barcode_QR_2x.png" alt=""></p>
<p>这便于库存跟踪系统用包含四个整型值的元组存储 UPC 码，以及用任意长度的字符串储存 QR 码。</p>
<p>在 Swift 中，使用如下方式定义表示两种商品条形码的枚举：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Barcode</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> qrCode(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以这么理解：</p>
<p>“定义一个名为 <code>Barcode</code> 的枚举类型，它的一个成员值是具有 <code>(Int，Int，Int，Int)</code> 类型关联值的 <code>upc</code>，另一个成员值是具有 <code>String</code> 类型关联值的 <code>qrCode</code>。”</p>
<p>这个定义不提供任何 <code>Int</code> 或 <code>String</code> 类型的关联值，它只是定义了，当 <code>Barcode</code> 常量和变量等于 <code>Barcode.upc</code> 或 <code>Barcode.qrCode</code> 时，可以存储的关联值的类型。</p>
<p>然后你可以使用任意一种条形码类型创建新的条形码，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productBarcode <span class="operator">=</span> <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>上面的例子创建了一个名为 <code>productBarcode</code> 的变量，并将 <code>Barcode.upc</code> 赋值给它，关联的元组值为 <code>(8, 85909, 51226, 3)</code>。</p>
<p>同一个商品可以被分配一个不同类型的条形码，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productBarcode <span class="operator">=</span> .qrCode(<span class="string">&quot;ABCDEFGHIJKLMNOP&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这时，原始的 <code>Barcode.upc</code> 和其整数关联值被新的 <code>Barcode.qrCode</code> 和其字符串关联值所替代。<code>Barcode</code> 类型的常量和变量可以存储一个 <code>.upc</code> 或者一个 <code>.qrCode</code>（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。</p>
<p>你可以使用一个 switch 语句来检查不同的条形码类型，和之前使用 Switch 语句来匹配枚举值的例子一样。然而，这一次，关联值可以被提取出来作为 switch 语句的一部分。你可以在 <code>switch</code> 的 case 分支代码中提取每个关联值作为一个常量（用 <code>let</code> 前缀）或者作为一个变量（用 <code>var</code> 前缀）来使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .upc(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .qrCode(<span class="keyword">let</span> productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;QR code: <span class="subst">\(productCode)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“QR code: ABCDEFGHIJKLMNOP.”</span></span><br></pre></td></tr></table></figure>
<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个 <code>let</code> 或者 <code>var</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .upc(numberSystem, manufacturer, product, check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .qrCode(productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;QR code: <span class="subst">\(productCode)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“QR code: ABCDEFGHIJKLMNOP.”</span></span><br></pre></td></tr></table></figure>
<h2 id="原始值">原始值</h2>
<p>在 <a href="#associated_values">关联值</a> 小节的条形码例子中，演示了如何声明存储不同类型关联值的枚举成员。作为关联值的替代选择，枚举成员可以被默认值（称为<em>原始值</em>）预填充，这些原始值的类型必须相同。</p>
<p>这是一个使用 ASCII 码作为原始值的枚举：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ASCIIControlCharacter</span>: <span class="title class_ inherited__">Character</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> tab <span class="operator">=</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> lineFeed <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> carriageReturn <span class="operator">=</span> <span class="string">&quot;<span class="subst">\r</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型 <code>ASCIIControlCharacter</code> 的原始值类型被定义为 <code>Character</code>，并设置了一些比较常见的 ASCII 控制字符。<code>Character</code> 的描述详见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/03_Strings_and_Characters.html">字符串和字符</a> 部分。</p>
<p>原始值可以是字符串、字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。</p>
<blockquote>
<p>注意</p>
<p>原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。</p>
</blockquote>
<h3 id="原始值的隐式赋值">原始值的隐式赋值</h3>
<p>在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。</p>
<p>例如，当使用整数作为原始值时，隐式赋值的值依次递增 <code>1</code>。如果第一个枚举成员没有设置原始值，其原始值将为 <code>0</code>。</p>
<p>下面的枚举是对之前 <code>Planet</code> 这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span>: <span class="title class_ inherited__">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mercury <span class="operator">=</span> <span class="number">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>Plant.mercury</code> 的显式原始值为 <code>1</code>，<code>Planet.venus</code> 的隐式原始值为 <code>2</code>，依次类推。</p>
<p>当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。</p>
<p>下面的例子是 <code>CompassPoint</code> 枚举的细化，使用字符串类型的原始值来表示各个方向的名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span>: <span class="title class_ inherited__">String</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>CompassPoint.south</code> 拥有隐式原始值 <code>south</code>，依次类推。</p>
<p>使用枚举成员的 <code>rawValue</code> 属性可以访问该枚举成员的原始值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> earthsOrder <span class="operator">=</span> <span class="type">Planet</span>.earth.rawValue</span><br><span class="line"><span class="comment">// earthsOrder 值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sunsetDirection <span class="operator">=</span> <span class="type">CompassPoint</span>.west.rawValue</span><br><span class="line"><span class="comment">// sunsetDirection 值为 &quot;west&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用原始值初始化枚举实例">使用原始值初始化枚举实例</h3>
<p>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做 <code>rawValue</code> 的参数，参数类型即为原始值类型，返回值则是枚举成员或 <code>nil</code>。你可以使用这个初始化方法来创建一个新的枚举实例。</p>
<p>这个例子利用原始值 <code>7</code> 创建了枚举成员 <code>Uranus</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblePlanet <span class="operator">=</span> <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">// possiblePlanet 类型为 Planet? 值为 Planet.uranus</span></span><br></pre></td></tr></table></figure>
<p>然而，并非所有 <code>Int</code> 值都可以找到一个匹配的行星。因此，原始值构造器总是返回一个<em>可选</em>的枚举成员。在上面的例子中，<code>possiblePlanet</code> 是 <code>Planet?</code> 类型，或者说“可选的 <code>Planet</code>”。</p>
<blockquote>
<p>注意</p>
<p>原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。更多信息请参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter3/05_Declarations.html#failable_initializers">可失败构造器</a></p>
</blockquote>
<p>如果你试图寻找一个位置为 <code>11</code> 的行星，通过原始值构造器返回的可选 <code>Planet</code> 值将是 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positionToFind <span class="operator">=</span> <span class="number">11</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> somePlanet <span class="operator">=</span> <span class="type">Planet</span>(rawValue: positionToFind) &#123;</span><br><span class="line">    <span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line">    <span class="keyword">case</span> .earth:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Mostly harmless&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Not a safe place for humans&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;There isn&#x27;t a planet at position <span class="subst">\(positionToFind)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“There isn&#x27;t a planet at position 11”</span></span><br></pre></td></tr></table></figure>
<p>这个例子使用了可选绑定（optional binding），试图通过原始值 <code>11</code> 来访问一个行星。<code>if let somePlanet = Planet(rawValue: 11)</code> 语句创建了一个可选 <code>Planet</code>，如果可选 <code>Planet</code> 的值存在，就会赋值给 <code>somePlanet</code>。在这个例子中，无法检索到位置为 <code>11</code> 的行星，所以 <code>else</code> 分支被执行。</p>
<h2 id="递归枚举">递归枚举</h2>
<p><em>递归枚举</em>是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上 <code>indirect</code> 来表示该成员可递归。</p>
<p>例如，下面的例子中，枚举类型存储了简单的算术表达式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ArithmeticExpression</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以在枚举类型开头加上 <code>indirect</code> 关键字来表明它的所有成员都是可递归的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="keyword">enum</span> <span class="title class_">ArithmeticExpression</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员 <code>addition</code> 和 <code>multiplication</code> 的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式 <code>(5 + 4) * 2</code>，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用 <code>ArithmeticExpression</code> 这个递归枚举创建表达式 <code>(5 + 4) * 2</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> five <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.number(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.number(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.addition(five, four)</span><br><span class="line"><span class="keyword">let</span> product <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.multiplication(sum, <span class="type">ArithmeticExpression</span>.number(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">evaluate</span>(<span class="keyword">_</span> <span class="params">expression</span>: <span class="type">ArithmeticExpression</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> expression &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .number(value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .addition(left, right):</span><br><span class="line">        <span class="keyword">return</span> evaluate(left) <span class="operator">+</span> evaluate(right)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .multiplication(left, right):</span><br><span class="line">        <span class="keyword">return</span> evaluate(left) <span class="operator">*</span> evaluate(right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(evaluate(product))</span><br><span class="line"><span class="comment">// 打印“18”</span></span><br></pre></td></tr></table></figure>
<p>该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/06/25/Swift/swift%E6%9E%9A%E4%B8%BE/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../../2023/06/24/Swift/swift%E9%97%AD%E5%8C%85/"
                            aria-label=": swift闭包"
                        >
                            swift闭包
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-24T10:13:17+08:00">
	
		    2023 年 6 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../">编程语言</a>, <a class="category-link" href="../../">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="闭包">闭包</h2>
<p><em>闭包</em>是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的匿名函数（Lambdas）比较相似。</p>
<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为<em>包裹</em>常量和变量。 Swift 会为你管理在捕获过程中涉及到的所有内存操作。</p>
<blockquote>
<p>注意</p>
<p>如果你不熟悉捕获（capturing）这个概念也不用担心，在 <a href="#capturing_values">值捕获</a> 章节有它更详细的介绍。</p>
</blockquote>
<p>在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html">函数</a> 章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采用如下三种形式之一：</p>
<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>
<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>
<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略 <code>return</code> 关键字</li>
<li>参数名称缩写</li>
<li>尾随闭包语法</li>
</ul>
<h2 id="闭包表达式">闭包表达式</h2>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#Nested_Functions">嵌套函数</a> 作为复杂函数的一部分时，它自包含代码块式的定义和命名形式在使用上带来了方便。当然，编写未完整声明和没有函数名的类函数结构代码是很有用的，尤其是在编码中涉及到函数作为参数的那些方法时。</p>
<p><em>闭包表达式</em>是一种构建内联闭包的方式，它的语法简洁。在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式。下面通过对 <code>sorted(by:)</code> 这一个案例的多次迭代改进来展示这个过程，每次迭代都使用了更加简明的方式描述了相同功能。。</p>
<h3 id="排序方法">排序方法</h3>
<p>Swift 标准库提供了名为 <code>sorted(by:)</code> 的方法，它会基于你提供的排序闭包表达式的判断结果对数组中的值（类型确定）进行排序。一旦它完成排序过程，<code>sorted(by:)</code> 方法会返回一个与旧数组类型大小相同类型的新数组，该数组的元素有着正确的排序顺序。原数组不会被 <code>sorted(by:)</code> 方法修改。</p>
<p>下面的闭包表达式示例使用 <code>sorted(by:)</code> 方法对一个 <code>String</code> 类型的数组进行字母逆序排序。以下是初始数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>sorted(by:)</code> 方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值<em>前面</em>，排序闭包函数需要返回 <code>true</code>，反之返回 <code>false</code>。</p>
<p>该例子对一个 <code>String</code> 类型的数组进行排序，因此排序闭包函数类型需为 <code>(String, String) -&gt; Bool</code>。</p>
<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为 <code>sorted(by:)</code> 方法的参数传入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">backward</span>(<span class="keyword">_</span> <span class="params">s1</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">s2</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversedNames <span class="operator">=</span> names.sorted(by: backward)</span><br><span class="line"><span class="comment">// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果第一个字符串（<code>s1</code>）大于第二个字符串（<code>s2</code>），<code>backward(_:_:)</code> 函数会返回 <code>true</code>，表示在新的数组中 <code>s1</code> 应该出现在 <code>s2</code> 前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母 <code>&quot;B&quot;</code> 大于字母 <code>&quot;A&quot;</code> ，字符串 <code>&quot;Tom&quot;</code> 大于字符串 <code>&quot;Tim&quot;</code>。该闭包将进行字母逆序排序，<code>&quot;Barry&quot;</code> 将会排在 <code>&quot;Alex&quot;</code> 之前。</p>
<p>然而，以这种方式来编写一个实际上很简单的表达式（<code>a &gt; b</code>)，确实太过繁琐了。对于这个例子来说，利用闭包表达式语法可以更好地构造一个内联排序闭包。</p>
<h3 id="闭包表达式语法">闭包表达式语法</h3>
<p>闭包表达式语法有如下的一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>闭包表达式参数</em> 可以是 in-out 参数，但不能设定默认值。如果你命名了可变参数，也可以使用此可变参数。元组也可以作为参数和返回值。</p>
<p>下面的例子展示了之前 <code>backward(_:_:)</code> 函数对应的闭包表达式版本的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>需要注意的是内联闭包参数和返回值类型声明与 <code>backward(_:_:)</code> 函数类型声明相同。在这两种方式中，都写成了 <code>(s1: String, s2: String) -&gt; Bool</code>。然而在内联闭包表达式中，函数和返回值类型都写在<em>大括号内</em>，而不是大括号外。</p>
<p>闭包的函数体部分由关键字 <code>in</code> 引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>
<p>由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>该例中 <code>sorted(by:)</code> 方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。</p>
<h3 id="根据上下文推断类型">根据上下文推断类型</h3>
<p>因为排序闭包函数是作为 <code>sorted(by:)</code> 方法的参数传入的，Swift 可以推断其参数和返回值的类型。<code>sorted(by:)</code> 方法被一个字符串数组调用，因此其参数必须是 <code>(String, String) -&gt; Bool</code> 类型的函数。这意味着 <code>(String, String)</code> 和 <code>Bool</code> 类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头（<code>-&gt;</code>）和围绕在参数周围的括号也可以被省略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>实际上，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，你几乎不需要利用完整格式构造内联闭包。</p>
<p>尽管如此，你仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则我们更鼓励采用完整格式的闭包。而在 <code>sorted(by:)</code> 方法这个例子里，显然闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。</p>
<h3 id="单表达式闭包的隐式返回">单表达式闭包的隐式返回</h3>
<p>单行表达式闭包可以通过省略 <code>return</code> 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>sorted(by:)</code> 方法的参数类型明确了闭包必须返回一个 <code>Bool</code> 类型值。因为闭包函数体只包含了一个单一表达式（<code>s1 &gt; s2</code>），该表达式返回 <code>Bool</code> 类型值，因此这里没有歧义，<code>return</code> 关键字可以省略。</p>
<h3 id="参数名称缩写">参数名称缩写</h3>
<p>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 <code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数，以此类推。</p>
<p>如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code> 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125; )</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>$0</code> 和 <code>$1</code> 表示闭包中第一个和第二个 <code>String</code> 类型的参数。</p>
<h3 id="运算符方法">运算符方法</h3>
<p>实际上还有一种更<em>简短的</em>方式来编写上面例子中的闭包表达式。Swift 的 <code>String</code> 类型定义了关于大于号（<code>&gt;</code>）的字符串实现，其作为一个函数接受两个 <code>String</code> 类型的参数并返回 <code>Bool</code> 类型的值。而这正好与 <code>sorted(by:)</code> 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断找到系统自带的那个字符串函数的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: <span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>
<p>更多关于运算符方法的内容请查看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/26_Advanced_Operators.html#operator_methods">运算符方法</a>。</p>
<h2 id="尾随闭包">尾随闭包</h2>
<p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <a href="#closure_expression_syntax">闭包表达式语法</a> 上章节中的字符串排序闭包可以作为尾随包的形式改写在 <code>sorted(by:)</code> 方法圆括号的外面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted() &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 <code>()</code> 省略掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。举例来说，Swift 的 <code>Array</code> 类型有一个 <code>map(_:)</code> 方法，这个方法获取一个闭包表达式作为其唯一参数。该闭包函数会为数组中的每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。</p>
<p>当提供给数组的闭包应用于每个数组元素后，<code>map(_:)</code> 方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。</p>
<p>下例介绍了如何在 <code>map(_:)</code> 方法中使用尾随闭包将 <code>Int</code> 类型数组 <code>[16, 58, 510]</code> 转换为包含对应 <code>String</code> 类型的值的数组 <code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> digitNames <span class="operator">=</span> [</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;Zero&quot;</span>, <span class="number">1</span>: <span class="string">&quot;One&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Two&quot;</span>,   <span class="number">3</span>: <span class="string">&quot;Three&quot;</span>, <span class="number">4</span>: <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">&quot;Five&quot;</span>, <span class="number">6</span>: <span class="string">&quot;Six&quot;</span>, <span class="number">7</span>: <span class="string">&quot;Seven&quot;</span>, <span class="number">8</span>: <span class="string">&quot;Eight&quot;</span>, <span class="number">9</span>: <span class="string">&quot;Nine&quot;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">16</span>, <span class="number">58</span>, <span class="number">510</span>]</span><br></pre></td></tr></table></figure>
<p>如上代码创建了一个整型数位和它们英文版本名字相映射的字典。同时还定义了一个准备转换为字符串数组的整型数组。</p>
<p>你现在可以通过传递一个尾随闭包给 <code>numbers</code> 数组的 <code>map(_:)</code> 方法来创建对应的字符串版本数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings <span class="operator">=</span> numbers.map &#123;</span><br><span class="line">    (number) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> number <span class="operator">=</span> number</span><br><span class="line">    <span class="keyword">var</span> output <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">repeat</span> &#123;</span><br><span class="line">        output <span class="operator">=</span> digitNames[number <span class="operator">%</span> <span class="number">10</span>]<span class="operator">!</span> <span class="operator">+</span> output</span><br><span class="line">        number <span class="operator">/=</span> <span class="number">10</span></span><br><span class="line">    &#125; <span class="keyword">while</span> number <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// strings 常量被推断为字符串类型数组，即 [String]</span></span><br><span class="line"><span class="comment">// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>map(_:)</code> 为数组中每一个元素调用了一次闭包表达式。你不需要指定闭包的输入参数 <code>number</code> 的类型，因为可以通过要映射的数组类型进行推断。</p>
<p>在该例中，局部变量 <code>number</code> 的值由闭包中的 <code>number</code> 参数获得，因此可以在闭包函数体内对其进行修改，(闭包或者函数的参数总是常量)，闭包表达式指定了返回类型为 <code>String</code>，以表明存储映射值的新数组类型为 <code>String</code>。</p>
<p>闭包表达式在每次被调用的时候创建了一个叫做 <code>output</code> 的字符串并返回。其使用求余运算符（<code>number % 10</code>）计算最后一位数字并利用 <code>digitNames</code> 字典获取所映射的字符串。这个闭包能够用于创建任意正整数的字符串表示。</p>
<blockquote>
<p>注意</p>
<p>字典 <code>digitNames</code> 下标后跟着一个叹号（<code>!</code>），因为字典下标返回一个可选值（optional value），表明该键不存在时会查找失败。在上例中，由于可以确定 <code>number % 10</code> 总是 <code>digitNames</code> 字典的有效下标，因此叹号可以用于强制解包（force-unwrap）存储在下标的可选类型的返回值中的 <code>String</code> 类型的值。</p>
</blockquote>
<p>从 <code>digitNames</code> 字典中获取的字符串被添加到 <code>output</code> 的<em>前部</em>，逆序建立了一个字符串版本的数字。（在表达式 <code>number % 10</code> 中，如果 <code>number</code> 为 <code>16</code>，则返回 <code>6</code>，<code>58</code> 返回 <code>8</code>，<code>510</code> 返回 <code>0</code>。）</p>
<p><code>number</code> 变量之后除以 <code>10</code>。因为其是整数，在计算过程中未除尽部分被忽略。因此 <code>16</code> 变成了 <code>1</code>，<code>58</code> 变成了 <code>5</code>，<code>510</code> 变成了 <code>51</code>。</p>
<p>整个过程重复进行，直到 <code>number /= 10</code> 为 <code>0</code>，这时闭包会将字符串 <code>output</code> 返回，而 <code>map(_:)</code> 方法则会将字符串添加到映射数组中。</p>
<p>在上面的例子中，通过尾随闭包语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在 <code>map(_:)</code> 方法的括号内。</p>
<h2 id="值捕获">值捕获</h2>
<p>闭包可以在其被定义的上下文中<em>捕获</em>常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>
<p>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>
<p>举个例子，这有一个叫做 <code>makeIncrementer</code> 的函数，其包含了一个叫做 <code>incrementer</code> 的嵌套函数。嵌套函数 <code>incrementer()</code> 从上下文中捕获了两个值，<code>runningTotal</code> 和 <code>amount</code>。捕获这些值之后，<code>makeIncrementer</code> 将 <code>incrementer</code> 作为闭包返回。每次调用 <code>incrementer</code> 时，其会以 <code>amount</code> 作为增量增加 <code>runningTotal</code> 的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeIncrementer</span>(<span class="params">forIncrement</span> <span class="params">amount</span>: <span class="type">Int</span>) -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal <span class="operator">+=</span> amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makeIncrementer</code> 返回类型为 <code>() -&gt; Int</code>。这意味着其返回的是一个<em>函数</em>，而非一个简单类型的值。该函数在每次调用时不接受参数，只返回一个 <code>Int</code> 类型的值。关于函数返回其他函数的内容，请查看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#function_types_as_return_types">函数类型作为返回类型</a>。</p>
<p><code>makeIncrementer(forIncrement:)</code> 函数定义了一个初始值为 <code>0</code> 的整型变量 <code>runningTotal</code>，用来存储当前总计数值。该值为 <code>incrementer</code> 的返回值。</p>
<p><code>makeIncrementer(forIncrement:)</code> 有一个 <code>Int</code> 类型的参数，其外部参数名为 <code>forIncrement</code>，内部参数名为 <code>amount</code>，该参数表示每次 <code>incrementer</code> 被调用时 <code>runningTotal</code> 将要增加的量。<code>makeIncrementer</code> 函数还定义了一个嵌套函数 <code>incrementer</code>，用来执行实际的增加操作。该函数简单地使 <code>runningTotal</code> 增加 <code>amount</code>，并将其返回。</p>
<p>如果我们单独考虑嵌套函数 <code>incrementer()</code>，会发现它有些不同寻常：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    runningTotal <span class="operator">+=</span> amount</span><br><span class="line">    <span class="keyword">return</span> runningTotal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>incrementer()</code> 函数并没有任何参数，但是在函数体内访问了 <code>runningTotal</code> 和 <code>amount</code> 变量。这是因为它从外围函数捕获了 <code>runningTotal</code> 和 <code>amount</code> 变量的<em>引用</em>。捕获引用保证了 <code>runningTotal</code> 和 <code>amount</code> 变量在调用完 <code>makeIncrementer</code> 后不会消失，并且保证了在下一次执行 <code>incrementer</code> 函数时，<code>runningTotal</code> 依旧存在。</p>
<blockquote>
<p>注意</p>
<p>为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。</p>
<p>Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
</blockquote>
<p>下面是一个使用 <code>makeIncrementer</code> 的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>该例子定义了一个叫做 <code>incrementByTen</code> 的常量，该常量指向一个每次调用会将其 <code>runningTotal</code> 变量增加 <code>10</code> 的 <code>incrementer</code> 函数。调用这个函数多次可以得到以下结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为10</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为20</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为30</span></span><br></pre></td></tr></table></figure>
<p>如果你创建了另一个 <code>incrementer</code>，它会有属于自己的引用，指向一个全新、独立的 <code>runningTotal</code> 变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementBySeven <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()</span><br><span class="line"><span class="comment">// 返回的值为7</span></span><br></pre></td></tr></table></figure>
<p>再次调用原来的 <code>incrementByTen</code> 会继续增加它自己的 <code>runningTotal</code> 变量，该变量和 <code>incrementBySeven</code> 中捕获的变量没有任何联系：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为40</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用。更多信息，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/23_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包引起的循环强引用</a>。</p>
</blockquote>
<h2 id="闭包是引用类型">闭包是引用类型</h2>
<p>上面的例子中，<code>incrementBySeven</code> 和 <code>incrementByTen</code> 都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是<em>引用类型</em>。</p>
<p>无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的<em>引用</em>。上面的例子中，指向闭包的引用 <code>incrementByTen</code> 是一个常量，而并非闭包内容本身。</p>
<p>这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoIncrementByTen <span class="operator">=</span> incrementByTen</span><br><span class="line">alsoIncrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为50</span></span><br></pre></td></tr></table></figure>
<h2 id="逃逸闭包">逃逸闭包</h2>
<p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中<em>逃逸</em>。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 <code>@escaping</code>，用来指明这个闭包是允许“逃逸”出这个函数的。</p>
<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>someFunctionWithEscapingClosure(_:)</code> 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你不将这个参数标记为 <code>@escaping</code>，就会得到一个编译错误。</p>
<p>将一个闭包标记为 <code>@escaping</code> 意味着你必须在闭包中显式地引用 <code>self</code>。比如说，在下面的代码中，传递到 <code>someFunctionWithEscapingClosure(_:)</code> 中的闭包是一个逃逸闭包，这意味着它需要显式地引用 <code>self</code>。相对的，传递到 <code>someFunctionWithNonescapingClosure(_:)</code> 中的闭包是一个非逃逸闭包，这意味着它可以隐式引用 <code>self</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithNonescapingClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x <span class="operator">=</span> <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x <span class="operator">=</span> <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// 打印出“200”</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first<span class="operator">?</span>()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// 打印出“100”</span></span><br></pre></td></tr></table></figure>
<h2 id="自动闭包">自动闭包</h2>
<p><em>自动闭包</em>是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。</p>
<p>我们经常会<em>调用</em>采用自动闭包的函数，但是很少去<em>实现</em>这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code> 函数接受自动闭包作为它的 <code>condition</code> 参数和 <code>message</code> 参数；它的 <code>condition</code> 参数仅会在 debug 模式下被求值，它的 <code>message</code> 参数仅当 <code>condition</code> 参数为 <code>false</code> 时被计算求值。</p>
<p>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。下面的代码展示了闭包如何延时求值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“5”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customerProvider <span class="operator">=</span> &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“5”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Chris!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“4”</span></span><br></pre></td></tr></table></figure>
<p>尽管在闭包的代码中，<code>customersInLine</code> 的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，<code>customerProvider</code> 的类型不是 <code>String</code>，而是 <code>() -&gt; String</code>，一个没有参数且返回值为 <code>String</code> 的函数。</p>
<p>将闭包作为参数传递给函数时，你能获得同样的延时求值行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )</span><br><span class="line"><span class="comment">// 打印出“Now serving Alex!”</span></span><br></pre></td></tr></table></figure>
<p>上面的 <code>serve(customer:)</code> 函数接受一个返回顾客名字的显式的闭包。下面这个版本的 <code>serve(customer:)</code> 完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 <code>@autoclosure</code> 来接收一个自动闭包。现在你可以将该函数当作接受 <code>String</code> 类型参数（而非闭包）的函数来调用。<code>customerProvider</code> 参数将自动转化为一个闭包，因为该参数被标记了 <code>@autoclosure</code> 特性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 打印“Now serving Ewa!”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>过度使用 <code>autoclosures</code> 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</p>
</blockquote>
<p>如果你想让一个自动闭包可以“逃逸”，则应该同时使用 <code>@autoclosure</code> 和 <code>@escaping</code> 属性。<code>@escaping</code> 属性的讲解见上面的 <a href="#escaping_closures">逃逸闭包</a>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine i= [&quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">collectCustomerProviders</span>(<span class="keyword">_</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Collected <span class="subst">\(customerProviders.count)</span> closures.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Collected 2 closures.”</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Now serving Barry!”</span></span><br><span class="line"><span class="comment">// 打印“Now serving Daniella!”</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>collectCustomerProviders(_:)</code> 函数并没有调用传入的 <code>customerProvider</code> 闭包，而是将闭包追加到了 <code>customerProviders</code> 数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包能够在函数返回之后被调用。因此，<code>customerProvider</code> 参数必须允许“逃逸”出函数作用域。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../../2023/06/24/Swift/swift%E9%97%AD%E5%8C%85/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../../"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../3/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 2 頁 共 3 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
