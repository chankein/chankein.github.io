
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>分類: mysql - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/categories/database/mysql/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../#about"
            >
        
        
            <img class="header-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/20/cheat-sheet/mysql-cheat-sheet/"
                            aria-label=": mysql cheat sheet"
                        >
                            mysql cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:41:22+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">database</a>, <a class="category-link" href="">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="mysql">mysql:</h3>


	<div class="row">
    <embed src="/assets/pdf/mysql-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>



                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/20/cheat-sheet/mysql-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2017/09/16/database/%E6%90%AD%E5%BB%BAMySQL5-7-19%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%A5%E5%8F%8A%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/"
                            aria-label=": 搭建MySQL5.7.19主从复制,以及复制实现细节分析"
                        >
                            搭建MySQL5.7.19主从复制,以及复制实现细节分析
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-09-16T22:58:58+08:00">
	
		    2017 年 9 月 16 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">database</a>, <a class="category-link" href="">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="搭建-MySQL-5-7-19-主从复制，以及复制实现细节分析">搭建 MySQL 5.7.19 主从复制，以及复制实现细节分析</h2>
<h3 id="概念">概念</h3>
<p>主从复制可以使MySQL数据库主服务器的主数据库，复制到一个或多个MySQL从服务器从数据库，默认情况下，复制异步; 根据配置，可以复制数据库中的所有数据库，选定的数据库或甚至选定的表。</p>
<h3 id="MySQL中主从复制的优点">MySQL中主从复制的优点</h3>
<p><strong>横向扩展解决方案</strong></p>
<p>在多个从库之间扩展负载以提高性能。在这种环境中，所有写入和更新在主库上进行。但是，读取可能发生在一个或多个从库上。该模型可以提高写入的性能（由于主库专用于更新），同时在多个从库上读取，可以大大提高读取速度。</p>
<p><strong>数据安全性</strong></p>
<p>由于主库数据被复制到从库，从库可以暂停复制过程，可以在从库上运行备份服务，而不会破坏对应的主库数据。</p>
<p><strong>分析</strong></p>
<p>可以在主库上创建实时数据，而信息分析可以在从库上进行，而不会影响主服务器的性能。</p>
<p><strong>长距离数据分发</strong></p>
<p>可以使用复制创建远程站点使用的数据的本地副本，而无需永久访问主库。</p>
<h3 id="1-准备工作">1.准备工作</h3>
<p><a href="hhttps://dev.mysql.com/doc/refman/5.7/en/replication.html">参考 MySQL官网 - 第16章主从复制</a></p>
<p>Mysql版本：MySQL 5.7.19<br>
Master-Server : 192.168.252.123<br>
Slave-Server : 192.168.252.124</p>
<p>关闭防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<h4 id="安装-MySQL">安装 MySQL</h4>
<p><a href="https://chankein.github.io/2017/08/16/database/CentOs7-3-%E5%AE%89%E8%A3%85-MySQL-5-7-19-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88%E6%9C%AC/">参考 - CentOs7.3 安装 MySQL 5.7.19 二进制版本</a></p>
<p>首先在两台机器上装上，保证正常启动，可以使用</p>
<h3 id="2-Master-Server-配置">2. Master-Server 配置</h3>
<h4 id="修改-my-cnf">修改 my.cnf</h4>
<p>配置 Master 以使用基于二进制日志文件位置的复制，必须启用二进制日志记录并建立唯一的服务器ID,否则则无法进行主从复制。</p>
<p>停止MySQL服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service mysql.server stop</span><br></pre></td></tr></table></figure>
<p>开启binlog ，每台设置不同的 server-id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure>
<p>启动MySQL服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service mysql.server start</span><br></pre></td></tr></table></figure>
<p>登录MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/mysql/bin/mysql -uroot -p</span><br></pre></td></tr></table></figure>
<h4 id="创建用户">创建用户</h4>
<p>每个从库使用MySQL用户名和密码连接到主库，因此主库上必须有用户帐户，从库可以连接。任何帐户都可以用于此操作，只要它已被授予 <code>REPLICATION SLAVE</code>权限。可以选择为每个从库创建不同的帐户，或者每个从库使用相同帐户连接到主库</p>
<p>虽然不必专门为复制创建帐户，但应注意，复制用到的用户名和密码会以纯文本格式存储在主信息存储库文件或表中 。因此，需要创建一个单独的帐户，该帐户只具有复制过程的权限，以尽可能减少对其他帐户的危害。</p>
<p>登录MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/mysql/bin/mysql -uroot -p</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;replication&#x27;</span>@<span class="string">&#x27;192.168.252.124&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mima&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;replication&#x27;</span>@<span class="string">&#x27;192.168.252.124&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-Slave-Server-配置">3.Slave-Server 配置</h3>
<h4 id="修改-my-cnf-2">修改 my.cnf</h4>
<p>停止MySQL服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service mysql.server stop</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure>
<p><strong>如果要设置多个从库，则每个从库的server-id与主库和其他从库设置不同的唯一值。</strong></p>
<p>启动MySQL服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service mysql.server start</span><br></pre></td></tr></table></figure>
<p>登录MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/mysql/bin/mysql -uroot -p</span><br></pre></td></tr></table></figure>
<h4 id="配置主库通信">配置主库通信</h4>
<p><strong>查看 Master-Server ， binlog File 文件名称和 Position值位置 并且记下来</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> File             <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB <span class="operator">|</span> Binlog_Ignore_DB <span class="operator">|</span> Executed_Gtid_Set <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>      <span class="number">629</span> <span class="operator">|</span>              <span class="operator">|</span>                  <span class="operator">|</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>要设置从库与主库进行通信，进行复制，使用必要的连接信息配置从库在从库上执行以下语句<br>
<strong>将选项值替换为与系统相关的实际值</strong></p>
<p><strong>参数格式，请勿执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">    -&gt;     MASTER_HOST=&#x27;master_host_name&#x27;,</span><br><span class="line">    -&gt;     MASTER_USER=&#x27;replication_user_name&#x27;,</span><br><span class="line">    -&gt;     MASTER_PASSWORD=&#x27;replication_password&#x27;,</span><br><span class="line">    -&gt;     MASTER_LOG_FILE=&#x27;recorded_log_file_name&#x27;,</span><br><span class="line">    -&gt;     MASTER_LOG_POS=recorded_log_position;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">    -&gt; MASTER_HOST=&#x27;192.168.252.123&#x27;,</span><br><span class="line">    -&gt; MASTER_USER=&#x27;replication&#x27;,</span><br><span class="line">    -&gt; MASTER_PASSWORD=&#x27;mima&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,</span><br><span class="line">    -&gt; MASTER_LOG_POS=629;</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.02 sec)</span><br></pre></td></tr></table></figure>
<p><code>MASTER_LOG_POS=0</code> 写成0 也是可以的</p>
<p>放在一行执行方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.252.123&#x27;, MASTER_USER=&#x27;replication&#x27;, MASTER_PASSWORD=&#x27;mima&#x27;, MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;, MASTER_LOG_POS=629;</span><br></pre></td></tr></table></figure>
<p>启动从服务器复制线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START SLAVE;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<h4 id="查看复制状态">查看复制状态</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 192.168.252.123</span><br><span class="line">                  Master_User: replication</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 629</span><br><span class="line">               Relay_Log_File: master2-relay-bin.000003</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><strong>检查主从复制通信状态</strong></p>
<p><code>Slave_IO_State</code> #从站的当前状态<br>
<code>Slave_IO_Running： Yes</code> #读取主程序二进制日志的I/O线程是否正在运行<br>
<code>Slave_SQL_Running： Yes</code> #执行读取主服务器中二进制日志事件的SQL线程是否正在运行。与I/O线程一样<br>
<code>Seconds_Behind_Master</code> #是否为0，0就是已经同步了</p>
<p><strong>必须都是 Yes</strong></p>
<p>如果不是原因主要有以下 4 个方面：</p>
<p>1、网络不通<br>
2、密码不对<br>
3、MASTER_LOG_POS 不对 ps<br>
4、mysql 的 <code>auto.cnf</code> server-uuid 一样（可能你是复制的mysql）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find / -name &#x27;auto.cnf&#x27;</span><br><span class="line">$ cat /var/lib/mysql/auto.cnf</span><br><span class="line">[auto]</span><br><span class="line">server-uuid=6b831bf3-8ae7-11e7-a178-000c29cb5cbc # 按照这个16进制格式，修改server-uuid，重启mysql即可</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/replication-administration-status.html">检查复制状态</a></p>
<h3 id="4-测试主从复制">4.测试主从复制</h3>
<p>启动MySQL服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service mysql.server start</span><br></pre></td></tr></table></figure>
<p>登录MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/mysql/bin/mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>在 Master-Server 创建测试库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> DATABASE `replication_wwww.ymq.io`;</span><br><span class="line">mysql<span class="operator">&gt;</span> use `replication_wwww.ymq.io`;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> `sync_test` (`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT, `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>, <span class="keyword">PRIMARY KEY</span> (`id`) ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>在 Slave-Server 查看是否同步过来</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> Database                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> replication_wwww.ymq.io <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use replication_wwww.ymq.io</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_replication_wwww.ymq.io <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> sync_test                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h4 id="一些命令">一些命令</h4>
<p>查看主服务器的运行状态</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> File             <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB <span class="operator">|</span> Binlog_Ignore_DB <span class="operator">|</span> Executed_Gtid_Set <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>     <span class="number">1190</span> <span class="operator">|</span>              <span class="operator">|</span>                  <span class="operator">|</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br></pre></td></tr></table></figure>
<p>查看从服务器主机列表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> slave hosts;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+------+------+-----------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Server_id <span class="operator">|</span> Host <span class="operator">|</span> Port <span class="operator">|</span> Master_id <span class="operator">|</span> Slave_UUID                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+------+------+-----------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">2</span> <span class="operator">|</span>      <span class="operator">|</span> <span class="number">3306</span> <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span> <span class="number">6</span>b831bf2<span class="number">-8</span>ae7<span class="number">-11e7</span><span class="operator">-</span>a178<span class="number">-000</span>c29cb5cbc <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+------+------+-----------+--------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>获取binlog文件列表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="type">binary</span> logs;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name         <span class="operator">|</span> File_size <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>      <span class="number">1190</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------+</span></span><br></pre></td></tr></table></figure>
<p>只查看第一个binlog文件的内容</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Log_name         <span class="operator">|</span> Pos <span class="operator">|</span> Event_type     <span class="operator">|</span> Server_id <span class="operator">|</span> End_log_pos <span class="operator">|</span> Info                                                                                                                                                                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> Format_desc    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">123</span> <span class="operator">|</span> Server ver: <span class="number">5.7</span><span class="number">.19</span><span class="operator">-</span>log, Binlog ver: <span class="number">4</span>                                                                                                                                                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">123</span> <span class="operator">|</span> Previous_gtids <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">154</span> <span class="operator">|</span>                                                                                                                                                                                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">420</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">485</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                                                                                                                                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">485</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">629</span> <span class="operator">|</span> <span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;replication&#x27;</span>@<span class="string">&#x27;192.168.252.124&#x27;</span>                                                                                                                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">629</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">694</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                                                                                                                                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">694</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">847</span> <span class="operator">|</span> <span class="keyword">CREATE</span> DATABASE `replication_wwww.ymq.io`                                                                                                                                                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">847</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">912</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                                                                                                                                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">912</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>        <span class="number">1190</span> <span class="operator">|</span> use `replication_wwww.ymq.io`; <span class="keyword">CREATE TABLE</span> `sync_test` (`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT, `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>, <span class="keyword">PRIMARY KEY</span> (`id`) ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>查看指定binlog文件的内容</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.000001&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Log_name         <span class="operator">|</span> Pos <span class="operator">|</span> Event_type     <span class="operator">|</span> Server_id <span class="operator">|</span> End_log_pos <span class="operator">|</span> Info                                                                                                                                                                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> Format_desc    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">123</span> <span class="operator">|</span> Server ver: <span class="number">5.7</span><span class="number">.19</span><span class="operator">-</span>log, Binlog ver: <span class="number">4</span>                                                                                                                                                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">123</span> <span class="operator">|</span> Previous_gtids <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">154</span> <span class="operator">|</span>                                                                                                                                                                                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">420</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">485</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                                                                                                                                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">485</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">629</span> <span class="operator">|</span> <span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;replication&#x27;</span>@<span class="string">&#x27;192.168.252.124&#x27;</span>                                                                                                                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">629</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">694</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                                                                                                                                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">694</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">847</span> <span class="operator">|</span> <span class="keyword">CREATE</span> DATABASE `replication_wwww.ymq.io`                                                                                                                                                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">847</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">912</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                                                                                                                                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">912</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>        <span class="number">1190</span> <span class="operator">|</span> use `replication_wwww.ymq.io`; <span class="keyword">CREATE TABLE</span> `sync_test` (`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT, `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>, <span class="keyword">PRIMARY KEY</span> (`id`) ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>启动从库复制线程</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> SLAVE;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>停止从库复制线程</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> STOP SLAVE;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="5-复制实现细节分析">5.复制实现细节分析</h3>
<p>MySQL主从复制功能使用<strong>三个线程实现</strong>，<strong>一个在主服务器上</strong>，<strong>两个在从服务器上</strong></p>
<h4 id="1-Binlog转储线程。">1.Binlog转储线程。</h4>
<p>当从服务器与主服务器连接时，主服务器会创建一个线程将二进制日志内容发送到从服务器。<br>
该线程可以使用 语句 <code>SHOW PROCESSLIST</code>(下面有示例介绍) 在服务器 sql 控制台输出中标识为Binlog Dump线程。</p>
<p>二进制日志转储线程获取服务器上二进制日志上的锁，用于读取要发送到从服务器的每个事件。一旦事件被读取，即使在将事件发送到从服务器之前，锁会被释放。</p>
<h4 id="2-从服务器I-O线程。">2.从服务器I/O线程。</h4>
<p>当在从服务器sql 控制台发出 <code>START SLAVE</code>语句时，从服务器将创建一个I/O线程，该线程连接到主服务器，并要求它发送记录在主服务器上的二进制更新日志。</p>
<p>从机I/O线程读取主服务器Binlog Dump线程发送的更新 （参考上面 Binlog转储线程 介绍），并将它们复制到自己的本地文件二进制日志中。</p>
<p>该线程的状态显示详情 Slave_IO_running 在输出端 使用 命令<code>SHOW SLAVE STATUS</code></p>
<p>使用<code>\G</code>语句终结符,而不是分号,是为了，易读的垂直布局</p>
<p>这个命令在上面 <strong>查看从服务器状态</strong> 用到过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW SLAVE STATUS\G</span><br></pre></td></tr></table></figure>
<h4 id="3-从服务器SQL线程。">3.从服务器SQL线程。</h4>
<p>从服务器创建一条SQL线程来读取由主服务器I/O线程写入的二级制日志，并执行其中包含的事件。</p>
<p>在前面的描述中，每个主/从连接有三个线程。主服务器为每个当前连接的从服务器创建一个二进制日志转储线程，每个从服务器都有自己的I/O和SQL线程。<br>
从服务器使用两个线程将读取更新与主服务器更新事件，并将其执行为独立任务。因此，如果语句执行缓慢，则读取语句的任务不会减慢。</p>
<p>例如，如果从服务器开始几分钟没有运行，或者即使SQL线程远远落后，它的I/O线程也可以从主服务器建立连接时，快速获取所有二进制日志内容。</p>
<p>如果从服务器在SQL线程执行所有获取的语句之前停止，则I/O线程至少获取已经读取到的内容，以便将语句的安全副本存储在自己的二级制日志文件中，准备下次执行主从服务器建立连接，继续同步。</p>
<p>使用命令 <code>SHOW PROCESSLIST\G</code> 可以查看有关复制的信息</p>
<p>命令 SHOW FULL PROCESSLISTG</p>
<p><strong>在 Master 主服务器 执行的数据示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  SHOW FULL PROCESSLIST\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     Id: 22</span><br><span class="line">   User: repl</span><br><span class="line">   Host: node2:39114</span><br><span class="line">     db: NULL</span><br><span class="line">Command: Binlog Dump</span><br><span class="line">   Time: 4435</span><br><span class="line">  State: Master has sent all binlog to slave; waiting for more updates</span><br><span class="line">   Info: NULL</span><br></pre></td></tr></table></figure>
<p>Id: 22是Binlog Dump服务连接的从站的复制线程<br>
Host: node2:39114 是从服务，主机名 级及端口<br>
State: 信息表示所有更新都已同步发送到从服务器，并且主服务器正在等待更多更新发生。<br>
如果Binlog Dump在主服务器上看不到 线程，意味着主从复制没有配置成功; 也就是说，没有从服务器连接主服务器。</p>
<p>命令 SHOW PROCESSLISTG</p>
<p><strong>在 Slave 从服务器 ，查看两个线程的更新状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROCESSLIST\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     Id: 6</span><br><span class="line">   User: system user</span><br><span class="line">   Host: </span><br><span class="line">     db: NULL</span><br><span class="line">Command: Connect</span><br><span class="line">   Time: 6810</span><br><span class="line">  State: Waiting for master to send event</span><br><span class="line">   Info: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">     Id: 7</span><br><span class="line">   User: system user</span><br><span class="line">   Host: </span><br><span class="line">     db: NULL</span><br><span class="line">Command: Connect</span><br><span class="line">   Time: 3069</span><br><span class="line">  State: Slave has read all relay log; waiting for more updates</span><br><span class="line">   Info: NULL</span><br></pre></td></tr></table></figure>
<p><strong>Id: 6</strong>是与主服务器通信的I/O线程<br>
<strong>Id: 7</strong>是正在处理存储在中继日志中的更新的SQL线程</p>
<p>在 运行 <code>SHOW PROCESSLIST</code> 命令时，两个线程都空闲，等待进一步更新</p>
<p>如果在主服务器上在设置的超时，时间内 Binlog Dump线程没有活动，则主服务器会和从服务器断开连接。超时取决于的 <strong>服务器系统变量</strong> 值 net_write_timeout(在中止写入之前等待块写入连接的秒数，默认10秒)和 net_retry_count;(如果通信端口上的读取或写入中断，请在重试次数，默认10次) 设置 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html">服务器系统变量</a></p>
<p>该SHOW SLAVE STATUS语句提供了有关从服务器上复制处理的附加信息。请参见 第16.1.7.1节“检查复制状态”。</p>
<h3 id="6-更多常见主从复制问题：">6.更多常见主从复制问题：</h3>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/faqs-replication.html">常见主从复制问题</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2017/09/16/database/%E6%90%AD%E5%BB%BAMySQL5-7-19%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%A5%E5%8F%8A%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2017/08/17/database/MySQL-%E4%BD%BF%E7%94%A8-SSL-%E8%BF%9E%E6%8E%A5-%E9%99%84-Docker-%E4%BE%8B%E5%AD%90/"
                            aria-label=": MySQL 使用 SSL 连接(附 Docker 例子)"
                        >
                            MySQL 使用 SSL 连接(附 Docker 例子)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-08-17T22:55:08+08:00">
	
		    2017 年 8 月 17 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">database</a>, <a class="category-link" href="">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="查看是否支持-SSL">查看是否支持 SSL</h2>
<p>首先在 MySQL 上执行如下命令, 查询是否 MySQL 支持 SSL:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW VARIABLES LIKE <span class="string">&#x27;have_ssl&#x27;</span>;</span></span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| have_ssl      | YES   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure>
<p>当 <code>have_ssl</code> 为 <code>YES</code> 时, 表示此时 MySQL 服务已经支持 SSL 了. 如果是 <code>DESABLE</code>, 则需要在启动 MySQL 服务时, 使能 SSL 功能.</p>
<h2 id="使用-OpenSSL-创建-SSL-证书和私钥">使用 OpenSSL 创建 SSL 证书和私钥</h2>
<p>首先我们需要使用 openssl 来创建服务器端的证书和私钥. 我使用的 openssl 版本为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; /usr/local/Cellar/openssl/1.0.2j/bin/openssl version</span><br><span class="line">OpenSSL 1.0.2j  26 Sep 2016</span><br></pre></td></tr></table></figure>
<p>新建一个 <strong>~/temp/cert</strong> 目录, 用于存放生成的证书和私钥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/temp/cert</span><br><span class="line">cd ~/temp/cert</span><br></pre></td></tr></table></figure>
<h3 id="创建-CA-私钥和-CA-证书">创建 CA 私钥和 CA 证书</h3>
<p>然后, 我们先来生成一个 CA 私钥:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa 2048 &gt; ca-key.pem</span><br></pre></td></tr></table></figure>
<p>当有了一个 CA 私钥, 我们接下来就可以使用这个私钥生成一个新的数字证书:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -sha1 -new -x509 -nodes -days 3650 -key ca-key.pem &gt; ca-cert.pem</span><br></pre></td></tr></table></figure>
<p>执行这个命令时, 会需要填写一些问题, 随便填写就可以了. 例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; openssl req -sha1 -new -x509 -nodes -days 3650 -key ca-key.pem &gt; ca-cert.pem</span><br><span class="line"></span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [AU]:CN</span><br><span class="line">State or Province Name (full name) [Some-State]:Beijing</span><br><span class="line">Locality Name (eg, city) []:Beijing</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:xys</span><br><span class="line">Organizational Unit Name (eg, section) []:xys</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:xys</span><br><span class="line">Email Address []:yongshun1228@gmail.com</span><br></pre></td></tr></table></figure>
<p>执行上述命令后, 我们就有了一个 CA 私钥和一个 CA 证书.</p>
<h3 id="创建服务器端的-RSA-私钥和数字证书">创建服务器端的 RSA 私钥和数字证书</h3>
<p>接着, 我们需要创建服务器端的私钥和一个证书请求文件, 命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -sha1 -newkey rsa:2048 -days 3650 -nodes -keyout server-key.pem &gt; server-req.pem</span><br></pre></td></tr></table></figure>
<p>上面这个命令会生成一个新的私钥(server-key.pem), 同时会使用这个新私钥来生成一个证书请求文件(server-req.pem).<br>
上面这个命令同样需要回答几个问题, 随便填写即可. 不过需要注意的是, <code>A challenge password</code> 这一项需要为空.<br>
即:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; openssl req -sha1 -newkey rsa:2048 -days 3650 -nodes -keyout server-key.pem &gt; server-req.pem</span><br><span class="line"></span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">.................+++</span><br><span class="line">..+++</span><br><span class="line">writing new private key to &#x27;server-key.pem&#x27;</span><br><span class="line">-----</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [AU]:CN</span><br><span class="line">State or Province Name (full name) [Some-State]:Beijing</span><br><span class="line">Locality Name (eg, city) []:Beijing</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:xys</span><br><span class="line">Organizational Unit Name (eg, section) []:xys</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:xys</span><br><span class="line">Email Address []:yongshun1228@gmail.com</span><br><span class="line"></span><br><span class="line">Please enter the following &#x27;extra&#x27; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br></pre></td></tr></table></figure>
<p>下一步, 我们需要将生成的私钥转换为 RSA 私钥文件格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in server-key.pem -out server-key.pem</span><br></pre></td></tr></table></figure>
<p>最后一步, 我们需要使用原先生成的 CA 证书来生成一个服务器端的数字证书:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -sha1 -req -in server-req.pem -days 3650 -CA ca-cert.pem -CAkey ca-key.pem -set_serial 01 &gt; server-cert.pem</span><br></pre></td></tr></table></figure>
<p>上面的命令会创建以服务器端的数字证书文件.</p>
<h3 id="创建客户端的-RSA-私钥和数字证书">创建客户端的 RSA 私钥和数字证书</h3>
<p>和服务器端所执行的命令类似, 我们也需要为客户端生成一个私钥和证书请求文件, 命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -sha1 -newkey rsa:2048 -days 3650 -nodes -keyout client-key.pem &gt; client-req.pem</span><br></pre></td></tr></table></figure>
<p>同样地, 我们需要将生成的私钥转换为 RSA 私钥文件格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in client-key.pem -out client-key.pem</span><br></pre></td></tr></table></figure>
<p>最后, 我们也需要为客户端创建一个数字证书:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -sha1 -req -in client-req.pem -days 3650 -CA ca-cert.pem -CAkey ca-key.pem -set_serial 01 &gt; client-cert.pem</span><br></pre></td></tr></table></figure>
<h2 id="使用工具创建证书与私钥">使用工具创建证书与私钥</h2>
<p>前面我们介绍了如何使用 OpenSSL 来创建 SSL 连接的私钥和证书文件, 现在我们来看一个更简单的方法.<br>
在 MySQL 5.7 中, 提供了一个名为 <code>mysql_ssl_rsa_setup</code> 的工具, 通过它, 我们可以很方便地创建 SSL 连接所需要的各种文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/temp/cert</span><br><span class="line">cd ~/temp/cert</span><br><span class="line">mysql_ssl_rsa_setup --datadir ./</span><br></pre></td></tr></table></figure>
<p>上面的命令中, <code>--datadir</code> 表示生成的文件的目录.</p>
<p>当执行了上述命令后, 也会生成八个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ca-key.pem</span><br><span class="line">ca.pem</span><br><span class="line">client-cert.pem</span><br><span class="line">client-key.pem</span><br><span class="line">private_key.pem</span><br><span class="line">public_key.pem</span><br><span class="line">server-cert.pem</span><br><span class="line">server-key.pem</span><br></pre></td></tr></table></figure>
<p>这些文件和我们使用 OpenSSL 所创建的那八个文件的作用是一样的, 这里就不再详述了.</p>
<h2 id="SSL-配置">SSL 配置</h2>
<p>在前面的步骤中, 我们已经生成了8个文件, 分别是:</p>
<ul>
<li>
<p>ca-cert.pem: CA 证书, 用于生成服务器端/客户端的数字证书.</p>
</li>
<li>
<p>ca-key.pem: CA 私钥, 用于生成服务器端/客户端的数字证书.</p>
</li>
<li>
<p>server-key.pem: 服务器端的 RSA 私钥</p>
</li>
<li>
<p>server-req.pem: 服务器端的证书请求文件, 用于生成服务器端的数字证书.</p>
</li>
<li>
<p>server-cert.pem: 服务器端的数字证书.</p>
</li>
<li>
<p>client-key.pem: 客户端的 RSA 私钥</p>
</li>
<li>
<p>client-req.pem: 客户端的证书请求文件, 用于生成客户端的数字证书.</p>
</li>
<li>
<p>client-cert.pem: 客户端的数字证书.</p>
</li>
</ul>
<p>接下来我们就需要分别配置服务器端和客户端.</p>
<h3 id="服务器端配置">服务器端配置</h3>
<p>服务器端需要用到三个文件, 分别是: <code>CA 证书</code>, <code>服务器端的 RSA 私钥</code>, <code>服务器端的数字证书</code>, 我们需要在 <code>[mysqld]</code> 配置域下添加如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">ssl-ca=/etc/mysql/ca-cert.pem</span><br><span class="line">ssl-cert=/etc/mysql/server-cert.pem</span><br><span class="line">ssl-key=/etc/mysql/server-key.pem</span><br></pre></td></tr></table></figure>
<p>接着我们还可以更改 <code>bind-address</code>, 使 MySQL 服务可以接收来自所有 ip 地址的客户端, 即:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind-address = *</span><br></pre></td></tr></table></figure>
<p>当配置好后, 我们需要重启 MySQL 服务, 使能配置.</p>
<p>最后一步, 我们添加一个需要使用 SSL 才可以登录的帐号, 来验证一下我们所配置的 SSL 是否生效:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;ssl_test&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;ssl_test&#x27; REQUIRE SSL;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>当配置好后, 使用 root 登录 MySQL, 执行 <code>show variables like '%ssl%'</code> 语句会有如下输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%ssl%&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| have_openssl  | YES             |</span><br><span class="line">| have_ssl      | YES             |</span><br><span class="line">| ssl_ca        | ca.pem          |</span><br><span class="line">| ssl_capath    |                 |</span><br><span class="line">| ssl_cert      | server-cert.pem |</span><br><span class="line">| ssl_cipher    |                 |</span><br><span class="line">| ssl_crl       |                 |</span><br><span class="line">| ssl_crlpath   |                 |</span><br><span class="line">| ssl_key       | server-key.pem  |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">9 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<h3 id="客户端配置">客户端配置</h3>
<p>客户端配置相对简单一些. 首先我们需要拷贝 <code>ca-cert.pem</code>, <code>client-cert.pem</code> 和 <code>client-key.pem</code> 这三个文件到客户端主机中, 然后我们可以执行如下命令来使用 SSL 连接 MySQL 服务:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --ssl-ca=/path/to/ca-cert.pem --ssl-cert=/path/to/client-cert.pem --ssl-key=/path/to/client-key.pem -h host_name -u ssl_test -p</span><br></pre></td></tr></table></figure>
<p>除了上述的使用命令行方式配置 SSL 外, 我们也可以使用配置文件的方式. 即在 <code>~/.my.cnf</code> 文件中添加如下内容即可:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">ssl-ca=/path/to/ca-cert.pem</span><br><span class="line">ssl-cert=/path/to/client-cert.pem</span><br><span class="line">ssl-key=/path/to/client-key.pem</span><br></pre></td></tr></table></figure>
<p>当连接成功后, 我们执行如下指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; \s</span><br><span class="line">--------------</span><br><span class="line">mysql  Ver 14.14 Distrib 5.7.17, for Linux (x86_64) using  EditLine wrapper</span><br><span class="line"></span><br><span class="line">Connection id:        14</span><br><span class="line">Current database:</span><br><span class="line">Current user:        ssl_test@172.17.0.4</span><br><span class="line">SSL:            Cipher in use is DHE-RSA-AES256-SHA</span><br><span class="line">Current pager:        stdout</span><br><span class="line">Using outfile:        &#x27;&#x27;</span><br><span class="line">Using delimiter:    ;</span><br><span class="line">Server version:        5.7.17 MySQL Community Server (GPL)</span><br><span class="line">Protocol version:    10</span><br><span class="line">Connection:        test_db via TCP/IP</span><br><span class="line">Server characterset:    latin1</span><br><span class="line">Db     characterset:    latin1</span><br><span class="line">Client characterset:    latin1</span><br><span class="line">Conn.  characterset:    latin1</span><br><span class="line">TCP port:        3306</span><br><span class="line">Uptime:            1 hour 2 min 9 sec</span><br><span class="line"></span><br><span class="line">Threads: 1  Questions: 23  Slow queries: 0  Opens: 126  Flush tables: 3  Open tables: 0  Queries per second avg: 0.006</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>
<p>如果输出中有 <code>SSL: Cipher in use is DHE-RSA-AES256-SHA</code> 之类的信息, 则表示已经使用 SSL 来连接了.</p>
<h2 id="在-Docker-中使能-MySQL-SSL-连接">在 Docker 中使能 MySQL SSL 连接</h2>
<p>上面我们简单介绍了一下如果使能 MySQL SSL 连接, 那么现在我们使用 Docker 来具体的实战一把吧!</p>
<p>首先拉取最新的 MySQL 镜像:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
<p>然后需要准备一下挂载到 Docker 容器的目录结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; cd ~/temp</span><br><span class="line">&gt;&gt;&gt; tree</span><br><span class="line">.</span><br><span class="line">├── cert</span><br><span class="line">│   ├── ca-key.pem</span><br><span class="line">│   ├── ca.pem</span><br><span class="line">│   ├── client-cert.pem</span><br><span class="line">│   ├── client-key.pem</span><br><span class="line">│   ├── private_key.pem</span><br><span class="line">│   ├── public_key.pem</span><br><span class="line">│   ├── server-cert.pem</span><br><span class="line">│   └── server-key.pem</span><br><span class="line">├── config</span><br><span class="line">│   └── my.cnf</span><br><span class="line">└── db</span><br><span class="line"></span><br><span class="line">3 directories, 9 files</span><br></pre></td></tr></table></figure>
<p>在 temp 目录下有三个子目录:</p>
<ul>
<li>
<p><code>cert</code> 目录用于存放我们先前生成的证书和私钥信息;</p>
</li>
<li>
<p><code>config</code> 目录用于存放 MySQL 服务的配置文件</p>
</li>
<li>
<p><code>db</code> 目录是用于存放 MySQL 的数据.</p>
</li>
</ul>
<p>下一步我们需要使用如下命令启动 MySQL 容器:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --name test_db -p 10000:3306 -e MYSQL_ROOT_PASSWORD=root -v /Users/xiongyongshun/temp/db:/var/lib/mysql -v /Users/xiongyongshun/temp/config:/etc/mysql/conf.d -v /Users/xiongyongshun/temp/cert:/etc/mysql/cert mysql:latest</span><br></pre></td></tr></table></figure>
<p>我们在上面的命令中, 我们分别挂载了 <code>cert</code>, <code>config</code>, <code>db</code> 这三个宿主机上的目录到 MySQL 容器中.</p>
<p>启动了 MySQL 服务后, 可以先使用 root 帐号登录 MySQL, 来检查 MySQL 服务此时是否已经开启了 SSL 功能:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --link test_db:test_db --rm  mysql sh -c &#x27;exec mysql -u root -p -h test_db&#x27;</span><br></pre></td></tr></table></figure>
<p>登录成功后, 我们在 MySQL 中执行如下指令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%ssl%&#x27;;</span><br><span class="line">+---------------+---------------------------------+</span><br><span class="line">| Variable_name | Value                           |</span><br><span class="line">+---------------+---------------------------------+</span><br><span class="line">| have_openssl  | YES                             |</span><br><span class="line">| have_ssl      | YES                             |</span><br><span class="line">| ssl_ca        | /etc/mysql/cert/ca-cert.pem     |</span><br><span class="line">| ssl_capath    |                                 |</span><br><span class="line">| ssl_cert      | /etc/mysql/cert/server-cert.pem |</span><br><span class="line">| ssl_cipher    |                                 |</span><br><span class="line">| ssl_crl       |                                 |</span><br><span class="line">| ssl_crlpath   |                                 |</span><br><span class="line">| ssl_key       | /etc/mysql/cert/server-key.pem  |</span><br><span class="line">+---------------+---------------------------------+</span><br><span class="line">9 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>有上面的输出后, 表明此时 MySQL 服务已经使用 SSL 功能了.</p>
<p>接着下一步, 我们按照前面所提到的, 创建一个仅仅可以使用 SSL 登录的帐号, 来检验我们的配置是否有效:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;ssl_test&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;ssl_test&#x27; REQUIRE SSL;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>上面的命令创建了一个帐号名为 <code>ssl_test</code>, 密码为 <code>ssl_test</code>, 并且不限制登录主机 ip 的帐号.</p>
<p>这些都配置成功后, 我们再启动一个 MySQL 客户端容器:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --link test_db:test_db --rm -v /Users/xiongyongshun/temp/cert:/etc/mysql/cert mysql sh -c &#x27;exec mysql --ssl-ca=/etc/mysql/cert/ca-cert.pem --ssl-cert=/etc/mysql/cert/client-cert.pem --ssl-key=/etc/mysql/cert/client-key.pem -h test_db -u ssl_test -p&#x27;</span><br></pre></td></tr></table></figure>
<p>从上面的这个命令中我们可以看到, 启动 MySQL 客户端容器时, 我们挂载了宿主机的 <code>cert</code> 目录到容器内的 <code>/etc/mysql/cert</code> 目录, 这样在容器中就可以访问到 SSL 私钥和证书文件了. 接着我们在 MySQL 客户端命令行中, 使用 <code>--ssl-ca</code>, <code>--ssl-cert</code>, <code>--ssl-key</code> 这三个参数来指定 SSL 连接所需要的 CA 证书, RSA 私钥和客户端证书.</p>
<p>登录成功后, 我们执行 <code>s</code> 命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; \s</span><br><span class="line">--------------</span><br><span class="line">mysql  Ver 14.14 Distrib 5.7.17, for Linux (x86_64) using  EditLine wrapper</span><br><span class="line"></span><br><span class="line">Connection id:        5</span><br><span class="line">Current database:</span><br><span class="line">Current user:        ssl_test@172.17.0.5</span><br><span class="line">SSL:            Cipher in use is DHE-RSA-AES256-SHA</span><br><span class="line">Current pager:        stdout</span><br><span class="line">Using outfile:        &#x27;&#x27;</span><br><span class="line">Using delimiter:    ;</span><br><span class="line">Server version:        5.7.17 MySQL Community Server (GPL)</span><br><span class="line">Protocol version:    10</span><br><span class="line">Connection:        test_db via TCP/IP</span><br><span class="line">Server characterset:    latin1</span><br><span class="line">Db     characterset:    latin1</span><br><span class="line">Client characterset:    latin1</span><br><span class="line">Conn.  characterset:    latin1</span><br><span class="line">TCP port:        3306</span><br><span class="line">Uptime:            6 min 8 sec</span><br><span class="line"></span><br><span class="line">Threads: 2  Questions: 10  Slow queries: 0  Opens: 113  Flush tables: 1  Open tables: 106  Queries per second avg: 0.027</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>
<p>输出中有 <code>SSL: Cipher in use is DHE-RSA-AES256-SHA</code> 信息则说明我们确实是使用了 SSL 连接的 MySQL 服务器.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2017/08/17/database/MySQL-%E4%BD%BF%E7%94%A8-SSL-%E8%BF%9E%E6%8E%A5-%E9%99%84-Docker-%E4%BE%8B%E5%AD%90/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2017/08/16/database/CentOs7-3-%E5%AE%89%E8%A3%85-MySQL-5-7-19-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88%E6%9C%AC/"
                            aria-label=": CentOs7.3 安装 MySQL 5.7.19 二进制版本"
                        >
                            CentOs7.3 安装 MySQL 5.7.19 二进制版本
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-08-16T22:55:08+08:00">
	
		    2017 年 8 月 16 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">database</a>, <a class="category-link" href="">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="CentOs7-3-安装-MySQL-5-7-19-二进制版本">CentOs7.3 安装 MySQL 5.7.19 二进制版本</h2>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/binary-installation.html">参考官网 - 使用通用二进制文件在Unix / Linux上安装MySQL</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/mysql/">MySQL社区版 下载地址</a></p>
<p>采用二进制方式免编译安装MySQL,适合各类MySQL产品系列,不需要复杂的编译设置和编译时间等待,直接解压下载的软件包,初始化即可完成MySQL的安装和启动.</p>
<h3 id="1-准备工作">1.准备工作</h3>
<h4 id="依赖环境">依赖环境</h4>
<p>关闭防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<p>MySQL依赖于libaio 库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum search libaio</span><br><span class="line">$ yum install libaio</span><br></pre></td></tr></table></figure>
<h4 id="下载，解压，重命名">下载，解压，重命名</h4>
<p>通常解压在 <code>/usr/local/mysql</code></p>
<p>把<code>mysql-5.7.19-linux-glibc2.12-x86_64</code> 文件夹，重命名成<code>mysql</code>,这样就凑成<code>/usr/local/mysql</code>目录了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /opt/</span><br><span class="line">$ wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">$ tar -zxvf /opt/mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz -C /usr/local/</span><br><span class="line">$ mv /usr/local/mysql-5.7.19-linux-glibc2.12-x86_64/ /usr/local/mysql</span><br></pre></td></tr></table></figure>
<p>解压目录内容</p>
<p><code>bin</code> mysqld服务器，客户端和实用程序<br>
<code>data</code> 日志文件，数据库<br>
<code>docs</code> MySQL手册信息格式<br>
<code>man</code> Unix手册页<br>
<code>include</code> 包含（标题）文件<br>
<code>lib</code> 库<br>
<code>share</code> 其他支持文件，包括错误消息，示例配置文件，用于数据库安装的SQL</p>
<h3 id="2-安装MySQL">2.安装MySQL</h3>
<p><strong>1. 新建用户组和用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/mysql/ </span><br><span class="line">$ groupadd mysql</span><br><span class="line">$ useradd mysql -g mysql</span><br></pre></td></tr></table></figure>
<p><strong>2. 创建目录并授权</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir data mysql-files</span><br><span class="line">$ chmod 750 mysql-files</span><br><span class="line">$ chown -R mysql .</span><br><span class="line">$ chgrp -R mysql .</span><br></pre></td></tr></table></figure>
<p><strong>3. 初始化MySQL</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/mysqld --initialize --user=mysql # MySQL 5.7.6 and up</span><br></pre></td></tr></table></figure>
<h4 id="注意密码">注意密码</h4>
<p><strong>4. mysql 临时密码</strong></p>
<blockquote>
<p>[注意]root@localhost生成临时密码：<code>;b;s;)/rn6A3</code>,也就是<code>root@localhost:</code>后的字符串</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-08-26T03:23:35.368366Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).</span><br><span class="line">2017-08-26T03:23:35.748679Z 0 [Warning] InnoDB: New log files created, LSN=45790</span><br><span class="line">2017-08-26T03:23:35.793190Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.</span><br><span class="line">2017-08-26T03:23:35.848286Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: f210c54b-8a0d-11e7-abbd-000c29129bb0.</span><br><span class="line">2017-08-26T03:23:35.848889Z 0 [Warning] Gtid table is not ready to be used. Table &#x27;mysql.gtid_executed&#x27; cannot be opened.</span><br><span class="line">2017-08-26T03:23:35.849421Z 1 [Note] A temporary password is generated for root@localhost: ;b;s;)/rn6A3</span><br></pre></td></tr></table></figure>
<p><strong>5. 生成RSA私钥，可以跳过此步骤</strong></p>
<p><code>mysql_ssl_rsa_setup</code>需要<code>openssl</code>支持，用于启用数据量ssl连接，需要进一步配置。</p>
<p><a href="https://chankein.github.io/2017/08/17/database/MySQL-%E4%BD%BF%E7%94%A8-SSL-%E8%BF%9E%E6%8E%A5-%E9%99%84-Docker-%E4%BE%8B%E5%AD%90/">参考-MySQL 使用 SSL 连接</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/mysql_ssl_rsa_setup </span><br></pre></td></tr></table></figure>
<p><strong>6. 授予读写权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chown -R root .</span><br><span class="line">$ chown -R mysql data mysql-files</span><br></pre></td></tr></table></figure>
<p><strong>7. 添加到MySQL 启动脚本到系统服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp support-files/mysql.server /etc/init.d/mysql.server</span><br></pre></td></tr></table></figure>
<h3 id="3-启动MySQL服务">3.启动MySQL服务</h3>
<p><strong>启动脚本有两个分别是：</strong></p>
<p><code>/usr/local/mysql/bin/mysqld_safe</code><br>
<code>/usr/local/mysql/support-files/mysql.server</code>（即<code>/etc/init.d/mysqld</code>）</p>
<p><strong>当启动mysqld时，<code>mysqld_safe</code>同时启动</strong></p>
<p><strong><code>mysqld_safe</code>监控<code>mysqld</code>服务,记录错误日志，并在<code>mysqld</code>因故障停止时将其重启</strong></p>
<h4 id="启动方式一">启动方式一</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/mysqld_safe --user=mysql &amp;</span><br></pre></td></tr></table></figure>
<h4 id="启动方式二">启动方式二</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service mysql.server start</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mysql/support-files/mysql.server start</span><br></pre></td></tr></table></figure>
<h4 id="如若出现报错">如若出现报错</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting MySQL.2017-08-26T07:31:24.312411Z mysqld_safe error: log-error set to &#x27;/var/log/mariadb/mariadb.log&#x27;, however file don&#x27;t exists. Create writable for user &#x27;mysql&#x27;.</span><br><span class="line"> ERROR! The server quit without updating PID file (/var/lib/mysql/node1.pid).</span><br></pre></td></tr></table></figure>
<p><strong>给日志目录授予读写权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /var/log/mariadb</span><br><span class="line">$ touch /var/log/mariadb/mariadb.log</span><br><span class="line">$ chown -R mysql:mysql /var/log/mariadb</span><br></pre></td></tr></table></figure>
<h3 id="4-登录MySQL">4.登录MySQL</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/mysql/bin/mysql -uroot -p</span><br><span class="line">Enter password: </span><br></pre></td></tr></table></figure>
<p><strong>如果不知道密码</strong><br>
密码在，安装MySQL步骤 4 ，有提到，怎么找初始化临时密码</p>
<h4 id="如若出现报错-2">如若出现报错</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter password: </span><br><span class="line">ERROR 2002 (HY000): Can&#x27;t connect to local MySQL server through socket &#x27;/tmp/mysql.sock&#x27; (2)</span><br></pre></td></tr></table></figure>
<p><strong>故障分析</strong></p>
<p>查看mysql实例的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntlp  | grep 3306</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      10794/mysqld  </span><br></pre></td></tr></table></figure>
<p>查看my.cnf关于socket的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ more /etc/my.cnf |grep sock</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure>
<p><strong>解决方法,修改<code>/etc/my.cnf</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/my.cnf</span><br></pre></td></tr></table></figure>
<p>修改 <code>[mysqld]</code>组下的 <code>socket</code> 路径，我是选择注释掉，加一行为<code>tmp/mysql.soc</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">#socket=/var/lib/mysql/mysql.sock</span><br><span class="line">socket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure>
<p><strong>重启MySQL 服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service mysql.server start</span><br><span class="line">Shutting down MySQL.. SUCCESS!</span><br></pre></td></tr></table></figure>
<p>再次登录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/mysql/bin/mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p><strong>如果不知道密码</strong><br>
密码在，安装MySQL步骤 4 ，有提到，怎么找初始化临时密码</p>
<h4 id="设置MySQL密码">设置MySQL密码</h4>
<p>登陆成功后，设置MySQL密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER USER   &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;mima&#x27;;  </span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password=password(&quot;mima&quot;);</span><br></pre></td></tr></table></figure>
<p>刷新权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure>
<p>查看mysql.user表中存在哪些帐户 以及它们的密码是否为空：</p>
<p>MySQL 5.7.6起，使用这个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">User</span>, Host, HEX(authentication_string) <span class="keyword">FROM</span> mysql.user;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------+------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">User</span>          <span class="operator">|</span> Host      <span class="operator">|</span> HEX(authentication_string)                                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------+------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> root          <span class="operator">|</span> localhost <span class="operator">|</span> <span class="number">2</span>A39383730334637413534333934344644333831383037373636394637344436303631364442324338 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql.session <span class="operator">|</span> localhost <span class="operator">|</span> <span class="number">2</span>A5448495349534E4F544156414C494450415353574F52445448415443414E42455553454448455245 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql.sys     <span class="operator">|</span> localhost <span class="operator">|</span> <span class="number">2</span>A5448495349534E4F544156414C494450415353574F52445448415443414E42455553454448455245 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------+------------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="开启远程登录">开启远程登录</h4>
<p>关闭防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<p>以权限用户root登录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/mysql/bin/mysql -uroot -p</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> host <span class="operator">=</span> <span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure>
<p>第1行：选择mysql库<br>
第2行：修改host值（以通配符%的内容增加主机/IP地址），当然也可以直接增加IP地址<br>
第3行：刷新MySQL的系统权限相关表</p>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span>  <span class="keyword">to</span>  <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>  identified <span class="keyword">by</span> <span class="string">&#x27;mima&#x27;</span>  <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure>
<h3 id="推荐阅读">推荐阅读</h3>
<p><a href="https://chankein.github.io/2017/09/16/database/%E6%90%AD%E5%BB%BAMySQL5-7-19%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%BB%A5%E5%8F%8A%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/">CentOs7.3 搭建 MySQL 5.7.19 主从复制，以及复制实现细节分析</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2017/08/16/database/CentOs7-3-%E5%AE%89%E8%A3%85-MySQL-5-7-19-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88%E6%9C%AC/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2016/02/20/database/MySQL-explain-%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/"
                            aria-label=": MySQL explain 应用详解"
                        >
                            MySQL explain 应用详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-02-20T11:11:11+08:00">
	
		    2016 年 2 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">database</a>, <a class="category-link" href="">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<h3 id="什么是explain">什么是explain</h3>
</blockquote>
<p>使用explain可以模拟优化器执行SQL查询语句，从而知道MySQL怎么处理你的SQL语句的，分析你的查询语句和表结构的性能瓶颈。</p>
<blockquote>
<p>explain能够干什么</p>
</blockquote>
<ul>
<li>读取表的顺序</li>
<li>哪些索引能够被使用</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引能够被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被物理查询</li>
</ul>
<blockquote>
<h3 id="创建一个学习用的数据库">创建一个学习用的数据库</h3>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`mydb` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;</span><br><span class="line"></span><br><span class="line">USE `mydb`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `course` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `course`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `course` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">21</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `course` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert  into</span> `course`(`id`,`name`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;语文&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;高等数学&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;视听说&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;体育&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;马克思概况&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;民族理论&#x27;</span>),(<span class="number">7</span>,<span class="string">&#x27;毛中特&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;计算机基础&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;深度学习&#x27;</span>),(<span class="number">10</span>,<span class="string">&#x27;Java程序设计&#x27;</span>),(<span class="number">11</span>,<span class="string">&#x27;c语言程序设计&#x27;</span>),(<span class="number">12</span>,<span class="string">&#x27;操作系统&#x27;</span>),(<span class="number">13</span>,<span class="string">&#x27;计算机网络&#x27;</span>),(<span class="number">14</span>,<span class="string">&#x27;计算机组成原理&#x27;</span>),(<span class="number">15</span>,<span class="string">&#x27;数据结构&#x27;</span>),(<span class="number">16</span>,<span class="string">&#x27;数据分析&#x27;</span>),(<span class="number">17</span>,<span class="string">&#x27;大学物理&#x27;</span>),(<span class="number">18</span>,<span class="string">&#x27;数字逻辑&#x27;</span>),(<span class="number">19</span>,<span class="string">&#x27;嵌入式开发&#x27;</span>),(<span class="number">20</span>,<span class="string">&#x27;需求工程&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `stu_course` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `stu_course`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `stu_course` (</span><br><span class="line">  `sid` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `cid` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`sid`,`cid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `stu_course` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert  into</span> `stu_course`(`sid`,`cid`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">1</span>,<span class="number">14</span>),(<span class="number">1</span>,<span class="number">16</span>),(<span class="number">1</span>,<span class="number">19</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">8</span>),(<span class="number">2</span>,<span class="number">9</span>),(<span class="number">2</span>,<span class="number">14</span>),(<span class="number">3</span>,<span class="number">13</span>),(<span class="number">3</span>,<span class="number">14</span>),(<span class="number">3</span>,<span class="number">20</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">9</span>),(<span class="number">4</span>,<span class="number">11</span>),(<span class="number">4</span>,<span class="number">16</span>),(<span class="number">5</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">8</span>),(<span class="number">5</span>,<span class="number">9</span>),(<span class="number">5</span>,<span class="number">11</span>),(<span class="number">5</span>,<span class="number">12</span>),(<span class="number">5</span>,<span class="number">16</span>),(<span class="number">6</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="number">14</span>),(<span class="number">6</span>,<span class="number">17</span>),(<span class="number">7</span>,<span class="number">1</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">7</span>,<span class="number">15</span>),(<span class="number">8</span>,<span class="number">2</span>),(<span class="number">8</span>,<span class="number">3</span>),(<span class="number">8</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">17</span>),(<span class="number">9</span>,<span class="number">1</span>),(<span class="number">9</span>,<span class="number">7</span>),(<span class="number">9</span>,<span class="number">16</span>),(<span class="number">9</span>,<span class="number">20</span>),(<span class="number">10</span>,<span class="number">4</span>),(<span class="number">10</span>,<span class="number">12</span>),(<span class="number">10</span>,<span class="number">14</span>),(<span class="number">10</span>,<span class="number">20</span>),(<span class="number">11</span>,<span class="number">3</span>),(<span class="number">11</span>,<span class="number">9</span>),(<span class="number">11</span>,<span class="number">16</span>),(<span class="number">12</span>,<span class="number">3</span>),(<span class="number">12</span>,<span class="number">7</span>),(<span class="number">12</span>,<span class="number">9</span>),(<span class="number">12</span>,<span class="number">12</span>),(<span class="number">13</span>,<span class="number">1</span>),(<span class="number">13</span>,<span class="number">5</span>),(<span class="number">13</span>,<span class="number">13</span>),(<span class="number">14</span>,<span class="number">1</span>),(<span class="number">14</span>,<span class="number">3</span>),(<span class="number">14</span>,<span class="number">18</span>),(<span class="number">15</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">15</span>,<span class="number">9</span>),(<span class="number">15</span>,<span class="number">15</span>),(<span class="number">16</span>,<span class="number">2</span>),(<span class="number">16</span>,<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `student` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `student`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `student` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  KEY `name` (`name`),</span><br><span class="line">  KEY `name_age` (`name`,`age`),</span><br><span class="line">  KEY `id_name_age` (`id`,`name`,`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">31</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `student` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert  into</span> `student`(`id`,`name`,`age`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">25</span>,<span class="string">&#x27;乾隆&#x27;</span>,<span class="number">17</span>),(<span class="number">14</span>,<span class="string">&#x27;关羽&#x27;</span>,<span class="number">43</span>),(<span class="number">13</span>,<span class="string">&#x27;刘备&#x27;</span>,<span class="number">12</span>),(<span class="number">28</span>,<span class="string">&#x27;刘永&#x27;</span>,<span class="number">12</span>),(<span class="number">21</span>,<span class="string">&#x27;后裔&#x27;</span>,<span class="number">12</span>),(<span class="number">30</span>,<span class="string">&#x27;吕子乔&#x27;</span>,<span class="number">28</span>),(<span class="number">18</span>,<span class="string">&#x27;嬴政&#x27;</span>,<span class="number">76</span>),(<span class="number">22</span>,<span class="string">&#x27;孙悟空&#x27;</span>,<span class="number">21</span>),(<span class="number">4</span>,<span class="string">&#x27;安其拉&#x27;</span>,<span class="number">24</span>),(<span class="number">6</span>,<span class="string">&#x27;宋江&#x27;</span>,<span class="number">22</span>),(<span class="number">26</span>,<span class="string">&#x27;康熙&#x27;</span>,<span class="number">51</span>),(<span class="number">29</span>,<span class="string">&#x27;张伟&#x27;</span>,<span class="number">26</span>),(<span class="number">20</span>,<span class="string">&#x27;张郃&#x27;</span>,<span class="number">12</span>),(<span class="number">12</span>,<span class="string">&#x27;张飞&#x27;</span>,<span class="number">32</span>),(<span class="number">27</span>,<span class="string">&#x27;朱元璋&#x27;</span>,<span class="number">19</span>),(<span class="number">11</span>,<span class="string">&#x27;李世民&#x27;</span>,<span class="number">54</span>),(<span class="number">9</span>,<span class="string">&#x27;李逵&#x27;</span>,<span class="number">12</span>),(<span class="number">8</span>,<span class="string">&#x27;林冲&#x27;</span>,<span class="number">43</span>),(<span class="number">5</span>,<span class="string">&#x27;橘右京&#x27;</span>,<span class="number">43</span>),(<span class="number">24</span>,<span class="string">&#x27;沙和尚&#x27;</span>,<span class="number">25</span>),(<span class="number">23</span>,<span class="string">&#x27;猪八戒&#x27;</span>,<span class="number">22</span>),(<span class="number">15</span>,<span class="string">&#x27;王与&#x27;</span>,<span class="number">21</span>),(<span class="number">19</span>,<span class="string">&#x27;王建&#x27;</span>,<span class="number">23</span>),(<span class="number">10</span>,<span class="string">&#x27;王莽&#x27;</span>,<span class="number">43</span>),(<span class="number">16</span>,<span class="string">&#x27;秦叔宝&#x27;</span>,<span class="number">43</span>),(<span class="number">17</span>,<span class="string">&#x27;程咬金&#x27;</span>,<span class="number">65</span>),(<span class="number">3</span>,<span class="string">&#x27;荆轲&#x27;</span>,<span class="number">21</span>),(<span class="number">2</span>,<span class="string">&#x27;诸葛亮&#x27;</span>,<span class="number">71</span>),(<span class="number">7</span>,<span class="string">&#x27;钟馗&#x27;</span>,<span class="number">23</span>),(<span class="number">1</span>,<span class="string">&#x27;鲁班&#x27;</span>,<span class="number">21</span>);</span><br></pre></td></tr></table></figure>
<p>这个数据库实际上的业务是:学生表 - 选课表 - 课程表</p>
<blockquote>
<h3 id="如何使用explain">如何使用explain</h3>
</blockquote>
<p>使用而<code>explain</code>很简单就是，在你书写的SQL语句加一个单词 - <code>explain</code>，然后将 <code>explain</code> + SQL执行后会出现一个表，这个表会告诉你MySQL优化器是怎样执行你的SQL的。</p>
<p>就比如执行下面一句语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure>
<p>MySQL会给你反馈下面一个信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table    partitions  type    possible_keys  key       key_len  ref       rows  filtered  Extra        </span><br><span class="line">------  -----------  -------  ----------  ------  -------------  --------  -------  ------  ------  --------  -------------</span><br><span class="line">     1  SIMPLE       student  (NULL)      index   (NULL)         name_age  68       (NULL)      30    100.00  Using index  </span><br></pre></td></tr></table></figure>
<p>具体这些信息是干什么的，会对你有什么帮助，会在下面告诉你。</p>
<blockquote>
<h4 id="explain各个字段代表的意思">explain各个字段代表的意思</h4>
</blockquote>
<ul>
<li>id ：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</li>
<li>select_type ：查询类型 或者是 其他操作类型</li>
<li>table ：正在访问哪个表</li>
<li>partitions ：匹配的分区</li>
<li>type ：访问的类型</li>
<li>possible_keys ：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到</li>
<li>key ：实际使用到的索引，如果为NULL，则没有使用索引</li>
<li>key_len ：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li>
<li>ref ：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</li>
<li>rows ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数</li>
<li>filtered ：查询的表行占表的百分比</li>
<li>Extra ：包含不适合在其它列中显示但十分重要的额外信息</li>
</ul>
<p>上面介绍了每个字段的意思，可以大体看一下，下面会逐一介绍每个字段表示的啥？该关注什么？</p>
<blockquote>
<h4 id="id与table字段">id与table字段</h4>
</blockquote>
<p>为什么要将<code>id</code>和<code>table</code>放在一起讲呢？因为通过这两个字段可以<strong>完全</strong>判断出你的每一条SQL语句的执行顺序和表的查询顺序。</p>
<p>先看<code>id</code>后看<code>table</code>，<code>id</code>和<code>table</code>在SQL执行判断过程中的关系就像是足球联赛的积分榜，首先一个联赛的球队排名应该先看积分，积分越高的球队排名越靠前，当两支或多只球队的积分一样高怎么办呢？那我们就看净胜球，净胜球越多的球队，排在前面。而在<code>explain</code>中你可以把id看作是球队积分，<code>table</code>当作是净胜球。</p>
<p>比如说我们<code>explain</code>一下这一条SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    S.id,S.name,S.age,C.id,C.name</span><br><span class="line"><span class="keyword">FROM</span> course C <span class="keyword">JOIN</span> stu_course SC <span class="keyword">ON</span> C.id <span class="operator">=</span> SC.cid</span><br><span class="line"><span class="keyword">JOIN</span> student S <span class="keyword">ON</span> S.id <span class="operator">=</span> SC.sid</span><br></pre></td></tr></table></figure>
<p>结果是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys        key      key_len  ref      </span><br><span class="line">------  -----------  ------  ----------  ------  -------------------  -------  -------  ----------- </span><br><span class="line">     1  SIMPLE       SC      (NULL)      index   PRIMARY              PRIMARY  8        (NULL)     </span><br><span class="line">     1  SIMPLE       C       (NULL)      eq_ref  PRIMARY              PRIMARY  4        mydb.SC.cid </span><br><span class="line">     1  SIMPLE       S       (NULL)      eq_ref  PRIMARY,id_name_age  PRIMARY  4        mydb.SC.sid </span><br></pre></td></tr></table></figure>
<p>我们看到<code>id</code>全是1，那就说明光看id这个值是看不出来每个表的读取顺序的，那我们就来看<code>table</code>这一行，它的读取顺序是<strong>自上向下</strong>的，所以，这三个表的读取顺序应当是：SC - C - S。</p>
<p>再来看一条SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> C </span><br><span class="line"><span class="keyword">WHERE</span> C.`id` <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> SC.`cid` </span><br><span class="line">    <span class="keyword">FROM</span> stu_course <span class="keyword">AS</span> SC </span><br><span class="line">    <span class="keyword">WHERE</span> SC.`sid` <span class="operator">=</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> </span><br><span class="line">            S.`id` </span><br><span class="line">        <span class="keyword">FROM</span> student <span class="keyword">AS</span> S</span><br><span class="line">        <span class="keyword">WHERE</span>  S.`name` <span class="operator">=</span> &quot;安其拉&quot;</span><br><span class="line">    ) <span class="keyword">ORDER</span> <span class="keyword">BY</span> SC.`cid` LIMIT <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这条语句是查询结果是：一个叫安其拉的学生选的课里面，课程<code>id</code>最小的一门课的信息，然后来看一下<code>explain</code>的结果吧！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      key_len  ref    </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  -------  ------  </span><br><span class="line">     1  PRIMARY      C       (NULL)      const   PRIMARY        PRIMARY  4        const   </span><br><span class="line">     2  SUBQUERY     SC      (NULL)      ref     PRIMARY        PRIMARY  4        const  </span><br><span class="line">     3  SUBQUERY     S       (NULL)      ref     name,name_age  name     63       const </span><br></pre></td></tr></table></figure>
<p>此时我们发现id是不相同的，所以我们很容易就看出表读取的顺序了是吧！C - SC - S</p>
<p>注意！！！！！！你仔细看一下最里面的子查询是查询的哪个表，是S这张表，然后外面一层呢？是SC这张表，最外面这一层呢？是C这张表，所以执行顺序应该是啥呢？是…是…难道是S - SC - C吗？是<code>id</code>越大的<code>table</code>读取越在前面吗？是的！这就像刚才说的足球联赛积分，分数越高的球队的排序越靠前。</p>
<p>当然还有下面这种情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> C </span><br><span class="line"><span class="keyword">WHERE</span> C.`id` <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> SC.`cid` </span><br><span class="line">    <span class="keyword">FROM</span> stu_course <span class="keyword">AS</span> SC </span><br><span class="line">    <span class="keyword">WHERE</span> SC.`sid` <span class="operator">=</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> </span><br><span class="line">            S.`id` </span><br><span class="line">        <span class="keyword">FROM</span> student <span class="keyword">AS</span> S</span><br><span class="line">        <span class="keyword">WHERE</span>  S.`name` <span class="operator">=</span> &quot;安其拉&quot;</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个查询是：查询安其拉选课的课程信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      key_len  ref           </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  -------  ----------- </span><br><span class="line">     1  PRIMARY      SC      (NULL)      ref     PRIMARY        PRIMARY  4        const       </span><br><span class="line">     1  PRIMARY      C       (NULL)      eq_ref  PRIMARY        PRIMARY  4        mydb.SC.cid </span><br><span class="line">     3  SUBQUERY     S       (NULL)      ref     name,name_age  name     63       const        </span><br></pre></td></tr></table></figure>
<p>结果很明确：先看<code>id</code>应该是S表最先被读取，SC和C表<code>id</code>相同，然后table中SC更靠上，所以第二张读取的表应当是SC，最后读取C。</p>
<blockquote>
<h4 id="select-type字段">select_type字段</h4>
</blockquote>
<ul>
<li>
<p><code>SIMPLE</code> 简单查询，不包括子查询和<code>union</code>查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">JOIN</span> stu_course <span class="keyword">ON</span> student.`id` <span class="operator">=</span> sid</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table       partitions  type    possible_keys        key      </span><br><span class="line">------  -----------  ----------  ----------  ------  -------------------  --------  </span><br><span class="line">     1  SIMPLE       student     (NULL)      index   PRIMARY,id_name_age  name_age  </span><br><span class="line">     1  SIMPLE       stu_course  (NULL)      ref     PRIMARY              PRIMARY  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>PRIMARY</code> 当存在子查询时，最外面的查询被标记为主查询</p>
</li>
<li>
<p><code>SUBQUERY</code> 子查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> SC.`cid` </span><br><span class="line"><span class="keyword">FROM</span> stu_course <span class="keyword">AS</span> SC </span><br><span class="line"><span class="keyword">WHERE</span> SC.`sid` <span class="operator">=</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        S.`id` </span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">AS</span> S</span><br><span class="line">    <span class="keyword">WHERE</span>  S.`name` <span class="operator">=</span> &quot;安其拉&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      key_len  ref      </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  -------  ------ </span><br><span class="line">     1  PRIMARY      SC      (NULL)      ref     PRIMARY        PRIMARY  4        const  </span><br><span class="line">     2  SUBQUERY     S       (NULL)      ref     name,name_age  name     63       const   </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>UNION</code> 当一个查询在<code>UNION</code>关键字之后就会出现<code>UNION</code></p>
</li>
<li>
<p><code>UNION RESULT</code> 连接几个表查询后的结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type   table       partitions  type    possible_keys        key      </span><br><span class="line">------  ------------  ----------  ----------  ------  -------------------  ------- </span><br><span class="line">     1  PRIMARY       student     (NULL)      const   PRIMARY,id_name_age  PRIMARY  </span><br><span class="line">     2  UNION         student     (NULL)      const   PRIMARY,id_name_age  PRIMARY </span><br><span class="line">(NULL)  UNION RESULT  &lt;union1,2&gt;  (NULL)      ALL     (NULL)               (NULL)   </span><br></pre></td></tr></table></figure>
<p>上面可以看到第三行<code>table</code>的值是<code>&lt;union1,2&gt;</code></p>
</li>
<li>
<p><code>DERIVED</code> 在<code>FROM</code>列表中包含的子查询被标记为<code>DERIVED</code>（衍生），MySQL<br>
会递归执行这些子查询，把结果放在临时表中<br>
MySQL5.7+ 进行优化了，增加了derived_merge（派生合并），默认开启，可加快查询效率</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sun_ashe/article/details/89522394">如果你想了解更详细的派生合并请点击这里</a></p>
<p>当你的MySQL是5.7及以上版本时你要将derived_merge关闭后才能看到<code>DERIVED</code> 状态</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session optimizer_switch<span class="operator">=</span><span class="string">&#x27;derived_merge=off&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;derived_merge=off&#x27;</span>; </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">JOIN</span> stu_course <span class="keyword">AS</span> SC </span><br><span class="line">    <span class="keyword">ON</span> S.`id` <span class="operator">=</span> SC.`sid`</span><br><span class="line">) <span class="keyword">AS</span> SSC</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table       partitions  type    possible_keys        key       </span><br><span class="line">------  -----------  ----------  ----------  ------  -------------------  -------- </span><br><span class="line">     1  PRIMARY      &lt;derived2&gt;  (NULL)      ALL     (NULL)               (NULL)    </span><br><span class="line">     2  DERIVED      S           (NULL)      index   PRIMARY,id_name_age  name_age </span><br><span class="line">     2  DERIVED      SC          (NULL)      ref     PRIMARY              PRIMARY  </span><br></pre></td></tr></table></figure>
<p>上面我们观察，最外层的主查询的表是<derived2>,而S和SC表的<code>select_type</code>都是<code>DERIVED</code>,这说明S和SC都被用来做衍生查询，而这两张表查询的结果组成了名为<derived2>的衍生表，而衍生表的命名就是<code>&lt;select_type + id&gt;</code>。</p>
</li>
</ul>
<blockquote>
<h4 id="partitions字段">partitions字段</h4>
</blockquote>
<p>该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。</p>
<blockquote>
<h4 id="type字段">type字段</h4>
</blockquote>
<p><strong>注意！！！注意！！！重点来了！</strong></p>
<p>首先说一下这个字段，要记住以下10个状态，（从左往右，越靠左边的越优秀）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>NULL</code> MySQL能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引</p>
<p>有没有这样一种疑惑，不查询索引也不查询表那你的数据是从哪里来的啊？谁说<code>SELECT</code>语句必须查询某样东西了？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">5</span><span class="operator">*</span><span class="number">7</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key     </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  ------ </span><br><span class="line">     1  SIMPLE       (NULL)  (NULL)      (NULL)  (NULL)         (NULL) </span><br></pre></td></tr></table></figure>
<p>我就简简单单算个数不好吗？好啊😊。。。</p>
<p>但是！！如果只是这样的话我们还<code>explain</code>个毛线啊！我很闲吗？</p>
<p>存在这样一种情况，大家都知道索引是将数据在B+Tree中进行排序了，所以你的查询速率才这么高，那么B+树的最边上的叶子节点是不是要么是最大值要么是最小值啊？既然你都知道了，那MySQL比你更知道啊！当你要查询最大值或者最小值时，MySQL会直接到你的索引得分叶子节点上直接拿，所以不用访问表或者索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(id) <span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key    </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  ------ </span><br><span class="line">     1  SIMPLE       (NULL)  (NULL)      (NULL)  (NULL)         (NULL) </span><br></pre></td></tr></table></figure>
<p>但是！你要记住，<code>NULL</code>的前提是你已经建立了索引。</p>
</li>
<li>
<p><code>SYSTEM</code> 表只有一行记录（等于系统表），这是<code>const</code>类型的特列，平时不大会出现，可以忽略。</p>
</li>
<li>
<p><code>const</code> 表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或<code>uique</code>索引，因为只匹配一行数据，所以很快，如主键置于<code>where</code>列表中，MySQL就能将该查询转换为一个常量。</p>
<p>简单来说，<code>const</code>是直接按主键或唯一键读取。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      const   PRIMARY        PRIMARY  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>eq_ref</code> 用于联表查询的情况，按联表的主键或唯一键联合查询。</p>
<p>多表<code>join</code>时，对于来自前面表的每一行，在<strong>当前表中只能找到一行</strong>。这可能是除了<code>system</code>和<code>const</code>之外最好的类型。当主键或唯一非<code>NULL</code>索引的所有字段都被用作<code>join</code>联接时会使用此类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">JOIN</span> stu_course <span class="keyword">AS</span> SC <span class="keyword">ON</span>  S.`id` <span class="operator">=</span> SC.`cid`</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key     </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  </span><br><span class="line">     1  SIMPLE       SC      (NULL)      index   (NULL)         PRIMARY  </span><br><span class="line">     1  SIMPLE       S       (NULL)      eq_ref  PRIMARY        PRIMARY </span><br></pre></td></tr></table></figure>
<p>以上面查询为例，我们观察<code>id</code>和<code>table</code>会知道，先是从SC表中取出一行数据，然后再S表查找匹配的数据，我们观察，SC中取出cid和S表中的id比较，毫无疑问因为id是S表中的主键（不重复），所以只能出现一个id与cid的值相同。所以！满足条件 S 表的 <code>type</code>为<code>eq_ref</code>。</p>
</li>
<li>
<p><code>ref</code> 可以用于单表扫描或者连接。如果是连接的话，驱动表的一条记录能够在被驱动表中通过非唯一（主键）属性所在索引中匹配多行数据，或者是在单表查询的时候通过非唯一（主键）属性所在索引中查到一行数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">JOIN</span> stu_course <span class="keyword">AS</span> SC <span class="keyword">ON</span> S.id <span class="operator">=</span> SC.`sid`</span><br></pre></td></tr></table></figure>
<p>不要在意SQL，以上SQL没有实际查询的意义只是用于表达用例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      ALL     PRIMARY        (NULL)   </span><br><span class="line">     1  SIMPLE       SC      (NULL)      ref     PRIMARY        PRIMARY  </span><br></pre></td></tr></table></figure>
<p>SC的主键索引是（cid,sid）所以sid列中肯定是重复的数据，虽然在后面的<code>key</code>中显示使用了主键索引。然后，就很明确了S.id一行能在SC表中通过索引查询到多行数据。</p>
<p>下面是单表了，写一个例子，但是不细讲了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">WHERE</span> S.`name` <span class="operator">=</span> &quot;张飞&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key        </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  ---------- </span><br><span class="line">     1  SIMPLE       S       (NULL)      ref     index_name     index_name</span><br></pre></td></tr></table></figure>
<p>注意<code>name</code>字段是有索引的哈！！！</p>
</li>
<li>
<p><code>ref_or_null</code> 类似ref，但是可以搜索值为<code>NULL</code>的行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">WHERE</span> S.`name` <span class="operator">=</span> &quot;张飞&quot; <span class="keyword">OR</span> S.`name` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type         possible_keys  key        </span><br><span class="line">------  -----------  ------  ----------  -----------  -------------  ----------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      ref_or_null  index_name     index_name  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>index_merge</code> 表示查询使用了两个以上的索引，最后取交集或者并集，常见<code>and</code> ，<code>or</code>的条件使用了不同的索引，官方排序这个在<code>ref_or_null</code>之后，但是实际上由于要读取多个索引，性能可能大部分时间都不如<code>range</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">WHERE</span> S.`name` <span class="keyword">LIKE</span> &quot;张%&quot; <span class="keyword">OR</span> S.`age` <span class="operator">=</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type         possible_keys         key                   </span><br><span class="line">------  -----------  ------  ----------  -----------  --------------------  -------------------- </span><br><span class="line">     1  SIMPLE       S       (NULL)      index_merge  index_name,index_age  index_name,index_age </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>range</code> 索引范围查询，常见于使用 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN()或者like等运算符的查询中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> S.`age` <span class="keyword">FROM</span> student  <span class="keyword">AS</span> S <span class="keyword">WHERE</span> S.`age` <span class="operator">&gt;</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys         key         </span><br><span class="line">------  -----------  ------  ----------  ------  --------------------  ----------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      range   index_name,index_age  index_name  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>index</code> <code>index</code>只遍历索引树，通常比<code>All</code>快。因为，索引文件通常比数据文件小，也就是虽然<code>all</code>和<code>index</code>都是读全表，但<code>index</code>是从索引中读取的，而<code>all</code>是从硬盘读的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> S.`name` <span class="keyword">FROM</span> student <span class="keyword">AS</span> S </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key         </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  ----------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      index   (NULL)         index_name  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ALL</code> 如果一个查询的<code>type</code>是<code>All</code>,并且表的数据量很大，那么请解决它！！！</p>
</li>
</ul>
<blockquote>
<h4 id="possible-keys字段">possible_keys字段</h4>
</blockquote>
<p>这个表里面存在且可能会被使用的索引，可能会在这个字段下面出现，但是一般都以<code>key</code>为准。</p>
<blockquote>
<h4 id="key字段">key字段</h4>
</blockquote>
<p>实际使用的索引，如果为<code>null</code>,则没有使用索引，否则会显示你使用了哪些索引，查询中若使用了覆盖索引（查询的列刚好是索引），则该索引仅出现在<code>key</code>列表。</p>
<blockquote>
<h4 id="ref字段">ref字段</h4>
</blockquote>
<p>显示哪些列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值。</p>
<blockquote>
<h4 id="rows字段和Filter字段">rows字段和Filter字段</h4>
</blockquote>
<p><code>rows</code>是根据表的统计信息和索引的选用情况，优化器大概帮你估算出你执行这行函数所需要查询的行数。</p>
<p><code>Filter</code>是查询的行数与总行数的比值。其实作用与<code>rows</code>差不多，都是数值越小，效率越高。</p>
<blockquote>
<h4 id="Extra字段">Extra字段</h4>
</blockquote>
<p>这一字段包含不适合在其他列显示，但是也非常重要的额外信息。</p>
<ul>
<li>
<p><code>Using filesort</code> 表示当SQL中有一个地方需要对一些数据进行排序的时候，优化器找不到能够使用的索引，所以只能使用外部的索引排序，外部排序就不断的在磁盘和内存中交换数据，这样就摆脱不了很多次磁盘IO，以至于SQL执行的效率很低。反之呢？由于索引的底层是B+Tree实现的，他的叶子节点本来就是有序的，这样的查询能不爽吗？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> course <span class="keyword">AS</span> C <span class="keyword">ORDER</span> <span class="keyword">BY</span> C.`name` </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type    possible_keys  key     key_len  ref       rows  filtered  Extra           </span><br><span class="line">------  -------------  ------  -------  ------  ------  --------  ----------------</span><br><span class="line">ALL     (NULL)         (NULL)  (NULL)   (NULL)      20    100.00  Using filesort  </span><br></pre></td></tr></table></figure>
<p>没有给<code>C.name</code>建立索引，所以在根据<code>C.name</code>排序的时候，他就使用了外部排序</p>
</li>
<li>
<p><code>Using tempporary</code> 表示在对MySQL查询结果进行排序时，使用了临时表,这样的查询效率是比外部排序更低的，常见于<code>order by</code>和<code>group by</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> C.`name` <span class="keyword">FROM</span> course <span class="keyword">AS</span> C <span class="keyword">GROUP</span> <span class="keyword">BY</span> C.`name`</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">possible_keys  key     key_len  ref       rows  filtered  Extra                            </span><br><span class="line">-------------  ------  -------  ------  ------  --------  ---------------------------------</span><br><span class="line">(NULL)         (NULL)  (NULL)   (NULL)      20    100.00  Using temporary; Using filesort  </span><br></pre></td></tr></table></figure>
<p>上面这个查询就是同时触发了<code>Using temporary</code>和<code>Using filesort</code>，可谓是雪上加霜。</p>
</li>
<li>
<p><code>Using index</code> 表示使用了索引，很优秀👍。</p>
</li>
<li>
<p><code>Using where</code> 使用了<code>where</code>但是好像没啥用。</p>
</li>
<li>
<p><code>Using join buffer</code> 表明使用了连接缓存,比如说在查询的时候，多表<code>join</code>的次数非常多，那么将配置文件中的缓冲区的<code>join buffer</code>调大一些。</p>
</li>
<li>
<p><code>impossible where</code> 筛选条件没能筛选出任何东西</p>
</li>
<li>
<p><code>distinct</code> 优化<code>distinct</code>操作，在找到第一匹配的元组后即停止找同样值的动作</p>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2016/02/20/database/MySQL-explain-%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2016/02/16/database/MySQL%E4%BC%98%E5%8C%96-12%E7%A7%8D%E6%8F%90%E5%8D%87SQL%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/"
                            aria-label=": MySQL优化:12种提升SQL执行效率的有效方法"
                        >
                            MySQL优化:12种提升SQL执行效率的有效方法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-02-16T10:46:38+08:00">
	
		    2016 年 2 月 16 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">database</a>, <a class="category-link" href="">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在数据库管理和优化的世界里，MySQL作为一个流行的关系型数据库管理系统，其性能优化是任何数据密集型应用成功的关键。优化MySQL数据库不仅可以显著提高SQL查询的效率，还能确保数据的稳定性和可靠性。</p>
<p>在本文中，我将介绍12种提升SQL执行效率的有效方法，并通过实用的代码示例来具体展示如何实施这些优化策略。</p>
<h2 id="1、使用索引优化查询">1、使用索引优化查询</h2>
<p><strong>使用场景</strong>：当你的数据库表中有大量数据，而你需要频繁进行搜索查询时，索引是提高查询效率的关键。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们有一个员工表 employees</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为department_id字段创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_department <span class="keyword">ON</span> employees(department_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用索引进行查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一步是创建一个包含<strong>id</strong>, <strong>name</strong>, <strong>department_id</strong>字段的<strong>employees</strong>表。</p>
<p>然后为<strong>department_id</strong>字段创建一个索引<strong>idx_department</strong>。这个操作会让基于<strong>department_id</strong>的查询更快。</p>
<p>最后，我们执行一个查询，利用创建的索引，从而提高查询效率。</p>
<h2 id="2、优化查询语句">2、优化查询语句</h2>
<p><strong>使用场景</strong>：避免使用高成本的SQL操作，如<strong>SELECT</strong> *，尽量指定需要的列，减少数据传输和处理时间。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不推荐的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一个查询语句使用了<strong>SELECT</strong> *，它会获取所有列，这在数据量大时非常低效。</p>
<p>第二个查询仅请求需要的<strong>id</strong>和<strong>name</strong>列，减少了数据处理的负担。</p>
<h2 id="3、使用查询缓存">3、使用查询缓存</h2>
<p><strong>使用场景</strong>：当相同的查询被频繁执行时，使用查询缓存可以避免重复的数据库扫描。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启用查询缓存</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> query_cache_size <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> query_cache_type <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行查询</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>通过设置<strong>query_cache_size</strong>和<strong>query_cache_type</strong>，我们启用了查询缓存。</p>
<p>当我们执行查询时，MySQL会检查缓存中是否已经有了该查询的结果，如果有，则直接返回结果，避免了重复的数据库扫描。</p>
<h2 id="4、避免全表扫描">4、避免全表扫描</h2>
<p><strong>使用场景</strong>：当表中数据量巨大时，全表扫描会非常耗时。通过使用合适的查询条件来避免全表扫描，可以显著提高查询效率。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们需要查询员工表中特定部门的员工</span></span><br><span class="line"><span class="comment">-- 不推荐的查询方式，会导致全表扫描</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">AND</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一个查询使用了模糊匹配<strong>LIKE</strong>，但缺乏有效的过滤条件，可能导致全表扫描。</p>
<p>第二个查询在<strong>name</strong>字段的模糊匹配前，增加了对<strong>department_id</strong>的条件过滤，这样就可以先缩小查找范围，避免全表扫描。</p>
<h2 id="5、使用JOIN代替子查询">5、使用JOIN代替子查询</h2>
<p><strong>使用场景</strong>：在需要关联多个表的复杂查询中，使用JOIN代替子查询可以提高查询效率。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们有一个部门表 departments</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> departments (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不推荐的子查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的JOIN查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.<span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.id <span class="keyword">WHERE</span> departments.name <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一个查询使用了子查询，这在执行时可能效率较低，特别是当子查询或主查询的结果集较大时。</p>
<p>第二个查询使用了<strong>JOIN</strong>操作，这通常比子查询更有效，尤其是在处理大型数据集时。</p>
<h2 id="6、合理分页">6、合理分页</h2>
<p><strong>使用场景</strong>：在处理大量数据的列表展示时，合理的分页策略可以减少单次查询的负担，提高响应速度。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们需要分页显示员工信息</span></span><br><span class="line"><span class="comment">-- 不推荐的分页方式，尤其是当offset值很大时</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">10000</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的分页方式，使用更高效的条件查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10000</span> LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一个查询使用了<strong>LIMIT</strong>和较大的偏移量<strong>offset</strong>，在大数据集上执行时会逐行扫描跳过大量记录，效率低下。</p>
<p>第二个查询通过在<strong>WHERE</strong>子句中添加条件来避免不必要的扫描，从而提高分页效率。</p>
<h2 id="7、利用分区提高性能">7、利用分区提高性能</h2>
<p><strong>使用场景</strong>：对于大型表，特别是那些行数以百万计的表，使用分区可以提高查询性能和数据管理效率。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们需要对一个大型的订单表 orders 进行分区</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (order_id)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> ( <span class="keyword">YEAR</span>(order_date) ) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p2020 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2021</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2021 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2022 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2023</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询特定年份的订单</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2021-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>我们为<strong>orders</strong>表创建了基于<strong>order_date</strong>字段的年份范围分区。</p>
<p>查询特定年份的数据时，MySQL只会在相关分区中搜索，提高了查询效率。</p>
<h2 id="8、利用批处理减少I-O操作">8、利用批处理减少I/O操作</h2>
<p><strong>使用场景</strong>：在进行大量数据插入或更新时，批处理可以减少数据库的I/O操作次数，从而提高性能。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量插入数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> employees (name, department_id)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;张三&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">&#x27;李四&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">&#x27;王五&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">    <span class="comment">-- 更多记录</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量更新数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> department_id <span class="operator">=</span> <span class="keyword">CASE</span> name</span><br><span class="line">    <span class="keyword">WHEN</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">THEN</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">WHEN</span> <span class="string">&#x27;李四&#x27;</span> <span class="keyword">THEN</span> <span class="number">2</span></span><br><span class="line">    <span class="comment">-- 更多条件</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">IN</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="comment">-- 更多名称);</span></span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>在批量插入示例中，我们一次性插入多条记录，而不是对每条记录进行单独的插入操作。</p>
<p>在批量更新示例中，我们使用<strong>CASE</strong>语句一次性更新多条记录，这比单独更新每条记录更有效率。</p>
<h2 id="9、使用临时表优化复杂查询">9、使用临时表优化复杂查询</h2>
<p><strong>使用场景</strong>：对于复杂的多步骤查询，使用临时表可以存储中间结果，从而简化查询并提高性能。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个临时表来存储中间结果</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_employees</span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> emp_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用临时表进行查询</span></span><br><span class="line"><span class="keyword">SELECT</span> departments.name, temp_employees.emp_count</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">JOIN</span> temp_employees <span class="keyword">ON</span> departments.id <span class="operator">=</span> temp_employees.department_id;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>首先，我们通过聚合查询创建了一个临时表<strong>temp_employees</strong>，用于存储每个部门的员工计数。</p>
<p>然后，我们将这个临时表与部门表<strong>departments</strong>进行连接查询，这样的查询通常比直接在原始表上执行复杂的聚合查询要高效。</p>
<h2 id="10、优化数据类型">10、优化数据类型</h2>
<p><strong>使用场景</strong>：在设计数据库表时，选择合适的数据类型对性能有显著影响。优化数据类型可以减少存储空间，提高查询效率。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原始表结构</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    description TEXT,</span><br><span class="line">    created_at DATETIME,</span><br><span class="line">    is_active <span class="type">BOOLEAN</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后的表结构</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> optimized_example (</span><br><span class="line">    id MEDIUMINT AUTO_INCREMENT,</span><br><span class="line">    description <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    created_at <span class="type">DATE</span>,</span><br><span class="line">    is_active TINYINT(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>在原始表中，使用了<strong>INT</strong>和<strong>TEXT</strong>这样的宽泛类型，这可能会占用更多的存储空间。</p>
<p>在优化后的表中，<strong>id</strong>字段改为<strong>MEDIUMINT</strong>，<strong>description</strong>改为长度有限的<strong>VARCHAR(255)</strong>，<strong>created_at</strong>只存储日期，而<strong>is_active</strong>使用**TINYINT(1)**来表示布尔值。这样的优化减少了每行数据的大小，提高了存储效率。</p>
<h2 id="11、避免使用函数和操作符">11、避免使用函数和操作符</h2>
<p><strong>使用场景</strong>：在WHERE子句中避免对列使用函数或操作符，可以让MySQL更有效地使用索引。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不推荐的查询方式，使用了函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(birth_date) <span class="operator">=</span> <span class="number">1980</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> birth_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;1980-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1980-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>在第一个查询中，使用**YEAR()**函数会导致MySQL无法利用索引，因为它必须对每行数据应用函数。</p>
<p>第二个查询直接使用日期范围，这样MySQL可以有效利用<strong>birth_date</strong>字段的索引。</p>
<h2 id="12、合理使用正规化和反正规化">12、合理使用正规化和反正规化</h2>
<p><strong>使用场景</strong>：数据库设计中的正规化可以减少数据冗余，而反正规化可以提高查询效率。合理平衡这两者，可以获得最佳性能。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正规化设计</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> departments (</span><br><span class="line">    department_id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (department_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (department_id) <span class="keyword">REFERENCES</span> departments(department_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 反正规化设计</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> employees_denormalized (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>在正规化设计中，<strong>departments</strong>和<strong>employees</strong>表被分开，减少了数据冗余，但可能需要JOIN操作来获取完整信息。</p>
<p>在反正规化设计中，<strong>employees_denormalized</strong>表通过直接包含部门信息来简化查询，提高读取性能，但可能会增加数据冗余和更新成本。</p>
<h2 id="总结">总结</h2>
<p>以上提到的优化方法只是众多MySQL优化技术中的一小部分。在实际应用中，应根据具体的数据模式和查询需求灵活选择最合适的优化策略。数据库优化是一个持续的过程，定期的性能评估和调优是保持数据库高效运行的关键。通过实践这些优化技巧，你可以显著提升数据库的性能和响应速度。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2016/02/16/database/MySQL%E4%BC%98%E5%8C%96-12%E7%A7%8D%E6%8F%90%E5%8D%87SQL%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2015/10/12/database/mysql%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"
                            aria-label=": mysql基础教程"
                        >
                            mysql基础教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-10-12T10:00:15+08:00">
	
		    2015 年 10 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../">database</a>, <a class="category-link" href="">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>为什么需要数据库？</p>
<p>因为应用程序需要保存用户的数据，比如Word需要把用户文档保存起来，以便下次继续编辑或者拷贝到另一台电脑。</p>
<p>要保存用户的数据，一个最简单的方法是把用户数据写入文件。例如，要保存一个班级所有学生的信息，可以向文件中写入一个CSV文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id,name,gender,score</span><br><span class="line">1,小明,M,90</span><br><span class="line">2,小红,F,95</span><br><span class="line">3,小军,M,88</span><br><span class="line">4,小丽,F,88</span><br></pre></td></tr></table></figure>
<p>如果要保存学校所有班级的信息，可以写入另一个CSV文件。</p>
<p>但是，随着应用程序的功能越来越复杂，数据量越来越大，如何管理这些数据就成了大问题：</p>
<ul>
<li>读写文件并解析出数据需要大量重复代码；</li>
<li>从成千上万的数据中快速查询出指定数据需要复杂的逻辑。</li>
</ul>
<p>如果每个应用程序都各自写自己的读写数据的代码，一方面效率低，容易出错，另一方面，每个应用程序访问数据的接口都不相同，数据难以复用。</p>
<p>所以，数据库作为一种专门管理数据的软件就出现了。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│application│</span><br><span class="line">└───────────┘</span><br><span class="line">     ▲ │</span><br><span class="line">     │ │</span><br><span class="line"> read│ │write</span><br><span class="line">     │ │</span><br><span class="line">     │ ▼</span><br><span class="line">┌───────────┐</span><br><span class="line">│ database  │</span><br><span class="line">└───────────┘</span><br></pre></td></tr></table></figure>
<p>这样一来，编写应用程序的时候，数据读写的功能就被大大地简化了。</p>
<h3 id="数据模型">数据模型</h3>
<p>数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：</p>
<ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
</ul>
<p>层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            ┌─────┐</span><br><span class="line">            │     │</span><br><span class="line">            └─────┘</span><br><span class="line">               │</span><br><span class="line">       ┌───────┴───────┐</span><br><span class="line">       │               │</span><br><span class="line">    ┌─────┐         ┌─────┐</span><br><span class="line">    │     │         │     │</span><br><span class="line">    └─────┘         └─────┘</span><br><span class="line">       │               │</span><br><span class="line">   ┌───┴───┐       ┌───┴───┐</span><br><span class="line">   │       │       │       │</span><br><span class="line">┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│     │ │     │ │     │ │     │</span><br><span class="line">└─────┘ └─────┘ └─────┘ └─────┘</span><br></pre></td></tr></table></figure>
<p>网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     ┌─────┐      ┌─────┐</span><br><span class="line">   ┌─│     │──────│     │──┐</span><br><span class="line">   │ └─────┘      └─────┘  │</span><br><span class="line">   │    │            │     │</span><br><span class="line">   │    └──────┬─────┘     │</span><br><span class="line">   │           │           │</span><br><span class="line">┌─────┐     ┌─────┐     ┌─────┐</span><br><span class="line">│     │─────│     │─────│     │</span><br><span class="line">└─────┘     └─────┘     └─────┘</span><br><span class="line">   │           │           │</span><br><span class="line">   │     ┌─────┴─────┐     │</span><br><span class="line">   │     │           │     │</span><br><span class="line">   │  ┌─────┐     ┌─────┐  │</span><br><span class="line">   └──│     │─────│     │──┘</span><br><span class="line">      └─────┘     └─────┘</span><br></pre></td></tr></table></figure>
<p>关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────┬─────┬─────┬─────┬─────┐</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">├─────┼─────┼─────┼─────┼─────┤</span><br><span class="line">│     │     │     │     │     │</span><br><span class="line">└─────┴─────┴─────┴─────┴─────┘</span><br></pre></td></tr></table></figure>
<p>随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。</p>
<p>为什么关系数据库获得了最广泛的应用？</p>
<p>因为相比层次模型和网状模型，关系模型理解和使用起来最简单。</p>
<p>关系数据库的关系模型是基于数学理论建立的。我们把域（Domain）定义为一组具有相同数据类型的值的集合，给定一组域D1,D2,…,Dn，它们的笛卡尔集定义为D1×D2×……×Dn={(d1,d2,…,dn)|di∈Di,i=1,2,…,n}， 而D1×D2×……×Dn的子集叫作在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)，这里的R表示#%&amp;^@!&amp;$#;!~％¥%……算了，根本讲不明白，大家也不用理解。</p>
<p>基于数学理论的关系模型虽然讲起来挺复杂，但是，基于日常生活的关系模型却十分容易理解。我们以学校班级为例，一个班级的学生就可以用一个表格存起来，并且定义如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>姓名</th>
<th>班级ID</th>
<th>性别</th>
<th>年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>小明</td>
<td>201</td>
<td>M</td>
<td>9</td>
</tr>
<tr>
<td>2</td>
<td>小红</td>
<td>202</td>
<td>F</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td>小军</td>
<td>202</td>
<td>M</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>小白</td>
<td>201</td>
<td>F</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>其中，班级ID对应着另一个班级表：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>名称</th>
<th>班主任</th>
</tr>
</thead>
<tbody>
<tr>
<td>201</td>
<td>二年级一班</td>
<td>王老师</td>
</tr>
<tr>
<td>202</td>
<td>二年级二班</td>
<td>李老师</td>
</tr>
</tbody>
</table>
<p>通过给定一个班级名称，可以查到一条班级记录，根据班级ID，又可以查到多条学生记录，这样，二维表之间就通过ID映射建立了“一对多”关系。</p>
<h3 id="数据类型">数据类型</h3>
<p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>INT</td>
<td>整型</td>
<td>4字节整数类型，范围约+/-21亿</td>
</tr>
<tr>
<td>BIGINT</td>
<td>长整型</td>
<td>8字节整数类型，范围约+/-922亿亿</td>
</tr>
<tr>
<td>REAL</td>
<td>浮点型</td>
<td>4字节浮点数，范围约+/-1038</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>浮点型</td>
<td>8字节浮点数，范围约+/-10308</td>
</tr>
<tr>
<td>DECIMAL(M,N)</td>
<td>高精度小数</td>
<td>由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td>
</tr>
<tr>
<td>CHAR(N)</td>
<td>定长字符串</td>
<td>存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td>
</tr>
<tr>
<td>VARCHAR(N)</td>
<td>变长字符串</td>
<td>存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>布尔类型</td>
<td>存储True或者False</td>
</tr>
<tr>
<td>DATE</td>
<td>日期类型</td>
<td>存储日期，例如，2018-06-22</td>
</tr>
<tr>
<td>TIME</td>
<td>时间类型</td>
<td>存储时间，例如，12:20:59</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期和时间类型</td>
<td>存储日期+时间，例如，2018-06-22 12:20:59</td>
</tr>
</tbody>
</table>
<p>上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，<code>REAL</code>又可以写成<code>FLOAT(24)</code>。还有一些不常用的数据类型，例如，<code>TINYINT</code>（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如<code>JSON</code>。</p>
<p>选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，<code>BIGINT</code>能满足整数存储的需求，<code>VARCHAR(N)</code>能满足字符串存储的需求，这两种类型是使用最广泛的。</p>
<h3 id="主流关系数据库">主流关系数据库</h3>
<p>目前，主流的关系数据库主要分为以下几类：</p>
<ol>
<li>商用数据库，例如：<a target="_blank" rel="noopener" href="https://www.oracle.com/">Oracle</a>，<a target="_blank" rel="noopener" href="https://www.microsoft.com/sql-server/">SQL Server</a>，<a target="_blank" rel="noopener" href="https://www.ibm.com/db2/">DB2</a>等；</li>
<li>开源数据库，例如：<a target="_blank" rel="noopener" href="https://www.mysql.com/">MySQL</a>，<a target="_blank" rel="noopener" href="https://www.postgresql.org/">PostgreSQL</a>等；</li>
<li>桌面数据库，以微软<a target="_blank" rel="noopener" href="https://products.office.com/access">Access</a>为代表，适合桌面应用程序使用；</li>
<li>嵌入式数据库，以<a target="_blank" rel="noopener" href="https://sqlite.org/">Sqlite</a>为代表，适合手机应用和桌面程序。</li>
</ol>
<h3 id="SQL">SQL</h3>
<p>什么是SQL？SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p>
<p>虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为<code>PL/SQL</code>，Microsoft把自己扩展的SQL称为<code>T-SQL</code>。</p>
<p>现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。</p>
<p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p>
<h4 id="DDL：Data-Definition-Language">DDL：Data Definition Language</h4>
<p>DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。</p>
<h4 id="DML：Data-Manipulation-Language">DML：Data Manipulation Language</h4>
<p>DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。</p>
<h4 id="DQL：Data-Query-Language">DQL：Data Query Language</h4>
<p>DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。</p>
<h3 id="语法特点">语法特点</h3>
<p>SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。</p>
<p>所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。</p>
<p>MySQL是目前应用最广泛的开源关系数据库。MySQL最早是由瑞典的MySQL AB公司开发，该公司在2008年被SUN公司收购，紧接着，SUN公司在2009年被Oracle公司收购，所以MySQL最终就变成了Oracle旗下的产品。</p>
<p>和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括：</p>
<ul>
<li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li>
<li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li>
</ul>
<p>MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。</p>
<p>使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择<em>InnoDB</em>就好了。</p>
<p>因为MySQL一开始就是开源的，所以基于MySQL的开源版本，又衍生出了各种版本：</p>
<h3 id="MariaDB">MariaDB</h3>
<p>由MySQL的创始人创建的一个开源分支版本，使用XtraDB引擎。</p>
<h3 id="Aurora">Aurora</h3>
<p>由Amazon改进的一个MySQL版本，专门提供给在AWS托管MySQL用户，号称5倍的性能提升。</p>
<h3 id="PolarDB">PolarDB</h3>
<p>由Alibaba改进的一个MySQL版本，专门提供给在阿里云托管的MySQL用户，号称6倍的性能提升。</p>
<p>而MySQL官方版本又分了好几个版本：</p>
<ul>
<li>Community Edition：社区开源版本，免费；</li>
<li>Standard Edition：标准版；</li>
<li>Enterprise Edition：企业版；</li>
<li>Cluster Carrier Grade Edition：集群版。</li>
</ul>
<p>以上版本的功能依次递增，价格也依次递增。不过，功能增加的主要是监控、集群等管理功能，对于基本的SQL功能是完全一样的。</p>
<p>所以使用MySQL就带来了一个巨大的好处：可以在自己的电脑上安装免费的Community Edition版本，进行学习、开发、测试，部署的时候，可以选择付费的高级版本，或者云服务商提供的兼容版本，而不需要对应用程序本身做改动。</p>
<h3 id="安装MySQL">安装MySQL</h3>
<p>要安装MySQL，可以从MySQL官方网站下载最新的MySQL Community Server版本：</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p>
<p>选择对应的操作系统版本，下载安装即可。在安装过程中，MySQL会自动创建一个<code>root</code>用户，并提示输入<code>root</code>口令。</p>
<p>要在Linux上安装MySQL，可以使用发行版的包管理器。例如，Debian和Ubuntu用户可以简单地通过命令<code>apt install mysql-server</code>安装最新的MySQL版本。</p>
<p>MySQL安装后会自动在后台运行。为了验证MySQL安装是否正确，我们需要通过<code>mysql</code>这个命令行程序来连接MySQL服务器。</p>
<p>在命令提示符下输入<code>mysql -u root -p</code>，然后输入口令，如果一切正确，就会连接到MySQL服务器，同时提示符变为<code>mysql&gt;</code>。</p>
<p>输入<code>exit</code>退出MySQL命令行。注意，MySQL服务器仍在后台运行。</p>
<h3 id="使用Docker运行MySQL">使用Docker运行MySQL</h3>
<p>另一种运行MySQL的方式不需要下载安装包，而是直接通过Docker安装最新的MySQL：</p>
<p>首先安装<a target="_blank" rel="noopener" href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a>，然后在命令行输入以下命令拉取MySQL最新版：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql</span><br></pre></td></tr></table></figure>
<p>拉取完成后，输入以下命令直接启动MySQL服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password -v /Users/chankein/mysql-data:/var/lib/mysql mysql</span><br></pre></td></tr></table></figure>
<p>命令<code>docker run</code>表示启动一个容器，后面各参数含义如下：</p>
<ul>
<li><code>-d</code>：表示在后台执行；</li>
<li><code>--name mysql</code>：表示容器的名字，不输入Docker会自动选择一个名字；</li>
<li><code>-p 3306:3306</code>：表示把容器的端口3306映射到本机，这样可以在本机通过3306端口连接MySQL；</li>
<li><code>-e MYSQL_ROOT_PASSWORD=password</code>：表示传入一个环境变量，作为root的口令，这里设置的口令是<code>password</code>，不输入此项则会自动生成一个口令，需要查看日志才能知道口令；</li>
<li><code>-v /Users/chankein/mysql-data:/var/lib/mysql</code>：表示将本地目录映射到容器目录<code>/var/lib/mysql</code>作为MySQL数据库存放的位置，需要将<code>/Users/chankein/mysql-data</code>改为你的电脑上的实际目录；</li>
<li><code>mysql</code>：最后一个参数是Docker镜像的名称。</li>
</ul>
<p>可以在Docker Desktop的管理窗口中选择<code>Containers</code>，看到正在运行的MySQL：</p>
<p><img src="https://liaoxuefeng.com/books/sql/rdbms/install-mysql/docker-mysql.png" alt="docker-mysql"></p>
<p>点击MySQL查看日志：</p>
<p><img src="https://liaoxuefeng.com/books/sql/rdbms/install-mysql/docker-mysql-log.png" alt="docker-mysql-log"></p>
<p>点击Exec进入命令行，输入命令<code>mysql -u root -p</code>，输入口令，即可进入MySQL命令行界面：</p>
<p><img src="https://liaoxuefeng.com/books/sql/rdbms/install-mysql/docker-mysql-exec.png" alt="docker-mysql-exec"></p>
<p>使用Docker运行MySQL时，任何时候都可以删除MySQL容器并重新运行。如果删除了本地映射的目录，重新运行就相当于一个全新的MySQL，因此，建议仅作为学习和开发使用，不要存储重要的数据。</p>
<h2 id="关系模型">关系模型</h2>
<p>我们已经知道，关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多Excel表。</p>
<p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</p>
<p>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p>
<p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<code>NULL</code>。注意<code>NULL</code>表示字段数据不存在。一个整型字段如果为<code>NULL</code>不表示它的值为<code>0</code>，同样的，一个字符串型字段为<code>NULL</code>也不表示它的值为空串<code>''</code>。</p>
<p>提示</p>
<p>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p>
<p>和Excel表有所不同的是，关系数据库的表和表之间需要建立“一对多”，“多对一”和“一对一”的关系，这样才能够按照应用程序的逻辑来组织和存储数据。</p>
<p>例如，一个班级表：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>名称</th>
<th>班主任</th>
</tr>
</thead>
<tbody>
<tr>
<td>201</td>
<td>二年级一班</td>
<td>王老师</td>
</tr>
<tr>
<td>202</td>
<td>二年级二班</td>
<td>李老师</td>
</tr>
</tbody>
</table>
<p>每一行对应着一个班级，而一个班级对应着多个学生，所以班级表和学生表的关系就是“一对多”：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>姓名</th>
<th>班级ID</th>
<th>性别</th>
<th>年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>小明</td>
<td>201</td>
<td>M</td>
<td>9</td>
</tr>
<tr>
<td>2</td>
<td>小红</td>
<td>202</td>
<td>F</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td>小军</td>
<td>202</td>
<td>M</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>小白</td>
<td>201</td>
<td>F</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>反过来，如果我们先在学生表中定位了一行记录，例如<code>ID=1</code>的小明，要确定他的班级，只需要根据他的“班级ID”对应的值<code>201</code>找到班级表中<code>ID=201</code>的记录，即二年级一班。所以，学生表和班级表是“多对一”的关系。</p>
<p>如果我们把班级表分拆得细一点，例如，单独创建一个教师表：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>名称</th>
<th>年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td>A1</td>
<td>王老师</td>
<td>26</td>
</tr>
<tr>
<td>A2</td>
<td>张老师</td>
<td>39</td>
</tr>
<tr>
<td>A3</td>
<td>李老师</td>
<td>32</td>
</tr>
<tr>
<td>A4</td>
<td>赵老师</td>
<td>27</td>
</tr>
</tbody>
</table>
<p>班级表只存储教师ID：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>名称</th>
<th>班主任ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>201</td>
<td>二年级一班</td>
<td>A1</td>
</tr>
<tr>
<td>202</td>
<td>二年级二班</td>
<td>A3</td>
</tr>
</tbody>
</table>
<p>这样，一个班级总是对应一个教师，班级表和教师表就是“一对一”关系。</p>
<p>在关系数据库中，关系是通过<em>主键</em>和<em>外键</em>来维护的。我们在后面会分别深入讲解。</p>
<h2 id="主键">主键</h2>
<p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>class_id</th>
<th>name</th>
<th>gender</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>小明</td>
<td>M</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>小红</td>
<td>F</td>
<td>95</td>
</tr>
</tbody>
</table>
<p>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。</p>
<p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p>
<p>例如，假设我们把<code>name</code>字段作为主键，那么通过名字<code>小明</code>或<code>小红</code>就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。</p>
<p>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p>
<p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p>
<p>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</p>
<p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<em>不可</em>用作主键。</p>
<p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p>
<ol>
<li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li>
<li>全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li>
</ol>
<p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p>
<p>注意</p>
<p>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p>
<h3 id="联合主键">联合主键</h3>
<p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p>
<p>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：</p>
<table>
<thead>
<tr>
<th>id_num</th>
<th>id_type</th>
<th>other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>A</td>
<td>…</td>
</tr>
<tr>
<td>2</td>
<td>A</td>
<td>…</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>如果我们把上述表的<code>id_num</code>和<code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p>
<p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p>
<h3 id="小结">小结</h3>
<p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p>
<p>可以使用多个列作为联合主键，但联合主键并不常用。</p>
<p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>小明</td>
<td>…</td>
</tr>
<tr>
<td>2</td>
<td>小红</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>一班</td>
<td>…</td>
</tr>
<tr>
<td>2</td>
<td>二班</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p>
<p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p>
<p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>class_id</th>
<th>name</th>
<th>other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>小明</td>
<td>…</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>小红</td>
<td>…</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>小白</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p>
<p>例如：</p>
<ul>
<li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li>
<li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li>
<li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li>
</ul>
<p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code>。</p>
<p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN KEY</span> (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id);</span><br></pre></td></tr></table></figure>
<p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p>
<p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p>
<p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p>
<p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> fk_class_id;</span><br></pre></td></tr></table></figure>
<p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p>
<h3 id="多对多">多对多</h3>
<p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p>
<p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p>
<p><code>teachers</code>表：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>张老师</td>
</tr>
<tr>
<td>2</td>
<td>王老师</td>
</tr>
<tr>
<td>3</td>
<td>李老师</td>
</tr>
<tr>
<td>4</td>
<td>赵老师</td>
</tr>
</tbody>
</table>
<p><code>classes</code>表：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>一班</td>
</tr>
<tr>
<td>2</td>
<td>二班</td>
</tr>
</tbody>
</table>
<p>中间表<code>teacher_class</code>关联两个一对多关系：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>teacher_id</th>
<th>class_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>通过中间表<code>teacher_class</code>可知<code>teachers</code>到<code>classes</code>的关系：</p>
<ul>
<li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li>
<li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li>
<li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li>
<li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li>
</ul>
<p>同理可知<code>classes</code>到<code>teachers</code>的关系：</p>
<ul>
<li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li>
<li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li>
</ul>
<p>因此，通过中间表，我们就定义了一个“多对多”关系。</p>
<h3 id="一对一">一对一</h3>
<p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p>
<p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表<code>contacts</code>，我们就可以得到一个“一对一”关系：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>student_id</th>
<th>mobile</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>135xxxx6300</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>138xxxx2209</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>139xxxx8086</td>
</tr>
</tbody>
</table>
<p>有细心的童鞋会问，既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p>
<p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表。</p>
<p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p>
<h3 id="小结-2">小结</h3>
<p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p>
<p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p>
<p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p>
<p>例如，对于<code>students</code>表：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>class_id</th>
<th>name</th>
<th>gender</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>小明</td>
<td>M</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>小红</td>
<td>F</td>
<td>95</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>小军</td>
<td>M</td>
<td>88</td>
</tr>
</tbody>
</table>
<p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_score (score);</span><br></pre></td></tr></table></figure>
<p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure>
<p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p>
<p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p>
<p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p>
<h3 id="唯一索引">唯一索引</h3>
<p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p>
<p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设<code>students</code>表的<code>name</code>不能重复：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uni_name (name);</span><br></pre></td></tr></table></figure>
<p>通过<code>UNIQUE</code>关键字我们就添加了一个唯一索引。</p>
<p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (name);</span><br></pre></td></tr></table></figure>
<p>这种情况下，<code>name</code>列没有索引，但仍然具有唯一性保证。</p>
<p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p>
<h3 id="小结-3">小结</h3>
<p>通过对数据库表创建索引，可以提高查询速度；</p>
<p>通过创建唯一索引，可以保证某一列的值具有唯一性；</p>
<p>数据库索引对于用户和应用程序来说都是透明的。</p>
<p>在关系数据库中，最常用的操作就是查询。</p>
<h3 id="准备数据">准备数据</h3>
<p>为了便于讲解和练习，我们先准备好了一个<code>students</code>表和一个<code>classes</code>表，它们的结构和数据如下：</p>
<p><code>students</code>表存储了学生信息：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>class_id</th>
<th>name</th>
<th>gender</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>小明</td>
<td>M</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>小红</td>
<td>F</td>
<td>95</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>小军</td>
<td>M</td>
<td>88</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>小米</td>
<td>F</td>
<td>73</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>小白</td>
<td>F</td>
<td>81</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>小兵</td>
<td>M</td>
<td>55</td>
</tr>
<tr>
<td>7</td>
<td>2</td>
<td>小林</td>
<td>M</td>
<td>85</td>
</tr>
<tr>
<td>8</td>
<td>3</td>
<td>小新</td>
<td>F</td>
<td>91</td>
</tr>
<tr>
<td>9</td>
<td>3</td>
<td>小王</td>
<td>M</td>
<td>89</td>
</tr>
<tr>
<td>10</td>
<td>3</td>
<td>小丽</td>
<td>F</td>
<td>85</td>
</tr>
</tbody>
</table>
<p><code>classes</code>表存储了班级信息：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>一班</td>
</tr>
<tr>
<td>2</td>
<td>二班</td>
</tr>
<tr>
<td>3</td>
<td>三班</td>
</tr>
<tr>
<td>4</td>
<td>四班</td>
</tr>
</tbody>
</table>
<p>请注意，和<code>MySQL</code>的持久化存储不同的是，由于我们使用的是<a target="_blank" rel="noopener" href="https://alasql.org/">AlaSQL</a>内存数据库，两张表的数据在页面加载时导入，并且只存在于浏览器的内存中，因此，刷新页面后，数据会重置为上述初始值。</p>
<h3 id="MySQL">MySQL</h3>
<p>如果你想用MySQL练习，可以<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/sql/query/mysql-init-test-data.sql">下载这个SQL脚本</a>，然后在命令行运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p &lt; init-test-data.sql</span><br></pre></td></tr></table></figure>
<p>就可以自动创建<code>test</code>数据库，并且在<code>test</code>数据库下创建<code>students</code>表和<code>classes</code>表，以及必要的初始化数据。</p>
<p>和内存数据库不同的是，对MySQL数据库做的所有修改，都会保存下来。如果你希望恢复到初始状态，可以再次运行该脚本。</p>
<h2 id="基本查询">基本查询</h2>
<p>要查询数据库表的数据，我们使用如下的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>假设表名是<code>students</code>，要查询<code>students</code>表的所有行，我们用如下SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询students表的所有数据</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<p>使用<code>SELECT * FROM students</code>时，<code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是<code>students</code>表。</p>
<p>该SQL将查询出<code>students</code>表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。</p>
<p>要查询<code>classes</code>表的所有行，我们用如下SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询classes表的所有数据</span><br><span class="line">SELECT * FROM classes;</span><br></pre></td></tr></table></figure>
<p>运行上述SQL语句，观察查询结果。</p>
<p><code>SELECT</code>语句其实并不要求一定要有<code>FROM</code>子句。我们来试试下面的<code>SELECT</code>语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 计算100+200</span><br><span class="line">SELECT 100+200;</span><br></pre></td></tr></table></figure>
<p>上述查询会直接计算出表达式的结果。虽然<code>SELECT</code>可以用作计算，但它并不是SQL的强项。但是，不带<code>FROM</code>子句的<code>SELECT</code>语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条<code>SELECT 1;</code>来测试数据库连接。</p>
<h3 id="小结-4">小结</h3>
<p>使用SELECT查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据；</p>
<p>SELECT查询的结果是一个二维表。</p>
<p>使用<code>SELECT * FROM &lt;表名&gt;</code>可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。</p>
<p>SELECT语句可以通过<code>WHERE</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成<code>WHERE</code>条件就是<code>SELECT * FROM students WHERE score &gt;= 80</code>。</p>
<p>其中，<code>WHERE</code>关键字后面的<code>score &gt;= 80</code>就是条件。<code>score</code>是列名，该列存储了学生的成绩，因此，<code>score &gt;= 80</code>就筛选出了指定条件的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按条件查询students:</span><br><span class="line">SELECT * FROM students WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure>
<p>因此，条件查询的语法就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>条件表达式可以用<code>&lt;条件1&gt; AND &lt;条件2&gt;</code>表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来：</p>
<ul>
<li>条件1：根据score列的数据判断：<code>score &gt;= 80</code>；</li>
<li>条件2：根据gender列的数据判断：<code>gender = 'M'</code>，注意<code>gender</code>列存储的是字符串，需要用单引号括起来。</li>
</ul>
<p>就可以写出<code>WHERE</code>条件：<code>score &gt;= 80 AND gender = 'M'</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按AND条件查询students:</span><br><span class="line">SELECT * FROM students WHERE score &gt;= 80 AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure>
<p>第二种条件是<code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，表示满足条件1或者满足条件2。例如，把上述<code>AND</code>查询的两个条件改为<code>OR</code>，查询结果就是“分数在80分或以上”或者“男生”，满足任意之一的条件即选出该记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按OR条件查询students:</span><br><span class="line">SELECT * FROM students WHERE score &gt;= 80 OR gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure>
<p>很显然<code>OR</code>条件要比<code>AND</code>条件宽松，返回的符合条件的记录也更多。</p>
<p>第三种条件是<code>NOT &lt;条件&gt;</code>，表示“不符合该条件”的记录。例如，写一个“不是2班的学生”这个条件，可以先写出“是2班的学生”：<code>class_id = 2</code>，再加上<code>NOT</code>：<code>NOT class_id = 2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按NOT条件查询students:</span><br><span class="line">SELECT * FROM students WHERE NOT class_id = 2;</span><br></pre></td></tr></table></figure>
<p>上述<code>NOT</code>条件<code>NOT class_id = 2</code>其实等价于<code>class_id &lt;&gt; 2</code>，因此，<code>NOT</code>查询不是很常用。</p>
<p>要组合三个或者更多的条件，就需要用小括号<code>()</code>表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按多个条件查询students:</span><br><span class="line">SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure>
<p>如果不加括号，条件运算按照<code>NOT</code>、<code>AND</code>、<code>OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。</p>
<h3 id="常用的条件表达式">常用的条件表达式</h3>
<table>
<thead>
<tr>
<th>条件</th>
<th>表达式举例1</th>
<th>表达式举例2</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用=判断相等</td>
<td>score = 80</td>
<td>name = ‘abc’</td>
<td>字符串需要用单引号括起来</td>
</tr>
<tr>
<td>使用&gt;判断大于</td>
<td>score &gt; 80</td>
<td>name &gt; ‘abc’</td>
<td>字符串比较根据ASCII码，中文字符比较根据数据库设置</td>
</tr>
<tr>
<td>使用&gt;=判断大于或相等</td>
<td>score &gt;= 80</td>
<td>name &gt;= ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用&lt;判断小于</td>
<td>score &lt; 80</td>
<td>name &lt;= ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用&lt;=判断小于或相等</td>
<td>score &lt;= 80</td>
<td>name &lt;= ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用&lt;&gt;判断不相等</td>
<td>score &lt;&gt; 80</td>
<td>name &lt;&gt; ‘abc’</td>
<td></td>
</tr>
<tr>
<td>使用LIKE判断相似</td>
<td>name LIKE ‘ab%’</td>
<td>name LIKE ‘%bc%’</td>
<td>%表示任意字符，例如’ab%‘将匹配’ab’，‘abc’，‘abcd’</td>
</tr>
</tbody>
</table>
<p>查询分数在60分(含)～90分(含)之间的学生可以使用的WHERE语句是：</p>
<h3 id="小结-5">小结</h3>
<p>通过<code>WHERE</code>条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。</p>
<h2 id="投影查询">投影查询</h2>
<p>使用<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。</p>
<p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。</p>
<p>例如，从<code>students</code>表中返回<code>id</code>、<code>score</code>和<code>name</code>这三列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用投影查询</span><br><span class="line">SELECT id, score, name FROM students;</span><br></pre></td></tr></table></figure>
<p>这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。</p>
<p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p>
<p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用投影查询，并将列名重命名：</span><br><span class="line">SELECT id, score points, name FROM students;</span><br></pre></td></tr></table></figure>
<p>投影查询同样可以接<code>WHERE</code>条件，实现复杂的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用投影查询+WHERE条件：</span><br><span class="line">SELECT id, score points, name FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="小结-6">小结</h3>
<p>使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影；</p>
<p><code>SELECT</code>语句可以对结果集的列进行重命名。</p>
<h2 id="排序">排序</h2>
<h3 id="排序-2">排序</h3>
<p>我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照<code>id</code>排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上<code>ORDER BY</code>子句。例如按照成绩从低到高进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score从低到高:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score;</span><br></pre></td></tr></table></figure>
<p>如果要反过来，按照成绩从高到底排序，我们可以加上<code>DESC</code>表示“倒序”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score从高到低:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure>
<p>如果<code>score</code>列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按<code>score</code>列倒序，如果有相同分数的，再按<code>gender</code>列排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score, gender排序:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;</span><br></pre></td></tr></table></figure>
<p>默认的排序规则是<code>ASC</code>：“升序”，即从小到大。<code>ASC</code>可以省略，即<code>ORDER BY score ASC</code>和<code>ORDER BY score</code>效果一样。</p>
<p>如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 带WHERE条件的ORDER BY:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id = 1</span><br><span class="line">ORDER BY score DESC;</span><br></pre></td></tr></table></figure>
<p>这样，结果集仅包含符合<code>WHERE</code>条件的记录，并按照<code>ORDER BY</code>的设定排序。</p>
<h3 id="小结-7">小结</h3>
<p>使用<code>ORDER BY</code>可以对结果集进行排序；</p>
<p>可以对多列进行升序、倒序排序。</p>
<p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p>
<p>要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。</p>
<p>因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过<code>LIMIT &lt;N-M&gt; OFFSET &lt;M&gt;</code>子句实现。我们先把所有学生按照成绩从高到低进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按score从高到低:</span><br><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure>
<p>现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第1页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure>
<p>上述查询<code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。</p>
<p>如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把<code>OFFSET</code>设定为3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第2页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 3;</span><br></pre></td></tr></table></figure>
<p>类似的，查询第3页的时候，<code>OFFSET</code>应该设定为6:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第3页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 6;</span><br></pre></td></tr></table></figure>
<p>查询第4页的时候，<code>OFFSET</code>应该设定为9:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询第4页:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 9;</span><br></pre></td></tr></table></figure>
<p>由于第4页只有1条记录，因此最终结果集按实际数量1显示。<code>LIMIT 3</code>表示的意思是“最多3条记录”。</p>
<p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量<code>pageSize</code>（这里是3），然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p>
<ul>
<li><code>LIMIT</code>总是设定为<code>pageSize</code>；</li>
<li><code>OFFSET</code>计算公式为<code>pageSize * (pageIndex - 1)</code>。</li>
</ul>
<p>这样就能正确查询出第N页的记录集。</p>
<p>如果原本记录集一共就10条记录，但我们把<code>OFFSET</code>设置为20，会得到什么结果呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- OFFSET设定为20:</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 20;</span><br></pre></td></tr></table></figure>
<p><code>OFFSET</code>超过了查询的最大数量并不会报错，而是得到一个空的结果集。</p>
<h3 id="注意">注意</h3>
<p><code>OFFSET</code>是可选的，如果只写<code>LIMIT 15</code>，那么相当于<code>LIMIT 15 OFFSET 0</code>。</p>
<p>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。</p>
<p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>分页时，随着<code>N</code>越来越大，查询效率也会越来越低。</p>
<h3 id="思考">思考</h3>
<p>在分页查询之前，如何计算一共有几页？</p>
<h3 id="小结-8">小结</h3>
<p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p>
<p>分页查询需要先确定每页的数量和当前页数，然后确定<code>LIMIT</code>和<code>OFFSET</code>的值。</p>
<p>如果我们要统计一张表的数据量，例如，想查询<code>students</code>表一共有多少条记录，难道必须用<code>SELECT * FROM students</code>查出来然后再数一数有多少行吗？</p>
<p>这个方法当然可以，但是比较弱智。对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p>
<p>仍然以查询<code>students</code>表一共有多少条记录为例，我们可以使用SQL内置的<code>COUNT()</code>函数查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询:</span><br><span class="line">SELECT COUNT(*) FROM students;</span><br></pre></td></tr></table></figure>
<p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。</p>
<p>通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询并设置结果集的列名为num:</span><br><span class="line">SELECT COUNT(*) num FROM students;</span><br></pre></td></tr></table></figure>
<p><code>COUNT(*)</code>和<code>COUNT(id)</code>实际上是一样的效果。另外注意，聚合查询同样可以使用<code>WHERE</code>条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询并设置WHERE条件:</span><br><span class="line">SELECT COUNT(*) boys FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure>
<p>除了<code>COUNT()</code>函数外，SQL还提供了如下聚合函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SUM</td>
<td>计算某一列的合计值，该列必须为数值类型</td>
</tr>
<tr>
<td>AVG</td>
<td>计算某一列的平均值，该列必须为数值类型</td>
</tr>
<tr>
<td>MAX</td>
<td>计算某一列的最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>计算某一列的最小值</td>
</tr>
</tbody>
</table>
<p>注意，<code>MAX()</code>和<code>MIN()</code>函数并不限于数值类型。如果是字符类型，<code>MAX()</code>和<code>MIN()</code>会返回排序最后和排序最前的字符。</p>
<p>要统计男生的平均成绩，我们用下面的聚合查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 使用聚合查询计算男生平均成绩:</span><br><span class="line">SELECT AVG(score) average FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure>
<p>要特别注意：如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- WHERE条件gender = &#x27;X&#x27;匹配不到任何行:</span><br><span class="line">SELECT AVG(score) average FROM students WHERE gender = &#x27;X&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="分组">分组</h3>
<p>如果我们要统计一班的学生数量，我们知道，可以用<code>SELECT COUNT(*) num FROM students WHERE class_id = 1;</code>。如果要继续统计二班、三班的学生数量，难道必须不断修改<code>WHERE</code>条件来执行<code>SELECT</code>语句吗？</p>
<p>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id分组:</span><br><span class="line">SELECT COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure>
<p>执行这个查询，<code>COUNT()</code>的结果不再是一个，而是3个，这是因为，<code>GROUP BY</code>子句指定了按<code>class_id</code>分组，因此，执行该<code>SELECT</code>语句时，会把<code>class_id</code>相同的列先分组，再分别计算，因此，得到了3行结果。</p>
<p>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把<code>class_id</code>列也放入结果集中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id分组:</span><br><span class="line">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure>
<p>这下结果集就可以一目了然地看出各个班级的学生人数。我们再试试把<code>name</code>放入结果集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id分组:</span><br><span class="line">SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure>
<p>不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有<code>class_id</code>都相同，<code>name</code>是不同的，SQL引擎不能把多个<code>name</code>的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。</p>
<p>注意</p>
<p>AlaSQL并没有严格执行SQL标准，上述SQL在浏览器可以正常执行，但是在MySQL、Oracle等环境下将报错，请自行在MySQL中测试。</p>
<p>也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 按class_id, gender分组:</span><br><span class="line">SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;</span><br></pre></td></tr></table></figure>
<p>上述查询结果集一共有6条记录，分别对应各班级的男生和女生人数。</p>
<h3 id="练习">练习</h3>
<p>请使用一条SELECT查询查出每个班级的平均分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查出每个班级的平均分，结果集应当有3条记录:</span><br><span class="line">SELECT &#x27;TODO&#x27;;</span><br></pre></td></tr></table></figure>
<p>请使用一条SELECT查询查出每个班级男生和女生的平均分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查出每个班级的平均分，结果集应当有6条记录:</span><br><span class="line">SELECT &#x27;TODO&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="小结-9">小结</h3>
<p>使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；</p>
<p>聚合查询可以用<code>GROUP BY</code>分组聚合；</p>
<p>聚合查询也可以添加<code>WHERE</code>条件。</p>
<p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：<code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code>。</p>
<p>例如，同时从<code>students</code>表和<code>classes</code>表的“乘积”，即查询数据，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- FROM students, classes:</span><br><span class="line">SELECT * FROM students, classes;</span><br></pre></td></tr></table></figure>
<p>这种一次查询两个表的数据，查询的结果也是一个二维表，它是<code>students</code>表和<code>classes</code>表的“乘积”，即<code>students</code>表的每一行与<code>classes</code>表的每一行都两两拼在一起返回。结果集的列数是<code>students</code>表和<code>classes</code>表的列数之和，行数是<code>students</code>表和<code>classes</code>表的行数之积。</p>
<p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p>
<p>你可能还注意到了，上述查询的结果集有两列<code>id</code>和两列<code>name</code>，两列<code>id</code>是因为其中一列是<code>students</code>表的<code>id</code>，而另一列是<code>classes</code>表的<code>id</code>，但是在结果集中，不好区分。两列<code>name</code>同理</p>
<p>要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的<code>id</code>和<code>name</code>列起别名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- set alias:</span><br><span class="line">SELECT</span><br><span class="line">    students.id sid,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure>
<p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- set table alias:</span><br><span class="line">SELECT</span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line">FROM students s, classes c;</span><br></pre></td></tr></table></figure>
<p>注意到<code>FROM</code>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名<code>s</code>和<code>c</code>分别表示<code>students</code>表和<code>classes</code>表。</p>
<p>多表查询也是可以添加<code>WHERE</code>条件的，我们来试试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- set where clause:</span><br><span class="line">SELECT</span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line">FROM students s, classes c</span><br><span class="line">WHERE s.gender = &#x27;M&#x27; AND c.id = 1;</span><br></pre></td></tr></table></figure>
<p>这个查询的结果集每行记录都满足条件<code>s.gender = 'M'</code>和<code>c.id = 1</code>。添加<code>WHERE</code>条件后结果集的数量大大减少了。</p>
<h3 id="小结-10">小结</h3>
<p>使用多表查询可以获取M x N行记录；</p>
<p>多表查询的结果集可能非常巨大，要小心使用。</p>
<p>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</p>
<p>例如，我们想要选出<code>students</code>表的所有学生信息，可以用一条简单的SELECT语句完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 选出所有学生:</span><br><span class="line">SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s;</span><br></pre></td></tr></table></figure>
<p>但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有<code>class_id</code>列，缺少对应班级的<code>name</code>列。</p>
<p>现在问题来了，存放班级名称的<code>name</code>列存储在<code>classes</code>表中，只有根据<code>students</code>表的<code>class_id</code>，找到<code>classes</code>表对应的行，再取出<code>name</code>列，就可以获得班级名称。</p>
<p>这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 选出所有学生，同时返回班级名称:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure>
<p>注意INNER JOIN查询的写法是：</p>
<ol>
<li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li>
<li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li>
<li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li>
<li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li>
</ol>
<p>使用别名不是必须的，但可以更好地简化查询语句。</p>
<p>那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用OUTER JOIN:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">RIGHT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure>
<p>执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如<code>name</code>、<code>gender</code>、<code>score</code>都为<code>NULL</code>。</p>
<p>这也容易理解，因为根据<code>ON</code>条件<code>s.class_id = c.id</code>，<code>classes</code>表的<code>id=4</code>的行正是“四班”，但是，<code>students</code>表中并不存在<code>class_id=4</code>的行。</p>
<p>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p>
<p>INNER JOIN只返回同时存在于两张表的行数据，由于<code>students</code>表的<code>class_id</code>包含1，2，3，<code>classes</code>表的<code>id</code>包含1，2，3，4，所以，INNER JOIN根据条件<code>s.class_id = c.id</code>返回的结果集仅包含1，2，3。</p>
<p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以<code>NULL</code>填充剩下的字段。</p>
<p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加<code>class_id=5</code>，由于classes表并不存在<code>id=5</code>的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的<code>class_name</code>是<code>NULL</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 先增加一列class_id=5:</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) values (5, &#x27;新生&#x27;, &#x27;M&#x27;, 88);</span><br><span class="line">-- 使用LEFT OUTER JOIN:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">LEFT OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure>
<p>最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 使用FULL OUTER JOIN:</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">FULL OUTER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure>
<p>对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。</p>
<p>假设查询语句是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> tableA ??? <span class="keyword">JOIN</span> tableB <span class="keyword">ON</span> tableA.column1 <span class="operator">=</span> tableB.column2;</span><br></pre></td></tr></table></figure>
<p>我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：</p>
<p><img src="https://liaoxuefeng.com/books/sql/query/join/inner-join.jpg" alt="inner-join"></p>
<p>LEFT OUTER JOIN是选出左表存在的记录：</p>
<p><img src="https://liaoxuefeng.com/books/sql/query/join/left-outer-join.jpg" alt="left-outer-join"></p>
<p>RIGHT OUTER JOIN是选出右表存在的记录：</p>
<p><img src="https://liaoxuefeng.com/books/sql/query/join/right-outer-join.jpg" alt="right-outer-join"></p>
<p>FULL OUTER JOIN则是选出左右表都存在的记录：</p>
<p><img src="https://liaoxuefeng.com/books/sql/query/join/full-outer-join.jpg" alt="full-outer-join"></p>
<h3 id="小结-11">小结</h3>
<p>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；</p>
<p>INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;</code>；</p>
<p>JOIN查询仍然可以使用<code>WHERE</code>条件和<code>ORDER BY</code>排序。</p>
<p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了<code>SELECT</code>语句的详细用法。</p>
<p>而对于增、删、改，对应的SQL语句分别是：</p>
<ul>
<li>INSERT：插入新记录；</li>
<li>UPDATE：更新已有记录；</li>
<li>DELETE：删除已有记录。</li>
</ul>
<p>我们将分别讨论这三种修改数据的语句的使用方法。</p>
<h2 id="插入数据">插入数据</h2>
<p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。</p>
<p><code>INSERT</code>语句的基本语法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure>
<p>例如，我们向<code>students</code>表插入一条新记录，先列举出需要插入的字段名称，然后在<code>VALUES</code>子句中依次写出对应字段的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 添加一条新记录:</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;大牛&#x27;, &#x27;M&#x27;, 80);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<p>注意到我们并没有列出<code>id</code>字段，也没有列出<code>id</code>字段对应的值，这是因为<code>id</code>字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在<code>INSERT</code>语句中也可以不出现。</p>
<p>要注意，<code>INSERT</code>字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和<code>INSERT</code>字段顺序一致。也就是说，可以写<code>INSERT INTO students (score, gender, name, class_id) ...</code>，但是对应的<code>VALUES</code>就得变成<code>(80, 'M', '大牛', 2)</code>。</p>
<p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值，每组值用逗号<code>,</code>分隔：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 一次性添加多条新记录:</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#x27;大宝&#x27;, &#x27;M&#x27;, 87),</span><br><span class="line">  (2, &#x27;二宝&#x27;, &#x27;M&#x27;, 81),</span><br><span class="line">  (3, &#x27;三宝&#x27;, &#x27;M&#x27;, 83);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<h3 id="小结-12">小结</h3>
<p>使用<code>INSERT</code>，我们就可以一次向一个表中插入一条或多条记录。</p>
<hr>
<hr>
<p>如果要更新数据库表中的记录，我们就必须使用<code>UPDATE</code>语句。</p>
<p><code>UPDATE</code>语句的基本语法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>, ... <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure>
<p>例如，我们想更新<code>students</code>表<code>id=1</code>的记录的<code>name</code>和<code>score</code>这两个字段，先写出<code>UPDATE students SET name='大牛', score=66</code>，然后在<code>WHERE</code>子句中写出需要更新的行的筛选条件<code>id=1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=1的记录:</span><br><span class="line">UPDATE students SET name=&#x27;大牛&#x27;, score=66 WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students WHERE id=1;</span><br></pre></td></tr></table></figure>
<p>注意到<code>UPDATE</code>语句的<code>WHERE</code>条件和<code>SELECT</code>语句的<code>WHERE</code>条件其实是一样的，因此完全可以一次更新多条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=5,6,7的记录:</span><br><span class="line">UPDATE students SET name=&#x27;小牛&#x27;, score=77 WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<p>在<code>UPDATE</code>语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新score&lt;80的记录:</span><br><span class="line">UPDATE students SET score=score+10 WHERE score&lt;80;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<p>其中，<code>SET score=score+10</code>就是给当前行的<code>score</code>字段的值加上了10。</p>
<p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>UPDATE</code>语句不会报错，也不会有任何记录被更新。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=999的记录:</span><br><span class="line">UPDATE students SET score=100 WHERE id=999;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<p>最后，要特别小心的是，<code>UPDATE</code>语句可以没有<code>WHERE</code>条件，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> score<span class="operator">=</span><span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>这时，整个表的所有记录都会被更新。所以，在执行<code>UPDATE</code>语句时要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>UPDATE</code>更新。</p>
<h3 id="MySQL-2">MySQL</h3>
<p>在使用MySQL这类真正的关系数据库时，<code>UPDATE</code>语句会返回更新的行数以及<code>WHERE</code>条件匹配的行数。</p>
<p>例如，更新<code>id=1</code>的记录时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>
<p>MySQL会返回<code>1</code>，可以从打印的结果<code>Rows matched: 1 Changed: 1</code>看到。</p>
<p>当更新<code>id=999</code>的记录时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure>
<p>MySQL会返回<code>0</code>，可以从打印的结果<code>Rows matched: 0 Changed: 0</code>看到。</p>
<h3 id="小结-13">小结</h3>
<p>使用<code>UPDATE</code>，我们就可以一次更新表中的一条或多条记录。</p>
<h2 id="删除数据">删除数据</h2>
<p>如果要删除数据库表中的记录，我们可以使用<code>DELETE</code>语句。</p>
<p><code>DELETE</code>语句的基本语法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure>
<p>例如，我们想删除<code>students</code>表中<code>id=1</code>的记录，就需要这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=1的记录:</span><br><span class="line">DELETE FROM students WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<p>注意到<code>DELETE</code>语句的<code>WHERE</code>条件也是用来筛选需要删除的行，因此和<code>UPDATE</code>类似，<code>DELETE</code>语句也可以一次删除多条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=5,6,7的记录:</span><br><span class="line">DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>DELETE</code>语句不会报错，也不会有任何记录被删除。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=999的记录:</span><br><span class="line">DELETE FROM students WHERE id=999;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>
<p>最后，要特别小心的是，和<code>UPDATE</code>类似，不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure>
<p>这时，整个表的所有记录都会被删除。所以，在执行<code>DELETE</code>语句时也要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>DELETE</code>删除。</p>
<h3 id="MySQL-3">MySQL</h3>
<p>在使用MySQL这类真正的关系数据库时，<code>DELETE</code>语句也会返回删除的行数以及<code>WHERE</code>条件匹配的行数。</p>
<p>例如，分别执行删除<code>id=1</code>和<code>id=999</code>的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM students WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<h3 id="小结-14">小结</h3>
<p>使用<code>DELETE</code>，我们就可以一次删除表中的一条或多条记录。</p>
<h2 id="MySQL-4">MySQL</h2>
<p>安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。</p>
<p>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为<code>mysql&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\chankein&gt; mysql -u root -p                │</span><br><span class="line">│Enter password: ******                                   │</span><br><span class="line">│                                                         │</span><br><span class="line">│Server version: 5.7                                      │</span><br><span class="line">│Copyright (c) 2000, 2018, ...                            │</span><br><span class="line">│Type &#x27;help;&#x27; or &#x27;\h&#x27; for help.                           │</span><br><span class="line">│                                                         │</span><br><span class="line">│mysql&gt;                                                   │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p>
<p>提示</p>
<p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p>
<p>MySQL Client和MySQL Server的关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────▶│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure>
<p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是<code>127.0.0.1:3306</code>。</p>
<p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 10.0.1.99 -u root -p</span><br></pre></td></tr></table></figure>
<h3 id="小结-15">小结</h3>
<p>命令行程序<code>mysql</code>实际上是MySQL客户端，真正的MySQL服务器程序是<code>mysqld</code>，在后台运行。</p>
<hr>
<hr>
<p>要管理MySQL，可以使用可视化图形界面<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/workbench/">MySQL Workbench</a>。</p>
<p>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。</p>
<p>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</p>
<h3 id="数据库">数据库</h3>
<p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| shici              |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">| school             |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。</p>
<p>注意：在MySQL命令行客户端输入SQL后，记得加一个<code>;</code>表示SQL语句结束，再回车就可以执行该SQL语句。虽然有些SQL命令不需要<code>;</code>也能执行，但类似<code>SELECT</code>等语句不加<code>;</code>会让MySQL客户端换行后继续等待输入。如果在图形界面或程序开发中集成SQL则不需要加<code>;</code>。</p>
<p>要创建一个新数据库，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>要删除一个数据库，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE test;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>注意：删除一个数据库将导致该数据库的所有表全部被删除。</p>
<p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>
<h3 id="表">表</h3>
<p>列出当前数据库的所有表，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_test      |</span><br><span class="line">+---------------------+</span><br><span class="line">| classes             |</span><br><span class="line">| statistics          |</span><br><span class="line">| students            |</span><br><span class="line">| students_of_class1  |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<p>要查看一个表的结构，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC students;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| class_id | bigint(20)   | NO   |     | NULL    |                |</span><br><span class="line">| name     | varchar(100) | NO   |     | NULL    |                |</span><br><span class="line">| gender   | varchar(1)   | NO   |     | NULL    |                |</span><br><span class="line">| score    | int(11)      | NO   |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>还可以使用以下命令查看创建表的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE students;</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">| students | CREATE TABLE `students` (                             |</span><br><span class="line">|          |   `id` bigint(20) NOT NULL AUTO_INCREMENT,            |</span><br><span class="line">|          |   `class_id` bigint(20) NOT NULL,                     |</span><br><span class="line">|          |   `name` varchar(100) NOT NULL,                       |</span><br><span class="line">|          |   `gender` varchar(1) NOT NULL,                       |</span><br><span class="line">|          |   `score` int(11) NOT NULL,                           |</span><br><span class="line">|          |   PRIMARY KEY (`id`)                                  |</span><br><span class="line">|          | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 |</span><br><span class="line">+----------+-------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE students;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure>
<p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure>
<p>要删除列，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure>
<h3 id="退出MySQL">退出MySQL</h3>
<p>使用<code>EXIT</code>命令退出MySQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXIT</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure>
<p>注意<code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</p>
<p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</p>
<h3 id="插入或替换">插入或替换</h3>
<p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure>
<p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p>
<h3 id="插入或更新">插入或更新</h3>
<p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>) <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> name<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>, gender<span class="operator">=</span><span class="string">&#x27;F&#x27;</span>, score<span class="operator">=</span><span class="number">99</span>;</span><br></pre></td></tr></table></figure>
<p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p>
<h3 id="插入或忽略">插入或忽略</h3>
<p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> students (id, class_id, name, gender, score) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure>
<p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p>
<h3 id="快照">快照</h3>
<p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> students_of_class1 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> class_id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p>
<h3 id="写入查询结果集">写入查询结果集</h3>
<p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p>
<p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> statistics (</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">    class_id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    average <span class="keyword">DOUBLE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以用一条语句写入各班的平均成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> statistics (class_id, average) <span class="keyword">SELECT</span> class_id, <span class="built_in">AVG</span>(score) <span class="keyword">FROM</span> students <span class="keyword">GROUP</span> <span class="keyword">BY</span> class_id;</span><br></pre></td></tr></table></figure>
<p>确保<code>INSERT</code>语句的列和<code>SELECT</code>语句的列能一一对应，就可以在<code>statistics</code>表中直接保存查询的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="强制使用指定索引">强制使用指定索引</h3>
<p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students FORCE INDEX (idx_class_id) <span class="keyword">WHERE</span> class_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p>
<h2 id="事务">事务</h2>
<p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从id=1的账户给id=2的账户转账100元</span></span><br><span class="line"><span class="comment">-- 第一步：将id=1的A账户余额减去100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 第二步：将id=2的B账户余额加上100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。</p>
<p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<em>事务</em>。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p>
<p>可见，数据库事务具有ACID这4个特性：</p>
<ul>
<li>A：Atomicity，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li>
<li>C：Consistency，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li>
<li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li>
<li>D：Durability，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li>
</ul>
<p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p>
<p>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em>显式事务</em>，例如，把上述的转账操作作为一个显式事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。</p>
<p><code>COMMIT</code>是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果<code>COMMIT</code>语句执行失败了，整个事务也会失败。</p>
<p>有些时候，我们希望主动让事务失败，这时，可以用<code>ROLLBACK</code>回滚事务，整个事务会失败：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>
<p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p>
<h3 id="隔离级别">隔离级别</h3>
<p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p>
<p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p>
<table>
<thead>
<tr>
<th>Isolation Level</th>
<th>脏读（Dirty Read）</th>
<th>不可重复读（Non Repeatable Read）</th>
<th>幻读（Phantom Read）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read Uncommitted</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Read Committed</td>
<td>-</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>-</td>
<td>-</td>
<td>Yes</td>
</tr>
<tr>
<td>Serializable</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>我们会依次介绍4种隔离级别的数据一致性问题。</p>
<h3 id="小结-16">小结</h3>
<p>数据库事务具有ACID特性，用来保证多条SQL的全部执行。</p>
<h2 id="Read-Uncommitted">Read Uncommitted</h2>
<p>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。</p>
<p>我们来看一个例子。</p>
<p>首先，我们准备好<code>students</code>表的数据，该表仅一行记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
<td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>5</td>
<td>ROLLBACK;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<p>当事务A执行完第3步时，它更新了<code>id=1</code>的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。</p>
<p>随后，事务A在第5步进行了回滚，事务B再次读取<code>id=1</code>的记录，发现和上一次读取到的数据不一致，这就是脏读。</p>
<p>可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。</p>
<h2 id="Read-Committed">Read Committed</h2>
<p>在Read Committed隔离级别下，一个事务不会读到另一个事务还没有提交的数据，但可能会遇到不可重复读（Non Repeatable Read）的问题。</p>
<p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p>
<p>我们仍然先准备好<code>students</code>表的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
<td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1; – Alice</td>
</tr>
<tr>
<td>4</td>
<td>UPDATE students SET name = ‘Bob’ WHERE id = 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id = 1; – Bob</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<p>当事务B第一次执行第3步的查询时，得到的结果是<code>Alice</code>，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了<code>Bob</code>，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。</p>
<h2 id="Repeatable-Read">Repeatable Read</h2>
<p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p>
<p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p>
<p>我们仍然先准备好<code>students</code>表的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
<td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>SELECT * FROM students WHERE id = 99; – empty</td>
</tr>
<tr>
<td>4</td>
<td>INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id = 99; – empty</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>UPDATE students SET name = ‘Alice’ WHERE id = 99; – 1 row affected</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>SELECT * FROM students WHERE id = 99; – Alice</td>
</tr>
<tr>
<td>9</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<p>事务B在第3步第一次读取<code>id=99</code>的记录时，读到的记录为空，说明不存在<code>id=99</code>的记录。随后，事务A在第4步插入了一条<code>id=99</code>的记录并提交。事务B在第6步再次读取<code>id=99</code>的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取<code>id=99</code>的记录时，记录出现了。</p>
<p>可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。</p>
<hr>
<hr>
<p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p>
<p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p>
<h3 id="默认隔离级别">默认隔离级别</h3>
<p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2015/10/12/database/mysql%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 頁 共 1 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 198 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
