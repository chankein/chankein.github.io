
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>分類: devops - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/categories/devops/page/3/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/15/docker/14.Docker%20Podman(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 14.Docker Podman(Docker详细教程)"
                        >
                            14.Docker Podman(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-15T16:02:39+08:00">
	
		    2018 年 4 月 15 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="podman"><a href="#podman">#</a> podman</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/containers/podman"><code>podman</code> (opens new window)</a> 是一个无守护程序与 docker 命令兼容的下一代 Linux 容器工具。</p>
<h2 id="安装"><a href="#%E5%AE%89%E8%A3%85">#</a> 安装</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> yum -y install podman</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#%E4%BD%BF%E7%94%A8">#</a> 使用</h2>
<p><code>podman</code> 与 docker 命令完全兼容，只需将 <code>docker</code> 替换为 <code>podman</code> 即可，例如运行一个容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $ docker run -d -p 80:80 nginx:alpine</span></span><br><span class="line"></span><br><span class="line">$ podman run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#%E5%8F%82%E8%80%83">#</a> 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/">https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/15/docker/14.Docker%20Podman(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/14/docker/13.Docker%20Buildx(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 13.Docker Buildx(Docker详细教程)"
                        >
                            13.Docker Buildx(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-14T16:02:39+08:00">
	
		    2018 年 4 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Docker-Buildx"><a href="#docker-buildx">#</a> Docker Buildx</h2>
<p>Docker Buildx 是一个 docker CLI 插件，其扩展了 docker 命令，支持 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/buildx/buildkit.html">Moby BuildKit</a> 提供的功能。提供了与 docker build 相同的用户体验，并增加了许多新功能。</p>
<blockquote>
<p>该功能仅适用于 Docker v19.03+ 版本</p>
</blockquote>
<h2 id="使用-BuildKit-构建镜像"><a href="#%E4%BD%BF%E7%94%A8-buildkit-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F">#</a> 使用 <code>BuildKit</code> 构建镜像</h2>
<p><strong>BuildKit</strong> 是下一代的镜像构建组件，在 <a target="_blank" rel="noopener" href="https://github.com/moby/buildkit">https://github.com/moby/buildkit</a> 开源。</p>
<p><strong>注意：如果您的镜像构建使用的是云服务商提供的镜像构建服务（腾讯云容器服务、阿里云容器服务等），由于上述服务提供商的 Docker 版本低于 18.09，BuildKit 无法使用，将造成镜像构建失败。建议使用 BuildKit 构建镜像时使用一个新的 Dockerfile 文件（例如 Dockerfile.buildkit）</strong></p>
<p>目前，Docker Hub 自动构建已经支持 buildkit，具体请参考 <a target="_blank" rel="noopener" href="https://github.com/docker-practice/docker-hub-buildx">https://github.com/docker-practice/docker-hub-buildx</a></p>
<h2 id="Dockerfile-新增指令详解"><a href="#dockerfile-%E6%96%B0%E5%A2%9E%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3">#</a> <code>Dockerfile</code> 新增指令详解</h2>
<p>启用 <code>BuildKit</code> 之后，我们可以使用下面几个新的 <code>Dockerfile</code> 指令来加快镜像构建。</p>
<h3 id="RUN-mount-type-cache"><a href="#run-mount-type-cache">#</a> <code>RUN --mount=type=cache</code></h3>
<p>目前，几乎所有的程序都会使用依赖管理工具，例如 <code>Go</code> 中的 <code>go mod</code>、<code>Node.js</code> 中的 <code>npm</code> 等等，当我们构建一个镜像时，往往会重复的从互联网中获取依赖包，难以缓存，大大降低了镜像的构建效率。</p>
<p>例如一个前端工程需要用到 <code>npm</code>：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /app/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm i --registry=https://registry.npm.taobao.org \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; <span class="built_in">rm</span> -rf ~/.npm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src /app/src</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/dist /app/dist</span></span><br></pre></td></tr></table></figure>
<p>使用多阶段构建，构建的镜像中只包含了目标文件夹 <code>dist</code>，但仍然存在一些问题，当 <code>package.json</code> 文件变动时，<code>RUN npm i &amp;&amp; rm -rf ~/.npm</code> 这一层会重新执行，变更多次后，生成了大量的中间层镜像。</p>
<p>为解决这个问题，进一步的我们可以设想一个类似 <strong>数据卷</strong> 的功能，在镜像构建时把 <code>node_modules</code> 文件夹挂载上去，在构建完成后，这个 <code>node_modules</code> 文件夹会自动卸载，实际的镜像中并不包含 <code>node_modules</code> 这个文件夹，这样我们就省去了每次获取依赖的时间，大大增加了镜像构建效率，同时也避免了生成了大量的中间层镜像。</p>
<p><code>BuildKit</code> 提供了 <code>RUN --mount=type=cache</code> 指令，可以实现上边的设想。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">FROM</span> node:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /app/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/app/node_modules,<span class="built_in">id</span>=my_app_npm_module,sharing=locked \</span></span><br><span class="line"><span class="language-bash">    --mount=<span class="built_in">type</span>=cache,target=/root/.npm,<span class="built_in">id</span>=npm_cache \</span></span><br><span class="line"><span class="language-bash">        npm i --registry=https://registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src /app/src</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/app/node_modules,<span class="built_in">id</span>=my_app_npm_module,sharing=locked \</span></span><br><span class="line"><span class="language-bash"><span class="comment"># --mount=type=cache,target=/app/dist,id=my_app_dist,sharing=locked \</span></span></span><br><span class="line"><span class="language-bash">        npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY --from=builder /app/dist /app/dist</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了更直观的说明 from 和 source 指令，这里使用 RUN 指令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/tmp/dist,from=builder,<span class="built_in">source</span>=/app/dist \</span></span><br><span class="line"><span class="language-bash">    <span class="comment"># --mount=type=cache,target/tmp/dist,from=my_app_dist,sharing=locked \</span></span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p /app/dist &amp;&amp; <span class="built_in">cp</span> -r /tmp/dist/* /app/dist</span></span><br></pre></td></tr></table></figure>
<p><strong>由于 <code>BuildKit</code> 为实验特性，每个 <code>Dockerfile</code> 文件开头都必须加上如下指令</strong></p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br></pre></td></tr></table></figure>
<p>第一个 <code>RUN</code> 指令执行后，<code>id</code> 为 <code>my_app_npm_module</code> 的缓存文件夹挂载到了 <code>/app/node_modules</code> 文件夹中。多次执行也不会产生多个中间层镜像。</p>
<p>第二个 <code>RUN</code> 指令执行时需要用到 <code>node_modules</code> 文件夹，<code>node_modules</code> 已经挂载，命令也可以正确执行。</p>
<p>第三个 <code>RUN</code> 指令将上一阶段产生的文件复制到指定位置，<code>from</code> 指明缓存的来源，这里 <code>builder</code> 表示缓存来源于构建的第一阶段，<code>source</code> 指明缓存来源的文件夹。</p>
<p>上面的 <code>Dockerfile</code> 中 <code>--mount=type=cache,...</code> 中指令作用如下：</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td><code>id</code> 设置一个标志，以便区分缓存。</td>
</tr>
<tr>
<td><code>target</code> (必填项)</td>
<td>缓存的挂载目标文件夹。</td>
</tr>
<tr>
<td><code>ro</code>,<code>readonly</code></td>
<td>只读，缓存文件夹不能被写入。</td>
</tr>
<tr>
<td><code>sharing</code></td>
<td>有 <code>shared</code> <code>private</code> <code>locked</code> 值可供选择。<code>sharing</code> 设置当一个缓存被多次使用时的表现，由于 <code>BuildKit</code> 支持并行构建，当多个步骤使用同一缓存时（同一 <code>id</code>）会发生冲突。<code>shared</code> 表示多个步骤可以同时读写，<code>private</code> 表示当多个步骤使用同一缓存时，每个步骤使用不同的缓存，<code>locked</code> 表示当一个步骤完成释放缓存后，后一个步骤才能继续使用该缓存。</td>
</tr>
<tr>
<td><code>from</code></td>
<td>缓存来源（构建阶段），不填写时为空文件夹。</td>
</tr>
<tr>
<td><code>source</code></td>
<td>来源的文件夹路径。</td>
</tr>
</tbody>
</table>
<h3 id="RUN-mount-type-bind"><a href="#run-mount-type-bind">#</a> <code>RUN --mount=type=bind</code></h3>
<p>该指令可以将一个镜像（或上一构建阶段）的文件挂载到指定位置。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=<span class="built_in">bind</span>,from=php:alpine,<span class="built_in">source</span>=/usr/local/bin/docker-php-entrypoint,target=/docker-php-entrypoint \</span></span><br><span class="line"><span class="language-bash">        <span class="built_in">cat</span> /docker-php-entrypoint</span></span><br></pre></td></tr></table></figure>
<h3 id="RUN-mount-type-tmpfs"><a href="#run-mount-type-tmpfs">#</a> <code>RUN --mount=type=tmpfs</code></h3>
<p>该指令可以将一个 <code>tmpfs</code> 文件系统挂载到指定位置。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=tmpfs,target=/temp \</span></span><br><span class="line"><span class="language-bash">        mount | grep /temp</span></span><br></pre></td></tr></table></figure>
<h3 id="RUN-mount-type-secret"><a href="#run-mount-type-secret">#</a> <code>RUN --mount=type=secret</code></h3>
<p>该指令可以将一个文件(例如密钥)挂载到指定位置。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=secret,<span class="built_in">id</span>=aws,target=/root/.aws/credentials \</span></span><br><span class="line"><span class="language-bash">        <span class="built_in">cat</span> /root/.aws/credentials</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t <span class="built_in">test</span> --secret <span class="built_in">id</span>=aws,src=<span class="variable">$HOME</span>/.aws/credentials .</span><br></pre></td></tr></table></figure>
<h3 id="RUN-mount-type-ssh"><a href="#run-mount-type-ssh">#</a> <code>RUN --mount=type=ssh</code></h3>
<p>该指令可以挂载 <code>ssh</code> 密钥。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:experimental</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache openssh-client</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p -m 0700 ~/.ssh &amp;&amp; ssh-keyscan gitlab.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=ssh ssh git@gitlab.com | <span class="built_in">tee</span> /hello</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> $(ssh-agent)</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br><span class="line">(Input your passphrase here)</span><br><span class="line">$ docker build -t <span class="built_in">test</span> --ssh default=<span class="variable">$SSH_AUTH_SOCK</span> .</span><br></pre></td></tr></table></figure>
<h2 id="官方文档"><a href="#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3">#</a> 官方文档</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md">https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md</a></li>
</ul>
<h2 id="使用-Buildx-构建镜像"><a href="#%E4%BD%BF%E7%94%A8-buildx-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F">#</a> 使用 Buildx 构建镜像</h2>
<h2 id="使用"><a href="#%E4%BD%BF%E7%94%A8">#</a> 使用</h2>
<p>你可以直接使用 <code>docker buildx build</code> 命令构建镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx build .</span><br><span class="line">[+] Building 8.4s (23/32)</span><br><span class="line"> =&gt; ...</span><br></pre></td></tr></table></figure>
<p>Buildx 使用 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/buildx/buildkit.html">BuildKit 引擎</a> 进行构建，支持许多新的功能，具体参考 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/buildx/buildkit.html">Buildkit</a> 一节。</p>
<h2 id="官方文档-2"><a href="#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3">#</a> 官方文档</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/buildx/">https://docs.docker.com/engine/reference/commandline/buildx/</a></li>
</ul>
<h2 id="使用-buildx-构建多种系统架构支持的-Docker-镜像"><a href="#%E4%BD%BF%E7%94%A8-buildx-%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81%E7%9A%84-docker-%E9%95%9C%E5%83%8F">#</a> 使用 buildx 构建多种系统架构支持的 Docker 镜像</h2>
<p>在之前的版本中构建多种系统架构支持的 Docker 镜像，要想使用统一的名字必须使用 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/image/manifest.html"><code>$ docker manifest</code></a> 命令。</p>
<p>在 Docker 19.03+ 版本中可以使用 <code>$ docker buildx build</code> 命令使用 <code>BuildKit</code> 构建镜像。该命令支持 <code>--platform</code> 参数可以同时构建支持多种系统架构的 Docker 镜像，大大简化了构建步骤。</p>
<h2 id="新建-builder-实例"><a href="#%E6%96%B0%E5%BB%BA-builder-%E5%AE%9E%E4%BE%8B">#</a> 新建 <code>builder</code> 实例</h2>
<p>Docker for Linux 不支持构建 <code>arm</code> 架构镜像，我们可以运行一个新的容器让其支持该特性，Docker 桌面版无需进行此项设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> --privileged tonistiigi/binfmt:latest --install all</span><br></pre></td></tr></table></figure>
<p>由于 Docker 默认的 <code>builder</code> 实例不支持同时指定多个 <code>--platform</code>，我们必须首先创建一个新的 <code>builder</code> 实例。同时由于国内拉取镜像较缓慢，我们可以使用配置了 <a target="_blank" rel="noopener" href="https://github.com/moby/buildkit/blob/master/docs/buildkitd.toml.md">镜像加速地址 (opens new window)</a> 的 <a target="_blank" rel="noopener" href="https://github.com/docker-practice/buildx"><code>dockerpracticesig/buildkit:master</code> (opens new window)</a> 镜像替换官方镜像。</p>
<blockquote>
<p>如果你有私有的镜像加速器，可以基于 <a target="_blank" rel="noopener" href="https://github.com/docker-practice/buildx">https://github.com/docker-practice/buildx</a> 构建自己的 buildkit 镜像并使用它。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适用于国内环境</span></span><br><span class="line">$ docker buildx create --use --name=mybuilder-cn --driver docker-container --driver-opt image=dockerpracticesig/buildkit:master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 适用于腾讯云环境(腾讯云主机、coding.net 持续集成)</span></span><br><span class="line">$ docker buildx create --use --name=mybuilder-cn --driver docker-container --driver-opt image=dockerpracticesig/buildkit:master-tencent</span><br><span class="line"></span><br><span class="line"><span class="comment"># $ docker buildx create --name mybuilder --driver docker-container</span></span><br><span class="line"></span><br><span class="line">$ docker buildx use mybuilder</span><br></pre></td></tr></table></figure>
<h2 id="构建镜像"><a href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F">#</a> 构建镜像</h2>
<p>新建 Dockerfile 文件。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> --platform=$TARGETPLATFORM alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">uname</span> -a &gt; /os.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">cat</span> /os.txt</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>$ docker buildx build</code> 命令构建镜像，注意将 <code>myusername</code> 替换为自己的 Docker Hub 用户名。</p>
<p><code>--push</code> 参数表示将构建好的镜像推送到 Docker 仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker buildx build --platform linux/arm,linux/arm64,linux/amd64 -t myusername/hello . --push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像信息</span></span><br><span class="line">$ docker buildx imagetools inspect myusername/hello</span><br></pre></td></tr></table></figure>
<p>在不同架构运行该镜像，可以得到该架构的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arm</span></span><br><span class="line">$ docker run -it --<span class="built_in">rm</span> myusername/hello</span><br><span class="line">Linux buildkitsandbox 4.9.125-linuxkit <span class="comment">#1 SMP Fri Sep 7 08:20:28 UTC 2018 armv7l Linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arm64</span></span><br><span class="line">$ docker run -it --<span class="built_in">rm</span> myusername/hello</span><br><span class="line">Linux buildkitsandbox 4.9.125-linuxkit <span class="comment">#1 SMP Fri Sep 7 08:20:28 UTC 2018 aarch64 Linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># amd64</span></span><br><span class="line">$ docker run -it --<span class="built_in">rm</span> myusername/hello</span><br><span class="line">Linux buildkitsandbox 4.9.125-linuxkit <span class="comment">#1 SMP Fri Sep 7 08:20:28 UTC 2018 x86_64 Linux</span></span><br></pre></td></tr></table></figure>
<h2 id="架构相关变量"><a href="#%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E5%8F%98%E9%87%8F">#</a> 架构相关变量</h2>
<p><code>Dockerfile</code> 支持如下架构相关的变量</p>
<p><strong>TARGETPLATFORM</strong></p>
<p>构建镜像的目标平台，例如 <code>linux/amd64</code>, <code>linux/arm/v7</code>, <code>windows/amd64</code>。</p>
<p><strong>TARGETOS</strong></p>
<p><code>TARGETPLATFORM</code> 的 OS 类型，例如 <code>linux</code>, <code>windows</code></p>
<p><strong>TARGETARCH</strong></p>
<p><code>TARGETPLATFORM</code> 的架构类型，例如 <code>amd64</code>, <code>arm</code></p>
<p><strong>TARGETVARIANT</strong></p>
<p><code>TARGETPLATFORM</code> 的变种，该变量可能为空，例如 <code>v7</code></p>
<p><strong>BUILDPLATFORM</strong></p>
<p>构建镜像主机平台，例如 <code>linux/amd64</code></p>
<p><strong>BUILDOS</strong></p>
<p><code>BUILDPLATFORM</code> 的 OS 类型，例如 <code>linux</code></p>
<p><strong>BUILDARCH</strong></p>
<p><code>BUILDPLATFORM</code> 的架构类型，例如 <code>amd64</code></p>
<p><strong>BUILDVARIANT</strong></p>
<p><code>BUILDPLATFORM</code> 的变种，该变量可能为空，例如 <code>v7</code></p>
<h3 id="使用举例"><a href="#%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B">#</a> 使用举例</h3>
<p>例如我们要构建支持 <code>linux/arm/v7</code> 和 <code>linux/amd64</code> 两种架构的镜像。假设已经生成了两个平台对应的二进制文件：</p>
<ul>
<li><code>bin/dist-linux-arm</code></li>
<li><code>bin/dist-linux-amd64</code></li>
</ul>
<p>那么 <code>Dockerfile</code> 可以这样书写：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用变量必须申明</span></span><br><span class="line"><span class="keyword">ARG</span> TARGETOS</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> TARGETARCH</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> bin/dist-<span class="variable">$&#123;TARGETOS&#125;</span>-<span class="variable">$&#123;TARGETARCH&#125;</span> /dist</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;dist&quot;</span>]</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/14/docker/13.Docker%20Buildx(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/13/docker/12.Docker%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 12.Docker 底层实现(Docker详细教程)"
                        >
                            12.Docker 底层实现(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-13T16:02:39+08:00">
	
		    2018 年 4 月 13 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="底层实现"><a href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">#</a> 底层实现</h2>
<p>Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p>
<p>我们知道，传统的虚拟机通过在宿主主机中运行 hypervisor 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔离的。 这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资源的浪费。 例如，以宿主机和虚拟机系统都为 Linux 系统为例，虚拟机中运行的应用其实可以利用宿主机系统中的运行环境。</p>
<p>我们知道，在操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU 等等，所有的资源都是应用进程直接共享的。 要想实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等等的相互隔离。 前者相对容易实现一些，后者则需要宿主机系统的深入支持。</p>
<p>随着 Linux 系统对于命名空间功能的完善实现，程序员已经可以实现上面的所有需求，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有自己的存在。这种机制就是容器（Container），利用命名空间来做权限的隔离控制，利用 cgroups 来做资源分配。</p>
<h2 id="基本架构"><a href="#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84">#</a> 基本架构</h2>
<p>Docker 采用了 <code>C/S</code> 架构，包括客户端和服务端。Docker 守护进程 （<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p>
<p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p>
<p><img src="https://vuepress.mirror.docker-practice.com/assets/img/docker_arch.d61c12da.png" alt="Docker 基本架构"></p>
<p>Docker 守护进程一般在宿主主机后台运行，等待接收来自客户端的消息。</p>
<p>Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。</p>
<h2 id="命名空间"><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a> 命名空间</h2>
<p>命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p>
<h2 id="pid-命名空间"><a href="#pid-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a> pid 命名空间</h2>
<p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为 Docker 进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p>
<h2 id="net-命名空间"><a href="#net-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a> net 命名空间</h2>
<p>有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p>
<h2 id="ipc-命名空间"><a href="#ipc-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a> ipc 命名空间</h2>
<p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p>
<h2 id="mnt-命名空间"><a href="#mnt-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a> mnt 命名空间</h2>
<p>类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。</p>
<h2 id="uts-命名空间"><a href="#uts-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a> uts 命名空间</h2>
<p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p>
<h2 id="user-命名空间"><a href="#user-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a> user 命名空间</h2>
<p>每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p>
<p>*注：更多关于 Linux 上命名空间的信息，请阅读 <a target="_blank" rel="noopener" href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">这篇文章 (opens new window)</a>。</p>
<h2 id="控制组"><a href="#%E6%8E%A7%E5%88%B6%E7%BB%84">#</a> 控制组</h2>
<p>控制组（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cgroups">cgroups (opens new window)</a>）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<p>控制组技术最早是由 Google 的程序员在 2006 年提出，Linux 内核自 2.6.24 开始支持。</p>
<p>控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p>
<h2 id="联合文件系统"><a href="#%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">#</a> 联合文件系统</h2>
<p>联合文件系统（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UnionFS">UnionFS (opens new window)</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p>
<p>各 Linux 发行版 Docker 推荐使用的存储驱动如下表。</p>
<table>
<thead>
<tr>
<th>Linux 发行版</th>
<th>Docker 推荐使用的存储驱动</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker on Ubuntu</td>
<td><code>overlay2</code> (16.04 +)</td>
</tr>
<tr>
<td>Docker on Debian</td>
<td><code>overlay2</code> (Debian Stretch), <code>aufs</code>, <code>devicemapper</code></td>
</tr>
<tr>
<td>Docker on CentOS</td>
<td><code>overlay2</code></td>
</tr>
<tr>
<td>Docker on Fedora</td>
<td><code>overlay2</code></td>
</tr>
</tbody>
</table>
<p>在可能的情况下，<a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">推荐 (opens new window)</a> 使用 <code>overlay2</code> 存储驱动，<code>overlay2</code> 是目前 Docker 默认的存储驱动，以前则是 <code>aufs</code>。你可以通过配置来使用以上提到的其他类型的存储驱动。</p>
<h2 id="容器格式"><a href="#%E5%AE%B9%E5%99%A8%E6%A0%BC%E5%BC%8F">#</a> 容器格式</h2>
<p>最初，Docker 采用了 <code>LXC</code> 中的容器格式。从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a target="_blank" rel="noopener" href="https://github.com/docker/libcontainer">libcontainer (opens new window)</a>，从 1.11 开始，则进一步演进为使用 <a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc">runC (opens new window)</a> 和 <a target="_blank" rel="noopener" href="https://github.com/containerd/containerd">containerd (opens new window)</a>。</p>
<h2 id="Docker-网络实现"><a href="#docker-%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0">#</a> Docker 网络实现</h2>
<p>Docker 的网络实现其实就是利用了 Linux 上的网络命名空间和虚拟网络设备（特别是 veth pair）。建议先熟悉了解这两部分的基本概念再阅读本章。</p>
<h2 id="基本原理"><a href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">#</a> 基本原理</h2>
<p>首先，要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包；此外，如果不同子网之间要进行通信，需要路由机制。</p>
<p>Docker 中的网络接口默认都是虚拟的接口。虚拟接口的优势之一是转发效率较高。 Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对于本地系统和容器内系统看来就像是一个正常的以太网卡，只是它不需要真正同外部网络设备通信，速度要快很多。</p>
<p>Docker 容器网络就利用了这项技术。它在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通（这样的一对接口叫做 <code>veth pair</code>）。</p>
<h2 id="创建网络参数"><a href="#%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0">#</a> 创建网络参数</h2>
<p>Docker 创建一个容器的时候，会执行如下操作：</p>
<ul>
<li>创建一对虚拟接口，分别放到本地主机和新容器中；</li>
<li>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</li>
<li>容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</li>
</ul>
<p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。</p>
<p>可以在 <code>docker run</code> 的时候通过 <code>--net</code> 参数来指定容器的网络配置，有4个可选值：</p>
<ul>
<li><code>--net=bridge</code> 这个是默认值，连接到默认的网桥。</li>
<li><code>--net=host</code> 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步的使用 <code>--privileged=true</code>，容器会被允许直接配置主机的网络堆栈。</li>
<li><code>--net=container:NAME_or_ID</code> 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 <code>lo</code> 环回接口通信。</li>
<li><code>--net=none</code> 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</li>
</ul>
<h2 id="网络配置细节"><a href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%BB%86%E8%8A%82">#</a> 网络配置细节</h2>
<p>用户使用 <code>--net=none</code> 后，可以自行配置网络，让容器达到跟平常一样具有访问网络的权限。通过这个过程，可以了解 Docker 配置网络的细节。</p>
<p>首先，启动一个 <code>/bin/bash</code> 容器，指定 <code>--net=none</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --<span class="built_in">rm</span> --net=none base /bin/bash</span><br><span class="line">root@63f36fc01b5f:/#</span><br></pre></td></tr></table></figure>
<p>在本地主机查找容器的进程 id，并为它创建网络命名空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 63f36fc01b5f</span><br><span class="line">2778</span><br><span class="line">$ pid=2778</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">ln</span> -s /proc/<span class="variable">$pid</span>/ns/net /var/run/netns/<span class="variable">$pid</span></span><br></pre></td></tr></table></figure>
<p>检查桥接网卡的 IP 和子网掩码信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show docker0</span><br><span class="line">21: docker0: ...</span><br><span class="line">inet 172.17.42.1/16 scope global docker0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>创建一对 “veth pair” 接口 A 和 B，绑定 A 到网桥 <code>docker0</code>，并启用它</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line">$ <span class="built_in">sudo</span> brctl addif docker0 A</span><br><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br></pre></td></tr></table></figure>
<p>将B放到容器的网络命名空间，命名为 eth0，启动它并配置一个可用 IP（桥接网段）和默认网关。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> B netns <span class="variable">$pid</span></span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev B name eth0</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip addr add 172.17.42.99/16 dev eth0</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip route add default via 172.17.42.1</span><br></pre></td></tr></table></figure>
<p>以上，就是 Docker 配置网络的具体过程。</p>
<p>当容器结束后，Docker 会清空容器，容器内的 eth0 会随网络命名空间一起被清除，A 接口也被自动从 <code>docker0</code> 卸载。</p>
<p>此外，用户可以使用 <code>ip netns exec</code> 命令来在指定网络命名空间中进行配置，从而配置容器内的网络。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/13/docker/12.Docker%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/12/docker/11.Docker%20%E5%AE%89%E5%85%A8(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 11.Docker 安全(Docker详细教程)"
                        >
                            11.Docker 安全(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-12T16:02:39+08:00">
	
		    2018 年 4 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="安全"><a href="#%E5%AE%89%E5%85%A8">#</a> 安全</h2>
<p>评估 Docker 的安全性时，主要考虑三个方面:</p>
<ul>
<li>由内核的命名空间和控制组机制提供的容器内在安全</li>
<li>Docker 程序（特别是服务端）本身的抗攻击性</li>
<li>内核安全性的加强机制对容器安全性的影响</li>
</ul>
<h2 id="内核命名空间"><a href="#%E5%86%85%E6%A0%B8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a> 内核命名空间</h2>
<p>Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。当用 <code>docker run</code> 启动一个容器时，在后台 Docker 为容器创建了一个独立的命名空间和控制组集合。</p>
<p>命名空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其它容器发现和作用。</p>
<p>每个容器都有自己独有的网络栈，意味着它们不能访问其他容器的 sockets 或接口。不过，如果主机系统上做了相应的设置，容器可以像跟主机交互一样的和其他容器交互。当指定公共端口或使用 links 来连接 2 个容器时，容器就可以相互通信了（可以根据配置来限制通信的策略）。</p>
<p>从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理机器通过物理交换机通信一样。</p>
<p>那么，内核中实现命名空间和私有网络的代码是否足够成熟？</p>
<p>内核命名空间从 2.6.15 版本（2008 年 7 月发布）之后被引入，数年间，这些机制的可靠性在诸多大型生产系统中被实践验证。</p>
<p>实际上，命名空间的想法和设计提出的时间要更早，最初是为了在内核中引入一种机制来实现 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OpenVZ">OpenVZ (opens new window)</a> 的特性。 而 OpenVZ 项目早在 2005 年就发布了，其设计和实现都已经十分成熟。</p>
<h2 id="控制组"><a href="#%E6%8E%A7%E5%88%B6%E7%BB%84">#</a> 控制组</h2>
<p>控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。</p>
<p>它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、CPU、磁盘 IO 等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p>
<p>尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务（DDOS）攻击方面是必不可少的。尤其是在多用户的平台（比如公有或私有的 PaaS）上，控制组十分重要。例如，当某些应用程序表现异常的时候，可以保证一致地正常运行和性能。</p>
<p>控制组机制始于 2006 年，内核从 2.6.24 版本开始被引入。</p>
<h2 id="Docker服务端的防护"><a href="#docker%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E9%98%B2%E6%8A%A4">#</a> Docker服务端的防护</h2>
<p>运行一个容器或应用程序的核心是通过 Docker 服务端。Docker 服务的运行目前需要 root 权限，因此其安全性十分关键。</p>
<p>首先，确保只有可信的用户才可以访问 Docker 服务。Docker 允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限制。例如，恶意用户启动容器的时候将主机的根目录<code>/</code>映射到容器的 <code>/host</code> 目录中，那么容器理论上就可以对主机的文件系统进行任意修改了。这听起来很疯狂？但是事实上几乎所有虚拟化系统都允许类似的资源共享，而没法禁止用户共享主机根文件系统到虚拟机系统。</p>
<p>这将会造成很严重的安全后果。因此，当提供容器创建服务时（例如通过一个 web 服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一些破坏性的容器。</p>
<p>为了加强对服务端的保护，Docker 的 REST API（客户端用来跟服务端通信）在 0.5.2 之后使用本地的 Unix 套接字机制替代了原先绑定在 127.0.0.1 上的 TCP 套接字，因为后者容易遭受跨站脚本攻击。现在用户使用 Unix 权限检查来加强套接字的访问安全。</p>
<p>用户仍可以利用 HTTP 提供 REST API 访问。建议使用安全机制，确保只有可信的网络或 VPN，或证书保护机制（例如受保护的 stunnel 和 ssl 认证）下的访问可以进行。此外，还可以使用 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/https/">HTTPS 和证书 (opens new window)</a> 来加强保护。</p>
<p>最近改进的 Linux 命名空间机制将可以实现使用非 root 用户来运行全功能的容器。这将从根本上解决了容器和主机之间共享文件系统而引起的安全问题。</p>
<p>终极目标是改进 2 个重要的安全特性：</p>
<ul>
<li>将容器的 root 用户 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/userns-remap/">映射到本地主机上的非 root 用户 (opens new window)</a>，减轻容器和主机之间因权限提升而引起的安全问题；</li>
<li>允许 Docker 服务端在 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/rootless/">非 root 权限(rootless 模式) (opens new window)</a> 下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</li>
</ul>
<p>最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容器中去运行。</p>
<h2 id="内核能力机制"><a href="#%E5%86%85%E6%A0%B8%E8%83%BD%E5%8A%9B%E6%9C%BA%E5%88%B6">#</a> 内核能力机制</h2>
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/capabilities.7.html">能力机制（Capability） (opens new window)</a> 是 Linux 内核一个强大的特性，可以提供细粒度的权限访问控制。 Linux 内核自 2.2 版本起就支持能力机制，它将权限划分为更加细粒度的操作能力，既可以作用在进程上，也可以作用在文件上。</p>
<p>例如，一个 Web 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 root 权限。那么它只需要被授权 <code>net_bind_service</code> 能力即可。此外，还有很多其他的类似能力来避免进程获取 root 权限。</p>
<p>默认情况下，Docker 启动的容器被严格限制只允许使用内核的一部分能力。</p>
<p>使用能力机制对加强 Docker 容器的安全有很多好处。通常，在服务器上会运行一堆需要特权权限的进程，包括有 ssh、cron、syslogd、硬件管理工具模块（例如负载模块）、网络配置工具等等。容器跟这些进程是不同的，因为几乎所有的特权进程都由容器以外的支持系统来进行管理。</p>
<ul>
<li>ssh 访问被主机上ssh服务来管理；</li>
<li>cron 通常应该作为用户进程执行，权限交给使用它服务的应用来处理；</li>
<li>日志系统可由 Docker 或第三方服务管理；</li>
<li>硬件管理无关紧要，容器中也就无需执行 udevd 以及类似服务；</li>
<li>网络管理也都在主机上设置，除非特殊需求，容器不需要对网络进行配置。</li>
</ul>
<p>从上面的例子可以看出，大部分情况下，容器并不需要“真正的” root 权限，容器只需要少数的能力即可。为了加强安全，容器可以禁用一些没必要的权限。</p>
<ul>
<li>完全禁止任何 mount 操作；</li>
<li>禁止直接访问本地主机的套接字；</li>
<li>禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；</li>
<li>禁止模块加载。</li>
</ul>
<p>这样，就算攻击者在容器中取得了 root 权限，也不能获得本地主机的较高权限，能进行的破坏也有限。</p>
<p>默认情况下，Docker采用 <a target="_blank" rel="noopener" href="https://github.com/moby/moby/blob/master/oci/caps/defaults.go">白名单 (opens new window)</a> 机制，禁用必需功能之外的其它权限。 当然，用户也可以根据自身需求来为 Docker 容器启用额外的权限。</p>
<h2 id="其它安全特性"><a href="#%E5%85%B6%E5%AE%83%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7">#</a> 其它安全特性</h2>
<p>除了能力机制之外，还可以利用一些现有的安全机制来增强使用 Docker 的安全性，例如 TOMOYO, AppArmor, Seccomp, SELinux, GRSEC 等。</p>
<p>Docker 当前默认只启用了能力机制。用户可以采用多种方案来加强 Docker 主机的安全，例如：</p>
<ul>
<li>在内核中启用 GRSEC 和 PAX，这将增加很多编译和运行时的安全检查；通过地址随机化避免恶意探测等。并且，启用该特性不需要 Docker 进行任何配置。</li>
<li>使用一些有增强安全特性的容器模板，比如带 AppArmor 的模板和 Redhat 带 SELinux 策略的模板。这些模板提供了额外的安全特性。</li>
<li>用户可以自定义访问控制机制来定制安全策略。</li>
</ul>
<p>跟其它添加到 Docker 容器的第三方工具一样（比如网络拓扑和文件系统共享），有很多类似的机制，在不改变 Docker 内核情况下就可以加固现有的容器。</p>
<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h2>
<p>总体来看，Docker 容器还是十分安全的，特别是在容器内不使用 root 权限来运行进程的话。</p>
<p>另外，用户可以使用现有工具，比如 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/apparmor/">Apparmor (opens new window)</a>, <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/seccomp/">Seccomp (opens new window)</a>, SELinux, GRSEC 来增强安全性；甚至自己在内核中实现更复杂的安全机制。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/12/docker/11.Docker%20%E5%AE%89%E5%85%A8(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/11/docker/10.Docker%20Swarm%20mode(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 10.Docker Swarm mode(Docker详细教程)"
                        >
                            10.Docker Swarm mode(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-11T16:02:39+08:00">
	
		    2018 年 4 月 11 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Swarm-mode"><a href="#swarm-mode">#</a> Swarm mode</h2>
<p>Docker 1.12 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/swarm/">Swarm mode (opens new window)</a> 已经内嵌入 Docker 引擎，成为了 docker 子命令 <code>docker swarm</code>。请注意与旧的 <code>Docker Swarm</code> 区分开来。</p>
<p><code>Swarm mode</code> 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。使得 Docker 原生的 <code>Swarm</code> 集群具备与 Mesos、Kubernetes 竞争的实力。</p>
<h2 id="基本概念"><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">#</a> 基本概念</h2>
<p><code>Swarm</code> 是使用 <a target="_blank" rel="noopener" href="https://github.com/docker/swarmkit/"><code>SwarmKit</code> (opens new window)</a> 构建的 Docker 引擎内置（原生）的集群管理和编排工具。</p>
<p>使用 <code>Swarm</code> 集群之前需要了解以下几个概念。</p>
<h2 id="节点"><a href="#%E8%8A%82%E7%82%B9">#</a> 节点</h2>
<p>运行 Docker 的主机可以主动初始化一个 <code>Swarm</code> 集群或者加入一个已存在的 <code>Swarm</code> 集群，这样这个运行 Docker 的主机就成为一个 <code>Swarm</code> 集群的节点 (<code>node</code>) 。</p>
<p>节点分为管理 (<code>manager</code>) 节点和工作 (<code>worker</code>) 节点。</p>
<p>管理节点用于 <code>Swarm</code> 集群的管理，<code>docker swarm</code> 命令基本只能在管理节点执行（节点退出集群命令 <code>docker swarm leave</code> 可以在工作节点执行）。一个 <code>Swarm</code> 集群可以有多个管理节点，但只有一个管理节点可以成为 <code>leader</code>，<code>leader</code> 通过 <code>raft</code> 协议实现。</p>
<p>工作节点是任务执行节点，管理节点将服务 (<code>service</code>) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。</p>
<p>来自 Docker 官网的这张图片形象的展示了集群中管理节点与工作节点的关系。</p>
<p><img src="https://docs.docker.com/engine/swarm/images/swarm-diagram.png" alt=""></p>
<h2 id="服务和任务"><a href="#%E6%9C%8D%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1">#</a> 服务和任务</h2>
<p>任务 （<code>Task</code>）是 <code>Swarm</code> 中的最小的调度单位，目前来说就是一个单一的容器。</p>
<p>服务 （<code>Services</code>） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p>
<ul>
<li>
<p><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务。</p>
</li>
<li>
<p><code>global services</code> 每个工作节点上运行一个任务</p>
</li>
</ul>
<p>两种模式通过 <code>docker service create</code> 的 <code>--mode</code> 参数指定。</p>
<p>来自 Docker 官网的这张图片形象的展示了容器、任务、服务的关系。</p>
<p><img src="https://docs.docker.com/engine/swarm/images/services-diagram.png" alt=""></p>
<h2 id="创建-Swarm-集群"><a href="#%E5%88%9B%E5%BB%BA-swarm-%E9%9B%86%E7%BE%A4">#</a> 创建 Swarm 集群</h2>
<p>阅读 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/swarm_mode/overview.html">基本概念</a> 一节我们知道 <code>Swarm</code> 集群由 <strong>管理节点</strong> 和 <strong>工作节点</strong> 组成。本节我们来创建一个包含一个管理节点和两个工作节点的最小 <code>Swarm</code> 集群。</p>
<h2 id="初始化集群"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%86%E7%BE%A4">#</a> 初始化集群</h2>
<p>在已经安装好 Docker 的主机上执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --advertise-addr 192.168.99.100</span><br><span class="line">Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm <span class="built_in">join</span> \</span><br><span class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run <span class="string">&#x27;docker swarm join-token manager&#x27;</span> and follow the instructions.</span><br></pre></td></tr></table></figure>
<p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 <code>--advertise-addr</code> 指定 IP。</p>
<blockquote>
<p>执行 <code>docker swarm init</code> 命令的节点自动成为管理节点。</p>
</blockquote>
<h2 id="增加工作节点"><a href="#%E5%A2%9E%E5%8A%A0%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9">#</a> 增加工作节点</h2>
<p>上一步我们初始化了一个 <code>Swarm</code> 集群，拥有了一个管理节点，下面我们继续在两个 Docker 主机中分别执行如下命令，创建工作节点并加入到集群中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm <span class="built_in">join</span> \</span><br><span class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>
<h2 id="查看集群"><a href="#%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4">#</a> 查看集群</h2>
<p>经过上边的两步，我们已经拥有了一个最小的 <code>Swarm</code> 集群，包含一个管理节点和两个工作节点。</p>
<p>在管理节点使用 <code>docker node ls</code> 查看集群。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker node <span class="built_in">ls</span></span><br><span class="line">ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">03g1y59jwfg7cf99w4lt0f662    worker2   Ready   Active</span><br><span class="line">9j68exjopxe7wfl6yuxml7a7j    worker1   Ready   Active</span><br><span class="line">dxn1zf6l61qsb1josjja83ngz *  manager   Ready   Active        Leader</span><br></pre></td></tr></table></figure>
<h2 id="部署服务"><a href="#%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1">#</a> 部署服务</h2>
<p>我们使用 <code>docker service</code> 命令来管理 <code>Swarm</code> 集群中的服务，该命令只能在管理节点运行。</p>
<h2 id="新建服务"><a href="#%E6%96%B0%E5%BB%BA%E6%9C%8D%E5%8A%A1">#</a> 新建服务</h2>
<p>现在我们在上一节创建的 <code>Swarm</code> 集群中运行一个名为 <code>nginx</code> 服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</span><br></pre></td></tr></table></figure>
<p>现在我们使用浏览器，输入任意节点 IP ，即可看到 nginx 默认页面。</p>
<h2 id="查看服务"><a href="#%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1">#</a> 查看服务</h2>
<p>使用 <code>docker service ls</code> 来查看当前 <code>Swarm</code> 集群运行的服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker service <span class="built_in">ls</span></span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                 PORTS</span><br><span class="line">kc57xffvhul5        nginx               replicated          3/3                 nginx:1.13.7-alpine   *:80-&gt;80/tcp</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker service ps</code> 来查看某个服务的详情。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps nginx</span><br><span class="line">ID                  NAME                IMAGE                 NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">pjfzd39buzlt        nginx.1             nginx:1.13.7-alpine   swarm2              Running             Running about a minute ago</span><br><span class="line">hy9eeivdxlaa        nginx.2             nginx:1.13.7-alpine   swarm1              Running             Running about a minute ago</span><br><span class="line">36wmpiv7gmfo        nginx.3             nginx:1.13.7-alpine   swarm3              Running             Running about a minute ago</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker service logs</code> 来查看某个服务的日志。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker service logs nginx</span><br><span class="line">nginx.3.36wmpiv7gmfo@swarm3    | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">nginx.3.36wmpiv7gmfo@swarm3    | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] <span class="string">&quot;GET /favicon.ico HTTP/1.1&quot;</span> 404 169 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">nginx.3.36wmpiv7gmfo@swarm3    | 2017/11/25 02:10:30 [error] 5#5: *1 open() <span class="string">&quot;/usr/share/nginx/html/favicon.ico&quot;</span> failed (2: No such file or directory), client: 10.255.0.4, server: localhost, request: <span class="string">&quot;GET /favicon.ico HTTP/1.1&quot;</span>, host: <span class="string">&quot;192.168.99.102&quot;</span></span><br><span class="line">nginx.1.pjfzd39buzlt@swarm2    | 10.255.0.2 - - [25/Nov/2017:02:10:26 +0000] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">nginx.1.pjfzd39buzlt@swarm2    | 10.255.0.2 - - [25/Nov/2017:02:10:27 +0000] <span class="string">&quot;GET /favicon.ico HTTP/1.1&quot;</span> 404 169 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">nginx.1.pjfzd39buzlt@swarm2    | 2017/11/25 02:10:27 [error] 5#5: *1 open() <span class="string">&quot;/usr/share/nginx/html/favicon.ico&quot;</span> failed (2: No such file or directory), client: 10.255.0.2, server: localhost, request: <span class="string">&quot;GET /favicon.ico HTTP/1.1&quot;</span>, host: <span class="string">&quot;192.168.99.101&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="服务伸缩"><a href="#%E6%9C%8D%E5%8A%A1%E4%BC%B8%E7%BC%A9">#</a> 服务伸缩</h2>
<p>我们可以使用 <code>docker service scale</code> 对一个服务运行的容器数量进行伸缩。</p>
<p>当业务处于高峰期时，我们需要扩展服务运行的容器数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service scale nginx=5</span><br></pre></td></tr></table></figure>
<p>当业务平稳时，我们需要减少服务运行的容器数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service scale nginx=2</span><br></pre></td></tr></table></figure>
<h2 id="删除服务"><a href="#%E5%88%A0%E9%99%A4%E6%9C%8D%E5%8A%A1">#</a> 删除服务</h2>
<p>使用 <code>docker service rm</code> 来从 <code>Swarm</code> 集群移除某个服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service <span class="built_in">rm</span> nginx</span><br></pre></td></tr></table></figure>
<h2 id="在-Swarm-集群中使用-compose-文件"><a href="#%E5%9C%A8-swarm-%E9%9B%86%E7%BE%A4%E4%B8%AD%E4%BD%BF%E7%94%A8-compose-%E6%96%87%E4%BB%B6">#</a> 在 Swarm 集群中使用 compose 文件</h2>
<p>正如之前使用 <code>docker-compose.yml</code> 来一次配置、启动多个容器，在 <code>Swarm</code> 集群中也可以使用 <code>compose</code> 文件 （<code>docker-compose.yml</code>） 来配置、启动多个服务。</p>
<p>上一节中，我们使用 <code>docker service create</code> 一次只能部署一个服务，使用 <code>docker-compose.yml</code> 我们可以一次启动多个关联的服务。</p>
<p>我们以在 <code>Swarm</code> 集群中部署 <code>WordPress</code> 为例进行说明。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">overlay</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">overlay</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db-data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span>]</span><br><span class="line"></span><br><span class="line">  <span class="attr">visualizer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockersamples/visualizer:stable</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">stop_grace_period:</span> <span class="string">1m30s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> [<span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">overlay:</span></span><br></pre></td></tr></table></figure>
<p>在 <code>Swarm</code> 集群管理节点新建该文件，其中的 <code>visualizer</code> 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p>
<p>在 <code>Swarm</code> 集群中使用 <code>docker-compose.yml</code> 我们用 <code>docker stack</code> 命令，下面我们对该命令进行详细讲解。</p>
<h2 id="部署服务-2"><a href="#%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1">#</a> 部署服务</h2>
<p>部署服务使用 <code>docker stack deploy</code>，其中 <code>-c</code> 参数指定 compose 文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml wordpress</span><br></pre></td></tr></table></figure>
<p>现在我们打开浏览器输入 <code>任一节点IP:8080</code> 即可看到各节点运行状态。如下图所示：</p>
<p><img src="https://vuepress.mirror.docker-practice.com/assets/img/wordpress.45232da8.png" alt=""></p>
<p>在浏览器新的标签页输入 <code>任一节点IP</code> 即可看到 <code>WordPress</code> 安装界面，安装完成之后，输入 <code>任一节点IP</code> 即可看到 <code>WordPress</code> 页面。</p>
<h2 id="查看服务-2"><a href="#%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1">#</a> 查看服务</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack <span class="built_in">ls</span></span><br><span class="line">NAME                SERVICES</span><br><span class="line">wordpress           3</span><br></pre></td></tr></table></figure>
<h2 id="移除服务"><a href="#%E7%A7%BB%E9%99%A4%E6%9C%8D%E5%8A%A1">#</a> 移除服务</h2>
<p>要移除服务，使用 <code>docker stack down</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack down wordpress</span><br><span class="line">Removing service wordpress_db</span><br><span class="line">Removing service wordpress_visualizer</span><br><span class="line">Removing service wordpress_wordpress</span><br><span class="line">Removing network wordpress_overlay</span><br><span class="line">Removing network wordpress_default</span><br></pre></td></tr></table></figure>
<p>该命令不会移除服务所使用的 <code>数据卷</code>，如果你想移除数据卷请使用 <code>docker volume rm</code></p>
<h2 id="在-Swarm-集群中管理敏感数据"><a href="#%E5%9C%A8-swarm-%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%AE%A1%E7%90%86%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE">#</a> 在 Swarm 集群中管理敏感数据</h2>
<p>在动态的、大规模的分布式集群上，管理和分发 <code>密码</code>、<code>证书</code> 等敏感信息是极其重要的工作。传统的密钥分发方式（如密钥放入镜像中，设置环境变量，volume 动态挂载等）都存在着潜在的巨大的安全风险。</p>
<p>Docker 目前已经提供了 <code>secrets</code> 管理功能，用户可以在 Swarm 集群中安全地管理密码、密钥证书等敏感数据，并允许在多个 Docker 容器实例之间共享访问指定的敏感数据。</p>
<blockquote>
<p>注意： <code>secret</code> 也可以在 <code>Docker Compose</code> 中使用。</p>
</blockquote>
<p>我们可以用 <code>docker secret</code> 命令来管理敏感信息。接下来我们在上面章节中创建好的 Swarm 集群中介绍该命令的使用。</p>
<p>这里我们以在 Swarm 集群中部署 <code>mysql</code> 和 <code>wordpress</code> 服务为例。</p>
<h2 id="创建-secret"><a href="#%E5%88%9B%E5%BB%BA-secret">#</a> 创建 secret</h2>
<p>我们使用 <code>docker secret create</code> 命令以管道符的形式创建 <code>secret</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rand -<span class="built_in">base64</span> 20 | docker secret create mysql_password -</span><br><span class="line"></span><br><span class="line">$ openssl rand -<span class="built_in">base64</span> 20 | docker secret create mysql_root_password -</span><br></pre></td></tr></table></figure>
<h2 id="查看-secret"><a href="#%E6%9F%A5%E7%9C%8B-secret">#</a> 查看 secret</h2>
<p>使用 <code>docker secret ls</code> 命令来查看 <code>secret</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker secret <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">ID                          NAME                  CREATED             UPDATED</span><br><span class="line">l1vinzevzhj4goakjap5ya409   mysql_password        41 seconds ago      41 seconds ago</span><br><span class="line">yvsczlx9votfw3l0nz5rlidig   mysql_root_password   12 seconds ago      12 seconds ago</span><br></pre></td></tr></table></figure>
<h2 id="创建-MySQL-服务"><a href="#%E5%88%9B%E5%BB%BA-mysql-%E6%9C%8D%E5%8A%A1">#</a> 创建 MySQL 服务</h2>
<p>创建服务相关命令已经在前边章节进行了介绍，这里直接列出命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d overlay mysql_private</span><br><span class="line"></span><br><span class="line">$ docker service create \</span><br><span class="line">     --name mysql \</span><br><span class="line">     --replicas 1 \</span><br><span class="line">     --network mysql_private \</span><br><span class="line">     --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=mydata,destination=/var/lib/mysql \</span><br><span class="line">     --secret <span class="built_in">source</span>=mysql_root_password,target=mysql_root_password \</span><br><span class="line">     --secret <span class="built_in">source</span>=mysql_password,target=mysql_password \</span><br><span class="line">     -e MYSQL_ROOT_PASSWORD_FILE=<span class="string">&quot;/run/secrets/mysql_root_password&quot;</span> \</span><br><span class="line">     -e MYSQL_PASSWORD_FILE=<span class="string">&quot;/run/secrets/mysql_password&quot;</span> \</span><br><span class="line">     -e MYSQL_USER=<span class="string">&quot;wordpress&quot;</span> \</span><br><span class="line">     -e MYSQL_DATABASE=<span class="string">&quot;wordpress&quot;</span> \</span><br><span class="line">     mysql:latest</span><br></pre></td></tr></table></figure>
<p>如果你没有在 <code>target</code> 中显式的指定路径时，<code>secret</code> 默认通过 <code>tmpfs</code> 文件系统挂载到容器的 <code>/run/secrets</code> 目录中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create \</span><br><span class="line">     --name wordpress \</span><br><span class="line">     --replicas 1 \</span><br><span class="line">     --network mysql_private \</span><br><span class="line">     --publish target=30000,port=80 \</span><br><span class="line">     --mount <span class="built_in">type</span>=volume,<span class="built_in">source</span>=wpdata,destination=/var/www/html \</span><br><span class="line">     --secret <span class="built_in">source</span>=mysql_password,target=wp_db_password,mode=0444 \</span><br><span class="line">     -e WORDPRESS_DB_USER=<span class="string">&quot;wordpress&quot;</span> \</span><br><span class="line">     -e WORDPRESS_DB_PASSWORD_FILE=<span class="string">&quot;/run/secrets/wp_db_password&quot;</span> \</span><br><span class="line">     -e WORDPRESS_DB_HOST=<span class="string">&quot;mysql:3306&quot;</span> \</span><br><span class="line">     -e WORDPRESS_DB_NAME=<span class="string">&quot;wordpress&quot;</span> \</span><br><span class="line">     wordpress:latest</span><br></pre></td></tr></table></figure>
<p>查看服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker service <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">ID            NAME   MODE        REPLICAS  IMAGE</span><br><span class="line">wvnh0siktqr3  mysql      replicated  1/1       mysql:latest</span><br><span class="line">nzt5xzae4n62  wordpress  replicated  1/1       wordpress:latest</span><br></pre></td></tr></table></figure>
<p>现在浏览器访问 <code>IP:30000</code>，即可开始 <code>WordPress</code> 的安装与使用。</p>
<p>通过以上方法，我们没有像以前通过设置环境变量来设置 MySQL 密码， 而是采用 <code>docker secret</code> 来设置密码，防范了密码泄露的风险。</p>
<h2 id="在-Swarm-集群中管理配置数据"><a href="#%E5%9C%A8-swarm-%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE">#</a> 在 Swarm 集群中管理配置数据</h2>
<p>在动态的、大规模的分布式集群上，管理和分发配置文件也是很重要的工作。传统的配置文件分发方式（如配置文件放入镜像中，设置环境变量，volume 动态挂载等）都降低了镜像的通用性。</p>
<p>在 Docker 17.06 以上版本中，Docker 新增了 <code>docker config</code> 子命令来管理集群中的配置信息，以后你无需将配置文件放入镜像或挂载到容器中就可实现对服务的配置。</p>
<blockquote>
<p>注意：<code>config</code> 仅能在 Swarm 集群中使用。</p>
</blockquote>
<p>这里我们以在 Swarm 集群中部署 <code>redis</code> 服务为例。</p>
<h2 id="创建-config"><a href="#%E5%88%9B%E5%BB%BA-config">#</a> 创建 config</h2>
<p>新建 <code>redis.conf</code> 文件</p>
<p>此项配置 Redis 监听 <code>6380</code> 端口</p>
<p>我们使用 <code>docker config create</code> 命令创建 <code>config</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker config create redis.conf redis.conf</span><br></pre></td></tr></table></figure>
<h2 id="查看-config"><a href="#%E6%9F%A5%E7%9C%8B-config">#</a> 查看 config</h2>
<p>使用 <code>docker config ls</code> 命令来查看 <code>config</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker config <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">ID                          NAME                CREATED             UPDATED</span><br><span class="line">yod8fx8iiqtoo84jgwadp86yk   redis.conf          4 seconds ago       4 seconds ago</span><br></pre></td></tr></table></figure>
<h2 id="创建-redis-服务"><a href="#%E5%88%9B%E5%BB%BA-redis-%E6%9C%8D%E5%8A%A1">#</a> 创建 redis 服务</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create \</span><br><span class="line">     --name redis \</span><br><span class="line">     <span class="comment"># --config source=redis.conf,target=/etc/redis.conf \</span></span><br><span class="line">     --config redis.conf \</span><br><span class="line">     -p 6379:6380 \</span><br><span class="line">     redis:latest \</span><br><span class="line">     redis-server /redis.conf</span><br></pre></td></tr></table></figure>
<p>如果你没有在 <code>target</code> 中显式的指定路径时，默认的 <code>redis.conf</code> 以 <code>tmpfs</code> 文件系统挂载到容器的 <code>/config.conf</code>。</p>
<p>经过测试，redis 可以正常使用。</p>
<p>以前我们通过监听主机目录来配置 Redis，就需要在集群的每个节点放置该文件，如果采用 <code>docker config</code> 来管理服务的配置信息，我们只需在集群中的管理节点创建 <code>config</code>，当部署服务时，集群会自动的将配置文件分发到运行服务的各个节点中，大大降低了配置信息的管理和分发难度。</p>
<h2 id="SWarm-mode-与滚动升级"><a href="#swarm-mode-%E4%B8%8E%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7">#</a> SWarm mode 与滚动升级</h2>
<p>在 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/swarm_mode/deploy.html">部署服务</a> 一节中我们使用 <code>nginx:1.13.7-alpine</code> 镜像部署了一个名为 <code>nginx</code> 的服务。</p>
<p>现在我们想要将 <code>NGINX</code> 版本升级到 <code>1.13.12</code>，那么在 Swarm mode 中如何升级服务呢？</p>
<p>你可能会想到，先停止原来的服务，再使用新镜像部署一个服务，不就完成服务的 “升级” 了吗。</p>
<p>这样做的弊端很明显，如果新部署的服务出现问题，原来的服务删除之后，很难恢复，那么在 Swarm mode 中到底该如何对服务进行滚动升级呢？</p>
<p>答案就是使用 <code>docker service update</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker service update \</span><br><span class="line">    --image nginx:1.13.12-alpine \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure>
<p>以上命令使用 <code>--image</code> 选项更新了服务的镜像。当然我们也可以使用 <code>docker service update</code> 更新任意的配置。</p>
<p><code>--secret-add</code> 选项可以增加一个密钥</p>
<p><code>--secret-rm</code> 选项可以删除一个密钥</p>
<p>更多选项可以通过 <code>docker service update -h</code> 命令查看。</p>
<h2 id="服务回退"><a href="#%E6%9C%8D%E5%8A%A1%E5%9B%9E%E9%80%80">#</a> 服务回退</h2>
<p>现在假设我们发现 <code>nginx</code> 服务的镜像升级到 <code>nginx:1.13.12-alpine</code> 出现了一些问题，我们可以使用命令一键回退。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service rollback nginx</span><br></pre></td></tr></table></figure>
<p>现在使用 <code>docker service ps</code> 命令查看 <code>nginx</code> 服务详情。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps nginx</span><br><span class="line"></span><br><span class="line">ID                  NAME                IMAGE                  NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">rt677gop9d4x        nginx.1             nginx:1.13.7-alpine   VM-20-83-debian     Running             Running about a minute ago</span><br><span class="line">d9pw13v59d00         \_ nginx.1         nginx:1.13.12-alpine  VM-20-83-debian     Shutdown            Shutdown 2 minutes ago</span><br><span class="line">i7ynkbg6ybq5         \_ nginx.1         nginx:1.13.7-alpine   VM-20-83-debian     Shutdown            Shutdown 2 minutes ago</span><br></pre></td></tr></table></figure>
<p>结果的输出详细记录了服务的部署、滚动升级、回退的过程。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/11/docker/10.Docker%20Swarm%20mode(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/10/docker/9.Docker%20%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 9.Docker 高级网络配置(Docker详细教程)"
                        >
                            9.Docker 高级网络配置(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-10T16:02:39+08:00">
	
		    2018 年 4 月 10 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="高级网络配置"><a href="#%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">#</a> 高级网络配置</h2>
<blockquote>
<p>注意：本章属于 <code>Docker</code> 高级配置，如果您是初学者，您可以暂时跳过本章节，直接学习 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/compose">Docker Compose</a> 一节。</p>
</blockquote>
<p>本章将介绍 Docker 的一些高级网络配置和选项。</p>
<p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc1918">RFC1918 (opens new window)</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p><img src="https://vuepress.mirror.docker-practice.com/assets/img/network.6ad909f2.png" alt="Docker 网络"></p>
<p>接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p>
<h2 id="快速配置指南"><a href="#%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97">#</a> 快速配置指南</h2>
<p>下面是一个跟 Docker 网络相关的命令列表。</p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p>
<ul>
<li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code> 定制 docker0 的掩码</li>
<li><code>-H SOCKET...</code> 或 <code>--host=SOCKET...</code> Docker 服务端接收命令的通道</li>
<li><code>--icc=true|false</code> 是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li>
<li><code>--iptables=true|false</code> 是否允许 Docker 添加 iptables 规则</li>
<li><code>--mtu=BYTES</code> 容器网络中的 MTU</li>
</ul>
<p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p>
<ul>
<li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li>
<li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li>
</ul>
<p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p>
<ul>
<li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li>
<li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li>
<li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li>
<li><code>-p SPEC</code> 或 <code>--publish=SPEC</code> 映射容器端口到宿主主机</li>
<li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li>
</ul>
<h2 id="容器访问控制"><a href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">#</a> 容器访问控制</h2>
<p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h2 id="容器访问外部网络"><a href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C">#</a> 容器访问外部网络</h2>
<p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sysctl</span> net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
<p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sysctl</span> -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure>
<p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p>
<h2 id="容器之间访问"><a href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%AE%BF%E9%97%AE">#</a> 容器之间访问</h2>
<p>容器之间相互访问，需要两方面的支持。</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</li>
<li>本地系统的防火墙软件 – <code>iptables</code> 是否允许通过。</li>
</ul>
<h3 id="访问所有端口"><a href="#%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%AB%AF%E5%8F%A3">#</a> 访问所有端口</h3>
<p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p>
<p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>&#123;&quot;icc&quot;: false&#125;</code> 来禁止它。</p>
<h3 id="访问指定端口"><a href="#%E8%AE%BF%E9%97%AE%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3">#</a> 访问指定端口</h3>
<p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口。</p>
<p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p>
<p>此时，系统中的 <code>iptables</code> 规则可能是类似</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -nL</span><br><span class="line">...</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>之后，启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code> 中的 <code>EXPOSE</code> 指令）。</p>
<p>当添加了 <code>--link=CONTAINER_NAME:ALIAS</code> 选项后，添加了 <code>iptables</code> 规则。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -nL</span><br><span class="line">...</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80</span><br><span class="line">ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>
<p>注意：<code>--link=CONTAINER_NAME:ALIAS</code> 中的 <code>CONTAINER_NAME</code> 目前必须是 Docker 分配的名字，或使用 <code>--name</code> 参数指定的名字。主机名则不会被识别。</p>
<h2 id="映射容器端口到宿主主机的实现"><a href="#%E6%98%A0%E5%B0%84%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%AE%BF%E4%B8%BB%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0">#</a> 映射容器端口到宿主主机的实现</h2>
<p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h2 id="容器访问外部实现"><a href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%AE%9E%E7%8E%B0">#</a> 容器访问外部实现</h2>
<p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -t nat -nL</span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中，上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h2 id="外部访问容器实现"><a href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0">#</a> 外部访问容器实现</h2>
<p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p>
<p>不管用那种办法，其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p>
<p>使用 <code>-P</code> 时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nL</span><br><span class="line">...</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>
<p>使用 <code>-p 80:80</code> 时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>
<p>这里的规则映射了 <code>0.0.0.0</code>，意味着将接受主机来自所有接口的流量。用户可以通过 <code>-p IP:host_port:container_port</code> 或 <code>-p IP::port</code> 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</p>
</li>
<li>
<p>如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</p>
</li>
</ul>
<h2 id="自定义网桥"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%A1%A5">#</a> 自定义网桥</h2>
<p>除了默认的 <code>docker0</code> 网桥，用户也可以指定网桥来连接各个容器。</p>
<p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> systemctl stop docker</span><br><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev docker0 down</span><br><span class="line">$ <span class="built_in">sudo</span> brctl delbr docker0</span><br></pre></td></tr></table></figure>
<p>然后创建一个网桥 <code>bridge0</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> brctl addbr bridge0</span><br><span class="line">$ <span class="built_in">sudo</span> ip addr add 192.168.5.1/24 dev bridge0</span><br><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev bridge0 up</span><br></pre></td></tr></table></figure>
<p>查看确认网桥创建并启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show bridge0</span><br><span class="line">4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.5.1/24 scope global bridge0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>启动 Docker 服务。</p>
<p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p>
<p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p>
<h2 id="工具和示例"><a href="#%E5%B7%A5%E5%85%B7%E5%92%8C%E7%A4%BA%E4%BE%8B">#</a> 工具和示例</h2>
<p>在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣：</p>
<h2 id="pipework"><a href="#pipework">#</a> pipework</h2>
<p>Jérôme Petazzoni 编写了一个叫 <a target="_blank" rel="noopener" href="https://github.com/jpetazzo/pipework">pipework (opens new window)</a> 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p>
<h2 id="playground"><a href="#playground">#</a> playground</h2>
<p>Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 <a target="_blank" rel="noopener" href="https://github.com/brandon-rhodes/fopnp/tree/m/playground">Python库 (opens new window)</a>，包括路由、NAT 防火墙；以及一些提供 <code>HTTP</code> <code>SMTP</code> <code>POP</code> <code>IMAP</code> <code>Telnet</code> <code>SSH</code> <code>FTP</code> 的服务器。</p>
<h2 id="编辑网络配置文件"><a href="#%E7%BC%96%E8%BE%91%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">#</a> 编辑网络配置文件</h2>
<p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p>
<p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</p>
<h2 id="示例：创建一个点到点连接"><a href="#%E7%A4%BA%E4%BE%8B-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%82%B9%E5%88%B0%E7%82%B9%E8%BF%9E%E6%8E%A5">#</a> 示例：创建一个点到点连接</h2>
<p>默认情况下，Docker 会将所有容器连接到由 <code>docker0</code> 提供的虚拟子网中。</p>
<p>用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。</p>
<p>解决办法很简单：创建一对 <code>peer</code> 接口，分别放到两个容器中，配置成点到点链路类型即可。</p>
<p>首先启动 2 个容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --<span class="built_in">rm</span> --net=none base /bin/bash</span><br><span class="line">root@1f1f4c1f931a:/#</span><br><span class="line">$ docker run -i -t --<span class="built_in">rm</span> --net=none base /bin/bash</span><br><span class="line">root@12e343489d2f:/#</span><br></pre></td></tr></table></figure>
<p>找到进程号，然后创建网络命名空间的跟踪文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 1f1f4c1f931a</span><br><span class="line">2989</span><br><span class="line">$ docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 12e343489d2f</span><br><span class="line">3004</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">ln</span> -s /proc/2989/ns/net /var/run/netns/2989</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">ln</span> -s /proc/3004/ns/net /var/run/netns/3004</span><br></pre></td></tr></table></figure>
<p>创建一对 <code>peer</code> 接口，然后配置路由</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> A netns 2989</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 2989 ip addr add 10.1.1.1/32 dev A</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 2989 ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 2989 ip route add 10.1.1.2/32 dev A</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> B netns 3004</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 3004 ip addr add 10.1.1.2/32 dev B</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 3004 ip <span class="built_in">link</span> <span class="built_in">set</span> B up</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 3004 ip route add 10.1.1.1/32 dev B</span><br></pre></td></tr></table></figure>
<p>现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p>
<p>此外，也可以不指定 <code>--net=none</code> 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p>
<p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 <code>--icc=false</code> 来关闭容器之间的通信。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/10/docker/9.Docker%20%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/09/docker/8.Docker%20%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 8.Docker 使用网络(Docker详细教程)"
                        >
                            8.Docker 使用网络(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-09T16:02:39+08:00">
	
		    2018 年 4 月 9 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Docker-中的网络功能介绍">Docker 中的网络功能介绍</h2>
<h2 id="Docker-中的网络功能介绍-2"><a href="#docker-%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D">#</a> Docker 中的网络功能介绍</h2>
<p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p>
<h2 id="外部访问容器"><a href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8">#</a> 外部访问容器</h2>
<p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P nginx:alpine</span><br><span class="line"></span><br><span class="line">$ docker container <span class="built_in">ls</span> -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">fae320d08268        nginx:alpine        <span class="string">&quot;/docker-entrypoint.…&quot;</span>   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</span><br></pre></td></tr></table></figure>
<p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs fa</span><br><span class="line">172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<h2 id="映射所有接口地址"><a href="#%E6%98%A0%E5%B0%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80">#</a> 映射所有接口地址</h2>
<p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h2 id="映射到指定地址的指定端口"><a href="#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3">#</a> 映射到指定地址的指定端口</h2>
<p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<h2 id="映射到指定地址的任意端口"><a href="#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%BB%E6%84%8F%E7%AB%AF%E5%8F%A3">#</a> 映射到指定地址的任意端口</h2>
<p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure>
<h2 id="查看映射端口配置"><a href="#%E6%9F%A5%E7%9C%8B%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE">#</a> 查看映射端口配置</h2>
<p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port fa 80</span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>
<p>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</p>
</li>
<li>
<p><code>-p</code> 标记可以多次使用来绑定多个端口</p>
</li>
</ul>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>
<h2 id="容器互联"><a href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94">#</a> 容器互联</h2>
<p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p>
<p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<h2 id="新建网络"><a href="#%E6%96%B0%E5%BB%BA%E7%BD%91%E7%BB%9C">#</a> 新建网络</h2>
<p>下面先创建一个新的 Docker 网络。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/swarm_mode/">Swarm mode</a>，在本小节中你可以忽略它。</p>
<h2 id="连接容器"><a href="#%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8">#</a> 连接容器</h2>
<p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure>
<p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure>
<p>再打开一个新的终端查看容器信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             <span class="string">&quot;sh&quot;</span>                11 minutes ago      Up 11 minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             <span class="string">&quot;sh&quot;</span>                16 minutes ago      Up 16 minutes                           busybox1</span><br></pre></td></tr></table></figure>
<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<p>在 <code>busybox1</code> 容器输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: <span class="built_in">seq</span>=0 ttl=64 <span class="keyword">time</span>=0.072 ms</span><br><span class="line">64 bytes from 172.19.0.3: <span class="built_in">seq</span>=1 ttl=64 <span class="keyword">time</span>=0.118 ms</span><br></pre></td></tr></table></figure>
<p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p>
<p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox1</span></span><br><span class="line">PING busybox1 (172.19.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.2: <span class="built_in">seq</span>=0 ttl=64 <span class="keyword">time</span>=0.064 ms</span><br><span class="line">64 bytes from 172.19.0.2: <span class="built_in">seq</span>=1 ttl=64 <span class="keyword">time</span>=0.143 ms</span><br></pre></td></tr></table></figure>
<p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<h2 id="Docker-Compose"><a href="#docker-compose">#</a> Docker Compose</h2>
<p>如果你有多个容器之间需要互相连接，推荐使用 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/network/compose">Docker Compose</a>。</p>
<h2 id="配置-DNS"><a href="#%E9%85%8D%E7%BD%AE-dns">#</a> 配置 DNS</h2>
<p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p>
<p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mount</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hostname <span class="built_in">type</span> ext4 ...</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hosts <span class="built_in">type</span> ext4 ...</span><br><span class="line">tmpfs on /etc/resolv.conf <span class="built_in">type</span> tmpfs ...</span><br></pre></td></tr></table></figure>
<p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p>
<p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> ubuntu:18.04  <span class="built_in">cat</span> etc/resolv.conf</span><br><span class="line"></span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>
<p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p>
<p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p>
<p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p>
<p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p>
<blockquote>
<p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/09/docker/8.Docker%20%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/08/docker/7.Docker%20%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 7.Docker 数据管理(Docker详细教程)"
                        >
                            7.Docker 数据管理(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-08T16:02:39+08:00">
	
		    2018 年 4 月 8 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Docker-数据管理"><a href="#docker-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86">#</a> Docker 数据管理</h2>
<p><img src="https://vuepress.mirror.docker-practice.com/assets/img/types-of-mounts.cd09b2d7.png" alt=""></p>
<p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p>
<ul>
<li>
<p>数据卷（Volumes）</p>
</li>
<li>
<p>挂载主机目录 (Bind mounts)</p>
</li>
</ul>
<h2 id="数据卷"><a href="#%E6%95%B0%E6%8D%AE%E5%8D%B7">#</a> 数据卷</h2>
<p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li>
<p><code>数据卷</code> 可以在容器之间共享和重用</p>
</li>
<li>
<p>对 <code>数据卷</code> 的修改会立马生效</p>
</li>
<li>
<p>对 <code>数据卷</code> 的更新，不会影响镜像</p>
</li>
<li>
<p><code>数据卷</code> 默认会一直存在，即使容器被删除</p>
</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<h2 id="创建一个数据卷"><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8D%B7">#</a> 创建一个数据卷</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure>
<p>查看所有的 <code>数据卷</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br></pre></td></tr></table></figure>
<p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="启动一个挂载数据卷的容器"><a href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%AE%B9%E5%99%A8">#</a> 启动一个挂载数据卷的容器</h2>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v my-vol:/usr/share/nginx/html \</span></span><br><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>
<h2 id="查看数据卷的具体信息"><a href="#%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF">#</a> 查看数据卷的具体信息</h2>
<p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<p><code>数据卷</code> 信息在 “Mounts” Key 下面</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-vol&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<h2 id="删除数据卷"><a href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%8D%B7">#</a> 删除数据卷</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume <span class="built_in">rm</span> my-vol</span><br></pre></td></tr></table></figure>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<h2 id="挂载主机目录"><a href="#%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95">#</a> 挂载主机目录</h2>
<h2 id="挂载一个主机目录作为数据卷"><a href="#%E6%8C%82%E8%BD%BD%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%8D%B7">#</a> 挂载一个主机目录作为数据卷</h2>
<p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>
<p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p>
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html:ro \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class="built_in">readonly</span> \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>
<p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/nginx/html <span class="comment"># touch new.txt</span></span><br><span class="line"><span class="built_in">touch</span>: new.txt: Read-only file system</span><br></pre></td></tr></table></figure>
<h2 id="查看数据卷的具体信息-2"><a href="#%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF">#</a> 查看数据卷的具体信息</h2>
<p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bind&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/src/webapp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<h2 id="挂载一个本地主机文件作为数据卷"><a href="#%E6%8C%82%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%8D%B7">#</a> 挂载一个本地主机文件作为数据卷</h2>
<p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> -it \</span><br><span class="line">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span><br><span class="line">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span><br><span class="line">   ubuntu:18.04 \</span><br><span class="line">   bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/# <span class="built_in">history</span></span><br><span class="line">1  <span class="built_in">ls</span></span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure>
<p>这样就可以记录在容器输入过的命令了。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/08/docker/7.Docker%20%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/07/docker/6.Docker%20%E4%BB%93%E5%BA%93(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 6.Docker 仓库(Docker详细教程)"
                        >
                            6.Docker 仓库(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-07T16:02:39+08:00">
	
		    2018 年 4 月 7 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="访问仓库"><a href="#%E8%AE%BF%E9%97%AE%E4%BB%93%E5%BA%93">#</a> 访问仓库</h2>
<p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。</p>
<h2 id="Docker-Hub"><a href="#docker-hub">#</a> Docker Hub</h2>
<p>目前 Docker 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub (opens new window)</a>，其中已经包括了数量超过 <a target="_blank" rel="noopener" href="https://hub.docker.com/search/?type=image">2,650,000 (opens new window)</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h2 id="注册"><a href="#%E6%B3%A8%E5%86%8C">#</a> 注册</h2>
<p>你可以在 <a target="_blank" rel="noopener" href="https://hub.docker.com">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h2 id="登录"><a href="#%E7%99%BB%E5%BD%95">#</a> 登录</h2>
<p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录。</p>
<h2 id="拉取镜像"><a href="#%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F">#</a> 拉取镜像</h2>
<p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<p>例如以 <code>centos</code> 为关键词进行搜索：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   6449      [OK]</span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              132                  [OK]</span><br><span class="line">consol/centos-xfce-vnc             Centos container with <span class="string">&quot;headless&quot;</span> VNC session…   126                  [OK]</span><br><span class="line">jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   117                  [OK]</span><br><span class="line">centos/systemd                     systemd enabled base container.                 96                   [OK]</span><br></pre></td></tr></table></figure>
<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p>
<p>根据是否是官方提供，可将镜像分为两类。</p>
<p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
<p>还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p>
<p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p>
<p>下载官方 <code>centos</code> 镜像到本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">7a0437f04f83: Pull complete</span><br><span class="line">Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line">docker.io/library/centos:latest</span><br></pre></td></tr></table></figure>
<h2 id="推送镜像"><a href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F">#</a> 推送镜像</h2>
<p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker search username</span><br><span class="line"></span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure>
<h2 id="自动构建"><a href="#%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA">#</a> 自动构建</h2>
<blockquote>
<p>2021 年 7 月 26 日之后，该项功能仅限<a target="_blank" rel="noopener" href="https://www.docker.com/blog/changes-to-docker-hub-autobuilds/">付费用户 (opens new window)</a>使用。</p>
</blockquote>
<p>自动构建（<code>Automated Builds</code>）可以自动触发构建镜像，方便升级镜像。</p>
<p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p>
<p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a target="_blank" rel="noopener" href="https://github.com/">GitHub (opens new window)</a> 或 <a target="_blank" rel="noopener" href="https://bitbucket.org/">BitBucket (opens new window)</a>）上的项目，一旦项目发生新的提交 （<code>commit</code>）或者创建了新的标签（<code>tag</code>），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动构建，包括如下的步骤：</p>
<ul>
<li>
<p>登录 Docker Hub；</p>
</li>
<li>
<p>在 Docker Hub 点击右上角头像，在账号设置（<code>Account Settings</code>）中关联（<code>Linked Accounts</code>）目标网站；</p>
</li>
<li>
<p>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</p>
</li>
<li>
<p>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</p>
</li>
<li>
<p>指定 <code>Dockerfile</code> 的位置，并保存。</p>
</li>
</ul>
<p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p>
<h2 id="私有仓库"><a href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93">#</a> 私有仓库</h2>
<p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p>
<p>本节介绍如何使用本地仓库。</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/registry/"><code>docker-registry</code> (opens new window)</a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a target="_blank" rel="noopener" href="https://github.com/docker/distribution"><code>docker-registry</code> (opens new window)</a> v2.x 版本。</p>
<h2 id="安装运行-docker-registry"><a href="#%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C-docker-registry">#</a> 安装运行 docker-registry</h2>
<h3 id="容器运行"><a href="#%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C">#</a> 容器运行</h3>
<p>你可以使用官方 <code>registry</code> 镜像来运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure>
<p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure>
<h2 id="在私有仓库上传、搜索、下载镜像"><a href="#%E5%9C%A8%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E4%B8%8A%E4%BC%A0%E3%80%81%E6%90%9C%E7%B4%A2%E3%80%81%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F">#</a> 在私有仓库上传、搜索、下载镜像</h2>
<p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p>
<p>先在本机查看已有的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p>
<p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker push</code> 上传标记的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker push 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure>
<p>用 <code>curl</code> 查看仓库中的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[<span class="string">&quot;ubuntu&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到 <code>&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125;</code>，表明镜像已经被成功上传了。</p>
<p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"></span><br><span class="line">$ docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure>
<h2 id="配置非-https-仓库地址"><a href="#%E9%85%8D%E7%BD%AE%E9%9D%9E-https-%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80">#</a> 配置非 https 仓库地址</h2>
<p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p>
<p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p>
<h3 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#ubuntu-16-04-debian-8-centos-7">#</a> Ubuntu 16.04+, Debian 8+, centos 7</h3>
<p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirror&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;192.168.199.100:5000&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p>
</blockquote>
<h2 id="其他"><a href="#%E5%85%B6%E4%BB%96">#</a> 其他</h2>
<p>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 <code>Docker Engine</code> 中进行编辑 ，增加和上边一样的字符串即可。</p>
<h2 id="私有仓库高级配置"><a href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE">#</a> 私有仓库高级配置</h2>
<p>上一节我们搭建了一个具有基础功能的私有仓库，本小节我们来使用 <code>Docker Compose</code> 搭建一个拥有权限认证、TLS 的私有仓库。</p>
<p>新建一个文件夹，以下步骤均在该文件夹中进行。</p>
<h2 id="准备站点证书"><a href="#%E5%87%86%E5%A4%87%E7%AB%99%E7%82%B9%E8%AF%81%E4%B9%A6">#</a> 准备站点证书</h2>
<p>如果你拥有一个域名，国内各大云服务商均提供免费的站点证书。你也可以使用 <code>openssl</code> 自行签发证书。</p>
<p>这里假设我们将要搭建的私有仓库地址为 <code>docker.domain.com</code>，下面我们介绍使用 <code>openssl</code> 自行签发 <code>docker.domain.com</code> 的站点 SSL 证书。</p>
<p>第一步创建 <code>CA</code> 私钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -out <span class="string">&quot;root-ca.key&quot;</span> 4096</span><br></pre></td></tr></table></figure>
<p>第二步利用私钥创建 <code>CA</code> 根证书请求文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req \</span><br><span class="line">          -new -key <span class="string">&quot;root-ca.key&quot;</span> \</span><br><span class="line">          -out <span class="string">&quot;root-ca.csr&quot;</span> -sha256 \</span><br><span class="line">          -subj <span class="string">&#x27;/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=Your Company Name Docker Registry CA&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上命令中 <code>-subj</code> 参数里的 <code>/C</code> 表示国家，如 <code>CN</code>；<code>/ST</code> 表示省；<code>/L</code> 表示城市或者地区；<code>/O</code> 表示组织名；<code>/CN</code> 通用名称。</p>
</blockquote>
<p>第三步配置 <code>CA</code> 根证书，新建 <code>root-ca.cnf</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root_ca]</span><br><span class="line">basicConstraints = critical,CA:TRUE,pathlen:1</span><br><span class="line">keyUsage = critical, nonRepudiation, cRLSign, keyCertSign</span><br><span class="line">subjectKeyIdentifier=<span class="built_in">hash</span></span><br></pre></td></tr></table></figure>
<p>第四步签发根证书。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -req  -days 3650  -<span class="keyword">in</span> <span class="string">&quot;root-ca.csr&quot;</span> \</span><br><span class="line">               -signkey <span class="string">&quot;root-ca.key&quot;</span> -sha256 -out <span class="string">&quot;root-ca.crt&quot;</span> \</span><br><span class="line">               -extfile <span class="string">&quot;root-ca.cnf&quot;</span> -extensions \</span><br><span class="line">               root_ca</span><br></pre></td></tr></table></figure>
<p>第五步生成站点 <code>SSL</code> 私钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -out <span class="string">&quot;docker.domain.com.key&quot;</span> 4096</span><br></pre></td></tr></table></figure>
<p>第六步使用私钥生成证书请求文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -new -key <span class="string">&quot;docker.domain.com.key&quot;</span> -out <span class="string">&quot;site.csr&quot;</span> -sha256 \</span><br><span class="line">          -subj <span class="string">&#x27;/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=docker.domain.com&#x27;</span></span><br></pre></td></tr></table></figure>
<p>第七步配置证书，新建 <code>site.cnf</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints = critical,CA:FALSE</span><br><span class="line">extendedKeyUsage=serverAuth</span><br><span class="line">keyUsage = critical, digitalSignature, keyEncipherment</span><br><span class="line">subjectAltName = DNS:docker.domain.com, IP:127.0.0.1</span><br><span class="line">subjectKeyIdentifier=<span class="built_in">hash</span></span><br></pre></td></tr></table></figure>
<p>第八步签署站点 <code>SSL</code> 证书。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -req -days 750 -<span class="keyword">in</span> <span class="string">&quot;site.csr&quot;</span> -sha256 \</span><br><span class="line">    -CA <span class="string">&quot;root-ca.crt&quot;</span> -CAkey <span class="string">&quot;root-ca.key&quot;</span>  -CAcreateserial \</span><br><span class="line">    -out <span class="string">&quot;docker.domain.com.crt&quot;</span> -extfile <span class="string">&quot;site.cnf&quot;</span> -extensions server</span><br></pre></td></tr></table></figure>
<p>这样已经拥有了 <code>docker.domain.com</code> 的网站 SSL 私钥 <code>docker.domain.com.key</code> 和 SSL 证书 <code>docker.domain.com.crt</code> 及 CA 根证书 <code>root-ca.crt</code>。</p>
<p>新建 <code>ssl</code> 文件夹并将 <code>docker.domain.com.key</code> <code>docker.domain.com.crt</code> <code>root-ca.crt</code> 这三个文件移入，删除其他文件。</p>
<h2 id="配置私有仓库"><a href="#%E9%85%8D%E7%BD%AE%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93">#</a> 配置私有仓库</h2>
<p>私有仓库默认的配置文件位于 <code>/etc/docker/registry/config.yml</code>，我们先在本地编辑 <code>config.yml</code>，之后挂载到容器中。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">accesslog:</span></span><br><span class="line">    <span class="attr">disabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">formatter:</span> <span class="string">text</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">staging</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">blobdescriptor:</span> <span class="string">inmemory</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">auth:</span></span><br><span class="line">  <span class="attr">htpasswd:</span></span><br><span class="line">    <span class="attr">realm:</span> <span class="string">basic-realm</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/etc/docker/registry/auth/nginx.htpasswd</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:443</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">https://docker.domain.com</span></span><br><span class="line">  <span class="attr">headers:</span></span><br><span class="line">    <span class="attr">X-Content-Type-Options:</span> [<span class="string">nosniff</span>]</span><br><span class="line">  <span class="attr">http2:</span></span><br><span class="line">    <span class="attr">disabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="attr">certificate:</span> <span class="string">/etc/docker/registry/ssl/docker.domain.com.crt</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">/etc/docker/registry/ssl/docker.domain.com.key</span></span><br><span class="line"><span class="attr">health:</span></span><br><span class="line">  <span class="attr">storagedriver:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line"><span class="attr">threshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="生成-http-认证文件"><a href="#%E7%94%9F%E6%88%90-http-%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6">#</a> 生成 http 认证文件</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> auth</span><br><span class="line"></span><br><span class="line">$ docker run --<span class="built_in">rm</span> \</span><br><span class="line">    --entrypoint htpasswd \</span><br><span class="line">    httpd:alpine \</span><br><span class="line">    -Bbn username password &gt; auth/nginx.htpasswd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将上面的 <code>username</code> <code>password</code> 替换为你自己的用户名和密码。</p>
</blockquote>
<h2 id="编辑-docker-compose-yml"><a href="#%E7%BC%96%E8%BE%91-docker-compose-yml">#</a> 编辑 <code>docker-compose.yml</code></h2>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/etc/docker/registry</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry-data:/var/lib/registry</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">registry-data:</span></span><br></pre></td></tr></table></figure>
<h2 id="修改-hosts"><a href="#%E4%BF%AE%E6%94%B9-hosts">#</a> 修改 hosts</h2>
<p>编辑 <code>/etc/hosts</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 docker.domain.com</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#%E5%90%AF%E5%8A%A8">#</a> 启动</h2>
<p>这样我们就搭建好了一个具有权限认证、TLS 的私有仓库，接下来我们测试其功能是否正常。</p>
<h2 id="测试私有仓库功能"><a href="#%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%8A%9F%E8%83%BD">#</a> 测试私有仓库功能</h2>
<p>由于自行签发的 CA 根证书不被系统信任，所以我们需要将 CA 根证书 <code>ssl/root-ca.crt</code> 移入 <code>/etc/docker/certs.d/docker.domain.com</code> 文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker/certs.d/docker.domain.com</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cp</span> ssl/root-ca.crt /etc/docker/certs.d/docker.domain.com/ca.crt</span><br></pre></td></tr></table></figure>
<p>登录到私有仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login docker.domain.com</span><br></pre></td></tr></table></figure>
<p>尝试推送、拉取镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker tag ubuntu:18.04 docker.domain.com/username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker push docker.domain.com/username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">rm</span> docker.domain.com/username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker pull docker.domain.com/username/ubuntu:18.04</span><br></pre></td></tr></table></figure>
<p>如果我们退出登录，尝试推送镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">logout</span> docker.domain.com</span><br><span class="line"></span><br><span class="line">$ docker push docker.domain.com/username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">no basic auth credentials</span><br></pre></td></tr></table></figure>
<p>发现会提示没有登录，不能将镜像推送到私有仓库中。</p>
<h2 id="注意事项"><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">#</a> 注意事项</h2>
<p>如果你本机占用了 <code>443</code> 端口，你可以配置 <a target="_blank" rel="noopener" href="https://docs.docker.com/registry/recipes/nginx/">Nginx 代理 (opens new window)</a>，这里不再赘述。</p>
<h2 id="Nexus3-x-的私有仓库"><a href="#nexus3-x-%E7%9A%84%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93">#</a> Nexus3.x 的私有仓库</h2>
<p>使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry。在企业中把内部的一些工具包放入 <code>Nexus</code> 中是比较常见的做法，最新版本 <code>Nexus3.x</code> 全面支持 Docker 的私有镜像。所以使用 <a target="_blank" rel="noopener" href="https://www.sonatype.com/product/repository-oss-download"><code>Nexus3.x</code> (opens new window)</a> 一个软件来管理 <code>Docker</code> , <code>Maven</code> , <code>Yum</code> , <code>PyPI</code> 等是一个明智的选择。</p>
<h2 id="启动-Nexus-容器"><a href="#%E5%90%AF%E5%8A%A8-nexus-%E5%AE%B9%E5%99%A8">#</a> 启动 Nexus 容器</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name nexus3 --restart=always \</span><br><span class="line">    -p 8081:8081 \</span><br><span class="line">    --mount src=nexus-data,target=/nexus-data \</span><br><span class="line">    sonatype/nexus3</span><br></pre></td></tr></table></figure>
<p>首次运行需等待 3-5 分钟，你可以使用 <code>docker logs nexus3 -f</code> 查看日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs nexus3 -f</span><br><span class="line"></span><br><span class="line">2021-03-11 15:31:21,990+0000 INFO  [jetty-main-1] *SYSTEM org.sonatype.nexus.bootstrap.jetty.JettyServer -</span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">Started Sonatype Nexus OSS 3.30.0-01</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你看到以上内容，说明 <code>Nexus</code> 已经启动成功，你可以使用浏览器打开 <code>http://YourIP:8081</code> 访问 <code>Nexus</code> 了。</p>
<p>首次运行请通过以下命令获取初始密码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> nexus3 <span class="built_in">cat</span> /nexus-data/admin.password</span><br><span class="line"></span><br><span class="line">9266139e-41a2-4abb-92ec-e4142a3532cb</span><br></pre></td></tr></table></figure>
<p>首次启动 Nexus 的默认帐号是 <code>admin</code> ，密码则是上边命令获取到的，点击右上角登录，首次登录需更改初始密码。</p>
<p>登录之后可以点击页面上方的齿轮按钮按照下面的方法进行设置。</p>
<h2 id="创建仓库"><a href="#%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93">#</a> 创建仓库</h2>
<p>创建一个私有仓库的方法： <code>Repository-&gt;Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p>
<ul>
<li><strong>Name</strong>: 仓库的名称</li>
<li><strong>HTTP</strong>: 仓库单独的访问端口（例如：<strong>5001</strong>）</li>
<li><strong>Hosted -&gt; Deployment pollcy</strong>: 请选择 <strong>Allow redeploy</strong> 否则无法上传 Docker 镜像。</li>
</ul>
<p>其它的仓库创建方法请各位自己摸索，还可以创建一个 <code>docker (proxy)</code> 类型的仓库链接到 DockerHub 上。再创建一个 <code>docker (group)</code> 类型的仓库把刚才的 <code>hosted</code> 与 <code>proxy</code> 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。</p>
<h2 id="添加访问权限"><a href="#%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">#</a> 添加访问权限</h2>
<p>菜单 <code>Security-&gt;Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p>
<p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p>
<p>添加用户：菜单 <code>Security-&gt;Users</code>-&gt;<code>Create local user</code> 在 <code>Roles</code> 选项中选中刚才创建的规则移动到右边的窗口保存。</p>
<h2 id="NGINX-加密代理"><a href="#nginx-%E5%8A%A0%E5%AF%86%E4%BB%A3%E7%90%86">#</a> NGINX 加密代理</h2>
<p>证书的生成请参见 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/repository/registry_auth.html"><code>私有仓库高级配置</code></a> 里面证书生成一节。</p>
<p>NGINX 示例配置如下</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> register</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="string">&quot;YourHostName OR IP&quot;</span>:<span class="number">5001</span>; <span class="comment">#端口为上面添加私有镜像仓库时设置的 HTTP 选项的端口号</span></span><br><span class="line">    <span class="attribute">check</span> interval=<span class="number">3000</span> rise=<span class="number">2</span> fall=<span class="number">10</span> timeout=<span class="number">1000</span> type=http;</span><br><span class="line">    <span class="attribute">check_http_send</span> <span class="string">&quot;HEAD / HTTP/1.0\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="attribute">check_http_expect_alive</span> http_4xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> YourDomainName;<span class="comment">#如果没有 DNS 服务器做解析，请删除此选项使用本机 IP 地址访问</span></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> key/example.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> key/example.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>   <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">300m</span>;</span><br><span class="line">    <span class="attribute">client_body_buffer_size</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span>   <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span>   <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_buffer_size</span>    <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">proxy_buffers</span>       <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">proxy_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">proxy_temp_file_write_size</span> <span class="number">512k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Port <span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://register;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">900s</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Docker-主机访问镜像仓库"><a href="#docker-%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93">#</a> Docker 主机访问镜像仓库</h2>
<p>如果不启用 SSL 加密可以通过 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/repository/registry.html">前面章节</a> 的方法添加非 https 仓库地址到 Docker 的配置文件中然后重启 Docker。</p>
<p>使用 SSL 加密以后程序需要访问就不能采用修改配置的方式了。具体方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl s_client -showcerts -connect YourDomainName OR HostIP:443 &lt;/dev/null 2&gt;/dev/null|openssl x509 -outform PEM &gt;ca.crt</span><br><span class="line">$ <span class="built_in">cat</span> ca.crt | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker login YourDomainName OR HostIP</code> 进行测试，用户名密码填写上面 Nexus 中设置的。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/07/docker/6.Docker%20%E4%BB%93%E5%BA%93(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2018/04/06/docker/5.Docker%20%E6%93%8D%E4%BD%9CDocker%E5%AE%B9%E5%99%A8(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/"
                            aria-label=": 5.Docker 操作Docker容器(Docker详细教程)"
                        >
                            5.Docker 操作Docker容器(Docker详细教程)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-06T16:02:39+08:00">
	
		    2018 年 4 月 6 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../">devops</a>, <a class="category-link" href="../../Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="操作-Docker-容器"><a href="#%E6%93%8D%E4%BD%9C-docker-%E5%AE%B9%E5%99%A8">#</a> 操作 Docker 容器</h2>
<p>容器是 Docker 又一核心概念。</p>
<p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>本章将具体介绍如何来管理一个容器，包括创建、启动和停止等。</p>
<h2 id="启动容器"><a href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8">#</a> 启动容器</h2>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h2 id="新建并启动"><a href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8">#</a> 新建并启动</h2>
<p>所需要的命令主要为 <code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/echo <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>这跟在本地直接执行 <code>/bin/echo 'hello world'</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/#</span><br></pre></td></tr></table></figure>
<p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/# <span class="built_in">pwd</span></span><br><span class="line">/</span><br><span class="line">root@af8bae53bdd3:/# <span class="built_in">ls</span></span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 <a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/repository/">registry</a> 下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h2 id="启动已终止容器"><a href="#%E5%90%AF%E5%8A%A8%E5%B7%B2%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8">#</a> 启动已终止容器</h2>
<p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:/# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 bash</span><br><span class="line">   11 ?        00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h2 id="后台运行"><a href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C">#</a> 后台运行</h2>
<p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p>如果使用了 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure>
<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:18.04  /bin/sh -c &#x27;while tr  2 minutes ago  Up 1 minute        agitated_wright</span><br></pre></td></tr></table></figure>
<p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [container ID or NAMES]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<h2 id="终止容器"><a href="#%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8">#</a> 终止容器</h2>
<p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">&quot;/bin/bash&quot;</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br></pre></td></tr></table></figure>
<p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="进入容器"><a href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8">#</a> 进入容器</h2>
<p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p>
<h2 id="attach-命令"><a href="#attach-%E5%91%BD%E4%BB%A4">#</a> <code>attach</code> 命令</h2>
<p>下面示例如何使用 <code>docker attach</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line">$ docker attach 243c</span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure>
<p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<h2 id="exec-命令"><a href="#exec-%E5%91%BD%E4%BB%A4">#</a> <code>exec</code> 命令</h2>
<h3 id="i-t-参数"><a href="#i-t-%E5%8F%82%E6%95%B0">#</a> <code>-i</code> <code>-t</code> 参数</h3>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</span><br><span class="line">root@69d137adef7a:/#</span><br></pre></td></tr></table></figure>
<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
<p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p>
<h2 id="导出和导入容器"><a href="#%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8">#</a> 导出和导入容器</h2>
<h2 id="导出容器"><a href="#%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8">#</a> 导出容器</h2>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:18.04        <span class="string">&quot;/bin/bash&quot;</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></span><br><span class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>
<p>这样将导出容器快照到本地文件。</p>
<h2 id="导入容器快照"><a href="#%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8%E5%BF%AB%E7%85%A7">#</a> 导入容器快照</h2>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<p><em>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h2 id="删除容器"><a href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8">#</a> 删除容器</h2>
<p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">rm</span> trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure>
<p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p>
<h2 id="清理所有处于终止状态的容器"><a href="#%E6%B8%85%E7%90%86%E6%89%80%E6%9C%89%E5%A4%84%E4%BA%8E%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%B9%E5%99%A8">#</a> 清理所有处于终止状态的容器</h2>
<p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2018/04/06/docker/5.Docker%20%E6%93%8D%E4%BD%9CDocker%E5%AE%B9%E5%99%A8(Docker%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B)/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../2/"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../4/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 3 頁 共 4 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 198 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
