
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>分類: devops - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/categories/devops/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../#about"
            >
        
        
            <img class="header-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2025/05/23/makefile%E6%95%99%E7%A8%8B/"
                            aria-label=": makefile教程"
                        >
                            makefile教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-23T12:48:01+08:00">
	
		    2025 年 5 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="make/">make</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="简介">简介</h2>
<p>Linux的<code>make</code>程序用来自动化编译大型源码，很多时候，我们在Linux下编译安装软件，只需要敲一个<code>make</code>就可以全自动完成，非常方便。</p>
<p><code>make</code>能自动化完成这些工作，是因为项目提供了一个<code>Makefile</code>文件，它负责告诉<code>make</code>，应该如何编译和链接程序。</p>
<p><code>Makefile</code>相当于Java项目的<code>pom.xml</code>，Node工程的<code>package.json</code>，Rust项目的<code>Cargo.toml</code>，不同之处在于，<code>make</code>虽然最初是针对C语言开发，但它实际上并不限定C语言，而是可以应用到任意项目，甚至不是编程语言。此外，<code>make</code>主要用于Unix/Linux环境的自动化开发，掌握<code>Makefile</code>的写法，可以更好地在Linux环境下做开发，也可以为后续开发Linux内核做好准备。</p>
<p>在本教程中，我们将由浅入深，一步一步学习如何编写<code>Makefile</code>，完全针对零基础小白，只需要提前掌握如何使用Linux命令。</p>
<hr>
<hr>
<p>在Linux环境下，当我们输入<code>make</code>命令时，它就在当前目录查找一个名为<code>Makefile</code>的文件，然后，根据这个文件定义的规则，自动化地执行任意命令，包括编译命令。</p>
<p><code>Makefile</code>这个单词，顾名思义，就是指如何生成文件。</p>
<p>我们举个例子：在当前目录下，有3个文本文件：<code>a.txt</code>，<code>b.txt</code>和<code>c.txt</code>。</p>
<p>现在，我们要合并<code>a.txt</code>与<code>b.txt</code>，生成中间文件<code>m.txt</code>，再用中间文件<code>m.txt</code>与<code>c.txt</code>合并，生成最终的目标文件<code>x.txt</code>，整个逻辑如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│a.txt│ │b.txt│ │c.txt│</span><br><span class="line">└─────┘ └─────┘ └─────┘</span><br><span class="line">   │       │       │</span><br><span class="line">   └───┬───┘       │</span><br><span class="line">       │           │</span><br><span class="line">       ▼           │</span><br><span class="line">    ┌─────┐        │</span><br><span class="line">    │m.txt│        │</span><br><span class="line">    └─────┘        │</span><br><span class="line">       │           │</span><br><span class="line">       └─────┬─────┘</span><br><span class="line">             │</span><br><span class="line">             ▼</span><br><span class="line">          ┌─────┐</span><br><span class="line">          │x.txt│</span><br><span class="line">          └─────┘</span><br></pre></td></tr></table></figure>
<p>根据上述逻辑，我们来编写<code>Makefile</code>。</p>
<h3 id="规则">规则</h3>
<p><code>Makefile</code>由若干条规则（Rule）构成，每一条规则指出一个目标文件（Target），若干依赖文件（prerequisites），以及生成目标文件的命令。</p>
<p>例如，要生成<code>m.txt</code>，依赖<code>a.txt</code>与<code>b.txt</code>，规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 目标文件: 依赖文件1 依赖文件2</span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>一条规则的格式为<code>目标文件: 依赖文件1 依赖文件2 ...</code>，紧接着，以Tab开头的是命令，用来生成目标文件。上述规则使用<code>cat</code>命令合并了<code>a.txt</code>与<code>b.txt</code>，并写入到<code>m.txt</code>。用什么方式生成目标文件<code>make</code>并不关心，因为命令完全是我们自己写的，可以是编译命令，也可以是<code>cp</code>、<code>mv</code>等任何命令。</p>
<p>以<code>#</code>开头的是注释，会被<code>make</code>命令忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Makefile的规则中，命令必须以Tab开头，不能是空格。</span><br></pre></td></tr></table></figure>
<p>类似的，我们写出生成<code>x.txt</code>的规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p>由于<code>make</code>执行时，默认执行第一条规则，所以，我们把规则<code>x.txt</code>放到前面。完整的<code>Makefile</code>如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br><span class="line"></span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>在当前目录创建<code>a.txt</code>、<code>b.txt</code>和<code>c.txt</code>，输入一些内容，执行<code>make</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p><code>make</code>默认执行第一条规则，也就是创建<code>x.txt</code>，但是由于<code>x.txt</code>依赖的文件<code>m.txt</code>不存在（另一个依赖<code>c.txt</code>已存在），故需要先执行规则<code>m.txt</code>创建出<code>m.txt</code>文件，再执行规则<code>x.txt</code>。执行完成后，当前目录下生成了两个文件<code>m.txt</code>和<code>x.txt</code>。</p>
<p>可见，<code>Makefile</code>定义了一系列规则，每个规则在满足依赖文件的前提下执行命令，就能创建出一个目标文件，这就是英文Make file的意思。</p>
<p>把默认执行的规则放第一条，其他规则的顺序是无关紧要的，因为<code>make</code>执行时自动判断依赖。</p>
<p>此外，<code>make</code>会打印出执行的每一条命令，便于我们观察执行顺序以便调试。</p>
<p>如果我们再次运行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">make: `x.txt&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p><code>make</code>检测到<code>x.txt</code>已经是最新版本，无需再次执行，因为<code>x.txt</code>的创建时间晚于它依赖的<code>m.txt</code>和<code>c.txt</code>的最后修改时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make使用文件的创建和修改时间来判断是否应该更新一个目标文件。</span><br></pre></td></tr></table></figure>
<p>修改<code>c.txt</code>后，运行<code>make</code>，会触发<code>x.txt</code>的更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p>但并不会触发<code>m.txt</code>的更新，原因是<code>m.txt</code>的依赖<code>a.txt</code>与<code>b.txt</code>并未更新，所以，<code>make</code>只会根据<code>Makefile</code>去执行那些必要的规则，并不会把所有规则都无脑执行一遍。</p>
<p>在编译大型程序时，全量编译往往需要几十分钟甚至几个小时。全量编译完成后，如果仅修改了几个文件，再全部重新编译完全没有必要，用<code>Makefile</code>实现增量编译就十分节省时间。</p>
<p>当然，是否能正确地实现增量更新，取决于我们的规则写得对不对，<code>make</code>本身并不会检查规则逻辑是否正确。</p>
<h3 id="伪目标">伪目标</h3>
<p>因为<code>m.txt</code>与<code>x.txt</code>都是自动生成的文件，所以，可以安全地删除。</p>
<p>删除时，我们也不希望手动删除，而是编写一个<code>clean</code>规则来删除它们：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p><code>clean</code>规则与我们前面编写的规则有所不同，它没有依赖文件，因此，要执行<code>clean</code>，必须用命令<code>make clean</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>然而，在执行<code>clean</code>时，我们并没有创建一个名为<code>clean</code>的文件，所以，因为目标文件<code>clean</code>不存在，每次运行<code>make clean</code>，都会执行这个规则的命令。</p>
<p>如果我们手动创建一个<code>clean</code>的文件，这个<code>clean</code>规则就不会执行了！</p>
<p>如果我们希望<code>make</code>把<code>clean</code>不要视为文件，可以添加一个标识：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>此时，<code>clean</code>就不被视为一个文件，而是伪目标（Phony Target）。</p>
<p>大型项目通常会提供<code>clean</code>、<code>install</code>这些约定俗成的伪目标名称，方便用户快速执行特定任务。</p>
<p>一般来说，并不需要用<code>.PHONY</code>标识<code>clean</code>等约定俗成的伪目标名称，除非有人故意搞破坏，手动创建名字叫<code>clean</code>的文件。</p>
<h3 id="执行多条命令">执行多条命令</h3>
<p>一个规则可以有多条命令，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd:</span></span><br><span class="line">	pwd</span><br><span class="line">	cd ..</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>执行<code>cd</code>规则：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make cd</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br></pre></td></tr></table></figure>
<p>观察输出，发现<code>cd ..</code>命令执行后，并未改变当前目录，两次输出的<code>pwd</code>是一样的，这是因为<code>make</code>针对每条命令，都会创建一个独立的Shell环境，类似<code>cd ..</code>这样的命令，并不会影响当前目录。</p>
<p>解决办法是把多条命令以<code>;</code>分隔，写到一行：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; cd ..; pwd;</span><br></pre></td></tr></table></figure>
<p>再执行<code>cd_ok</code>目标就得到了预期结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make cd_ok</span><br><span class="line">pwd; cd ..; pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">/home/ubuntu/makefile-tutorial</span><br></pre></td></tr></table></figure>
<p>可以使用<code>\</code>把一行语句拆成多行，便于浏览：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; \</span><br><span class="line">	cd ..; \</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>另一种执行多条命令的语法是用<code>&amp;&amp;</code>，它的好处是当某条命令失败时，后续命令不会继续执行：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure>
<h3 id="控制打印">控制打印</h3>
<p>默认情况下，<code>make</code>会打印出它执行的每一条命令。如果我们不想打印某一条命令，可以在命令前加上<code>@</code>，表示不打印命令（但是仍然会执行）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">	@echo &#x27;not display&#x27;</span><br><span class="line">	echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make no_output</span><br><span class="line">not display</span><br><span class="line">echo &#x27;will display&#x27;</span><br><span class="line">will display</span><br></pre></td></tr></table></figure>
<p>注意命令<code>echo 'not display'</code>本身没有打印，但命令仍然会执行，并且执行的结果仍然正常打印。</p>
<h3 id="控制错误">控制错误</h3>
<p><code>make</code>在执行命令时，会检查每一条命令的返回值，如果返回错误（非0值），就会中断执行。</p>
<p>例如，不使用<code>-f</code>删除一个不存在的文件会报错：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">has_error:</span></span><br><span class="line">	rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>执行上述目标，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make has_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: *** [has_error] Error 1</span><br></pre></td></tr></table></figure>
<p>由于命令<code>rm zzz.txt</code>报错，导致后面的命令<code>echo 'ok'</code>并不会执行，<code>make</code>打印出错误，然后退出。</p>
<p>有些时候，我们想忽略错误，继续执行后续命令，可以在需要忽略错误的命令前加上<code>-</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">	-rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>执行上述目标，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make ignore_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: [ignore_error] Error 1 (ignored)</span><br><span class="line">echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p><code>make</code>检测到<code>rm zzz.txt</code>报错，并打印错误，但显示<code>(ignored)</code>，然后继续执行后续命令。</p>
<p>对于执行可能出错，但不影响逻辑的命令，可以用<code>-</code>忽略。</p>
<h3 id="参考源码">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v1">GitHub</a>下载源码。</p>
<h3 id="小结">小结</h3>
<p>编写<code>Makefile</code>就是编写一系列规则，用来告诉<code>make</code>如何执行这些规则，最终生成我们期望的目标文件。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Rules.html">编写规则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Execution.html">执行命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">伪目标</a></li>
</ul>
<h2 id="编译C程序">编译C程序</h2>
<p>C程序的编译通常分两步：</p>
<ol>
<li>将每个<code>.c</code>文件编译为<code>.o</code>文件；</li>
<li>将所有<code>.o</code>文件链接为最终的可执行文件。</li>
</ol>
<p>我们假设如下的一个C项目，包含<code>hello.c</code>、<code>hello.h</code>和<code>main.c</code>。</p>
<p><code>hello.c</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hello.h</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>main.c</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>main.c</code>引用了头文件<code>hello.h</code>。我们很容易梳理出需要生成的文件，逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐ ┌───────┐ ┌───────┐</span><br><span class="line">│hello.c│ │main.c │ │hello.h│</span><br><span class="line">└───────┘ └───────┘ └───────┘</span><br><span class="line">    │         │         │</span><br><span class="line">    │         └────┬────┘</span><br><span class="line">    │              │</span><br><span class="line">    ▼              ▼</span><br><span class="line">┌───────┐      ┌───────┐</span><br><span class="line">│hello.o│      │main.o │</span><br><span class="line">└───────┘      └───────┘</span><br><span class="line">    │              │</span><br><span class="line">    └───────┬──────┘</span><br><span class="line">            │</span><br><span class="line">            ▼</span><br><span class="line">       ┌─────────┐</span><br><span class="line">       │world.out│</span><br><span class="line">       └─────────┘</span><br></pre></td></tr></table></figure>
<p>假定最终生成的可执行文件是<code>world.out</code>，中间步骤还需要生成<code>hello.o</code>和<code>main.o</code>两个文件。根据上述依赖关系，我们可以很容易地写出<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c:</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c:</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">	cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>在当前目录下可以看到<code>hello.o</code>、<code>main.o</code>以及最终的可执行程序<code>world.out</code>。执行<code>world.out</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, world!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>与我们预期相符。</p>
<p>修改<code>hello.c</code>，把输出改为<code>&quot;hello, bob!\n&quot;</code>，再执行<code>make</code>，观察输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>仅重新编译了<code>hello.c</code>，并未编译<code>main.c</code>。由于<code>hello.o</code>已更新，所以，仍然要重新生成<code>world.out</code>。执行<code>world.out</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, bob!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>与我们预期相符。</p>
<p>修改<code>hello.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 变为 void:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>以及<code>hello.c</code>，再次执行<code>make</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>会触发<code>main.c</code>的编译，因为<code>main.c</code>依赖<code>hello.h</code>。</p>
<p>执行<code>make clean</code>会删除所有的<code>.o</code>文件，以及可执行文件<code>world.out</code>，再次执行<code>make</code>就会强制全量编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make clean &amp;&amp; make</span><br><span class="line">rm -f *.o world.out</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>这个简单的<code>Makefile</code>使我们能自动化编译C程序，十分方便。</p>
<p>不过，随着越来越多的<code>.c</code>文件被添加进来，如何高效维护<code>Makefile</code>的规则？我们后面继续讲解。</p>
<h3 id="参考源码-2">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v2">GitHub</a>下载源码。</p>
<h3 id="小结-2">小结</h3>
<p>在<code>Makefile</code>正确定义规则后，我们就能用<code>make</code>自动化编译C程序。</p>
<hr>
<hr>
<h2 id="使用隐式规则">使用隐式规则</h2>
<p>我们仍然以上一节的C项目为例，当我们添加越来越多的<code>.c</code>文件时，就需要编写越来越多的规则来生成<code>.o</code>文件。</p>
<p>实际上，有的同学可能发现了，即使我们把<code>.o</code>的规则删掉，也能正常编译：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>我们没有定义<code>hello.o</code>和<code>main.o</code>的规则，为什么<code>make</code>也能正常创建这两个文件？</p>
<p>因为<code>make</code>最初就是为了编译C程序而设计的，为了免去重复创建编译<code>.o</code>文件的规则，<code>make</code>内置了隐式规则（Implicit Rule），即遇到一个<code>xyz.o</code>时，如果没有找到对应的规则，就自动应用一个隐式规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">xyz.o: xyz.c</span></span><br><span class="line">	cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure>
<p><code>make</code>针对C、C++、ASM、Fortran等程序内置了一系列隐式规则，可以参考官方手册查看。</p>
<p>对于C程序来说，使用隐式规则有一个潜在问题，那就是无法跟踪<code>.h</code>文件的修改。如果我们修改了<code>hello.h</code>的定义，由于隐式规则<code>main.o: main.c</code>并不会跟踪<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译，这个问题我们放到后面解决。</p>
<h3 id="参考源码-3">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v3">GitHub</a>下载源码。</p>
<h3 id="小结-3">小结</h3>
<p>针对C、C++、ASM、Fortran等程序，<code>make</code>内置了一系列隐式规则，使用隐式规则可减少大量重复的通用编译规则。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Using-Implicit.html">使用隐式规则</a></li>
</ul>
<hr>
<hr>
<p>当我们在<code>Makefile</code>中重复写很多文件名时，一来容易写错，二来如果要改名，要全部替换，费时费力。</p>
<p>编程语言使用变量（Variable）来解决反复引用的问题，类似的，在<code>Makefile</code>中，也可以使用变量来解决重复问题。</p>
<p>以上一节的<code>Makefile</code>为例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>编译的最终文件<code>world.out</code>重复出现了3次，因此，完全可以定义一个变量来替换它：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: hello.o main.o</span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>变量定义用<code>变量名 = 值</code>或者<code>变量名 := 值</code>，通常变量名全大写。引用变量用<code>$(变量名)</code>，非常简单。</p>
<p>注意到<code>hello.o main.o</code>这个“列表”也重复了，我们也可以用变量来替换：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJS = hello.o main.o</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>如果有一种方式能让<code>make</code>自动生成<code>hello.o main.o</code>这个“列表”，就更好了。注意到每个<code>.o</code>文件是由对应的<code>.c</code>文件编译产生的，因此，可以让<code>make</code>先获取<code>.c</code>文件列表，再替换，得到<code>.o</code>文件列表：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $(wildcard *.c) 列出当前目录下的所有 .c 文件: hello.c main.c</span></span><br><span class="line"><span class="comment"># 用函数 patsubst 进行模式替换得到: hello.o main.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>这样，我们每添加一个<code>.c</code>文件，不需要修改<code>Makefile</code>，变量<code>OBJS</code>会自动更新。</p>
<p>思考：为什么我们不能直接定义<code>OBJS = $(wildcard *.o)</code>让<code>make</code>列出所有<code>.o</code>文件？</p>
<h3 id="内置变量">内置变量</h3>
<p>我们还可以用变量<code>$(CC)</code>替换命令<code>cc</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>没有定义变量<code>CC</code>也可以引用它，因为它是<code>make</code>的内置变量（Builtin Variables），表示C编译器的名字，默认值是<code>cc</code>，我们也可以修改它，例如使用交叉编译时，指定编译器：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = riscv64-linux-gnu-gcc</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="自动变量">自动变量</h3>
<p>在<code>Makefile</code>中，经常可以看到<code>$@</code>、<code>$&lt;</code>这样的变量，这种变量称为自动变量（Automatic Variable），它们在一个规则中自动指向某个值。</p>
<p>例如，<code>$@</code>表示目标文件，<code>$^</code>表示所有依赖文件，因此，我们可以这么写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<p>在没有歧义时可以写<code>$@</code>，也可以写<code>$(@)</code>，有歧义时必须用括号，例如<code>$(@D)</code>。</p>
<p>为了更好地调试，我们还可以把变量打印出来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 变量 $@ 表示target</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 变量 $&lt; 表示第一个依赖项</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 变量 $^ 表示所有依赖项</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<p>执行结果输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$@ = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-4">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v4">GitHub</a>下载源码。</p>
<h3 id="小结-4">小结</h3>
<p>使用变量可以让<code>Makefile</code>更加容易维护。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Using-Variables.html">如何使用变量</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">自动变量</a></li>
</ul>
<h2 id="使用模式规则">使用模式规则</h2>
<p>前面我们讲了使用隐式规则可以让<code>make</code>在必要时自动创建<code>.o</code>文件的规则，但<code>make</code>的隐式规则的命令是固定的，对于<code>xyz.o: xyz.c</code>，它实际上是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>能修改的只有变量<code>$(CC)</code>和<code>$(CFLAGS)</code>。如果要执行多条命令，使用隐式规则就不行了。</p>
<p>这时，我们可以自定义模式规则（Pattern Rules），它允许<code>make</code>匹配模式规则，如果匹配上了，就自动创建一条模式规则。</p>
<p>我们修改上一节的<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配规则：当make需要目标 xyz.o 时，自动生成一条 xyz.o: xyz.c 规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">	cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>当<code>make</code>执行<code>world.out: hello.o main.o</code>时，发现没有<code>hello.o</code>文件，于是需要查找以<code>hello.o</code>为目标的规则，结果匹配到模式规则<code>%.o: %.c</code>，于是<code>make</code>自动根据模式规则为我们动态创建了如下规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">	cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>查找<code>main.o</code>也是类似的匹配过程，于是我们执行<code>make</code>，就可以用模式规则完成编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">compiling hello.c...</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">compiling main.c...</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>模式规则的命令完全由我们自己定义，因此，它比隐式规则更灵活。</p>
<p>但是，模式规则仍然没有解决修改<code>hello.h</code>头文件不会触发<code>main.c</code>重新编译的问题，这个依赖问题我们继续放到后面解决。</p>
<p>最后注意，模式规则是按需生成，如果我们在当前目录创建一个<code>zzz.o</code>文件，因为<code>make</code>并不会在执行过程中用到它，所以并不会自动生成<code>zzz.o: zzz.c</code>这个规则。</p>
<h3 id="参考源码-5">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v5">GitHub</a>下载源码。</p>
<h3 id="小结-5">小结</h3>
<p>使用模式规则可以灵活地按需动态创建规则，它比隐式规则更灵活。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html">模式规则</a></li>
</ul>
<hr>
<hr>
<p>前面我们讲了隐式规则和模式规则，这两种规则都可以解决自动把<code>.c</code>文件编译成<code>.o</code>文件，但都无法解决<code>.c</code>文件依赖<code>.h</code>文件的问题。</p>
<p>因为一个<code>.c</code>文件依赖哪个<code>.h</code>文件必须要分析文件内容才能确定，没有一个简单的文件名映射规则。</p>
<p>但是，要识别出<code>.c</code>文件的头文件依赖，可以用GCC提供的<code>-MM</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -MM main.c</span><br><span class="line">main.o: main.c hello.h</span><br></pre></td></tr></table></figure>
<p>上述输出告诉我们，编译<code>main.o</code>依赖<code>main.c</code>和<code>hello.h</code>两个文件。</p>
<p>因此，我们可以利用GCC的这个功能，对每个<code>.c</code>文件都生成一个依赖项，通常我们把它保存到<code>.d</code>文件中，再用<code>include</code>引入到<code>Makefile</code>，就相当于自动化完成了每个<code>.c</code>文件的精准依赖。</p>
<p>我们改写上一节的<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有 .c 文件:</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .o 文件列表:</span></span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .d 文件列表:</span></span><br><span class="line">DEPS = $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># xyz.d 的规则由 xyz.c 生成:</span></span><br><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o *.d <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>变量<code>$(SRCS)</code>通过扫描目录可以确定为<code>hello.c main.c</code>，因此，变量<code>$(OBJS)</code>赋值为<code>hello.o main.o</code>，变量<code>$(DEPS)</code>赋值为<code>hello.d main.d</code>。</p>
<p>通过<code>include $(DEPS)</code>我们引入<code>hello.d</code>和<code>main.d</code>文件，但是这两个文件一开始并不存在，不过，<code>make</code>通过模式规则匹配到<code>%.d: %.c</code>，这就给了我们一个机会，在这个模式规则内部，用<code>cc -MM</code>命令外加<code>sed</code>把<code>.d</code>文件创建出来。</p>
<p>运行<code>make</code>，首次输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Makefile:31: hello.d: No such file or directory</span><br><span class="line">Makefile:31: main.d: No such file or directory</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">rm -f hello.d; \</span><br><span class="line">        cc -MM hello.c &gt;hello.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(hello\)\.o[ :]*,\1.o hello.d : ,g&#x27; &lt; hello.d.tmp &gt; hello.d; \</span><br><span class="line">        rm -f hello.d.tmp</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p><code>make</code>会提示找不到<code>hello.d</code>和<code>main.d</code>，不过随后自动创建出<code>hello.d</code>和<code>main.d</code>。<code>hello.d</code>内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.o hello.d : hello.c</span><br></pre></td></tr></table></figure>
<p>上述规则有两个目标文件，实际上相当于如下两条规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello.o : hello.c</span><br><span class="line">hello.d : hello.c</span><br></pre></td></tr></table></figure>
<p><code>main.d</code>内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c hello.h</span><br></pre></td></tr></table></figure>
<p>因此，<code>main.o</code>依赖于<code>main.c</code>和<code>hello.h</code>，这个依赖关系就和我们手动指定的一致。</p>
<p>改动<code>hello.h</code>，再次运行<code>make</code>，可以触发<code>main.c</code>的编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>在实际项目中，对每个<code>.c</code>文件都可以生成一个对应的<code>.d</code>文件表示依赖关系，再通过<code>include</code>引入到<code>Makefile</code>，同时又能让<code>make</code>自动更新<code>.d</code>文件，有点蛋生鸡和鸡生蛋的关系，不过，这种机制能正常工作，除了<code>.d</code>文件不存在时会打印错误，有强迫症的同学肯定感觉不满意，这个问题我们后面解决。</p>
<h3 id="参考源码-6">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v6">GitHub</a>下载源码。</p>
<h3 id="小结-6">小结</h3>
<p>利用GCC生成<code>.d</code>文件，再用<code>include</code>引入<code>Makefile</code>，可解决一个<code>.c</code>文件应该如何正确触发编译的问题。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">自动生成依赖</a></li>
</ul>
<h2 id="完善Makefile">完善Makefile</h2>
<p>上一节我们解决了自动生成依赖的问题，这一节我们对项目目录进行整理，把所有源码放入<code>src</code>目录，所有编译生成的文件放入<code>build</code>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">└── src</span><br><span class="line">    ├── hello.c</span><br><span class="line">    ├── hello.h</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure>
<p>整理<code>Makefile</code>，内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR = ./src</span><br><span class="line">BUILD_DIR = ./build</span><br><span class="line">TARGET = <span class="variable">$(BUILD_DIR)</span>/world.out</span><br><span class="line"></span><br><span class="line">CC = cc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./src/*.c</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC_DIR)</span> -name &#x27;*.c&#x27;)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.d</span></span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.d,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.d 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.d: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,<span class="variable">$(BUILD_DIR)</span>/\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.o 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	@echo <span class="string">&quot;buiding <span class="variable">$@</span>...&quot;</span></span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 build 目录:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@echo <span class="string">&quot;clean...&quot;</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>这个<code>Makefile</code>定义了源码目录<code>SRC_DIR</code>、生成目录<code>BUILD_DIR</code>，以及其他变量，同时用<code>-include</code>消除了<code>.d</code>文件不存在的错误。执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -Wall -c -o build/hello.o src/hello.c</span><br><span class="line">cc -Wall -c -o build/main.o src/main.c</span><br><span class="line">buiding build/world.out...</span><br><span class="line">cc -o ./build/world.out ./build/hello.o ./build/main.o</span><br></pre></td></tr></table></figure>
<p>可以说基本满足编译需求，收工！</p>
<h3 id="参考源码-7">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v7">GitHub</a>下载源码。</p>
<h3 id="小结-7">小结</h3>
<p>除了基础的用法外，<code>Makefile</code>还支持条件判断，环境变量，嵌套执行，变量展开等各种功能，需要用到时可以查询<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/index.html">官方手册</a>。</p>
<hr>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2025/05/23/makefile%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2025/05/20/cheat-sheet/python-cheat-sheet/"
                            aria-label=": python cheat sheet"
                        >
                            python cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:48:40+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="python/">python</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="python">python:</h3>


	<div class="row">
    <embed src="/assets/pdf/python-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>



                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2025/05/20/cheat-sheet/python-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2025/05/20/cheat-sheet/vim-cheat-sheet/"
                            aria-label=": vim cheat sheet"
                        >
                            vim cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:41:16+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="vim/">vim</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="python">python:</h3>


	<div class="row">
    <embed src="/assets/pdf/vim-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>



                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2025/05/20/cheat-sheet/vim-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2025/05/20/cheat-sheet/ansible-cheat-sheet/"
                            aria-label=": ansible cheat sheet"
                        >
                            ansible cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:10:52+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="ansible/">ansible</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="ansible-command">ansible command:</h3>


	<div class="row">
    <embed src="/assets/pdf/ansible-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h3 id="playbook">playbook:</h3>


	<div class="row">
    <embed src="/assets/pdf/ansible-playbook.pdf" width="100%" height="550" type="application/pdf">
	</div>



                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2025/05/20/cheat-sheet/ansible-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2025/05/20/cheat-sheet/curl-cheat-sheet/"
                            aria-label=": curl cheat sheet"
                        >
                            curl cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T19:47:54+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="curl/">curl</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="curl-command">curl command:</h3>


	<div class="row">
    <embed src="/assets/pdf/curl-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2025/05/20/cheat-sheet/curl-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2025/05/20/cheat-sheet/docker-cheat-sheet/"
                            aria-label=": docker cheat sheet"
                        >
                            docker cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T19:36:58+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="docker/">docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="docker">docker:</h3>
<p><img src="/assets/images/docker-cheat-sheet.webp" alt="image"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2025/05/20/cheat-sheet/docker-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2025/05/14/git/git-cheat-sheet/"
                            aria-label=": git cheat sheet"
                        >
                            git cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-14T08:57:44+08:00">
	
		    2025 年 5 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/assets/images/gitcheatsheet.png" alt="image"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2025/05/14/git/git-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2025/05/12/vim%E6%95%99%E7%A8%8B/"
                            aria-label=": vim教程"
                        >
                            vim教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-12T16:01:20+08:00">
	
		    2025 年 5 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="vim/">vim</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>Vim 编辑器使用笔记整理</h1>
<h2 id="1-退出-Vim">1. 退出 Vim</h2>
<h3 id="命令行模式退出方式">命令行模式退出方式</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:wq</code></td>
<td>保存并退出</td>
</tr>
<tr>
<td><code>:q!</code></td>
<td>强制退出，不保存</td>
</tr>
<tr>
<td><code>:q</code></td>
<td>退出(未修改时)</td>
</tr>
<tr>
<td><code>:wq!</code></td>
<td>强制保存并退出</td>
</tr>
<tr>
<td><code>:w &lt;文件路径&gt;</code></td>
<td>另存为指定文件</td>
</tr>
<tr>
<td><code>:saveas 文件路径</code></td>
<td>另存为指定文件</td>
</tr>
<tr>
<td><code>:x</code></td>
<td>保存并退出(类似:wq)</td>
</tr>
</tbody>
</table>
<h3 id="普通模式退出方式">普通模式退出方式</h3>
<ul>
<li>输入 <code>Shift+zz</code> 即可保存退出</li>
</ul>
<h2 id="2-删除文本">2. 删除文本</h2>
<h3 id="普通模式删除命令">普通模式删除命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>删除游标所在字符</td>
</tr>
<tr>
<td><code>X</code></td>
<td>删除游标前一个字符</td>
</tr>
<tr>
<td><code>Delete</code></td>
<td>同 <code>x</code></td>
</tr>
<tr>
<td><code>dd</code></td>
<td>删除整行</td>
</tr>
<tr>
<td><code>dw</code></td>
<td>删除一个单词(不适用中文)</td>
</tr>
<tr>
<td><code>d$</code> 或 <code>D</code></td>
<td>删除至行尾</td>
</tr>
<tr>
<td><code>d^</code></td>
<td>删除至行首</td>
</tr>
<tr>
<td><code>dG</code></td>
<td>删除到文档结尾</td>
</tr>
<tr>
<td><code>d1G</code></td>
<td>删除至文档开头</td>
</tr>
<tr>
<td><code>:%d</code></td>
<td>清空整个文档内容（删除所有行）</td>
</tr>
<tr>
<td><code>:1,$d</code></td>
<td>同 <code>:%d</code>，删除从第一行到最后一行</td>
</tr>
<tr>
<td><code>ggdG</code></td>
<td>普通模式下清空文档的快捷方式（先跳转到首行，然后删除到末尾）</td>
</tr>
</tbody>
</table>
<p>注意：这些命令会立即生效且不可撤销，使用前请确保已保存重要内容</p>
<h3 id="数字前缀用法">数字前缀用法</h3>
<ul>
<li><code>2dd</code> 表示一次删除2行</li>
<li><code>3dw</code> 表示删除3个单词</li>
</ul>
<h2 id="3-重复执行命令">3. 重复执行命令</h2>
<ul>
<li>普通模式下 <code>.</code> (小数点)表示重复上一次命令</li>
<li>数字前缀：<code>10x</code> 删除10个连续字符</li>
</ul>
<h2 id="4-游标跳转">4. 游标跳转</h2>
<h3 id="行间跳转">行间跳转</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nG</code></td>
<td>跳转到第n行(需先<code>:set nu</code>显示行号)</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>跳转到第一行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>跳转到最后一行</td>
</tr>
</tbody>
</table>
<h3 id="行内跳转">行内跳转</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>w</code></td>
<td>到下一个单词开头</td>
</tr>
<tr>
<td><code>e</code></td>
<td>到当前单词结尾</td>
</tr>
<tr>
<td><code>b</code></td>
<td>到前一个单词开头</td>
</tr>
<tr>
<td><code>ge</code></td>
<td>到前一个单词结尾</td>
</tr>
<tr>
<td><code>0</code> 或 <code>^</code></td>
<td>到行头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>到行尾</td>
</tr>
<tr>
<td><code>f&lt;字母&gt;</code></td>
<td>向后搜索字母并跳转</td>
</tr>
<tr>
<td><code>F&lt;字母&gt;</code></td>
<td>向前搜索字母并跳转</td>
</tr>
<tr>
<td><code>t&lt;字母&gt;</code></td>
<td>向后搜索字母并跳转到匹配前</td>
</tr>
<tr>
<td><code>T&lt;字母&gt;</code></td>
<td>向前搜索字母并跳转到匹配后</td>
</tr>
</tbody>
</table>
<h2 id="5-复制粘贴和剪切">5. 复制粘贴和剪切</h2>
<h3 id="复制命令-yank">复制命令(yank)</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>yy</code></td>
<td>复制整行(3yy复制3行)</td>
</tr>
<tr>
<td><code>y^</code></td>
<td>复制至行首</td>
</tr>
<tr>
<td><code>y$</code></td>
<td>复制至行尾</td>
</tr>
<tr>
<td><code>yw</code></td>
<td>复制一个单词</td>
</tr>
<tr>
<td><code>yG</code></td>
<td>复制至文本末</td>
</tr>
<tr>
<td><code>y1G</code></td>
<td>复制至文本开头</td>
</tr>
</tbody>
</table>
<h3 id="粘贴命令">粘贴命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>p</code></td>
<td>粘贴至光标后</td>
</tr>
<tr>
<td><code>P</code></td>
<td>粘贴至光标前</td>
</tr>
</tbody>
</table>
<h2 id="6-替换和撤销">6. 替换和撤销</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r+&lt;字母&gt;</code></td>
<td>替换游标所在字母</td>
</tr>
<tr>
<td><code>R</code></td>
<td>连续替换(按Esc结束)</td>
</tr>
<tr>
<td><code>cc</code></td>
<td>替换整行</td>
</tr>
<tr>
<td><code>cw</code></td>
<td>替换一个单词</td>
</tr>
<tr>
<td><code>C</code></td>
<td>替换至行末</td>
</tr>
<tr>
<td><code>~</code></td>
<td>反转字母大小写</td>
</tr>
<tr>
<td><code>u</code></td>
<td>撤销操作</td>
</tr>
<tr>
<td><code>U</code></td>
<td>撤销当前行所有修改</td>
</tr>
<tr>
<td><code>Ctrl+r</code></td>
<td>重做(redo)</td>
</tr>
</tbody>
</table>
<h2 id="7-缩进调整">7. 缩进调整</h2>
<h3 id="缩进命令">缩进命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;&gt;</code></td>
<td>整行向右缩进</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>整行向左回退</td>
</tr>
<tr>
<td><code>:set shiftwidth=n</code></td>
<td>设置缩进字符数</td>
</tr>
</tbody>
</table>
<h3 id="文本位置调整">文本位置调整</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:ce</code></td>
<td>本行内容居中</td>
</tr>
<tr>
<td><code>:ri</code></td>
<td>本行文本靠右</td>
</tr>
<tr>
<td><code>:le</code></td>
<td>本行内容靠左</td>
</tr>
</tbody>
</table>
<h2 id="8-查找功能">8. 查找功能</h2>
<h3 id="基本查找">基本查找</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/字符串</code></td>
<td>向下查找</td>
</tr>
<tr>
<td><code>?字符串</code></td>
<td>向上查找</td>
</tr>
<tr>
<td><code>n</code></td>
<td>继续查找</td>
</tr>
<tr>
<td><code>N</code></td>
<td>反向查找</td>
</tr>
</tbody>
</table>
<h3 id="高级查找">高级查找</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>向后查找当前单词</td>
</tr>
<tr>
<td><code>#</code></td>
<td>向前查找当前单词</td>
</tr>
<tr>
<td><code>g*</code></td>
<td>向后查找部分匹配单词</td>
</tr>
<tr>
<td><code>g#</code></td>
<td>向前查找部分匹配单词</td>
</tr>
</tbody>
</table>
<h2 id="9-多文件编辑">9. 多文件编辑</h2>
<h3 id="多文件操作">多文件操作</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:n</code></td>
<td>编辑下一个文件</td>
</tr>
<tr>
<td><code>:N</code></td>
<td>编辑上一个文件</td>
</tr>
<tr>
<td><code>:e 文件名</code></td>
<td>打开新文件</td>
</tr>
<tr>
<td><code>:e#</code></td>
<td>回到前一个文件</td>
</tr>
<tr>
<td><code>:ls</code></td>
<td>列出编辑过的文档</td>
</tr>
<tr>
<td><code>:b 文件名/编号</code></td>
<td>切换到指定文件</td>
</tr>
<tr>
<td><code>:bd 文件名/编号</code></td>
<td>从列表删除文件</td>
</tr>
<tr>
<td><code>:f</code></td>
<td>显示当前文件名</td>
</tr>
</tbody>
</table>
<h3 id="文件恢复">文件恢复</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -r 文件名</span><br><span class="line">:ewcover 文件名</span><br></pre></td></tr></table></figure>
<h2 id="10-可视模式">10. 可视模式</h2>
<h3 id="进入可视模式">进入可视模式</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v</code></td>
<td>字符选择模式</td>
</tr>
<tr>
<td><code>V</code></td>
<td>行选择模式</td>
</tr>
<tr>
<td><code>Ctrl+v</code></td>
<td>区域选择模式</td>
</tr>
</tbody>
</table>
<h3 id="可视模式操作">可视模式操作</h3>
<ul>
<li><code>d</code> 删除选中区域</li>
<li><code>y</code> 复制选中区域</li>
</ul>
<h2 id="11-视窗操作">11. 视窗操作</h2>
<h3 id="窗口分割">窗口分割</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:new</code></td>
<td>新建窗口</td>
</tr>
<tr>
<td><code>:sp 文件名</code></td>
<td>水平分割窗口</td>
</tr>
<tr>
<td><code>:vsp 文件名</code></td>
<td>垂直分割窗口</td>
</tr>
<tr>
<td><code>Ctrl+w s</code></td>
<td>水平分割当前窗口</td>
</tr>
<tr>
<td><code>Ctrl+w v</code></td>
<td>垂直分割当前窗口</td>
</tr>
</tbody>
</table>
<h3 id="窗口切换">窗口切换</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl+w j/k/h/l</code></td>
<td>向下/上/左/右切换窗口</td>
</tr>
<tr>
<td><code>Ctrl+w q</code></td>
<td>关闭当前窗口</td>
</tr>
<tr>
<td><code>Ctrl+w o</code></td>
<td>只保留当前窗口</td>
</tr>
</tbody>
</table>
<h2 id="12-其他功能">12. 其他功能</h2>
<h3 id="文档加密">文档加密</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -x 文件名</span><br></pre></td></tr></table></figure>
<h3 id="执行外部命令">执行外部命令</h3>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:!命令</span><br><span class="line">:<span class="keyword">w</span> 文件名  # 另存为</span><br></pre></td></tr></table></figure>
<h3 id="帮助系统">帮助系统</h3>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:F1        # 打开帮助</span><br><span class="line">:h 主题    # 查看特定帮助</span><br><span class="line">:ver       # 显示版本</span><br></pre></td></tr></table></figure>
<h3 id="功能设定">功能设定</h3>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>    # 显示行号</span><br><span class="line">:<span class="keyword">set</span> ai    # 自动缩进</span><br><span class="line">:<span class="keyword">set</span> aw    # 自动保存</span><br><span class="line">:<span class="keyword">set</span> cin   # C语言风格缩进</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：所有设置可通过修改 <code>~/.vimrc</code> 文件永久保存</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2025/05/12/vim%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2023/01/17/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider/"
                            aria-label=": Terraform 基础概念-Provider"
                        >
                            Terraform 基础概念-Provider
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-17T17:43:45+08:00">
	
		    2023 年 1 月 17 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"><strong>1.3.1.1.</strong> Terraform 基础概念 —— Provider</a></p>
</li>
<li>
<p><a href="#%E4%B8%8B%E8%BD%BD-provider"><strong>1.3.1.1.1.</strong> 下载 Provider</a></p>
</li>
<li>
<p><a href="#%E6%90%9C%E7%B4%A2-provider"><strong>1.3.1.1.2.</strong> 搜索 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><strong>1.3.1.1.3.</strong> Provider 的声明</a></p>
</li>
<li>
<p><a href="#%E5%86%85%E5%BB%BA-provider"><strong>1.3.1.1.4.</strong> 内建 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.5.</strong> Provider 的配置</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><strong>1.3.1.1.6.</strong> 多 Provider 实例</a></p>
</li>
<li>
<p><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.1.</strong> 默认 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.2.</strong> 引用备用 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.3.</strong> 选择备用 Provider 配置</a></p>
</li>
</ul>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a></p>
<h2 id="1-3-1-1-Terraform-基础概念-——-Provider"><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a>1.3.1.1. Terraform 基础概念 —— Provider</h2>
<p>Terraform 被设计成一个多云基础设施编排工具，不像 CloudFormation 那样绑定 AWS 平台，Terraform 可以同时编排各种云平台或是其他基础设施的资源。Terraform 实现多云编排的方法就是 Provider 插件机制。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605496195438-image.png" alt="Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源"></p>
<p>图 1.3.1/1 - Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源</p>
<p>Terraform 使用的是 HashiCorp 自研的 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/go-plugin"><code>go-plugin</code> 库</a>)，本质上各个 Provider 插件都是独立的进程，与 Terraform 进程之间通过 Rpc 进行调用。Terraform 引擎首先读取并分析用户编写的 Terraform 代码，形成一个由 <code>data</code> 与 <code>resource</code> 组成的图(Graph)，再通过 Rpc 调用这些 <code>data</code> 与 <code>resource</code> 所对应的 Provider 插件；Provider 插件的编写者根据 Terraform 所制定的插件框架来定义各种 <code>data</code> 和 <code>resource</code>，并实现相应的 CRUD 方法；在实现这些 CRUD 方法时，可以调用目标平台提供的 SDK，或是直接通过调用 Http(s) API来操作目标平台。</p>
<h2 id="1-3-1-1-1-下载-Provider"><a href="#%E4%B8%8B%E8%BD%BD-provider"></a>1.3.1.1.1. 下载 Provider</h2>
<p>我们在第一章的小例子中，写完代码后在 <code>apply</code> 之前，首先我们执行了一次<code>terraform init</code>。<code>terraform init</code>会分析代码中所使用到的 Provider，并尝试下载 Provider 插件到本地。如果我们观察执行完第一章例子的文件夹，我们会发现有一个 <code>.terraform</code> 文件夹，我们所使用的 AWS Provider 插件就被下载安装在里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.terraform</span><br><span class="line">└── providers</span><br><span class="line">    └── registry.terraform.io</span><br><span class="line">        └── hashicorp</span><br><span class="line">            └── aws</span><br><span class="line">                └── 5.37.0</span><br><span class="line">                    └── windows_amd64</span><br><span class="line">                        └── terraform-provider-aws_v5.37.0_x5.exe</span><br></pre></td></tr></table></figure>
<p>有的时候下载某些 Provider 会非常缓慢，或是在开发环境中存在许多的 Terraform 项目，每个项目都保有自己独立的插件文件夹非常浪费磁盘，这时我们可以使用插件缓存。</p>
<p>有两种方式可以启用插件缓存：</p>
<p><strong>第一种方法</strong>是配置 <code>TF_PLUGIN_CACHE_DIR</code> 这个环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TF_PLUGIN_CACHE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.terraform.d/plugin-cache&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种方法</strong>是使用 CLI 配置文件。Windows 下是在相关用户的 <code>%APPDATA%</code> 目录下创建名为 <code>&quot;terraform.rc&quot;</code> 的文件，Macos 和 Linux 用户则是在用户的 <code>home</code> 下创建名为 <code>&quot;.terraformrc&quot;</code> 的文件。在文件中配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin_cache_dir = &quot;$HOME/.terraform.d/plugin-cache&quot;</span><br></pre></td></tr></table></figure>
<p>当启用插件缓存之后，每当执行 <code>terraform init</code> 命令时，Terraform 引擎会首先检查期望使用的插件在缓存文件夹中是否已经存在，如果存在，那么就会将缓存的插件拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。如果插件不存在，那么 Terraform 仍然会像之前那样下载插件，并首先保存在插件文件夹中，随后再从插件文件夹拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。为了尽量避免同一份插件被保存多次，只要操作系统提供支持，Terraform 就会使用符号连接而不是实际从插件缓存目录拷贝到工作目录。</p>
<p><strong>需要特别注意的是，Windows 系统下 <code>plugin_cache_dir</code> 的路径也必须使用 <code>/</code> 作为分隔符，应使用 <code>C:/somefolder/plugin_cahce</code> 而不是 <code>C:\somefolder\plugin_cache</code></strong></p>
<p>Terraform 引擎永远不会主动删除缓存文件夹中的插件，缓存文件夹的尺寸可能会随着时间而增长到非常大，这时需要手工清理。</p>
<h2 id="1-3-1-1-2-搜索-Provider"><a href="#%E6%90%9C%E7%B4%A2-provider"></a>1.3.1.1.2. 搜索 Provider</h2>
<p>想要了解有哪些被官方接纳的 Provider，就是前往<a target="_blank" rel="noopener" href="https://registry.terraform.io/browse/providers">registry.terraform.io</a>进行搜索：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-19/1605799350775-image.png" alt="registry.terraform.io上的插件页面"></p>
<p>图 1.3.1/2 - registry.terraform.io上的插件页面</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605498907942-image.png" alt="registry.terraform.io的搜索页面"></p>
<p>图 1.3.1/3 - registry.terraform.io的搜索页面</p>
<p>一般来说，相关 Provider 如何声明，以及相关 <code>data</code>、<code>resource</code> 的使用说明，都可以在 registry 上查阅到相关文档。</p>
<p><a target="_blank" rel="noopener" href="https://registry.terraform.io/"><code>registry.terraform.io</code></a> 不但可以查询 Provider，也可以用来发布 Provider；并且它也可以用来查询和发布模块(Module)，不过模块将是我们后续篇章讨论的话题。</p>
<h2 id="1-3-1-1-3-Provider-的声明"><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"></a>1.3.1.1.3. Provider 的声明</h2>
<p>一组 Terraform 代码要被执行，相关的 Provider 必须在代码中被声明。不少的 Provider 在声明时需要传入一些关键信息才能被使用，例如我们在第一章的例子中，必须给出访问密钥以及期望执行的 AWS 区域（Region）信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段 Provider 声明中，首先在 <code>terraform</code> 块的 <code>required_providers</code> 里声明了本段代码必须要名为 <code>aws</code> 的 Provider 才可以执行，<code>source = &quot;hashicorp/aws&quot;</code>这一行声明了 <code>aws</code> 这个插件的源地址(Source Address)。一个源地址是全球唯一的，它指示了 Terraform 如何下载该插件。一个源地址由三部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;HOSTNAME&gt;/]&lt;NAMESPACE&gt;/&lt;TYPE&gt;</span><br></pre></td></tr></table></figure>
<p><code>Hostname</code> 是选填的，默认是官方的 <code>registry.terraform.io</code>，读者也可以构建自己私有的Terraform仓库。<code>Namespace</code> 是在 Terraform 仓库内注册的组织名，这代表了发布和维护插件的组织或是个人。<code>Type</code> 是代表插件的一个短名，在特定的 <code>HostName</code>/<code>Namespace</code> 下 <code>Type</code> 必须唯一。</p>
<p><code>required_providers</code> 中的插件声明还声明了该源码所需要的插件的版本约束，在例子里就是 <code>version = &quot;~&gt;5.0&quot;</code>。Terraform 插件的版本号采用 <code>MAJOR.MINOR.PATCH</code> 的语义化格式，版本约束通常使用操作符和版本号表达约束条件，条件之间可以用逗号拼接，表达 <code>AND</code> 关联，例如 <code>&quot;&gt;= 1.2.0, &lt; 2.0.0&quot;</code>。可以采用的操作符有：</p>
<ul>
<li><code>=</code>(或者不加 <code>=</code>，直接使用版本号)：只允许特定版本号，不允许与其他条件合并使用</li>
<li><code>!=</code>：不允许特定版本号</li>
<li><code>\&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>：与特定版本号进行比较，可以是大于、大于等于、小于、小于等于</li>
<li><code>~&gt;</code>：只允许 <em>最右边</em> 的版本号增加。这种格式被称为 <em>悲观约束</em> 操作符。例如，要允许在特定的 <code>MINOR</code> 版本中允许新的 <code>PATCH</code> 版本：
<ul>
<li><code>~&gt; 1.0.4</code>：允许 Terraform 安装 <code>1.0.5</code> 和 <code>1.0.10</code>，但不允许 <code>1.1.0</code>。</li>
<li><code>~&gt; 1.1</code>：允许 Terraform 安装 <code>1.2</code> 和 <code>1.10</code>，但不允许 <code>2.0</code>。</li>
</ul>
</li>
</ul>
<p>Terraform 会检查当前工作环境或是插件缓存中是否存在满足版本约束的插件，如果不存在，那么 Terraform 会尝试下载。如果 Terraform 无法获得任何满足版本约束条件的插件，那么它会拒绝继续执行任何后续操作。</p>
<p>可以用添加后缀的方式来声明预览版，例如：<code>1.2.0-beta</code>。预览版只能通过 <code>&quot;=&quot;</code> 操作符(或是忽略操作符)后接明确的版本号的方式来指定，不可以与<code>&gt;=</code>、<code>~&gt;</code>等搭配使用。</p>
<ul>
<li>当依赖第三方模块时，需要指定特定版本，以确保只在您需要的时候进行更新。</li>
<li>对于在您的组织内维护的模块，如果一致使用语义版本控制，或者有一个定义良好的发布流程可以避免不必要的更新，那么指定版本范围可能是合适的。</li>
<li>可重用的模块应仅限制其 Terraform 和 Provider 的最低允许版本，例如 <code>&gt;= 0.12.0</code>。这有助于避免已知的不兼容性，同时允许模块的用户在不改变模块的情况下升级到 Terraform 的新版本。</li>
<li>根模块应使用 <code>~&gt;</code> 约束为它们依赖的每个 Provider 设置一个下限和上限版本。</li>
</ul>
<p>以上建议来自于 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/expressions/version-constraints#best-practices">HashiCorp 官方文档</a>，笔者个人给出一条个人建议：</p>
<ul>
<li>可复用的模块不但应该限制 Provider 的最低版本，同时也应该限制 Provider 的 <code>MAJOR</code> 版本。例如，<code>&gt;= 1.5.0, &lt; 2.0</code>。这样可以避免在 Provider 的 <code>MAJOR</code> 版本升级时，因为不兼容性导致的问题，Provider 的 <code>MAJOR</code> 版本升级通常会伴随着不兼容的改动，不应该在未加测试的情况下轻易升级。</li>
</ul>
<h2 id="1-3-1-1-4-内建-Provider"><a href="#%E5%86%85%E5%BB%BA-provider"></a>1.3.1.1.4. 内建 Provider</h2>
<p>绝大多数 Provider 是以插件形式单独分发的，但是目前有一个 Provider 是内建于Terraform主进程中的，那就是 <code>terraform_remote_state</code> data source。该 Provider 由于是内建的，所以使用时不需要在 <code>terraform</code> 中声明 <code>required_providers</code>。这个内建Provider的源地址是 <code>terraform.io/builtin/terraform</code>。这个地址有时可能出现在 Terraform 的错误消息和其他输出中，以便无歧义地引用内建 Provider，而不是假设的第三方提供者，其类型名称为 “terraform”。</p>
<p>还存在一个源地址为 <code>hashicorp/terraform</code> 的 Provider，这是现在内置 Provider 的旧版本，被 Terraform 的旧版本使用。<code>hashicorp/terraform</code> 与 Terraform v0.11 或更高版本不兼容，因此永远不应在 <code>required_providers</code> 块中声明。</p>
<h2 id="1-3-1-1-5-Provider-的配置"><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"></a>1.3.1.1.5. Provider 的配置</h2>
<p>Provider 的配置是声明在根模块中的一组 Terraform 配置。（子模块接收来自于根模块的 Provider 配置，更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider">模块的 <code>provider</code> 元参数</a>）</p>
<p>一个 Provider 配置是通过 <code>provider</code> 块来创建的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;google&quot; &#123;</span><br><span class="line">  project = &quot;acme-app&quot;</span><br><span class="line">  region  = &quot;us-central1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块头部设置的名称（例子中的 <code>&quot;google&quot;</code>）就是要配置的 Provider 的<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/providers/requirements#local-names">Local Name</a>。这个 Provider 必须已在 <code>required_providers</code> 块中声明。</p>
<p>块体（<code>&#123;</code> 和 <code>&#125;</code> 中间的内容）包含了 Provider 的配置参数。这些参数大多数是由 Provider 自己定义的；在这个例子中，<code>project</code> 和 <code>region</code> 都是 <code>google</code> Provider 特有的。</p>
<p>你可以在这些配置的值当中使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/8.%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，但是只能引用在配置 Provider 时已知的值。这意味着你可以安全地引用输入变量，但是不能引用从 <code>resource</code> 返回的属性（一个例外是直接在配置中硬编码的 <code>resource</code> 参数）。</p>
<p>一个 Provider 的文档应该列出它所需要的配置参数。对那些注册在 <a target="_blank" rel="noopener" href="https://registry.terraform.io/">Terraform Registry</a> 上的 Provider 来说，每个 Provider 的页面上都有版本化的文档，可以通过 Provider 页头的 “Documentation” 链接访问。</p>
<p>一些 Provider 可以使用环境变量（或是其他替代配置源，例如 AWS 的虚拟机实例 Profile）作为某些配置参数的值；我们建议尽可能使用这种方式来避免将凭证保存于版本控制的 Terraform 代码中。</p>
<p>There are also two “meta-arguments” that are defined by Terraform itself and available for all <code>provider</code> blocks:</p>
<p>有两个由 Terraform 自身定义的“元参数”，对所有 <code>provider</code> 块都可用：</p>
<ul>
<li><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><code>alias</code>，用以为不同的 <code>resource</code> 块配置参数不同的同类 Provider 实例</a></li>
<li><code>version</code>， 废弃，不推荐使用，现在请使用 <a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><code>required_providers</code></a></li>
</ul>
<p>与 Terraform 语言中的许多其他对象不同，如果 <code>provider</code> 块的内容为空，则可以省略该块。Terraform 假定未显式配置的任何 Provider 程序都具有空的默认配置。</p>
<h2 id="1-3-1-1-6-多-Provider-实例"><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"></a>1.3.1.1.6. 多 Provider 实例</h2>
<p><code>provider</code> 块声明了 <code>aws</code> 这个 Provider 所需要的各项配置。在上文的代码示例中，<code>provider &quot;aws&quot;</code>和<code>required_providers</code>中<code>aws = &#123;...&#125;</code>块里的<code>aws</code>，都是 Provider 的 Local Name，一个 Local Name 是在一个模块中对一个 Provider 的唯一的标识。</p>
<p>你可以选择为同一个 Provider 定义多个配置，并且可以根据每个资源或每个模块来选择使用哪一个。这主要是为了支持云平台的多个区域；其他例子包括针对多个 Docker 主机，多个 Consul 主机等。</p>
<p>要为某一个 Provider 创建多个配置，包括具有相同提供者名称的多个 <code>provider</code> 块。对于每个额外的非默认配置，使用 <code>alias</code> 元参数提供额外的名称段。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># The default provider configuration; resources that begin with `aws_` will use</span><br><span class="line"># it as the default, and it can be referenced as `aws`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Additional provider configuration for west coast region; resources can</span><br><span class="line"># reference this as `aws.west`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;west&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模块内声明配置 <code>alias</code> 以从父模块接收备用的 <code>provider</code> 配置，需要在该 <code>provider</code> 的 <code>required_providers</code> 条目中添加 <code>configuration_aliases</code> 参数。以下示例在包含的模块中声明了 <code>mycloud</code> 和 <code>mycloud.alternate</code> 的 <code>provider</code> 配置名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    mycloud = &#123;</span><br><span class="line">      source  = &quot;mycorp/mycloud&quot;</span><br><span class="line">      version = &quot;~&gt; 1.0&quot;</span><br><span class="line">      configuration_aliases = [ mycloud.alternate ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1-1-6-1-默认-Provider-配置"><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.1. 默认 Provider 配置</h3>
<p>没有 <code>alias</code> 参数的 <code>provider</code> 块是该 provider 的 <em>默认</em> 配置。未设置 <code>provider</code> 元参数的资源将使用与资源类型名称的第一个单词匹配的默认 provider 配置。（例如，除非另有说明，否则 <code>aws_instance</code> 资源将使用默认的 <code>aws</code> provider 配置。）</p>
<p>如果 provider 的每个显式配置都有别名，Terraform 将使用隐含的空配置作为该 provider 的默认配置。（如果 provider 有任何必需的配置参数，当资源默认使用空配置时，Terraform 将引发错误。）</p>
<h3 id="1-3-1-1-6-2-引用备用-Provider-配置"><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.2. 引用备用 Provider 配置</h3>
<p>当 Terraform 需要 provider 配置的名称时，它期望的是 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 形式的引用。在上面的例子中，<code>aws.west</code> 将引用 <code>us-west-2</code> 区域的 provider。</p>
<p>这些引用是特殊的表达式。像对其他命名实体（例如 <code>var.image_id</code>）的引用一样，它们不是字符串，不需要引号。但是它们只在 <code>resource</code>、<code>data</code> 和 <code>module</code> 块的特定元参数中有效，不能在任意表达式中使用。</p>
<h3 id="1-3-1-1-6-3-选择备用-Provider-配置"><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.3. 选择备用 Provider 配置</h3>
<p>默认情况下，资源使用从资源类型名称的第一个单词推断出的默认 provider 配置（没有 <code>alias</code> 参数的配置）。</p>
<p>要为资源或数据源指定备用 provider 配置，将其 <code>provider</code> 元参数设置为 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;foo&quot; &#123;</span><br><span class="line">  provider = aws.west</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要为子模块指定备用 provider 配置，使用其 <code>providers</code> 元参数指定应将哪些 provider 配置映射到模块内的哪些本地 provider 名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module &quot;aws_vpc&quot; &#123;</span><br><span class="line">  source = &quot;./aws_vpc&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws = aws.west</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在传递 provider 时，模块有一些特殊要求；有关更多详细信息，请参见 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html#module-providers">模块 <code>providers</code> 元参数</a>。在大多数情况下，只有 <em>根模块</em> 应定义 provider 配置，所有子模块都应从其父模块获取其 provider 配置。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2023/01/17/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../2022/12/15/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1Travis-CI%E6%95%99%E7%A8%8B/"
                            aria-label=": 持续集成服务Travis CI教程"
                        >
                            持续集成服务Travis CI教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-12-15T15:15:55+08:00">
	
		    2022 年 12 月 15 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="">devops</a>, <a class="category-link" href="CI-CD/">CI/CD</a>, <a class="category-link" href="CI-CD/TravisCI/">TravisCI</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>编写代码只是软件开发的一小部分，更多的时间往往花在构建（build）和测试（test）。</p>
<p>为了提高软件开发的效率，构建和测试的自动化工具层出不穷。<a target="_blank" rel="noopener" href="https://travis-ci.org/">Travis CI</a> 就是这类工具之中，<a target="_blank" rel="noopener" href="https://github.com/blog/2463-github-welcomes-all-ci-tools">市场份额</a>最大的一个。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017121901.png" alt=""></p>
<p>本文介绍 Travis CI 的基本用法。用好这个工具不仅可以提高效率，还能使开发流程更可靠和专业化，从而提高软件的价值。而且，它对于开源项目是免费的，不花一分钱，就能帮你做掉很多事情。</p>
<h2 id="一、什么是持续集成？">一、什么是持续集成？</h2>
<p>Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</p>
<p>持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码&quot;集成&quot;到主干。</p>
<p>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p>
<h2 id="二、使用准备">二、使用准备</h2>
<p>Travis CI 只支持 Github，不支持其他代码托管服务。这意味着，你必须满足以下条件，才能使用 Travis CI。</p>
<blockquote>
<ul>
<li>拥有 GitHub 帐号</li>
<li>该帐号下面有一个项目</li>
<li>该项目里面有可运行的代码</li>
<li>该项目还包含构建或测试脚本</li>
</ul>
</blockquote>
<p>如果这些条件都没问题，就可以开始使用 Travis CI 了。</p>
<p>首先，访问官方网站 <a target="_blank" rel="noopener" href="https://travis-ci.org/">travis-ci.org</a>，点击右上角的个人头像，使用 Github 账户登入 Travis CI。</p>
<p>Travis 会列出 Github 上面你的所有仓库，以及你所属于的组织。此时，选择你需要 Travis 帮你构建的仓库，打开仓库旁边的开关。一旦激活了一个仓库，Travis 会监听这个仓库的所有变化。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017121902.png" alt=""></p>
<h2 id="三、-travis-yml">三、.travis.yml</h2>
<p>Travis 要求项目的根目录下面，必须有一个<code>.travis.yml</code>文件。这是配置文件，指定了 Travis 的行为。该文件必须保存在 Github 仓库里面，一旦代码仓库有新的 Commit，Travis 就会去找这个文件，执行里面的命令。</p>
<p>这个文件采用 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML</a> 格式。下面是一个最简单的 Python 项目的<code>.travis.yml</code>文件。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">language</span>: python</span><br><span class="line"><span class="attr">script</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，设置了两个字段。<code>language</code>字段指定了默认运行环境，这里设定使用 Python 环境。<code>script</code>字段指定要运行的脚本，<code>script: true</code>表示不执行任何脚本，状态直接设为成功。</p>
<p>Travis 默认提供的运行环境，请参考<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/languages">官方文档</a> 。目前一共支持31种语言，以后还会不断增加。</p>
<p>下面是一个稍微复杂一点的<code>.travis.yml</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">language</span>: python</span><br><span class="line"><span class="attr">sudo</span>: required</span><br><span class="line"><span class="attr">before_install</span>: sudo pip install foo</span><br><span class="line"><span class="attr">script</span>: py.<span class="property">test</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，设置了四个字段：运行环境是 Python，需要<code>sudo</code>权限，在安装依赖之前需要安装<code>foo</code>模块，然后执行脚本<code>py.test</code>。</p>
<h2 id="四、运行流程">四、运行流程</h2>
<p>Travis 的运行流程很简单，任何项目都会经过两个阶段。</p>
<blockquote>
<ul>
<li>install 阶段：安装依赖</li>
<li>script 阶段：运行脚本</li>
</ul>
</blockquote>
<h3 id="4-1-install-字段">4.1 install 字段</h3>
<p><code>install</code>字段用来指定安装脚本。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">install</span>: ./install-dependencies.<span class="property">sh</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果有多个脚本，可以写成下面的形式。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">install</span>:</span><br><span class="line">  - command1</span><br><span class="line">  - command2</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，如果<code>command1</code>失败了，整个构建就会停下来，不再往下进行。</p>
<p>如果不需要安装，即跳过安装阶段，就直接设为<code>true</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">install</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-2、script-字段">4.2、script 字段</h3>
<p><code>script</code>字段用来指定构建或测试脚本。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">script</span>: bundle exec thor build</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果有多个脚本，可以写成下面的形式。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">script</span>:</span><br><span class="line">  - command1</span><br><span class="line">  - command2</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，<code>script</code>与<code>install</code>不一样，如果<code>command1</code>失败，<code>command2</code>会继续执行。但是，整个构建阶段的状态是失败。</p>
<p>如果<code>command2</code>只有在<code>command1</code>成功后才能执行，就要写成下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">script</span>: command1 &amp;&amp; command2</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-3-实例：Node-项目">4.3 实例：Node 项目</h3>
<p>Node 项目的环境需要写成下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">language</span>: node_js</span><br><span class="line"><span class="attr">node_js</span>:</span><br><span class="line">  - <span class="string">&quot;8&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>node_js</code>字段用来指定 Node 版本。</p>
<p>Node 项目的<code>install</code>和<code>script</code>阶段都有默认脚本，可以省略。</p>
<blockquote>
<ul>
<li><code>install</code>默认值：npm install</li>
<li><code>script</code>默认值：npm test</li>
</ul>
</blockquote>
<p>更多设置请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/">官方文档</a>。</p>
<h3 id="4-4-部署">4.4 部署</h3>
<p><code>script</code>阶段结束以后，还可以设置<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/notifications/">通知步骤</a>（notification）和<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/deployment/">部署步骤</a>（deployment），它们不是必须的。</p>
<p>部署的脚本可以在<code>script</code>阶段执行，也可以使用 Travis 为几十种常见服务提供的快捷部署功能。比如，要部署到 <a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/deployment/pages/">Github Pages</a>，可以写成下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">deploy</span>:</span><br><span class="line">  <span class="attr">provider</span>: pages</span><br><span class="line">  <span class="attr">skip_cleanup</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_token</span>: $GITHUB_TOKEN # <span class="title class_">Set</span> <span class="keyword">in</span> travis-ci.<span class="property">org</span> dashboard</span><br><span class="line">  <span class="attr">on</span>:</span><br><span class="line">    <span class="attr">branch</span>: master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>其他部署方式，请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/deployment/">官方文档</a>。</p>
<h3 id="4-5-钩子方法">4.5 钩子方法</h3>
<p>Travis 为上面这些阶段提供了7个钩子。</p>
<blockquote>
<ul>
<li>before_install：install 阶段之前执行</li>
<li>before_script：script 阶段之前执行</li>
<li>after_failure：script 阶段失败时执行</li>
<li>after_success：script 阶段成功时执行</li>
<li>before_deploy：deploy 步骤之前执行</li>
<li>after_deploy：deploy 步骤之后执行</li>
<li>after_script：script 阶段之后执行</li>
</ul>
</blockquote>
<p>完整的生命周期，从开始到结束是下面的流程。</p>
<blockquote>
<ol>
<li>before_install</li>
<li>install</li>
<li>before_script</li>
<li>script</li>
<li>after<em>success or after</em>failure</li>
<li>[OPTIONAL] before_deploy</li>
<li>[OPTIONAL] deploy</li>
<li>[OPTIONAL] after_deploy</li>
<li>after_script</li>
</ol>
</blockquote>
<p>下面是一个<code>before_install</code>钩子的例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">before_install</span>:</span><br><span class="line">  - sudo apt-get -qq update</span><br><span class="line">  - sudo apt-get install -y libxml2-dev</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码表示<code>before_install</code>阶段要做两件事，第一件事是要更新依赖，第二件事是安装<code>libxml2-dev</code>。用到的几个参数的含义如下：<code>-qq</code>表示减少中间步骤的输出，<code>-y</code>表示如果需要用户输入，总是输入<code>yes</code>。</p>
<h3 id="4-6-运行状态">4.6 运行状态</h3>
<p>最后，Travis 每次运行，可能会返回四种状态。</p>
<blockquote>
<ul>
<li>passed：运行成功，所有步骤的退出码都是<code>0</code></li>
<li>canceled：用户取消执行</li>
<li>errored：<code>before_install</code>、<code>install</code>、<code>before_script</code>有非零退出码，运行会立即停止</li>
<li>failed ：<code>script</code>有非零状态码 ，会继续运行</li>
</ul>
</blockquote>
<h2 id="五、使用技巧">五、使用技巧</h2>
<h3 id="5-1-环境变量">5.1 环境变量</h3>
<p><code>.travis.yml</code>的<code>env</code>字段可以定义环境变量。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">env</span>:</span><br><span class="line">  - <span class="variable constant_">DB</span>=postgres</span><br><span class="line">  - <span class="variable constant_">SH</span>=bash</span><br><span class="line">  - <span class="variable constant_">PACKAGE_VERSION</span>=<span class="string">&quot;1.0.*&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，脚本内部就使用这些变量了。</p>
<p>有些环境变量（比如用户名和密码）不能公开，这时可以通过 Travis 网站，写在每个仓库的设置页里面，Travis 会自动把它们加入环境变量。这样一来，脚本内部依然可以使用这些环境变量，但是只有管理员才能看到变量的值。具体操作请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/environment-variables">官方文档</a>。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017121903.png" alt=""></p>
<h3 id="5-2-加密信息">5.2 加密信息</h3>
<p>如果不放心保密信息明文存在 Travis 的网站，可以使用 Travis 提供的加密功能。</p>
<p>首先，安装 Ruby 的包<code>travis</code>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ gem install travis</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，就可以用<code>travis encrypt</code>命令加密信息。</p>
<p>在项目的根目录下，执行下面的命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis encrypt SOMEVAR=secretvalue</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令中，<code>SOMEVAR</code>是要加密的变量名，<code>secretvalue</code>是要加密的变量值。执行以后，屏幕上会输出如下信息。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">secure: <span class="string">&quot;.... encrypted data ....&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在，就可以把这一行加入<code>.travis.yml</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">env</span>:</span><br><span class="line">  <span class="attr">global</span>:</span><br><span class="line">    - <span class="attr">secure</span>: <span class="string">&quot;.... encrypted data ....&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，脚本里面就可以使用环境变量<code>$SOMEVAR</code>了，Travis 会在运行时自动对它解密。</p>
<p><code>travis encrypt</code>命令的<code>--add</code>参数会把输出自动写入<code>.travis.yml</code>，省掉了修改<code>env</code>字段的步骤。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis encrypt SOMEVAR=secretvalue --add</span><br></pre></td></tr></table></figure>
</blockquote>
<p>详细信息请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/encryption-keys/">官方文档</a>。</p>
<h3 id="5-3-加密文件">5.3 加密文件</h3>
<p>如果要加密的是文件（比如私钥），Travis 提供了加密文件功能。</p>
<p>安装命令行客户端以后，使用下面的命令登入 Travis CI。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis login </span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，进入项目的根目录，使用<code>travis encrypt-file</code>命令加密那些想要加密的文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis encrypt-file bacon.txt</span><br><span class="line"></span><br><span class="line">encrypting bacon.txt <span class="keyword">for</span> rkh/travis-encrypt-file-example</span><br><span class="line">storing result as bacon.txt.enc</span><br><span class="line">storing secure <span class="built_in">env</span> variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Please add the following to your build script (before_install stage <span class="keyword">in</span> your .travis.yml, <span class="keyword">for</span> instance):</span><br><span class="line"></span><br><span class="line">    openssl aes-256-cbc -K <span class="variable">$encrypted_0a6446eb3ae3_key</span> -iv <span class="variable">$encrypted_0a6446eb3ae3_key</span> -<span class="keyword">in</span> bacon.txt.enc -out bacon.txt -d</span><br><span class="line"></span><br><span class="line">Pro Tip: You can add it automatically by running with --add.</span><br><span class="line"></span><br><span class="line">Make sure to add bacon.txt.enc to the git repository.</span><br><span class="line">Make sure not to add bacon.txt to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码对文件<code>bacon.txt</code>进行加密，加密后会生成<code>bacon.txt.enc</code>，该文件需要提交到代码库。此外，该命令还会生成一个环境变量<code>$encrypted_0a6446eb3ae3_key</code>，保存密钥，储存在 Travis CI，文件解密时需要这个环境变量。你需要把解密所需的<code>openssl</code>命令，写在<code>.travis.yml</code>的<code>before_install</code>字段里面。这些都写在上面的命令行提示里面。</p>
<p><code>--add</code>参数可以自动把环境变量写入<code>.travis.yml</code>。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ travis encrypt-file bacon.txt --add</span><br><span class="line"></span><br><span class="line">encrypting bacon.txt <span class="keyword">for</span> rkh/travis-encrypt-file-example</span><br><span class="line">storing result as bacon.txt.enc</span><br><span class="line">storing secure <span class="built_in">env</span> variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Make sure to add bacon.txt.enc to the git repository.</span><br><span class="line">Make sure not to add bacon.txt to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>详细信息请看<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/encrypting-files/">官方文档</a>，实际的例子可以参考下面两篇文章。</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/domenic/ec8b0fc8ab45f39403dd">Auto-deploying built products to gh-pages with Travis</a></li>
<li><a target="_blank" rel="noopener" href="https://oncletom.io/2016/travis-ssh-deploy/">SSH deploys with Travis CI</a></li>
</ul>
</blockquote>
<p>（完）</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../2022/12/15/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1Travis-CI%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="page/2/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 1 頁 共 4 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 199 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
