
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>所有文章 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/archives/page/4/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../#about"
            >
        
        
            <img class="header-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/26/JavaScript/JavaScript-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"
                            aria-label=": JavaScript-快速入门"
                        >
                            JavaScript-快速入门
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-26T20:56:13+08:00">
	
		    2025 年 5 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;Hello, world&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由<code>&lt;script&gt;...&lt;/script&gt;</code>包含的代码就是JavaScript代码，它将直接被浏览器执行。</p>
<p>第二种方法是把JavaScript代码放到一个单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/abc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，<code>/static/js/abc.js</code>就会被浏览器执行。</p>
<p>把JavaScript代码放入一个单独的<code>.js</code>文件中更利于维护代码，并且多个页面可以各自引用同一份<code>.js</code>文件。</p>
<p>可以在同一个页面中引入多个<code>.js</code>文件，还可以在页面中多次编写<code>&lt;script&gt; js代码... &lt;/script&gt;</code>，浏览器按照顺序依次执行。</p>
<p>有些时候你会看到<code>&lt;script&gt;</code>标签还设置了一个<code>type</code>属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但这是没有必要的，因为默认的<code>type</code>就是JavaScript，所以不必显式地把<code>type</code>指定为JavaScript。</p>
<h3 id="如何编写JavaScript">如何编写JavaScript</h3>
<p>可以用任何文本编辑器来编写JavaScript代码。这里我们推荐以下几种文本编辑器：</p>
<h4 id="Visual-Studio-Code">Visual Studio Code</h4>
<p>微软出的<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a>，可以看做迷你版Visual Studio，免费，跨平台，内置JavaScript支持，强烈推荐使用！</p>
<h4 id="Sublime-Text">Sublime Text</h4>
<p><a target="_blank" rel="noopener" href="https://www.sublimetext.com/">Sublime Text</a>是一个好用的文本编辑器，免费，但不注册会不定时弹出提示框。</p>
<p><em>注意</em>：不可以用Word或写字板来编写JavaScript或HTML，因为带格式的文本保存后不是<em>纯文本文件</em>，无法被浏览器正常读取。也尽量不要用记事本编写，它会自作聪明地在保存UTF-8格式文本时添加BOM头。</p>
<h3 id="如何运行JavaScript">如何运行JavaScript</h3>
<p>要让浏览器运行JavaScript，必须先有一个HTML页面，在HTML页面中引入JavaScript，然后，让浏览器加载该HTML页面，就可以执行JavaScript代码。</p>
<p>你也许会想，直接在我的硬盘上创建好HTML和JavaScript文件，然后用浏览器打开，不就可以看到效果了吗？</p>
<p>这种方式运行部分JavaScript代码没有问题，但由于浏览器的安全限制，以<code>file://</code>开头的地址无法执行如联网等JavaScript代码，最终，你还是需要架设一个Web服务器，然后以<code>http://</code>开头的地址来正常执行所有JavaScript代码。</p>
<p>不过，开始学习阶段，你无须关心如何搭建开发环境的问题，我们提供在页面输入JavaScript代码并直接运行的功能，让你专注于JavaScript的学习。</p>
<p>试试直接点击“Run”按钮执行下面的JavaScript代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 以双斜杠开头直到行末的是注释，注释是给人看的，会被浏览器忽略</span><br><span class="line">/* 在这中间的也是注释，将被浏览器忽略 */</span><br><span class="line">// 第一个JavaScript代码:</span><br><span class="line"></span><br><span class="line">alert(&#x27;Hello, world&#x27;); // 观察执行效果</span><br></pre></td></tr></table></figure>
<p>浏览器将弹出一个对话框，显示“Hello, world”。你也可以修改两个单引号中间的内容，再试着运行。</p>
<h3 id="调试">调试</h3>
<p>俗话说得好，“工欲善其事，必先利其器。”，写JavaScript的时候，如果期望显示<code>ABC</code>，结果却显示<code>XYZ</code>，到底代码哪里出了问题？不要抓狂，也不要泄气，作为小白，要坚信：JavaScript本身没有问题，浏览器执行也没有问题，有问题的一定是我的代码。</p>
<p>如何找出问题代码？这就需要调试。</p>
<p>怎么在浏览器中调试JavaScript代码呢？</p>
<p>首先，你需要安装Google Chrome浏览器，Chrome浏览器对开发者非常友好，可以让你方便地调试JavaScript代码。从这里<a target="_blank" rel="noopener" href="https://www.google.com/chrome/?system=true&amp;standalone=1">下载Chrome浏览器</a>。打开网页出问题的童鞋请移步<a target="_blank" rel="noopener" href="https://www.google.cn/chrome/?system=true&amp;standalone=1">国内镜像</a>。</p>
<p>安装后，随便打开一个网页，然后点击菜单“查看(View)”-“开发者(Developer)”-“开发者工具(Developer Tools)”，浏览器窗口就会一分为二，下方就是开发者工具：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/quick-start/dev-tools.jpg" alt="chrome dev tools"></p>
<p>先点击“控制台(Console)“，在这个面板里可以直接输入JavaScript代码，按回车后执行。</p>
<p>要查看一个变量的内容，在Console中输入<code>console.log(a);</code>，回车后显示的值就是变量的内容。</p>
<p>关闭Console请点击右上角的“×”按钮。请熟练掌握Console的使用方法，在编写JavaScript代码时，经常需要在Console运行测试代码。</p>
<p>如果你对自己还有更高的要求，可以研究开发者工具的“源码(Sources)”，掌握断点、单步执行等高级调试技巧。</p>
<h3 id="练习">练习</h3>
<p>打开<a target="_blank" rel="noopener" href="http://www.sina.com.cn/">新浪首页</a>，然后查看页面源代码，找一找引入的JavaScript文件和直接编写在页面中的JavaScript代码。然后在Chrome中打开开发者工具，在控制台输入<code>console.log('Hello');</code>，回车查看JavaScript代码执行结果。</p>
<h2 id="基本语法">基本语法</h2>
<p>JavaScript的语法和Java语言类似，每个语句以<code>;</code>结束，语句块用<code>&#123;...&#125;</code>。但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。</p>
<p>提示</p>
<p>让JavaScript引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。在本教程中，我们不会省略;，所有语句都会添加;。</p>
<p>例如，下面的一行代码就是一个完整的赋值语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>下面的一行代码是一个字符串，但仍然可以视为一个完整的语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Hello, world&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>下面的一行代码包含两个语句，每个语句用<code>;</code>表示语句结束：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>; <span class="keyword">var</span> y = <span class="number">2</span>; <span class="comment">// 不建议一行写多个语句!</span></span><br></pre></td></tr></table></figure>
<p>语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行<code>&#123;...&#125;</code>中的所有语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">2</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">    z = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意花括号<code>&#123;...&#125;</code>内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。很多文本编辑器具有“自动缩进”的功能，可以帮助整理代码。</p>
<p><code>&#123;...&#125;</code>还可以嵌套，形成层级结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">2</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">    z = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        z = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        z = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。遇到这种情况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。</p>
<h3 id="注释">注释</h3>
<p>以<code>//</code>开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一行注释</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 这也是注释</span></span><br></pre></td></tr></table></figure>
<p>另一种块注释是用<code>/*...*/</code>把多行字符包裹起来，把一大“块”视为一个注释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从这里开始是块注释</span></span><br><span class="line"><span class="comment">仍然是注释</span></span><br><span class="line"><span class="comment">仍然是注释</span></span><br><span class="line"><span class="comment">注释结束 */</span></span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>分别利用行注释和块注释把下面的语句注释掉，使它不再执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 请注释掉下面的语句:</span><br><span class="line">alert(&#x27;我不想执行&#x27;);</span><br><span class="line">alert(&#x27;我也不想执行&#x27;);</span><br></pre></td></tr></table></figure>
<h3 id="大小写">大小写</h3>
<p>请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。</p>
<hr>
<hr>
<h3 id="数据类型">数据类型</h3>
<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在JavaScript中定义了以下几种数据类型：</p>
<h4 id="Number">Number</h4>
<p>JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>; <span class="comment">// 整数123</span></span><br><span class="line"><span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></span><br><span class="line"><span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></span><br><span class="line">-<span class="number">99</span>; <span class="comment">// 负数</span></span><br><span class="line"><span class="title class_">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></span><br><span class="line"><span class="title class_">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></span><br></pre></td></tr></table></figure>
<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等，它们和十进制表示的数值完全一样。</p>
<p>Number可以直接做四则运算，规则和数学一致：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">5</span> / <span class="number">2</span>; <span class="comment">// 7.5</span></span><br><span class="line"><span class="number">2</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="number">10</span> % <span class="number">3</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="number">10.5</span> % <span class="number">3</span>; <span class="comment">// 1.5</span></span><br></pre></td></tr></table></figure>
<p>注意<code>%</code>是求余运算。</p>
<p>要注意，JavaScript的Number不区分整数和浮点数，也就是说，<code>12.00 === 12</code>。（在大多数其他语言中，整数和浮点数不能直接比较）并且，JavaScript的整数最大范围不是±263，而是±253，因此，超过253的整数就可能无法精确表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 计算圆面积:</span><br><span class="line">var r = 123.456;</span><br><span class="line">var s = 3.14 * r * r;</span><br><span class="line">console.log(s); // 47857.94555904001</span><br><span class="line"></span><br><span class="line">// 打印Number能表示的最大整数:</span><br><span class="line">console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991</span><br></pre></td></tr></table></figure>
<h4 id="字符串">字符串</h4>
<p>字符串是以单引号’或双引号&quot;括起来的任意文本，比如<code>'abc'</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>''</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>'abc'</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。</p>
<h4 id="布尔值">布尔值</h4>
<p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>true</code>、<code>false</code>两种值，要么是<code>true</code>，要么是<code>false</code>，可以直接用<code>true</code>、<code>false</code>表示布尔值，也可以通过布尔运算计算出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>; <span class="comment">// 这是一个true值</span></span><br><span class="line"><span class="literal">false</span>; <span class="comment">// 这是一个false值</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span>; <span class="comment">// 这是一个true值</span></span><br><span class="line"><span class="number">2</span> &gt;= <span class="number">3</span>; <span class="comment">// 这是一个false值</span></span><br></pre></td></tr></table></figure>
<p><code>&amp;&amp;</code>运算是与运算，只有所有都为<code>true</code>，<code>&amp;&amp;</code>运算结果才是<code>true</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为true</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为false</span></span><br></pre></td></tr></table></figure>
<p><code>||</code>运算是或运算，只要其中有一个为<code>true</code>，<code>||</code>运算结果就是<code>true</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> || <span class="literal">false</span>; <span class="comment">// 这个||语句计算结果为false</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">// 这个||语句计算结果为true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">// 这个||语句计算结果为true</span></span><br></pre></td></tr></table></figure>
<p><code>!</code>运算是非运算，它是一个单目运算符，把<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">! <span class="literal">true</span>; <span class="comment">// 结果为false</span></span><br><span class="line">! <span class="literal">false</span>; <span class="comment">// 结果为true</span></span><br><span class="line">! (<span class="number">2</span> &gt; <span class="number">5</span>); <span class="comment">// 结果为true</span></span><br></pre></td></tr></table></figure>
<p>布尔值经常用在条件判断中，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;teenager&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较运算符">比较运算符</h3>
<p>当我们对Number做比较时，可以通过比较运算符得到一个布尔值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &gt; <span class="number">5</span>; <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> &gt;= <span class="number">2</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">7</span> == <span class="number">7</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>实际上，JavaScript允许对任意数据类型做比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> === <span class="number">0</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要特别注意相等运算符<code>==</code>。JavaScript在设计时，有两种比较运算符：</p>
<p>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p>
<p>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p>
<p>由于JavaScript这个设计缺陷，<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</p>
<p>另一个例外是<code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>最后要注意浮点数的相等比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / <span class="number">3</span> === (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="BigInt">BigInt</h4>
<p>要精确表示比253还大的整数，可以使用内置的BigInt类型，它的表示方法是在整数后加一个<code>n</code>，例如<code>9223372036854775808n</code>，也可以使用<code>BigInt()</code>把Number和字符串转换成BigInt：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用BigInt:</span><br><span class="line">var bi1 = 9223372036854775807n;</span><br><span class="line">var bi2 = BigInt(12345);</span><br><span class="line">var bi3 = BigInt(&quot;0x7fffffffffffffff&quot;);</span><br><span class="line">console.log(bi1 === bi2); // false</span><br><span class="line">console.log(bi1 === bi3); // true</span><br><span class="line">console.log(bi1 + bi2);</span><br></pre></td></tr></table></figure>
<p>使用BigInt可以正常进行加减乘除等运算，结果仍然是一个BigInt，但不能把一个BigInt和一个Number放在一起运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用BigInt:</span><br><span class="line">console.log(1234567n + 3456789n); // OK</span><br><span class="line">console.log(1234567n / 789n); // 1564, 除法运算结果仍然是BigInt</span><br><span class="line">console.log(1234567n % 789n); // 571, 求余</span><br><span class="line">console.log(1234567n + 3456789); // Uncaught TypeError: Cannot mix BigInt and other types</span><br></pre></td></tr></table></figure>
<h4 id="null和undefined">null和undefined</h4>
<p><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>''</code>不同，<code>0</code>是一个数值，<code>''</code>表示长度为0的字符串，而<code>null</code>表示“空”。</p>
<p>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</p>
<p>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</p>
<h4 id="数组">数组</h4>
<p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>
<p>上述数组包含6个元素。数组用<code>[]</code>表示，元素之间用<code>,</code>分隔。</p>
<p>另一种创建数组的方法是通过<code>Array()</code>函数实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建了数组[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>
<p>数组的元素可以通过索引来访问。请注意，索引的起始值为<code>0</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3.14, &#x27;Hello&#x27;, null, true];</span><br><span class="line">arr[0]; // 返回索引为0的元素，即1</span><br><span class="line">arr[5]; // 返回索引为5的元素，即true</span><br><span class="line">arr[6]; // 索引超出了范围，返回undefined</span><br><span class="line">console.log(arr[0], arr[5], arr[6]);</span><br></pre></td></tr></table></figure>
<h4 id="对象">对象</h4>
<p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">tags</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>],</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">    <span class="attr">hasCar</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">zipcode</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述<code>person</code>对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，<code>person</code>的<code>name</code>属性为<code>'Bob'</code>，<code>zipcode</code>属性为<code>null</code>。</p>
<p>要获取一个对象的属性，我们用<code>对象变量.属性名</code>的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.<span class="property">name</span>; <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line">person.<span class="property">zipcode</span>; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="变量">变量</h3>
<p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。申明一个变量用<code>var</code>语句，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 申明了变量a，此时a的值为undefined</span></span><br><span class="line"><span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></span><br><span class="line"><span class="keyword">var</span> s_007 = <span class="string">&#x27;007&#x27;</span>; <span class="comment">// s_007是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Answer</span> = <span class="literal">true</span>; <span class="comment">// Answer是一个布尔值true</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">null</span>; <span class="comment">// t的值是null</span></span><br></pre></td></tr></table></figure>
<p>变量名也可以用中文，但是，请不要给自己找麻烦。</p>
<p>在JavaScript中，使用等号<code>=</code>对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用<code>var</code>申明一次，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">// a的值是整数123</span></span><br><span class="line">a = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// a变为字符串</span></span><br></pre></td></tr></table></figure>
<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>; <span class="comment">// a是整数类型变量，类型用int申明</span></span><br><span class="line">a = <span class="string">&quot;ABC&quot;</span>; <span class="comment">// 错误：不能把字符串赋给整型变量</span></span><br></pre></td></tr></table></figure>
<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
<p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">x = x + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果从数学上理解<code>x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code>x + 2</code>，得到结果<code>12</code>，再赋给变量<code>x</code>。由于<code>x</code>之前的值是<code>10</code>，重新赋值后，<code>x</code>的值变成<code>12</code>。</p>
<p>要显示变量的内容，可以用<code>console.log(x)</code>，打开Chrome的控制台就可以看到结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 打印变量x</span><br><span class="line">var x = 100;</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure>
<p>使用<code>console.log()</code>代替<code>alert()</code>的好处是可以避免弹出烦人的对话框。</p>
<h3 id="strict模式">strict模式</h3>
<p>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span>; <span class="comment">// i现在是全局变量</span></span><br></pre></td></tr></table></figure>
<p>在同一个页面的不同的JavaScript文件中，如果都不用<code>var</code>申明，恰好都使用了变量<code>i</code>，将造成变量<code>i</code>互相影响，产生难以调试的错误结果。</p>
<p>使用<code>var</code>申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。</p>
<p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>
<p>来测试一下你的浏览器是否能支持strict模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    // 如果浏览器支持strict模式，</span><br><span class="line">    // 下面的代码将报ReferenceError错误:</span><br><span class="line">    helloStr = &#x27;hello&#x27;;</span><br><span class="line">    console.log(helloStr);</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure>
<p>运行代码，如果浏览器报错，请修复后再运行。如果浏览器不报错，说明你的浏览器太古老了，需要尽快升级。</p>
<p>不用<code>var</code>申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。</p>
<p>另一种申明变量的方式是<code>let</code>，这也是现代JavaScript推荐的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 用let申明变量:</span><br><span class="line">let s = &#x27;hello&#x27;;</span><br><span class="line">console.log(s);</span><br></pre></td></tr></table></figure>
<p>后续我们还会详细讨论<code>var</code>和<code>let</code>的区别。</p>
<p>JavaScript的字符串就是用<code>''</code>或<code>&quot;&quot;</code>括起来的字符表示。</p>
<p>如果<code>'</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I'm OK&quot;</code>包含的字符是<code>I</code>，<code>'</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</p>
<p>如果字符串内部既包含<code>'</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;I\&#x27;m \&quot;OK\&quot;!&#x27;</span>; <span class="comment">// I&#x27;m &quot;OK&quot;!</span></span><br></pre></td></tr></table></figure>
<p>表示的字符串内容是：<code>I'm &quot;OK&quot;!</code></p>
<p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>。</p>
<p>ASCII字符可以以<code>\x##</code>形式的十六进制表示，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\x41&#x27;</span>; <span class="comment">// 完全等同于 &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>
<p>还可以用<code>\u####</code>表示一个Unicode字符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\u4e2d\u6587&#x27;</span>; <span class="comment">// 完全等同于 &#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="多行字符串">多行字符串</h3>
<p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号`…`表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`这是一个</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">字符串`</span>;</span><br></pre></td></tr></table></figure>
<p><em>注意</em>：反引号在键盘的<code>ESC</code>下方，数字键<code>1</code>的左边：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐ ┌─────┬─────┬─────┬─────┐</span><br><span class="line">│ ESC │ │ F1  │ F2  │ F3  │ F4  │</span><br><span class="line">└─────┘ └─────┴─────┴─────┴─────┘</span><br><span class="line">┌─────┬─────┬─────┬─────┬─────┐</span><br><span class="line">│  ~  │  !  │  @  │  #  │  $  │</span><br><span class="line">│  `  │  1  │  2  │  3  │  4  │</span><br><span class="line">├─────┴──┬──┴──┬──┴──┬──┴──┬──┘</span><br><span class="line">│        │     │     │     │</span><br><span class="line">│  tab   │  Q  │  W  │  E  │</span><br><span class="line">├────────┴──┬──┴──┬──┴──┬──┘</span><br><span class="line">│           │     │     │</span><br><span class="line">│ caps lock │  A  │  S  │</span><br><span class="line">└───────────┴─────┴─────┘</span><br></pre></td></tr></table></figure>
<p>练习：测试你的浏览器是否支持ES6标准，如果不支持，请把多行字符串用<code>\n</code>重新表示出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果浏览器不支持ES6，将报SyntaxError错误:</span><br><span class="line">console.log(`多行</span><br><span class="line">字符串</span><br><span class="line">测试`);</span><br></pre></td></tr></table></figure>
<h3 id="模板字符串">模板字符串</h3>
<p>要把多个字符串连接起来，可以用<code>+</code>号连接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;你好, &#x27;</span> + name + <span class="string">&#x27;, 你今年&#x27;</span> + age + <span class="string">&#x27;岁了!&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>(message);</span><br></pre></td></tr></table></figure>
<p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line"><span class="title function_">alert</span>(message);</span><br></pre></td></tr></table></figure>
<p>练习：测试你的浏览器是否支持ES6模板字符串，如果不支持，请把模板字符串改为<code>+</code>连接的普通字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果浏览器支持模板字符串，将会替换字符串内部的变量:</span><br><span class="line">let name = &#x27;小明&#x27;;</span><br><span class="line">let age = 20;</span><br><span class="line">console.log(`你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`);</span><br></pre></td></tr></table></figure>
<h3 id="操作字符串">操作字符串</h3>
<p>字符串常见的操作如下：</p>
<p>获取字符串长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line">s.<span class="property">length</span>; <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>]; <span class="comment">// &#x27;H&#x27;</span></span><br><span class="line">s[<span class="number">6</span>]; <span class="comment">// &#x27; &#x27;</span></span><br><span class="line">s[<span class="number">7</span>]; <span class="comment">// &#x27;w&#x27;</span></span><br><span class="line">s[<span class="number">12</span>]; <span class="comment">// &#x27;!&#x27;</span></span><br><span class="line">s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></span><br></pre></td></tr></table></figure>
<p><em>需要特别注意的是</em>，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Test&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// s仍然为&#x27;Test&#x27;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p>
<h3 id="toUpperCase">toUpperCase</h3>
<p><code>toUpperCase()</code>把一个字符串全部变为大写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">s.<span class="title function_">toUpperCase</span>(); <span class="comment">// 返回&#x27;HELLO&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="toLowerCase">toLowerCase</h3>
<p><code>toLowerCase()</code>把一个字符串全部变为小写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lower = s.<span class="title function_">toLowerCase</span>(); <span class="comment">// 返回&#x27;hello&#x27;并赋值给变量lower</span></span><br><span class="line">lower; <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="indexOf">indexOf</h3>
<p><code>indexOf()</code>会搜索指定字符串出现的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;hello, world&#x27;</span>;</span><br><span class="line">s.<span class="title function_">indexOf</span>(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// 返回7</span></span><br><span class="line">s.<span class="title function_">indexOf</span>(<span class="string">&#x27;World&#x27;</span>); <span class="comment">// 没有找到指定的子串，返回-1</span></span><br></pre></td></tr></table></figure>
<h3 id="substring">substring</h3>
<p><code>substring()</code>返回指定索引区间的子串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回&#x27;hello&#x27;</span></span><br><span class="line">s.<span class="title function_">substring</span>(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回&#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript的<code>Array</code>可以包含任意数据类型，并通过索引来访问每个元素。</p>
<p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Array.length:</span><br><span class="line">let arr = [1, 2, 3.14, &#x27;Hello&#x27;, null, true];</span><br><span class="line">console.log(arr.length); // 6</span><br></pre></td></tr></table></figure>
<p><em>请注意</em>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];</span><br><span class="line">console.log(arr.length); // 3</span><br><span class="line">// 调整数组大小:</span><br><span class="line">arr.length = 6;</span><br><span class="line">console.log(arr); // arr变为[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, undefined, undefined, undefined]</span><br><span class="line">// 调整数组大小:</span><br><span class="line">arr.length = 2;</span><br><span class="line">console.log(arr); // arr变为[&#x27;A&#x27;, &#x27;B&#x27;]</span><br></pre></td></tr></table></figure>
<p><code>Array</code>可以通过索引把对应的元素修改为新的值，因此，对<code>Array</code>的索引进行赋值会直接修改这个<code>Array</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Array index:</span><br><span class="line">let arr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];</span><br><span class="line">arr[1] = 99;</span><br><span class="line">console.log(arr); // arr现在变为[&#x27;A&#x27;, 99, &#x27;C&#x27;]</span><br><span class="line">console.log(arr[1]); // 99</span><br></pre></td></tr></table></figure>
<p><em>请注意</em>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 索引超出范围会导致数组大小自动调整:</span><br><span class="line">let arr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];</span><br><span class="line">arr[5] = &#x27;x&#x27;;</span><br><span class="line">console.log(arr); // arr变为[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, undefined, undefined, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure>
<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的<code>Array</code>却不会有任何错误。在编写代码时，不建议直接修改<code>Array</code>的大小，访问索引时要确保索引不会越界。</p>
<h3 id="indexOf-2">indexOf</h3>
<p>与String类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;30&#x27;</span>); <span class="comment">// 元素&#x27;30&#x27;的索引为2</span></span><br></pre></td></tr></table></figure>
<p>注意了，数字<code>30</code>和字符串<code>'30'</code>是不同的元素。</p>
<h3 id="slice">slice</h3>
<p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.<span class="title function_">slice</span>(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>注意到<code>slice()</code>的起止参数包括开始索引，不包括结束索引。</p>
<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> aCopy = arr.<span class="title function_">slice</span>();</span><br><span class="line">aCopy; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">aCopy === arr; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="push和pop">push和pop</h3>
<p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line">arr.<span class="title function_">pop</span>(); <span class="comment">// pop()返回&#x27;B&#x27;</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;]</span></span><br><span class="line">arr.<span class="title function_">pop</span>(); arr.<span class="title function_">pop</span>(); arr.<span class="title function_">pop</span>(); <span class="comment">// 连续pop 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.<span class="title function_">pop</span>(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h3 id="unshift和shift">unshift和shift</h3>
<p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.<span class="title function_">shift</span>(); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">arr; <span class="comment">// [&#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.<span class="title function_">shift</span>(); arr.<span class="title function_">shift</span>(); arr.<span class="title function_">shift</span>(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.<span class="title function_">shift</span>(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h3 id="sort">sort</h3>
<p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>();</span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。</p>
<h3 id="reverse">reverse</h3>
<p><code>reverse()</code>把整个<code>Array</code>的元素给调个个，也就是反转：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">reverse</span>(); </span><br><span class="line">arr; <span class="comment">// [&#x27;three&#x27;, &#x27;two&#x27;, &#x27;one&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="splice">splice</h3>
<p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="concat">concat</h3>
<p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> added = arr.<span class="title function_">concat</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><em>请注意</em>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p>
<p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">concat</span>(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="join">join</h3>
<p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br></pre></td></tr></table></figure>
<p>练习：在新生欢迎会上，你已经拿到了新同学的名单，请排序后显示：欢迎XXX，XXX，XXX和XXX同学！：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;小明&#x27;, &#x27;小红&#x27;, &#x27;大军&#x27;, &#x27;阿黄&#x27;];</span><br><span class="line"></span><br><span class="line">console.log(&#x27;???&#x27;);</span><br></pre></td></tr></table></figure>
<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>
<h3 id="多维数组">多维数组</h3>
<p>如果数组的某个元素又是一个<code>Array</code>，则可以形成多维数组，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>], <span class="string">&#x27;-&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>上述<code>Array</code>包含3个元素，其中头两个元素本身也是<code>Array</code>。</p>
<p>练习：如何通过索引取到<code>500</code>这个值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [[1, 2, 3], [400, 500, 600], &#x27;-&#x27;];</span><br><span class="line"></span><br><span class="line">let x = ??;</span><br><span class="line">console.log(x); // x应该为500</span><br></pre></td></tr></table></figure>
<h3 id="小结">小结</h3>
<p><code>Array</code>提供了一种顺序存储一组元素的功能，并可以按索引来读写。</p>
<p>JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。</p>
<p>JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.70</span>,</span><br><span class="line">    <span class="attr">weight</span>: <span class="number">65</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JavaScript用一个<code>&#123;...&#125;</code>表示一个对象，键值对以<code>xxx: xxx</code>形式申明，用<code>,</code>隔开。注意，最后一个键值对不需要在末尾加<code>,</code>，如果加了，有的浏览器（如低版本的IE）将报错。</p>
<p>上述对象申明了一个<code>name</code>属性，值是<code>'小明'</code>，<code>birth</code>属性，值是<code>1990</code>，以及其他一些属性。最后，把这个对象赋值给变量<code>xiaoming</code>后，就可以通过变量<code>xiaoming</code>来获取小明的属性了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xiaoming.<span class="property">name</span>; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.<span class="property">birth</span>; <span class="comment">// 1990</span></span><br></pre></td></tr></table></figure>
<p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用<code>''</code>括起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaohong = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小红&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>''</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>['xxx']</code>来访问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaohong[<span class="string">&#x27;middle-school&#x27;</span>]; <span class="comment">// &#x27;No.1 Middle School&#x27;</span></span><br><span class="line">xiaohong[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// &#x27;小红&#x27;</span></span><br><span class="line">xiaohong.<span class="property">name</span>; <span class="comment">// &#x27;小红&#x27;</span></span><br></pre></td></tr></table></figure>
<p>也可以用<code>xiaohong['name']</code>来访问<code>xiaohong</code>的<code>name</code>属性，不过<code>xiaohong.name</code>的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过<code>object.prop</code>的形式访问一个属性了。</p>
<p>实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。</p>
<p>如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回<code>undefined</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line">let xiaoming = &#123;</span><br><span class="line">    name: &#x27;小明&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(xiaoming.name);</span><br><span class="line">console.log(xiaoming.age); // undefined</span><br></pre></td></tr></table></figure>
<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.<span class="property">age</span>; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.<span class="property">age</span> = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.<span class="property">age</span>; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.<span class="property">age</span>; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.<span class="property">age</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.<span class="property">name</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.<span class="property">school</span>; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure>
<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.70</span>,</span><br><span class="line">    <span class="attr">weight</span>: <span class="number">65</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因为<code>toString</code>定义在<code>object</code>对象中，而所有对象最终都会在原型链上指向<code>object</code>，所以<code>xiaoming</code>也拥有<code>toString</code>属性。</p>
<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="条件判断">条件判断</h2>
<p>JavaScript使用<code>if () &#123; ... &#125; else &#123; ... &#125;</code>来进行条件判断。例如，根据年龄显示不同内容，可以用<code>if</code>语句实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123; <span class="comment">// 如果age &gt;= 18为true，则执行if语句块</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则执行else语句块</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teenager&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>else</code>语句是可选的。如果语句块只包含一条语句，那么可以省略<code>&#123;&#125;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teenager&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>省略<code>&#123;&#125;</code>的危险之处在于，如果后来想添加一些语句，却忘了写<code>&#123;&#125;</code>，就改变了<code>if...else...</code>的语义，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let age = 20;</span><br><span class="line">if (age &gt;= 18)</span><br><span class="line">    console.log(&#x27;adult&#x27;);</span><br><span class="line">else</span><br><span class="line">    console.log(&#x27;age &lt; 18&#x27;); // 添加一行日志</span><br><span class="line">    console.log(&#x27;teenager&#x27;); // &lt;- 这行语句已经不在else的控制范围了</span><br></pre></td></tr></table></figure>
<p>上述代码的<code>else</code>子句实际上只负责执行<code>console.log('age &lt; 18');</code>，原有的<code>console.log('teenager');</code>已经不属于<code>if...else...</code>的控制范围了，它每次都会执行。</p>
<p>相反地，有<code>&#123;&#125;</code>的语句就不会出错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let age = 20;</span><br><span class="line">if (age &gt;= 18) &#123;</span><br><span class="line">    console.log(&#x27;adult&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;age &lt; 18&#x27;);</span><br><span class="line">    console.log(&#x27;teenager&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是为什么我们建议永远都要写上<code>&#123;&#125;</code>。</p>
<h3 id="多行条件判断">多行条件判断</h3>
<p>如果还要更细致地判断条件，可以使用多个<code>if...else...</code>的组合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teenager&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;kid&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述多个<code>if...else...</code>的组合实际上相当于两层<code>if...else...</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;adult&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;teenager&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;kid&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们通常把<code>else if</code>连写在一起，来增加可读性。这里的<code>else</code>略掉了<code>&#123;&#125;</code>是没有问题的，因为它只包含一个<code>if</code>语句。注意最后一个单独的<code>else</code>不要略掉<code>&#123;&#125;</code>。</p>
<p><em>请注意</em>，<code>if...else...</code>语句的执行特点是二选一，在多个<code>if...else...</code>语句中，如果某个条件成立，则后续就不再继续判断了。</p>
<p>试解释为什么下面的代码显示的是<code>teenager</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">let age = 20;</span><br><span class="line"></span><br><span class="line">if (age &gt;= 6) &#123;</span><br><span class="line">    console.log(&#x27;teenager&#x27;);</span><br><span class="line">&#125; else if (age &gt;= 18) &#123;</span><br><span class="line">    console.log(&#x27;adult&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;kid&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>age</code>的值为<code>20</code>，它实际上同时满足条件<code>age &gt;= 6</code>和<code>age &gt;= 18</code>，这说明条件判断的顺序非常重要。请修复后让其显示<code>adult</code>。</p>
<p>如果<code>if</code>的条件判断语句结果不是<code>true</code>或<code>false</code>怎么办？例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="property">length</span>) &#123; <span class="comment">// 条件计算结果为3</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript把<code>null</code>、<code>undefined</code>、<code>0</code>、<code>NaN</code>和空字符串<code>''</code>视为<code>false</code>，其他值一概视为<code>true</code>，因此上述代码条件判断的结果是<code>true</code>。</p>
<h3 id="练习-3">练习</h3>
<p>小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：</p>
<ul>
<li>低于18.5：过轻</li>
<li>18.5-25：正常</li>
<li>25-28：过重</li>
<li>28-32：肥胖</li>
<li>高于32：严重肥胖</li>
</ul>
<p>用<code>if...else...</code>判断并显示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let height = parseFloat(prompt(&#x27;请输入身高(m):&#x27;));</span><br><span class="line">let weight = parseFloat(prompt(&#x27;请输入体重(kg):&#x27;));</span><br><span class="line"></span><br><span class="line">// TODO:</span><br><span class="line">let bmi = ???;</span><br><span class="line">if ...</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<p>要计算1+2+3，我们可以直接写表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>要计算1+2+3+…+10，勉强也能写出来。</p>
<p>但是，要计算1+2+3+…+10000，直接写表达式就不可能了。</p>
<p>为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。</p>
<p>JavaScript的循环有两种，一种是<code>for</code>循环，通过初始条件、结束条件和递增条件来循环执行语句块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=<span class="number">10000</span>; i++) &#123;</span><br><span class="line">    x = x + i;</span><br><span class="line">&#125;</span><br><span class="line">x; <span class="comment">// 50005000</span></span><br></pre></td></tr></table></figure>
<p>让我们来分析一下<code>for</code>循环的控制条件：</p>
<ul>
<li>i=1 这是初始条件，将变量i置为1；</li>
<li>i&lt;=10000 这是判断条件，满足时就继续循环，不满足就退出循环；</li>
<li>i++ 这是每次循环后的递增条件，由于每次循环后变量i都会加1，因此它终将在若干次循环后不满足判断条件<code>i&lt;=10000</code>而退出循环。</li>
</ul>
<p>练习：利用<code>for</code>循环计算<code>1 * 2 * 3 * ... * 10</code>的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let x = ?;</span><br><span class="line">let i;</span><br><span class="line">for ...</span><br><span class="line"></span><br><span class="line">if (x === 3628800) &#123;</span><br><span class="line">    console.log(&#x27;1 x 2 x 3 x ... x 10 = &#x27; + x);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    console.log(&#x27;计算错误&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code>循环最常用的地方是利用索引来遍历数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> i, x;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    x = arr[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code>循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用<code>break</code>语句退出循环，否则就是死循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 将无限循环下去</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 通过if判断来退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    x ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-…-in">for … in</h3>
<p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要过滤掉对象继承的属性，用<code>hasOwnProperty()</code>来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a[i]); <span class="comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>请注意</em>，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p>
<h3 id="while">while</h3>
<p><code>for</code>循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的<code>for</code>循环容易让人看不清循环的逻辑，此时用<code>while</code>循环更佳。</p>
<p><code>while</code>循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x = x + n;</span><br><span class="line">    n = n - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">x; <span class="comment">// 2500</span></span><br></pre></td></tr></table></figure>
<p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足<code>while</code>条件，循环退出。</p>
<h3 id="do-…-while">do … while</h3>
<p>最后一种循环是<code>do &#123; ... &#125; while()</code>循环，它和<code>while</code>循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt; <span class="number">100</span>);</span><br><span class="line">n; <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>用<code>do &#123; ... &#125; while()</code>循环要小心，循环体会至少执行1次，而<code>for</code>和<code>while</code>循环则可能一次都不执行。</p>
<h3 id="练习-4">练习</h3>
<p>请利用循环遍历数组中的每个名字，并显示<code>Hello, xxx!</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;Bart&#x27;, &#x27;Lisa&#x27;, &#x27;Adam&#x27;];</span><br><span class="line"></span><br><span class="line">for ...</span><br></pre></td></tr></table></figure>
<p>请尝试<code>for</code>循环和<code>while</code>循环，并以正序、倒序两种方式遍历。</p>
<h3 id="小结-2">小结</h3>
<p>循环是让计算机做重复任务的有效的方法，有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。JavaScript的死循环会让浏览器无法正常显示或执行当前页面的逻辑，有的浏览器会直接挂掉，有的浏览器会在一段时间后提示你强行终止JavaScript的执行，因此，要特别注意死循环的问题。</p>
<p>在编写循环代码时，务必小心编写初始条件和判断条件，尤其是边界值。特别注意<code>i &lt; 100</code>和<code>i &lt;= 100</code>是不同的判断逻辑。</p>
<p>JavaScript的默认对象表示方式<code>&#123;&#125;</code>可以视为其他语言中的<code>Map</code>或<code>Dictionary</code>的数据结构，即一组键值对。</p>
<p>但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p>
<p>为了解决这个问题，最新的ES6规范引入了新的数据类型<code>Map</code>。要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let m = new Map();</span><br><span class="line">let s = new Set();</span><br><span class="line">console.log(&#x27;你的浏览器支持Map和Set！&#x27;);</span><br><span class="line">// 直接运行测试</span><br></pre></td></tr></table></figure>
<h3 id="Map">Map</h3>
<p><code>Map</code>是一组键值对的结构，具有极快的查找速度。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>Array</code>实现，需要两个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>];</span><br></pre></td></tr></table></figure>
<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p>
<p>如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]);</span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Michael&#x27;</span>); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>
<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 67</span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">88</span>);</span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>
<h3 id="Set">Set</h3>
<p><code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在<code>Set</code>中，没有重复的key。</p>
<p>要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p>重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意数字<code>3</code>和字符串<code>'3'</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="小结-3">小结</h3>
<p><code>Map</code>和<code>Set</code>是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p>
<p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p>
<p>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>
<p><code>for ... of</code>循环是ES6引入的新的语法，请测试你的浏览器是否支持：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3];</span><br><span class="line">for (let x of a) &#123;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;你的浏览器支持for ... of&#x27;);</span><br><span class="line">// 请直接运行测试</span><br></pre></td></tr></table></figure>
<p>用<code>for ... of</code>循环遍历集合，用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">0</span>] + <span class="string">&#x27;=&#x27;</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会有疑问，<code>for ... of</code>循环和<code>for ... in</code>循环有何区别？</p>
<p><code>for ... in</code>循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个<code>Array</code>数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p>
<p>当我们手动给<code>Array</code>对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for ... in</code>循环将把<code>name</code>包括在内，但<code>Array</code>的<code>length</code>属性却不包括在内。</p>
<p><code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是为什么要引入新的<code>for ... of</code>循环。</p>
<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];</span><br><span class="line">a.forEach(function (element, index, array) &#123;</span><br><span class="line">    // element: 指向当前元素的值</span><br><span class="line">    // index: 指向当前索引</span><br><span class="line">    // array: 指向Array对象本身</span><br><span class="line">    console.log(`$&#123;element&#125;, index = $&#123;index&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>注意</em>，<code>forEach()</code>方法是ES5.1标准引入的，你需要测试浏览器是否支持。</p>
<p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line">s.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Map</code>的回调函数参数依次为<code>value</code>、<code>key</code>和<code>map</code>本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line">m.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, key, map</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/26/JavaScript/JavaScript-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/24/java/JAVA-Spring%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/"
                            aria-label=": JAVA-Spring主从数据库的配置和动态数据源切换原理"
                        >
                            JAVA-Spring主从数据库的配置和动态数据源切换原理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-24T18:44:46+08:00">
	
		    2025 年 5 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在大型应用程序中，配置主从数据库并使用读写分离是常见的设计模式。在Spring应用程序中，要实现读写分离，最好不要对现有代码进行改动，而是在底层透明地支持。</p>
<p>Spring内置了一个<code>AbstractRoutingDataSource</code>，它可以把多个数据源配置成一个Map，然后，根据不同的key返回不同的数据源。因为<code>AbstractRoutingDataSource</code>也是一个DataSource接口，因此，应用程序可以先设置好key， 访问数据库的代码就可以从<code>AbstractRoutingDataSource</code>拿到对应的一个真实的数据源，从而访问指定的数据库。它的结构看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">   │        controller         │</span><br><span class="line">   │  set routing-key = &quot;xxx&quot;  │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">                 ▼</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">   │        logic code         │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">                 ▼</span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">   │    routing datasource     │</span><br><span class="line">   └───────────────────────────┘</span><br><span class="line">                 │</span><br><span class="line">       ┌─────────┴─────────┐</span><br><span class="line">       │                   │</span><br><span class="line">       ▼                   ▼</span><br><span class="line">┌─────────────┐     ┌─────────────┐</span><br><span class="line">│ read-write  │     │  read-only  │</span><br><span class="line">│ datasource  │     │ datasource  │</span><br><span class="line">└─────────────┘     └─────────────┘</span><br><span class="line">       │                   │</span><br><span class="line">       ▼                   ▼</span><br><span class="line">┌─────────────┐     ┌─────────────┐</span><br><span class="line">│  Master DB  │────▶│  Slave DB   │</span><br><span class="line">└─────────────┘     └─────────────┘</span><br></pre></td></tr></table></figure>
<h3 id="第一步：配置多数据源">第一步：配置多数据源</h3>
<p>首先，我们在SpringBoot中配置两个数据源，其中第二个数据源是<code>ro-datasource</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">rw</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">rw_password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">HikariCP</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="string">...</span></span><br><span class="line">  <span class="attr">ro-datasource:</span></span><br><span class="line">    <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ro</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ro_password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">HikariCP</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>在开发环境下，没有必要配置主从数据库。只需要给数据库设置两个用户，一个<code>rw</code>具有读写权限，一个<code>ro</code>只有SELECT权限，这样就模拟了生产环境下对主从数据库的读写分离。</p>
<p>在SpringBoot的配置代码中，我们初始化两个数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringBootApplication</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Master data source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;masterDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">masterDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">       logger.info(<span class="string">&quot;create master datasource...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Slave (read only) data source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;slaveDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.ro-datasource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">slaveDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;create slave datasource...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二步：编写RoutingDataSource">第二步：编写RoutingDataSource</h3>
<p>然后，我们用Spring内置的RoutingDataSource，把两个真实的数据源代理为一个动态数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;masterDataSource&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这个<code>RoutingDataSource</code>，需要在SpringBoot中配置好并设置为主数据源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringBootApplication</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    DataSource <span class="title function_">primaryDataSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource,</span></span><br><span class="line"><span class="params">            <span class="meta">@Autowired</span> <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;create routing datasource...&quot;</span>);</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;masterDataSource&quot;</span>, masterDataSource);</span><br><span class="line">        map.put(<span class="string">&quot;slaveDataSource&quot;</span>, slaveDataSource);</span><br><span class="line">        <span class="type">RoutingDataSource</span> <span class="variable">routing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSource</span>();</span><br><span class="line">        routing.setTargetDataSources(map);</span><br><span class="line">        routing.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">        <span class="keyword">return</span> routing;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，RoutingDataSource配置好了，但是，路由的选择是写死的，即永远返回<code>&quot;masterDataSource&quot;</code>，</p>
<p>现在问题来了：如何存储动态选择的key以及在哪设置key？</p>
<p>在Servlet的线程模型中，使用ThreadLocal存储key最合适，因此，我们编写一个RoutingDataSourceContext，来设置并动态存储key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSourceContext</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// holds data source key in thread local:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocalDataSourceKey = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDataSourceRoutingKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> threadLocalDataSourceKey.get();</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="string">&quot;masterDataSource&quot;</span> : key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoutingDataSourceContext</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        threadLocalDataSourceKey.set(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocalDataSourceKey.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，修改RoutingDataSource，获取key的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RoutingDataSourceContext.getDataSourceRoutingKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在某个地方，例如一个Controller的方法内部，就可以动态设置DataSource的Key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Get(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;slaveDataSource&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RoutingDataSourceContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSourceContext</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;html... www.liaoxuefeng.com&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，我们已经成功实现了数据库的动态路由访问。</p>
<p>这个方法是可行的，但是，需要读从数据库的地方，就需要加上一大段<code>try (RoutingDataSourceContext ctx = ...) &#123;&#125;</code>代码，使用起来十分不便。有没有方法可以简化呢？</p>
<p>有！</p>
<p>我们仔细想想，Spring提供的声明式事务管理，就只需要一个<code>@Transactional()</code>注解，放在某个Java方法上，这个方法就自动具有了事务。</p>
<p>我们也可以编写一个类似的<code>@RoutingWith(&quot;slaveDataSource&quot;)</code>注解，放到某个Controller的方法上，这个方法内部就自动选择了对应的数据源。代码看起来应该像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Get(&quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@RoutingWith(&quot;slaveDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;html... www.liaoxuefeng.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，完全不修改应用程序的逻辑，只在必要的地方加上注解，自动实现动态数据源切换，这个方法是最简单的。</p>
<p>想要在应用程序中少写代码，我们就得多做一点底层工作：必须使用类似Spring实现声明式事务的机制，即用AOP实现动态数据源切换。</p>
<p>实现这个功能也非常简单，编写一个<code>RoutingAspect</code>，利用AspectJ实现一个<code>Around</code>拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(routingWith)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">routingWithDataSource</span><span class="params">(ProceedingJoinPoint joinPoint, RoutingWith routingWith)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> routingWith.value();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RoutingDataSourceContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingDataSourceContext</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意方法的第二个参数<code>RoutingWith</code>是Spring传入的注解实例，我们根据注解的<code>value()</code>获取配置的key。编译前需要添加一个Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到此为止，我们就实现了用注解动态选择数据源的功能。最后一步重构是用字符串常量替换散落在各处的<code>&quot;masterDataSource&quot;</code>和<code>&quot;slaveDataSource&quot;</code>。</p>
<h3 id="使用限制">使用限制</h3>
<p>受Servlet线程模型的局限，动态数据源不能在一个请求内设定后再修改，也就是<code>@RoutingWith</code>不能嵌套。此外，<code>@RoutingWith</code>和<code>@Transactional</code>混用时，要设定AOP的优先级。</p>
<p>本文代码需要SpringBoot支持，JDK 1.8编译并打开<code>-parameters</code>编译参数。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/24/java/JAVA-Spring%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/24/java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
                            aria-label=": JAVA-设计模式"
                        >
                            JAVA-设计模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-24T17:50:55+08:00">
	
		    2025 年 5 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="设计模式">设计模式</h2>
<p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p>
<p>设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns</a>的书。这四人也被称为四人帮（GoF）。</p>
<p>为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：</p>
<h3 id="开闭原则">开闭原则</h3>
<p>由Bertrand Meyer提出的开闭原则（Open Closed Principle）是指，软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</p>
<h3 id="里氏替换原则">里氏替换原则</h3>
<p>里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p>
<p>设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF把23个常用模式分为创建型模式、结构型模式和行为型模式三类，我们后续会一一讲解。</p>
<p>学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计的复杂度和灵活性，并意识到设计模式也并不是万能的。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/24/java/JAVA-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/"
                            aria-label=": 函数式编程的核心思想"
                        >
                            函数式编程的核心思想
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-23T16:53:02+08:00">
	
		    2025 年 5 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/">计算机基础理论</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>函数式编程最近几年越炒越热，有函数式编程的语言鄙视没有函数式编程的语言，纯函数式编程的语言鄙视不纯的函数式编程的语言。</p>
<p>那么，到底什么是函数式编程，函数式编程的核心思想又是什么？</p>
<p>函数式编程的第一个特点就是可以把函数作为参数传递给另一个函数，也就是所谓的高阶函数。例如，对数组进行排序，可以传入一个排序函数作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123; <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Apple&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(array, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>
<p>函数式编程的第二个特点就是可以返回一个函数，这样就可以实现闭包或者惰性计算：</p>
<p>以上两个特点还仅仅是简化了代码。从代码的可维护性上讲，函数式编程最大的好处是引用透明，即函数运行的结果只依赖于输入的参数，而不依赖于外部状态，因此，我们常常说函数式编程没有副作用。</p>
<p>没有副作用有个巨大的好处，就是函数内部无状态，即输入确定，输出就是确定的，容易测试和维护。</p>
<p>很多初学者容易纠结“纯”函数式语言，认为只有Haskell这种消除了变量和副作用的语言才是正宗的函数式编程。还有人甚至认为纯函数不能有任何IO操作，包括打行日志都不行。</p>
<p>其实这种纠结是没有意义的，因为计算机底层就是一个完全可变的内存和不可预测输入的系统，追求完美的无副作用是不现实的，我们只需要理解函数式编程的思想，把业务逻辑做到“无副作用”，至于有变量、打日志、读缓存这些无关紧要的“副作用”，根本不用担心，不需要解决，也几乎没法解决。</p>
<p>我们来举个栗子。</p>
<p>比如一个财务软件，需要一个函数专门计算个人所得税，输入是一个<code>IncomeRecord</code>，输出是个税金额：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又假设<code>IncomeRecord</code>长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncomeRecord</span> &#123;</span><br><span class="line">    String id; <span class="comment">// 身份证号</span></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">double</span> salary; <span class="comment">// 工资</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不考虑五险一金这些乱七八糟的东西，我们只关注如何计算个税。为了简化，我们假设直接扣除一个免征额后按20%计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">3500</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> record.salary &lt;= threshold ? <span class="number">0</span> : (record.salary - threshold) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序在2018年9月1号前是没问题的，问题是2018年9月1号后起征点调整到了5000，那2018年8月和2018年9月，计算结果应该不一样。怎么改？</p>
<p>普通开发者的改法：那还不简单？直接获取当前日期，返回正确的起征点就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> today() &lt; date(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">1</span>) ? <span class="number">3500</span> : <span class="number">5000</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> record.salary &lt;= threshold ? <span class="number">0</span> : (record.salary - threshold) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序是没错，问题是：</p>
<p>同样的输入，8月31号跑，和9月1号跑，结果不一样，难道会计要在9月1号做8月份的工资条，必须把电脑的时间先调到8月份？</p>
<p>用函数式编程的观点思考一下，就发现问题所在：</p>
<p><code>today()</code>这个函数，返回结果与时间有关，这就造成了<code>calculateIncomeTax()</code>不再是一个纯函数，它与当前时间相关了。</p>
<p>那怎么把<code>calculateIncomeTax()</code>恢复成一个纯函数，同时要支持起征点调整？</p>
<p>方法是把时间相关的变量作为参数传进来，例如，给<code>IncomeRecord</code>增加几个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncomeRecord</span> &#123;</span><br><span class="line">    String id; <span class="comment">// 身份证号</span></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">double</span> salary; <span class="comment">// 工资</span></span><br><span class="line">    <span class="type">int</span> year; <span class="comment">// 年</span></span><br><span class="line">    <span class="type">int</span> month; <span class="comment">// 月</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以消除<code>today()</code>的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">calculateIncomeTax</span><span class="params">(IncomeRecord record)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">threshold</span> <span class="operator">=</span> date(record.year, record.month) &lt; date(<span class="number">2018</span>, <span class="number">9</span>) ? <span class="number">3500</span> : <span class="number">5000</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tax</span> <span class="operator">=</span> record.salary &lt;= threshold ? <span class="number">0</span> : (record.salary - threshold) * <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">return</span> tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>calculateIncomeTax()</code>又变成了一个纯函数，会计就不用改电脑时间了。</p>
<p>是不是觉得这个例子太简单了？其实简单的函数如果都能写成有状态的，那么复杂的业务逻辑必然写成一锅粥。</p>
<p>举个复杂的栗子：</p>
<p>对于一个股票交易系统，如果我们把输入定义为：开盘前所有股民的现金和持股，以及交易时段的所有订单，那么，输出就是收盘后所有股民的现金和持股：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StockStatus <span class="title function_">process</span><span class="params">(StockStatus old, List&lt;Order&gt; orders)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">        ...</span><br><span class="line">        sendExchangeResult(...); <span class="comment">// 给每一笔成交发送信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然这是一个纯函数，虽然在处理过程中，这个函数会给股民朋友发送各种心跳消息。</p>
<p>如果把交易系统的模型设计成这样一个纯函数，那么理论上我们只需要从股市开市的那一天开始，把所有订单全部处理一遍，就可以正确得到今天收盘后的状态。</p>
<p>或者说，只要取任意一天开盘前的系统状态的备份（就是整个数据库的备份），把当天的订单重新处理一遍，就得到了当天收盘的状态。这个过程可以做任意次，结果不变，因此，非常适合验证代码的修改是否影响了业务流程。</p>
<p>那么问题来了，交易系统中有无数和时间相关的状态，怎么处理成纯函数？这个模型的处理，可比计算个税复杂多了。</p>
<p>这就是函数式编程的精髓：业务系统模型无状态。模型的好坏，直接影响到代码的正确性、可靠性、稳定性，以及是否需要996。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/23/makefile%E6%95%99%E7%A8%8B/"
                            aria-label=": makefile教程"
                        >
                            makefile教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-23T12:48:01+08:00">
	
		    2025 年 5 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/make/">make</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="简介">简介</h2>
<p>Linux的<code>make</code>程序用来自动化编译大型源码，很多时候，我们在Linux下编译安装软件，只需要敲一个<code>make</code>就可以全自动完成，非常方便。</p>
<p><code>make</code>能自动化完成这些工作，是因为项目提供了一个<code>Makefile</code>文件，它负责告诉<code>make</code>，应该如何编译和链接程序。</p>
<p><code>Makefile</code>相当于Java项目的<code>pom.xml</code>，Node工程的<code>package.json</code>，Rust项目的<code>Cargo.toml</code>，不同之处在于，<code>make</code>虽然最初是针对C语言开发，但它实际上并不限定C语言，而是可以应用到任意项目，甚至不是编程语言。此外，<code>make</code>主要用于Unix/Linux环境的自动化开发，掌握<code>Makefile</code>的写法，可以更好地在Linux环境下做开发，也可以为后续开发Linux内核做好准备。</p>
<p>在本教程中，我们将由浅入深，一步一步学习如何编写<code>Makefile</code>，完全针对零基础小白，只需要提前掌握如何使用Linux命令。</p>
<hr>
<hr>
<p>在Linux环境下，当我们输入<code>make</code>命令时，它就在当前目录查找一个名为<code>Makefile</code>的文件，然后，根据这个文件定义的规则，自动化地执行任意命令，包括编译命令。</p>
<p><code>Makefile</code>这个单词，顾名思义，就是指如何生成文件。</p>
<p>我们举个例子：在当前目录下，有3个文本文件：<code>a.txt</code>，<code>b.txt</code>和<code>c.txt</code>。</p>
<p>现在，我们要合并<code>a.txt</code>与<code>b.txt</code>，生成中间文件<code>m.txt</code>，再用中间文件<code>m.txt</code>与<code>c.txt</code>合并，生成最终的目标文件<code>x.txt</code>，整个逻辑如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│a.txt│ │b.txt│ │c.txt│</span><br><span class="line">└─────┘ └─────┘ └─────┘</span><br><span class="line">   │       │       │</span><br><span class="line">   └───┬───┘       │</span><br><span class="line">       │           │</span><br><span class="line">       ▼           │</span><br><span class="line">    ┌─────┐        │</span><br><span class="line">    │m.txt│        │</span><br><span class="line">    └─────┘        │</span><br><span class="line">       │           │</span><br><span class="line">       └─────┬─────┘</span><br><span class="line">             │</span><br><span class="line">             ▼</span><br><span class="line">          ┌─────┐</span><br><span class="line">          │x.txt│</span><br><span class="line">          └─────┘</span><br></pre></td></tr></table></figure>
<p>根据上述逻辑，我们来编写<code>Makefile</code>。</p>
<h3 id="规则">规则</h3>
<p><code>Makefile</code>由若干条规则（Rule）构成，每一条规则指出一个目标文件（Target），若干依赖文件（prerequisites），以及生成目标文件的命令。</p>
<p>例如，要生成<code>m.txt</code>，依赖<code>a.txt</code>与<code>b.txt</code>，规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 目标文件: 依赖文件1 依赖文件2</span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>一条规则的格式为<code>目标文件: 依赖文件1 依赖文件2 ...</code>，紧接着，以Tab开头的是命令，用来生成目标文件。上述规则使用<code>cat</code>命令合并了<code>a.txt</code>与<code>b.txt</code>，并写入到<code>m.txt</code>。用什么方式生成目标文件<code>make</code>并不关心，因为命令完全是我们自己写的，可以是编译命令，也可以是<code>cp</code>、<code>mv</code>等任何命令。</p>
<p>以<code>#</code>开头的是注释，会被<code>make</code>命令忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Makefile的规则中，命令必须以Tab开头，不能是空格。</span><br></pre></td></tr></table></figure>
<p>类似的，我们写出生成<code>x.txt</code>的规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p>由于<code>make</code>执行时，默认执行第一条规则，所以，我们把规则<code>x.txt</code>放到前面。完整的<code>Makefile</code>如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.txt: m.txt c.txt</span><br><span class="line">	cat m.txt c.txt &gt; x.txt</span><br><span class="line"></span><br><span class="line">m.txt: a.txt b.txt</span><br><span class="line">	cat a.txt b.txt &gt; m.txt</span><br></pre></td></tr></table></figure>
<p>在当前目录创建<code>a.txt</code>、<code>b.txt</code>和<code>c.txt</code>，输入一些内容，执行<code>make</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat a.txt b.txt &gt; m.txt</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p><code>make</code>默认执行第一条规则，也就是创建<code>x.txt</code>，但是由于<code>x.txt</code>依赖的文件<code>m.txt</code>不存在（另一个依赖<code>c.txt</code>已存在），故需要先执行规则<code>m.txt</code>创建出<code>m.txt</code>文件，再执行规则<code>x.txt</code>。执行完成后，当前目录下生成了两个文件<code>m.txt</code>和<code>x.txt</code>。</p>
<p>可见，<code>Makefile</code>定义了一系列规则，每个规则在满足依赖文件的前提下执行命令，就能创建出一个目标文件，这就是英文Make file的意思。</p>
<p>把默认执行的规则放第一条，其他规则的顺序是无关紧要的，因为<code>make</code>执行时自动判断依赖。</p>
<p>此外，<code>make</code>会打印出执行的每一条命令，便于我们观察执行顺序以便调试。</p>
<p>如果我们再次运行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">make: `x.txt&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p><code>make</code>检测到<code>x.txt</code>已经是最新版本，无需再次执行，因为<code>x.txt</code>的创建时间晚于它依赖的<code>m.txt</code>和<code>c.txt</code>的最后修改时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make使用文件的创建和修改时间来判断是否应该更新一个目标文件。</span><br></pre></td></tr></table></figure>
<p>修改<code>c.txt</code>后，运行<code>make</code>，会触发<code>x.txt</code>的更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure>
<p>但并不会触发<code>m.txt</code>的更新，原因是<code>m.txt</code>的依赖<code>a.txt</code>与<code>b.txt</code>并未更新，所以，<code>make</code>只会根据<code>Makefile</code>去执行那些必要的规则，并不会把所有规则都无脑执行一遍。</p>
<p>在编译大型程序时，全量编译往往需要几十分钟甚至几个小时。全量编译完成后，如果仅修改了几个文件，再全部重新编译完全没有必要，用<code>Makefile</code>实现增量编译就十分节省时间。</p>
<p>当然，是否能正确地实现增量更新，取决于我们的规则写得对不对，<code>make</code>本身并不会检查规则逻辑是否正确。</p>
<h3 id="伪目标">伪目标</h3>
<p>因为<code>m.txt</code>与<code>x.txt</code>都是自动生成的文件，所以，可以安全地删除。</p>
<p>删除时，我们也不希望手动删除，而是编写一个<code>clean</code>规则来删除它们：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p><code>clean</code>规则与我们前面编写的规则有所不同，它没有依赖文件，因此，要执行<code>clean</code>，必须用命令<code>make clean</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm -f m.txt</span><br><span class="line">rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>然而，在执行<code>clean</code>时，我们并没有创建一个名为<code>clean</code>的文件，所以，因为目标文件<code>clean</code>不存在，每次运行<code>make clean</code>，都会执行这个规则的命令。</p>
<p>如果我们手动创建一个<code>clean</code>的文件，这个<code>clean</code>规则就不会执行了！</p>
<p>如果我们希望<code>make</code>把<code>clean</code>不要视为文件，可以添加一个标识：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f m.txt</span><br><span class="line">	rm -f x.txt</span><br></pre></td></tr></table></figure>
<p>此时，<code>clean</code>就不被视为一个文件，而是伪目标（Phony Target）。</p>
<p>大型项目通常会提供<code>clean</code>、<code>install</code>这些约定俗成的伪目标名称，方便用户快速执行特定任务。</p>
<p>一般来说，并不需要用<code>.PHONY</code>标识<code>clean</code>等约定俗成的伪目标名称，除非有人故意搞破坏，手动创建名字叫<code>clean</code>的文件。</p>
<h3 id="执行多条命令">执行多条命令</h3>
<p>一个规则可以有多条命令，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd:</span></span><br><span class="line">	pwd</span><br><span class="line">	cd ..</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>执行<code>cd</code>规则：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make cd</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">cd ..</span><br><span class="line">pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br></pre></td></tr></table></figure>
<p>观察输出，发现<code>cd ..</code>命令执行后，并未改变当前目录，两次输出的<code>pwd</code>是一样的，这是因为<code>make</code>针对每条命令，都会创建一个独立的Shell环境，类似<code>cd ..</code>这样的命令，并不会影响当前目录。</p>
<p>解决办法是把多条命令以<code>;</code>分隔，写到一行：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; cd ..; pwd;</span><br></pre></td></tr></table></figure>
<p>再执行<code>cd_ok</code>目标就得到了预期结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make cd_ok</span><br><span class="line">pwd; cd ..; pwd</span><br><span class="line">/home/ubuntu/makefile-tutorial/v1</span><br><span class="line">/home/ubuntu/makefile-tutorial</span><br></pre></td></tr></table></figure>
<p>可以使用<code>\</code>把一行语句拆成多行，便于浏览：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	pwd; \</span><br><span class="line">	cd ..; \</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>另一种执行多条命令的语法是用<code>&amp;&amp;</code>，它的好处是当某条命令失败时，后续命令不会继续执行：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">	cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure>
<h3 id="控制打印">控制打印</h3>
<p>默认情况下，<code>make</code>会打印出它执行的每一条命令。如果我们不想打印某一条命令，可以在命令前加上<code>@</code>，表示不打印命令（但是仍然会执行）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">	@echo &#x27;not display&#x27;</span><br><span class="line">	echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make no_output</span><br><span class="line">not display</span><br><span class="line">echo &#x27;will display&#x27;</span><br><span class="line">will display</span><br></pre></td></tr></table></figure>
<p>注意命令<code>echo 'not display'</code>本身没有打印，但命令仍然会执行，并且执行的结果仍然正常打印。</p>
<h3 id="控制错误">控制错误</h3>
<p><code>make</code>在执行命令时，会检查每一条命令的返回值，如果返回错误（非0值），就会中断执行。</p>
<p>例如，不使用<code>-f</code>删除一个不存在的文件会报错：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">has_error:</span></span><br><span class="line">	rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>执行上述目标，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make has_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: *** [has_error] Error 1</span><br></pre></td></tr></table></figure>
<p>由于命令<code>rm zzz.txt</code>报错，导致后面的命令<code>echo 'ok'</code>并不会执行，<code>make</code>打印出错误，然后退出。</p>
<p>有些时候，我们想忽略错误，继续执行后续命令，可以在需要忽略错误的命令前加上<code>-</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">	-rm zzz.txt</span><br><span class="line">	echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure>
<p>执行上述目标，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make ignore_error</span><br><span class="line">rm zzz.txt</span><br><span class="line">rm: zzz.txt: No such file or directory</span><br><span class="line">make: [ignore_error] Error 1 (ignored)</span><br><span class="line">echo &#x27;ok&#x27;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p><code>make</code>检测到<code>rm zzz.txt</code>报错，并打印错误，但显示<code>(ignored)</code>，然后继续执行后续命令。</p>
<p>对于执行可能出错，但不影响逻辑的命令，可以用<code>-</code>忽略。</p>
<h3 id="参考源码">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v1">GitHub</a>下载源码。</p>
<h3 id="小结">小结</h3>
<p>编写<code>Makefile</code>就是编写一系列规则，用来告诉<code>make</code>如何执行这些规则，最终生成我们期望的目标文件。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Rules.html">编写规则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Execution.html">执行命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">伪目标</a></li>
</ul>
<h2 id="编译C程序">编译C程序</h2>
<p>C程序的编译通常分两步：</p>
<ol>
<li>将每个<code>.c</code>文件编译为<code>.o</code>文件；</li>
<li>将所有<code>.o</code>文件链接为最终的可执行文件。</li>
</ol>
<p>我们假设如下的一个C项目，包含<code>hello.c</code>、<code>hello.h</code>和<code>main.c</code>。</p>
<p><code>hello.c</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hello.h</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>main.c</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>main.c</code>引用了头文件<code>hello.h</code>。我们很容易梳理出需要生成的文件，逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐ ┌───────┐ ┌───────┐</span><br><span class="line">│hello.c│ │main.c │ │hello.h│</span><br><span class="line">└───────┘ └───────┘ └───────┘</span><br><span class="line">    │         │         │</span><br><span class="line">    │         └────┬────┘</span><br><span class="line">    │              │</span><br><span class="line">    ▼              ▼</span><br><span class="line">┌───────┐      ┌───────┐</span><br><span class="line">│hello.o│      │main.o │</span><br><span class="line">└───────┘      └───────┘</span><br><span class="line">    │              │</span><br><span class="line">    └───────┬──────┘</span><br><span class="line">            │</span><br><span class="line">            ▼</span><br><span class="line">       ┌─────────┐</span><br><span class="line">       │world.out│</span><br><span class="line">       └─────────┘</span><br></pre></td></tr></table></figure>
<p>假定最终生成的可执行文件是<code>world.out</code>，中间步骤还需要生成<code>hello.o</code>和<code>main.o</code>两个文件。根据上述依赖关系，我们可以很容易地写出<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c:</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c:</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">	cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>在当前目录下可以看到<code>hello.o</code>、<code>main.o</code>以及最终的可执行程序<code>world.out</code>。执行<code>world.out</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, world!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>与我们预期相符。</p>
<p>修改<code>hello.c</code>，把输出改为<code>&quot;hello, bob!\n&quot;</code>，再执行<code>make</code>，观察输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>仅重新编译了<code>hello.c</code>，并未编译<code>main.c</code>。由于<code>hello.o</code>已更新，所以，仍然要重新生成<code>world.out</code>。执行<code>world.out</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./world.out </span><br><span class="line">start...</span><br><span class="line">hello, bob!</span><br><span class="line">exit.</span><br></pre></td></tr></table></figure>
<p>与我们预期相符。</p>
<p>修改<code>hello.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 变为 void:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>以及<code>hello.c</code>，再次执行<code>make</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>会触发<code>main.c</code>的编译，因为<code>main.c</code>依赖<code>hello.h</code>。</p>
<p>执行<code>make clean</code>会删除所有的<code>.o</code>文件，以及可执行文件<code>world.out</code>，再次执行<code>make</code>就会强制全量编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make clean &amp;&amp; make</span><br><span class="line">rm -f *.o world.out</span><br><span class="line">cc -c hello.c</span><br><span class="line">cc -c main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>这个简单的<code>Makefile</code>使我们能自动化编译C程序，十分方便。</p>
<p>不过，随着越来越多的<code>.c</code>文件被添加进来，如何高效维护<code>Makefile</code>的规则？我们后面继续讲解。</p>
<h3 id="参考源码-2">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v2">GitHub</a>下载源码。</p>
<h3 id="小结-2">小结</h3>
<p>在<code>Makefile</code>正确定义规则后，我们就能用<code>make</code>自动化编译C程序。</p>
<hr>
<hr>
<h2 id="使用隐式规则">使用隐式规则</h2>
<p>我们仍然以上一节的C项目为例，当我们添加越来越多的<code>.c</code>文件时，就需要编写越来越多的规则来生成<code>.o</code>文件。</p>
<p>实际上，有的同学可能发现了，即使我们把<code>.o</code>的规则删掉，也能正常编译：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则:</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>我们没有定义<code>hello.o</code>和<code>main.o</code>的规则，为什么<code>make</code>也能正常创建这两个文件？</p>
<p>因为<code>make</code>最初就是为了编译C程序而设计的，为了免去重复创建编译<code>.o</code>文件的规则，<code>make</code>内置了隐式规则（Implicit Rule），即遇到一个<code>xyz.o</code>时，如果没有找到对应的规则，就自动应用一个隐式规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">xyz.o: xyz.c</span></span><br><span class="line">	cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure>
<p><code>make</code>针对C、C++、ASM、Fortran等程序内置了一系列隐式规则，可以参考官方手册查看。</p>
<p>对于C程序来说，使用隐式规则有一个潜在问题，那就是无法跟踪<code>.h</code>文件的修改。如果我们修改了<code>hello.h</code>的定义，由于隐式规则<code>main.o: main.c</code>并不会跟踪<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译，这个问题我们放到后面解决。</p>
<h3 id="参考源码-3">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v3">GitHub</a>下载源码。</p>
<h3 id="小结-3">小结</h3>
<p>针对C、C++、ASM、Fortran等程序，<code>make</code>内置了一系列隐式规则，使用隐式规则可减少大量重复的通用编译规则。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Using-Implicit.html">使用隐式规则</a></li>
</ul>
<hr>
<hr>
<p>当我们在<code>Makefile</code>中重复写很多文件名时，一来容易写错，二来如果要改名，要全部替换，费时费力。</p>
<p>编程语言使用变量（Variable）来解决反复引用的问题，类似的，在<code>Makefile</code>中，也可以使用变量来解决重复问题。</p>
<p>以上一节的<code>Makefile</code>为例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o world.out</span><br></pre></td></tr></table></figure>
<p>编译的最终文件<code>world.out</code>重复出现了3次，因此，完全可以定义一个变量来替换它：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: hello.o main.o</span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>变量定义用<code>变量名 = 值</code>或者<code>变量名 := 值</code>，通常变量名全大写。引用变量用<code>$(变量名)</code>，非常简单。</p>
<p>注意到<code>hello.o main.o</code>这个“列表”也重复了，我们也可以用变量来替换：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJS = hello.o main.o</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>如果有一种方式能让<code>make</code>自动生成<code>hello.o main.o</code>这个“列表”，就更好了。注意到每个<code>.o</code>文件是由对应的<code>.c</code>文件编译产生的，因此，可以让<code>make</code>先获取<code>.c</code>文件列表，再替换，得到<code>.o</code>文件列表：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $(wildcard *.c) 列出当前目录下的所有 .c 文件: hello.c main.c</span></span><br><span class="line"><span class="comment"># 用函数 patsubst 进行模式替换得到: hello.o main.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>这样，我们每添加一个<code>.c</code>文件，不需要修改<code>Makefile</code>，变量<code>OBJS</code>会自动更新。</p>
<p>思考：为什么我们不能直接定义<code>OBJS = $(wildcard *.o)</code>让<code>make</code>列出所有<code>.o</code>文件？</p>
<h3 id="内置变量">内置变量</h3>
<p>我们还可以用变量<code>$(CC)</code>替换命令<code>cc</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
<p>没有定义变量<code>CC</code>也可以引用它，因为它是<code>make</code>的内置变量（Builtin Variables），表示C编译器的名字，默认值是<code>cc</code>，我们也可以修改它，例如使用交叉编译时，指定编译器：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC = riscv64-linux-gnu-gcc</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="自动变量">自动变量</h3>
<p>在<code>Makefile</code>中，经常可以看到<code>$@</code>、<code>$&lt;</code>这样的变量，这种变量称为自动变量（Automatic Variable），它们在一个规则中自动指向某个值。</p>
<p>例如，<code>$@</code>表示目标文件，<code>$^</code>表示所有依赖文件，因此，我们可以这么写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<p>在没有歧义时可以写<code>$@</code>，也可以写<code>$(@)</code>，有歧义时必须用括号，例如<code>$(@D)</code>。</p>
<p>为了更好地调试，我们还可以把变量打印出来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 变量 $@ 表示target</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 变量 $&lt; 表示第一个依赖项</span></span><br><span class="line">	@echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 变量 $^ 表示所有依赖项</span></span><br><span class="line">	cc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>
<p>执行结果输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$@ = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<h3 id="参考源码-4">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v4">GitHub</a>下载源码。</p>
<h3 id="小结-4">小结</h3>
<p>使用变量可以让<code>Makefile</code>更加容易维护。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Using-Variables.html">如何使用变量</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">自动变量</a></li>
</ul>
<h2 id="使用模式规则">使用模式规则</h2>
<p>前面我们讲了使用隐式规则可以让<code>make</code>在必要时自动创建<code>.o</code>文件的规则，但<code>make</code>的隐式规则的命令是固定的，对于<code>xyz.o: xyz.c</code>，它实际上是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>能修改的只有变量<code>$(CC)</code>和<code>$(CFLAGS)</code>。如果要执行多条命令，使用隐式规则就不行了。</p>
<p>这时，我们可以自定义模式规则（Pattern Rules），它允许<code>make</code>匹配模式规则，如果匹配上了，就自动创建一条模式规则。</p>
<p>我们修改上一节的<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配规则：当make需要目标 xyz.o 时，自动生成一条 xyz.o: xyz.c 规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">	cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>当<code>make</code>执行<code>world.out: hello.o main.o</code>时，发现没有<code>hello.o</code>文件，于是需要查找以<code>hello.o</code>为目标的规则，结果匹配到模式规则<code>%.o: %.c</code>，于是<code>make</code>自动根据模式规则为我们动态创建了如下规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	@echo &#x27;compiling <span class="variable">$&lt;</span>...&#x27;</span><br><span class="line">	cc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>查找<code>main.o</code>也是类似的匹配过程，于是我们执行<code>make</code>，就可以用模式规则完成编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">compiling hello.c...</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">compiling main.c...</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>模式规则的命令完全由我们自己定义，因此，它比隐式规则更灵活。</p>
<p>但是，模式规则仍然没有解决修改<code>hello.h</code>头文件不会触发<code>main.c</code>重新编译的问题，这个依赖问题我们继续放到后面解决。</p>
<p>最后注意，模式规则是按需生成，如果我们在当前目录创建一个<code>zzz.o</code>文件，因为<code>make</code>并不会在执行过程中用到它，所以并不会自动生成<code>zzz.o: zzz.c</code>这个规则。</p>
<h3 id="参考源码-5">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v5">GitHub</a>下载源码。</p>
<h3 id="小结-5">小结</h3>
<p>使用模式规则可以灵活地按需动态创建规则，它比隐式规则更灵活。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html">模式规则</a></li>
</ul>
<hr>
<hr>
<p>前面我们讲了隐式规则和模式规则，这两种规则都可以解决自动把<code>.c</code>文件编译成<code>.o</code>文件，但都无法解决<code>.c</code>文件依赖<code>.h</code>文件的问题。</p>
<p>因为一个<code>.c</code>文件依赖哪个<code>.h</code>文件必须要分析文件内容才能确定，没有一个简单的文件名映射规则。</p>
<p>但是，要识别出<code>.c</code>文件的头文件依赖，可以用GCC提供的<code>-MM</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -MM main.c</span><br><span class="line">main.o: main.c hello.h</span><br></pre></td></tr></table></figure>
<p>上述输出告诉我们，编译<code>main.o</code>依赖<code>main.c</code>和<code>hello.h</code>两个文件。</p>
<p>因此，我们可以利用GCC的这个功能，对每个<code>.c</code>文件都生成一个依赖项，通常我们把它保存到<code>.d</code>文件中，再用<code>include</code>引入到<code>Makefile</code>，就相当于自动化完成了每个<code>.c</code>文件的精准依赖。</p>
<p>我们改写上一节的<code>Makefile</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有 .c 文件:</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .o 文件列表:</span></span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据SRCS生成 .d 文件列表:</span></span><br><span class="line">DEPS = $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line">TARGET = world.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># xyz.d 的规则由 xyz.c 生成:</span></span><br><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式规则:</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o *.d <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>变量<code>$(SRCS)</code>通过扫描目录可以确定为<code>hello.c main.c</code>，因此，变量<code>$(OBJS)</code>赋值为<code>hello.o main.o</code>，变量<code>$(DEPS)</code>赋值为<code>hello.d main.d</code>。</p>
<p>通过<code>include $(DEPS)</code>我们引入<code>hello.d</code>和<code>main.d</code>文件，但是这两个文件一开始并不存在，不过，<code>make</code>通过模式规则匹配到<code>%.d: %.c</code>，这就给了我们一个机会，在这个模式规则内部，用<code>cc -MM</code>命令外加<code>sed</code>把<code>.d</code>文件创建出来。</p>
<p>运行<code>make</code>，首次输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Makefile:31: hello.d: No such file or directory</span><br><span class="line">Makefile:31: main.d: No such file or directory</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">rm -f hello.d; \</span><br><span class="line">        cc -MM hello.c &gt;hello.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(hello\)\.o[ :]*,\1.o hello.d : ,g&#x27; &lt; hello.d.tmp &gt; hello.d; \</span><br><span class="line">        rm -f hello.d.tmp</span><br><span class="line">cc -c -o hello.o hello.c</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p><code>make</code>会提示找不到<code>hello.d</code>和<code>main.d</code>，不过随后自动创建出<code>hello.d</code>和<code>main.d</code>。<code>hello.d</code>内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.o hello.d : hello.c</span><br></pre></td></tr></table></figure>
<p>上述规则有两个目标文件，实际上相当于如下两条规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello.o : hello.c</span><br><span class="line">hello.d : hello.c</span><br></pre></td></tr></table></figure>
<p><code>main.d</code>内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c hello.h</span><br></pre></td></tr></table></figure>
<p>因此，<code>main.o</code>依赖于<code>main.c</code>和<code>hello.h</code>，这个依赖关系就和我们手动指定的一致。</p>
<p>改动<code>hello.h</code>，再次运行<code>make</code>，可以触发<code>main.c</code>的编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">rm -f main.d; \</span><br><span class="line">        cc -MM main.c &gt;main.d.tmp; \</span><br><span class="line">        sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.tmp &gt; main.d; \</span><br><span class="line">        rm -f main.d.tmp</span><br><span class="line">cc -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure>
<p>在实际项目中，对每个<code>.c</code>文件都可以生成一个对应的<code>.d</code>文件表示依赖关系，再通过<code>include</code>引入到<code>Makefile</code>，同时又能让<code>make</code>自动更新<code>.d</code>文件，有点蛋生鸡和鸡生蛋的关系，不过，这种机制能正常工作，除了<code>.d</code>文件不存在时会打印错误，有强迫症的同学肯定感觉不满意，这个问题我们后面解决。</p>
<h3 id="参考源码-6">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v6">GitHub</a>下载源码。</p>
<h3 id="小结-6">小结</h3>
<p>利用GCC生成<code>.d</code>文件，再用<code>include</code>引入<code>Makefile</code>，可解决一个<code>.c</code>文件应该如何正确触发编译的问题。</p>
<p>查看官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Prerequisites.html">自动生成依赖</a></li>
</ul>
<h2 id="完善Makefile">完善Makefile</h2>
<p>上一节我们解决了自动生成依赖的问题，这一节我们对项目目录进行整理，把所有源码放入<code>src</code>目录，所有编译生成的文件放入<code>build</code>目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">└── src</span><br><span class="line">    ├── hello.c</span><br><span class="line">    ├── hello.h</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure>
<p>整理<code>Makefile</code>，内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR = ./src</span><br><span class="line">BUILD_DIR = ./build</span><br><span class="line">TARGET = <span class="variable">$(BUILD_DIR)</span>/world.out</span><br><span class="line"></span><br><span class="line">CC = cc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./src/*.c</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC_DIR)</span> -name &#x27;*.c&#x27;)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.o,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"><span class="comment"># ./src/*.c =&gt; ./build/*.d</span></span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c,<span class="variable">$(BUILD_DIR)</span>/%.d,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标:</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.d 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.d: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt;<span class="variable">$@</span>.tmp; \</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,<span class="variable">$(BUILD_DIR)</span>/\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.tmp &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># build/xyz.o 的规则由 src/xyz.c 生成:</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接:</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	@echo <span class="string">&quot;buiding <span class="variable">$@</span>...&quot;</span></span><br><span class="line">	@mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 build 目录:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@echo <span class="string">&quot;clean...&quot;</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入所有 .d 文件:</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>这个<code>Makefile</code>定义了源码目录<code>SRC_DIR</code>、生成目录<code>BUILD_DIR</code>，以及其他变量，同时用<code>-include</code>消除了<code>.d</code>文件不存在的错误。执行<code>make</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -Wall -c -o build/hello.o src/hello.c</span><br><span class="line">cc -Wall -c -o build/main.o src/main.c</span><br><span class="line">buiding build/world.out...</span><br><span class="line">cc -o ./build/world.out ./build/hello.o ./build/main.o</span><br></pre></td></tr></table></figure>
<p>可以说基本满足编译需求，收工！</p>
<h3 id="参考源码-7">参考源码</h3>
<p>可以从<a target="_blank" rel="noopener" href="https://github.com/michaelliao/makefile-tutorial/tree/main/v7">GitHub</a>下载源码。</p>
<h3 id="小结-7">小结</h3>
<p>除了基础的用法外，<code>Makefile</code>还支持条件判断，环境变量，嵌套执行，变量展开等各种功能，需要用到时可以查询<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/index.html">官方手册</a>。</p>
<hr>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/23/makefile%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/21/cheat-sheet/pandas-cheat-sheet/"
                            aria-label=": pandas cheat sheet"
                        >
                            pandas cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-21T13:08:04+08:00">
	
		    2025 年 5 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E6%95%B0%E6%8D%AE/">数据</a>, <a class="category-link" href="../../../categories/%E6%95%B0%E6%8D%AE/python/">python</a>, <a class="category-link" href="../../../categories/%E6%95%B0%E6%8D%AE/python/pandas/">pandas</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="pandas">pandas:</h3>


	<div class="row">
    <embed src="/assets/pdf/pandas-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/21/cheat-sheet/pandas-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/21/cheat-sheet/spring-framework-cheat-sheet/"
                            aria-label=": spring-framework cheat sheet"
                        >
                            spring-framework cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-21T00:02:55+08:00">
	
		    2025 年 5 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/spring-framework-4/">spring-framework-4</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="java">java:</h3>


	<div class="row">
    <embed src="/assets/pdf/spring-framework-4-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/21/cheat-sheet/spring-framework-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/21/cheat-sheet/java-fundamentals-cheat-sheet/"
                            aria-label=": java fundamentals cheat sheet"
                        >
                            java fundamentals cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-21T00:01:18+08:00">
	
		    2025 年 5 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="java">java:</h3>


	<div class="row">
    <embed src="/assets/pdf/java-fundamentals-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/21/cheat-sheet/java-fundamentals-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/20/cheat-sheet/postgresql-cheat-sheet/"
                            aria-label=": postgresql cheat sheet"
                        >
                            postgresql cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:49:43+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/database/">database</a>, <a class="category-link" href="../../../categories/database/postgresql/">postgresql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="postgresql">postgresql:</h3>


	<div class="row">
    <embed src="/assets/pdf/postgresql-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>





	<div class="row">
    <embed src="/assets/pdf/postgresql-cheat-sheet2.pdf" width="100%" height="550" type="application/pdf">
	</div>



                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/20/cheat-sheet/postgresql-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/20/cheat-sheet/django-cheat-sheet/"
                            aria-label=": django cheat sheet"
                        >
                            django cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:48:46+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/">服务端</a>, <a class="category-link" href="../../../categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/python/">python</a>, <a class="category-link" href="../../../categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/python/django/">django</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="django">django:</h3>


	<div class="row">
    <embed src="/assets/pdf/django-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/20/cheat-sheet/django-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../3/"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../5/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 4 頁 共 21 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 210 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
