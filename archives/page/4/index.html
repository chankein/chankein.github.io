
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>所有文章 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://keinchan.com/archives/page/4/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../#about"
            >
        
        
            <img class="header-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/08/29/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/"
                            aria-label=": 一文搞懂贝叶斯定理（应用篇）"
                        >
                            一文搞懂贝叶斯定理（应用篇）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-08-29T16:26:57+08:00">
	
		    2023 年 8 月 29 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E5%9F%BA%E7%A1%80/">基础</a>, <a class="category-link" href="../../../categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/">数学</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在统计学里，长期以来，有频率学派和贝叶斯学派两大学派，他们互相鄙视对方，就像华山派的气宗与剑宗之争。</p>
<p>这两大学派最根本的观点在于看待世界的方式不同：</p>
<ul>
<li>频率学派认为世界是客观的，必须通过大量独立采样来获得统计均值，不能先给出一个主观的先验概率（假设）；</li>
<li>贝叶斯学派则认为概率是一种信念度，可以有非常主观的先验概率，然后，通过一次次采样结果修正先验概率，使之逼近客观事实。</li>
</ul>
<p>这两大学派哪个才是正确的？其实都对，只是看待世界的角度不同。但是在现实世界中，除了抛硬币、掷骰子、玩老虎机等少数符合理想数学模型的场景，频率学派才能发挥作用。大多数需要我们估算概率的现实场景，只能用贝叶斯理论来指导实践。</p>
<p>举个例子，假设我住在市区，希望赶上飞机的概率不低于90%，那么我应该提前多久出发呢？我必须试验至少100次，看看样本空间，才能获得一个比较准确的统计均值。然而这是不现实的，因为我一年可能就坐几次飞机。我只能拍脑袋先估一个提前30分钟就够了，结果第三次就没赶上，这说明我必须修正我的先验概率，后续改为提前45分钟，才能提升赶上飞机的概率。</p>
<p>我们再以《狼来了》的故事为例，当小孩第一次喊狼来了，村民听到后可以根据先验概率，比如P(小孩是诚实的)=90%判断赶紧去帮忙，结果发现被骗了，于是大家根据“被骗了”这一证据把后验概率P(小孩是诚实的)调整为60%，第二次又被骗了，于是再次把后验概率调整为20%，等到第三次听见小孩求救时，大家根据P(小孩是诚实的)=20%判断，他大概率还是在说谎，于是没有人去帮忙了。</p>
<p>有的同学会问，你说的这些，都是定性分析，没有定量计算啊！</p>
<p>要把贝叶斯定理用到定量计算，必须得借助计算机。</p>
<p>以吴军老师在中文分词领域举的一个例子来说，对于一个句子：南京市长江大桥，可以有两种划分：</p>
<ul>
<li>南京市 / 长江大桥</li>
<li>南京市长 / 江大桥</li>
</ul>
<p>到底哪一种更合理？我们可以计算条件概率：</p>
<ul>
<li>P(长江大桥|南京市) = 出现“南京市”时，出现“长江大桥”的概率；</li>
<li>P(江大桥|南京市长) = 出现“南京市长”时，出现“江大桥”的概率。</li>
</ul>
<p>提前准备好大量的中文语料，计算出任意两个词的条件概率，我们就可以得出哪种分词更合理。</p>
<p>在互联网领域，凡是遇到“当出现xyz时应该推荐什么”这样的条件概率时，也总是能应用贝叶斯理论。</p>
<p>例如，我们在搜索引擎中输入<code>elon</code>这个单词后，搜索框自动给出了联想补全：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-29-bayes-use/elon.png" alt="elon"></p>
<p>怎么实现这个功能？把用户最近搜索的所有可能的单词列出来，然后计算条件概率：</p>
<ul>
<li>P(mask|elon)=0.5</li>
<li>P(jerk|elon)=0.1</li>
<li>P(university|elon)=0.2</li>
<li>…</li>
</ul>
<p>把它们排个序，选出条件概率最大的几个，就是搜索建议。</p>
<p>诸如反垃圾邮件、电商推荐系统等，都是贝叶斯理论在机器学习中的应用。由于需要大量的计算，贝叶斯理论也只有在计算机时代才能广泛应用。</p>
<h3 id="关于信念">关于信念</h3>
<p>我们再回顾一下贝叶斯定理：</p>
<p>稍微改一下，变为：</p>
<p>P(H)是先验概率，P(H|E)是后验概率，P(E|H)/P(E)被称为调整因子，先验概率乘以调整因子就得到后验概率。</p>
<p>我们发现，如果P(H)=0，则P(H|E)=0；如果P(H)=1，则P(E|H)=P(E)，P(H|E)=1。</p>
<p>也就是说，如果先验概率为0%或100%，那么，无论出现任何证据E，都无法改变后验概率P(H|E)。这对我们看待世界的认知有重大指导意义，因为贝叶斯概率的本质是信念，通过一次次事件，我们可能加强某种信念，也可能减弱某种信念，但如果信念保持100%或0%，则可以做到对外界输入完全“免疫”。</p>
<p>举个例子，十年前许多人都认为比特币是庞氏骗局，如果100%坚定地持有这种信念，那么他将无视用户越来越多、价格上涨、交易量扩大、机构入市等诸多证据，至今仍然会坚信比特币是骗局而错过无数次机会。（注：此处示例不构成任何投资建议）</p>
<p>对于新生事物，每个人都可以有非常主观的先验概率，但只要我们不把先验概率定死为0或100%，就有机会改变自己的信念，从而更有可能接近客观事实，这也是贝叶斯定理的精髓：</p>
<blockquote>
<p>你相信什么并不重要，重要的是你别完全相信它。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/08/29/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"
                            aria-label=": 一文搞懂贝叶斯定理（原理篇）"
                        >
                            一文搞懂贝叶斯定理（原理篇）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-08-27T16:26:10+08:00">
	
		    2023 年 8 月 27 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E5%9F%BA%E7%A1%80/">基础</a>, <a class="category-link" href="../../../categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/">数学</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>托马斯·贝叶斯（Thomas Bayes）是18世纪的英国数学家，也是一位虔诚的牧师。据说他为了反驳对上帝的质疑而推导出贝叶斯定理。贝叶斯定理是一个由结果倒推原因的概率算法，在贝叶斯提出这个条件概率公式后，很长一段时间，大家并没有觉得它有什么作用，并一直受到主流统计学派的排斥。直到计算机诞生后，人们发现，贝叶斯定理可以广泛应用在数据分析、模式识别、统计决策，以及最火的人工智能中，结果，贝叶斯定理是如此有用，以至于不仅应用在计算机上，还广泛应用在经济学、心理学、博弈论等各种领域，可以说，掌握并应用贝叶斯定理，是每个人必备的技能。</p>
<p>这里推荐两个视频，深入浅出地解释了贝叶斯定理：</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Pu675cHJ7bg">Bayes’ Theorem 贝叶斯定理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=HZGCoVF3YvM">Bayes theorem, the geometry of changing beliefs</a></p>
<p>如果你不想花太多时间看视频，可以继续阅读，我把视频内容编译成文字，以便快速学习贝叶斯定理。</p>
<p>为了搞明白贝叶斯定理究竟要解决什么问题，我们先看一个现实生活的例子：</p>
<p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p>
<ul>
<li>如果有病，则准确率是99%（即有1%未检出阳性）；</li>
<li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li>
</ul>
<p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p>
<p>如果我们从大街上随便找一个人，那么他患病的概率就是0.1%，因为这个概率是基于历史统计数据的先验概率。</p>
<p>现在，他做了一次测试，结果为阳性，我们要计算他患病的概率，就是计算条件概率，即：在测试为阳性这一条件下，患病的概率是多少。</p>
<p>从直觉上这个人患病的概率大于0.1%，但也肯定小于99%。究竟是多少，怎么计算，我们先放一放。</p>
<p>为了理解条件概率，我们换一个更简单的例子：掷两次骰子，一共可能出现的结果有6x6=36种：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-all.png" alt="sample space"></p>
<p>这就是所谓的样本空间，每个样本的概率均为1/36，这个很好理解。</p>
<p>如果我们定义事件A为：至少有一个骰子是2，那么事件A的样本空间如下图红色部分所示：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-a.png" alt="Event A"></p>
<p>事件A一共有11种情况，我们计算事件A的概率P(A)：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pa.png" alt="P(A)"></p>
<p>我们再定义事件B：两个骰子之和为7，那么事件B的样本空间如下图绿色部分所示：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-b.png" alt="Event B"></p>
<p>事件B一共有6种情况，我们计算事件B的概率P(B)：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pb.png" alt="P(B)"></p>
<p>接下来我们用P(A∩B)表示A和B同时发生的概率，A∩B就是A和B的交集，如下图蓝色部分所示：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-p-a-and-b.png" alt="P(A∩B)"></p>
<p>显然A∩B只有两种情况，因此，计算P(A∩B)：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b.png" alt="P(A∩B)"></p>
<p>接下来我们就可以讨论条件概率了。我们用P(A|B)表示在B发生的条件下，A发生的概率。由于B已经发生，所以，样本空间就是B的样本数量6，而要发生A则只能是A、B同时发生，即A∩B，有两种情况。</p>
<p>因此，计算P(A|B)如下：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-b.png" alt="P(A|B)"></p>
<p>同理，我们用P(B|A)表示在A发生的条件下，B发生的概率。此时，分子仍然是A∩B的样本数量，但分母变成A的样本数量：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-b-a.png" alt="P(B|A)"></p>
<p>可见，条件概率P(A|B)和P(B|A)是不同的。</p>
<p>我们再回到A、B同时发生的概率，观察P(A∩B)可以改写为：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b-2.png" alt="P(B|A)xP(A)"></p>
<p>同理，P(A∩B)还可以改写为：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b-3.png" alt="P(A|B)xP(B)"></p>
<p>因此，根据上述两个等式，我们推导出下面的等式：</p>
<p>把左边的<code>P(A∩B)</code>去掉，我们得到等式：</p>
<p>最后，整理一下等式，我们推导出贝叶斯定理如下：</p>
<p>这就是著名的贝叶斯定理，它表示，当出现B时，如何计算A的概率。</p>
<p>很多时候，我们把<code>A</code>改写为<code>H</code>，把<code>B</code>改写为<code>E</code>：</p>
<p>H表示Hypothesis（假设），E表示Evidence（证据），贝叶斯定理的意义就在于，给定一个先验概率P(H)，在出现了证据E的情况下，计算后验概率P(H|E)。</p>
<h3 id="计算">计算</h3>
<p>有了贝叶斯定理，我们就可以回到开头的问题：</p>
<p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p>
<ul>
<li>如果有病，则准确率是99%（即有1%未检出阳性）；</li>
<li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li>
</ul>
<p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p>
<p>用H表示患病，E表示测试为阳性，那么，我们要计算在测试为阳性的条件下，一个人患病的概率，就是计算P(H|E)。根据贝叶斯定理，计算如下：</p>
<p>P(H)表示患病的概率，根据发病率可知，P(H)=0.1%；</p>
<p>P(E|H)表示在患病的情况下，测试为阳性的概率，根据“如果有病，则准确率是99%”可知，P(E|H)=99%；</p>
<p>P(E)表示测试为阳性的概率。这个概率就稍微复杂点，因为它是指对所有人（包含病人和健康人）进行测试，结果阳性的概率。</p>
<p>我们可以把检测人数放大，例如放大到10万人，对10万人进行检测，根据发病率可知：</p>
<ul>
<li>有100人是病人，另外99900是健康人；</li>
<li>对100个病人进行测试，有99人显示阳性，另有1人未检出（阴性）；</li>
<li>对99900个健康人进行测试，有2%=1998人显示阳性（误报），另有98%=97902人为阴性。</li>
</ul>
<p>下图显示了检测为阳性的结果的分布：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">           ┌───────┐</span><br><span class="line">           │100000 │</span><br><span class="line">           └───────┘</span><br><span class="line">               │</span><br><span class="line">       ┌───────┴───────┐</span><br><span class="line">       ▼               ▼</span><br><span class="line">   ┌───────┐       ┌───────┐</span><br><span class="line">   │  100  │       │ 99900 │</span><br><span class="line">   └───────┘       └───────┘</span><br><span class="line">       │               │</span><br><span class="line">   ┌───┴───┐       ┌───┴───┐</span><br><span class="line">   ▼       ▼       ▼       ▼</span><br><span class="line">┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│ 99  │ │  1  │ │1998 │ │97902│</span><br><span class="line">└─────┘ └─────┘ └─────┘ └─────┘</span><br><span class="line">   │               │</span><br><span class="line">   ▼               ▼</span><br><span class="line">   +               +</span><br></pre></td></tr></table></figure>
<p>所以，对于10万人的样本空间来说，事件E=显示阳性的概率为(99+1998)/100000=2.097%。</p>
<p>带入贝叶斯定理，计算P(H|E)：</p>
<p>计算结果为患病的概率为4.721%，这个概率远小于99%，且与大多数人的直觉不同，原因在于庞大的健康人群导致的误报数量远多于病人，当出现“检测阳性”的证据时，患病的概率从先验概率0.1%提升到4.721%，还远不足以确诊。</p>
<h3 id="贝叶斯定理的另一种表示">贝叶斯定理的另一种表示</h3>
<p>在上述计算中，我们发现计算P(E)是比较困难的，很多时候，甚至无法知道P(E)。此时，我们需要贝叶斯定理的另一种表示形式。</p>
<p>我们用P(H)表示H发生的概率，用H表示H不发生，P(H)表示H不发生的概率。显然P(H)=1-P(H)。</p>
<p>下图红色部分表示H，红色部分以外则表示H：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/ph.png" alt="P(H)"></p>
<p>事件E用绿色表示：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pe.png" alt="P(E)"></p>
<p>可见，P(E)可以分为两部分，一部分是E和H的交集，另一部分是E和H的交集：</p>
<p>根据上文的公式P(A∩B)=P(A|B)xP(B)，代入可得：</p>
<p>把P(E)替换掉，我们得到贝叶斯定理的另一种写法：</p>
<p>用这个公式来计算，我们就不必计算P(E)了。再次回到开头的问题：</p>
<p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p>
<ul>
<li>如果有病，则准确率是99%（即有1%未检出阳性）；</li>
<li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li>
</ul>
<p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p>
<ul>
<li>P(E|H)表示患病时检测阳性的概率=99%；</li>
<li>P(H)表示患病的概率=0.1%；</li>
<li>P(E|H)表示没有患病但检测阳性的概率=2%；</li>
<li>P(H)表示没有患病的概率=1-P(H)=99.9%。</li>
</ul>
<p>代入公式，计算：</p>
<p>检测为阳性这一证据使得患病的概率从0.1%提升到4.721%。假设这个人又做了一次检测，结果仍然是阳性，那么他患病的概率是多少？</p>
<p>我们仍然使用贝叶斯定理计算，只不过现在先验概率P(H)不再是0.1%，而是4.721%，P(E|H)和P(E|H)仍保持不变，计算新的P(H|E)：</p>
<p>结果为71%，两次检测为阳性的结果使得先验概率从0.1%提升到4.721%再提升到71%，继续第三次检测如果为阳性则概率将提升至99.18%。</p>
<p>可见，贝叶斯定理的核心思想就是不断根据新的证据，将先验概率调整为后验概率，使之更接近客观事实。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"
                            aria-label=": swift高级运算符"
                        >
                            swift高级运算符
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-14T10:13:17+08:00">
	
		    2023 年 7 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="高级运算符">高级运算符</h2>
<p>除了之前介绍过的 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/02_Basic_Operators.html">基本运算符</a>，Swift 还提供了数种可以对数值进行复杂运算的高级运算符。它们包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。</p>
<p>与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运算符（<code>&amp;+</code>）。所有的这些溢出运算符都是以 <code>&amp;</code> 开头的。</p>
<p>自定义结构体、类和枚举时，如果也为它们提供标准 Swift 运算符的实现，将会非常有用。在 Swift 中为这些运算符提供自定义的实现非常简单，运算符也会针对不同类型使用对应实现。</p>
<p>我们不用被预定义的运算符所限制。在 Swift 中可以自由地定义中缀、前缀、后缀和赋值运算符，它们具有自定义的优先级与关联值。这些运算符在代码中可以像预定义的运算符一样使用，你甚至可以扩展已有的类型以支持自定义运算符。</p>
<h2 id="位运算符">位运算符</h2>
<p><em>位运算符</em>可以操作数据结构中每个独立的比特位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。</p>
<p>Swift 支持 C 语言中的全部位运算符，接下来会一一介绍。</p>
<h3 id="Bitwise-NOT-Operator（按位取反运算符）">Bitwise NOT Operator（按位取反运算符）</h3>
<p>*按位取反运算符（<code>~</code>）*对一个数值的全部比特位进行取反：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitwiseNOT_2x.png" alt="Art/bitwiseNOT_2x.png"></p>
<p>按位取反运算符是一个前缀运算符，直接放在运算数之前，并且它们之间不能添加任何空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initialBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00001111</span></span><br><span class="line"><span class="keyword">let</span> invertedBits <span class="operator">=</span> <span class="operator">~</span>initialBits <span class="comment">// 等于 0b11110000</span></span><br></pre></td></tr></table></figure>
<p><code>UInt8</code> 类型的整数有 8 个比特位，可以存储 <code>0 ~ 255</code> 之间的任意整数。这个例子初始化了一个 <code>UInt8</code> 类型的整数，并赋值为二进制的 <code>00001111</code>，它的前 4 位为 <code>0</code>，后 4 位为 <code>1</code>。这个值等价于十进制的 <code>15</code>。</p>
<p>接着使用按位取反运算符创建了一个名为 <code>invertedBits</code> 的常量，这个常量的值与全部位取反后的 <code>initialBits</code> 相等。即所有的 <code>0</code> 都变成了 <code>1</code>，同时所有的 <code>1</code> 都变成 <code>0</code>。<code>invertedBits</code> 的二进制值为 <code>11110000</code>，等价于无符号十进制数的 <code>240</code>。</p>
<h3 id="Bitwise-AND-Operator（按位与运算符）">Bitwise AND Operator（按位与运算符）</h3>
<p><em>按位与运算符（<code>&amp;</code>）</em> 对两个数的比特位进行合并。它返回一个新的数，只有当两个数的对应位<em>都</em>为 <code>1</code> 的时候，新数的对应位才为 <code>1</code>：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitwiseAND_2x.png" alt="Art/bitwiseAND_2x.png"></p>
<p>在下面的示例当中，<code>firstSixBits</code> 和 <code>lastSixBits</code> 中间 4 个位的值都为 <code>1</code>。使用按位与运算符之后，得到二进制数值 <code>00111100</code>，等价于无符号十进制数的 <code>60</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstSixBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b11111100</span></span><br><span class="line"><span class="keyword">let</span> lastSixBits: <span class="type">UInt8</span>  <span class="operator">=</span> <span class="number">0b00111111</span></span><br><span class="line"><span class="keyword">let</span> middleFourBits <span class="operator">=</span> firstSixBits <span class="operator">&amp;</span> lastSixBits <span class="comment">// 等于 00111100</span></span><br></pre></td></tr></table></figure>
<h3 id="Bitwise-OR-Operator（按位或运算符）">Bitwise OR Operator（按位或运算符）</h3>
<p><em>按位或运算符（<code>|</code>）<em>可以对两个数的比特位进行比较。它返回一个新的数，只要两个数的对应位中有</em>任意一个</em>为 <code>1</code> 时，新数的对应位就为 <code>1</code>：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitwiseOR_2x.png" alt="Art/bitwiseOR_2x.png"></p>
<p>在下面的示例中，<code>someBits</code> 和 <code>moreBits</code> 存在不同的位被设置为 <code>1</code>。使用按位或运算符之后，得到二进制数值 <code>11111110</code>，等价于无符号十进制数的 <code>254</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b10110010</span></span><br><span class="line"><span class="keyword">let</span> moreBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b01011110</span></span><br><span class="line"><span class="keyword">let</span> combinedbits <span class="operator">=</span> someBits <span class="operator">|</span> moreBits <span class="comment">// 等于 11111110</span></span><br></pre></td></tr></table></figure>
<h3 id="Bitwise-XOR-Operator（按位异或运算符）">Bitwise XOR Operator（按位异或运算符）</h3>
<p><em>按位异或运算符</em>，或称“排外的或运算符”（<code>^</code>），可以对两个数的比特位进行比较。它返回一个新的数，当两个数的对应位不相同时，新数的对应位就为 <code>1</code>，并且对应位相同时则为 <code>0</code>：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitwiseXOR_2x.png" alt="Art/bitwiseXOR_2x.png"></p>
<p>在下面的示例当中，<code>firstBits</code> 和 <code>otherBits</code> 都有一个自己为 <code>1</code>，而对方为 <code>0</code> 的位。按位异或运算符将新数的这两个位都设置为 <code>1</code>。在其余的位上 <code>firstBits</code> 和 <code>otherBits</code> 是相同的，所以设置为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00010100</span></span><br><span class="line"><span class="keyword">let</span> otherBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">0b00000101</span></span><br><span class="line"><span class="keyword">let</span> outputBits <span class="operator">=</span> firstBits <span class="operator">^</span> otherBits <span class="comment">// 等于 00010001</span></span><br></pre></td></tr></table></figure>
<h3 id="Bitwise-Left-and-Right-Shift-Operators（按位左移、右移运算符）">Bitwise Left and Right Shift Operators（按位左移、右移运算符）</h3>
<p><em>按位左移运算符（<code>&lt;&lt;</code>）</em> 和 *按位右移运算符（<code>&gt;&gt;</code>）*可以对一个数的所有位进行指定位数的左移和右移，但是需要遵守下面定义的规则。</p>
<p>对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。</p>
<h4 id="无符号整数的移位运算">无符号整数的移位运算</h4>
<p>对无符号整数进行移位的规则如下：</p>
<ol>
<li>已存在的位按指定的位数进行左移和右移。</li>
<li>任何因移动而超出整型存储范围的位都会被丢弃。</li>
<li>用 <code>0</code> 来填充移位后产生的空白位。</li>
</ol>
<p>这种方法称为<em>逻辑移位</em>。</p>
<p>以下这张图展示了 <code>11111111 &lt;&lt; 1</code>（即把 <code>11111111</code> 向左移动 <code>1</code> 位），和 <code>11111111 &gt;&gt; 1</code>（即把 <code>11111111</code> 向右移动 <code>1</code> 位）的结果。蓝色的数字是被移位的，灰色的数字是被抛弃的，橙色的 <code>0</code> 则是被填充进来的：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftUnsigned_2x.png" alt="Art/bitshiftUnsigned_2x.png"></p>
<p>下面的代码演示了 Swift 中的移位运算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shiftBits: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">4</span> <span class="comment">// 即二进制的 00000100</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">1</span>           <span class="comment">// 00001000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">2</span>           <span class="comment">// 00010000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">5</span>           <span class="comment">// 10000000</span></span><br><span class="line">shiftBits <span class="operator">&lt;&lt;</span> <span class="number">6</span>           <span class="comment">// 00000000</span></span><br><span class="line">shiftBits <span class="operator">&gt;&gt;</span> <span class="number">2</span>           <span class="comment">// 00000001</span></span><br></pre></td></tr></table></figure>
<p>可以使用移位运算对其他的数据类型进行编码和解码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pink: <span class="type">UInt32</span> <span class="operator">=</span> <span class="number">0xCC6699</span></span><br><span class="line"><span class="keyword">let</span> redComponent <span class="operator">=</span> (pink <span class="operator">&amp;</span> <span class="number">0xFF0000</span>) <span class="operator">&gt;&gt;</span> <span class="number">16</span>  <span class="comment">// redComponent 是 0xCC，即 204</span></span><br><span class="line"><span class="keyword">let</span> greenComponent <span class="operator">=</span> (pink <span class="operator">&amp;</span> <span class="number">0x00FF00</span>) <span class="operator">&gt;&gt;</span> <span class="number">8</span> <span class="comment">// greenComponent 是 0x66， 即 102</span></span><br><span class="line"><span class="keyword">let</span> blueComponent <span class="operator">=</span> pink <span class="operator">&amp;</span> <span class="number">0x0000FF</span>         <span class="comment">// blueComponent 是 0x99，即 153</span></span><br></pre></td></tr></table></figure>
<p>这个示例使用了一个命名为 <code>pink</code> 的 <code>UInt32</code> 型常量来存储 Cascading Style Sheets（CSS）中粉色的颜色值。该 CSS 的颜色值 <code>#CC6699</code>，在 Swift 中表示为十六进制的 <code>0xCC6699</code>。然后利用按位与运算符（<code>&amp;</code>）和按位右移运算符（<code>&gt;&gt;</code>）从这个颜色值中分解出红（<code>CC</code>）、绿（<code>66</code>）以及蓝（<code>99</code>）三个部分。</p>
<p>红色部分是通过对 <code>0xCC6699</code> 和 <code>0xFF0000</code> 进行按位与运算后得到的。<code>0xFF0000</code> 中的 <code>0</code> 部分“掩盖”了 <code>OxCC6699</code> 中的第二、第三个字节，使得数值中的 <code>6699</code> 被忽略，只留下 <code>0xCC0000</code>。</p>
<p>然后，将这个数向右移动 16 位（<code>&gt;&gt; 16</code>）。十六进制中每两个字符占用 8 个比特位，所以移动 16 位后 <code>0xCC0000</code> 就变为 <code>0x0000CC</code>。这个数和 <code>0xCC</code> 是等同的，也就是十进制数值的 <code>204</code>。</p>
<p>同样的，绿色部分通过对 <code>0xCC6699</code> 和 <code>0x00FF00</code> 进行按位与运算得到 <code>0x006600</code>。然后将这个数向右移动 8 位，得到 <code>0x66</code>，也就是十进制数值的 <code>102</code>。</p>
<p>最后，蓝色部分通过对 <code>0xCC6699</code> 和 <code>0x0000FF</code> 进行按位与运算得到 <code>0x000099</code>。这里不需要再向右移位，而 <code>0x000099</code> 也就是 <code>0x99</code> ，也就是十进制数值的 <code>153</code>。</p>
<h4 id="有符号整数的移位运算">有符号整数的移位运算</h4>
<p>对比无符号整数，有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。（为了简单起见，以下的示例都是基于 8 比特的有符号整数，但是其中的原理对任何位数的有符号整数都是通用的。）</p>
<p>有符号整数使用第 1 个比特位（通常被称为<em>符号位</em>）来表示这个数的正负。符号位为 <code>0</code> 代表正数，为 <code>1</code> 代表负数。</p>
<p>其余的比特位（通常被称为<em>数值位</em>）存储了实际的值。有符号正整数和无符号数的存储方式是一样的，都是从 <code>0</code> 开始算起。这是值为 <code>4</code> 的 <code>Int8</code> 型整数的二进制位表现形式：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSignedFour_2x.png" alt="Art/bitshiftSignedFour_2x.png"></p>
<p>符号位为 <code>0</code>（代表这是一个“正数”），另外 7 位则代表了十进制数值 <code>4</code> 的二进制表示。</p>
<p>负数的存储方式略有不同。它存储 <code>2</code> 的 <code>n</code> 次方减去其实际值的绝对值，这里的 <code>n</code> 是数值位的位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 <code>2</code> 的 <code>7</code> 次方，即 <code>128</code>。</p>
<p>这是值为 <code>-4</code> 的 <code>Int8</code> 型整数的二进制表现形式：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSignedMinusFour_2x.png" alt="Art/bitshiftSignedMinusFour_2x.png"></p>
<p>这次的符号位为 <code>1</code>，说明这是一个负数，另外 7 个位则代表了数值 <code>124</code>（即 <code>128 - 4</code>）的二进制表示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSignedMinusFourValue_2x.png" alt="Art/bitshiftSignedMinusFourValue_2x.png"></p>
<p>负数的表示通常被称为<em>二进制补码</em>。用这种方法来表示负数乍看起来有点奇怪，但它有几个优点。</p>
<p>首先，如果想对 <code>-1</code> 和 <code>-4</code> 进行加法运算，我们只需要对这两个数的全部 8 个比特位执行标准的二进制相加（包括符号位），并且将计算结果中超出 8 位的数值丢弃：</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSignedAddition_2x.png" alt="Art/bitshiftSignedAddition_2x.png"></p>
<p>其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：当对有符号整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用<em>符号位</em>进行填充，而不是用 <code>0</code>。</p>
<p><img src="https://docs.swift.org/swift-book/_images/bitshiftSigned_2x.png" alt="Art/bitshiftSigned_2x.png"></p>
<p>这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为<em>算术移位</em>。</p>
<p>由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 <code>0</code>。在移位的过程中保持符号位不变，意味着负整数在接近 <code>0</code> 的过程中会一直保持为负。</p>
<h2 id="溢出运算符">溢出运算符</h2>
<p>当向一个整数类型的常量或者变量赋予超过它容量的值时，Swift 默认会报错，而不是允许生成一个无效的数。这个行为为我们在运算过大或者过小的数时提供了额外的安全性。</p>
<p>例如，<code>Int16</code> 型整数能容纳的有符号整数范围是 <code>-32768</code> 到 <code>32767</code>。当为一个 <code>Int16</code> 类型的变量或常量赋予的值超过这个范围时，系统就会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> potentialOverflow <span class="operator">=</span> <span class="type">Int16</span>.max</span><br><span class="line"><span class="comment">// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数</span></span><br><span class="line">potentialOverflow <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 这里会报错</span></span><br></pre></td></tr></table></figure>
<p>在赋值时为过大或者过小的情况提供错误处理，能让我们在处理边界值时更加灵活。</p>
<p>然而，当你希望的时候也可以选择让系统在数值溢出的时候采取截断处理，而非报错。Swift 提供的三个<em>溢出运算符</em>来让系统支持整数溢出运算。这些运算符都是以 <code>&amp;</code> 开头的：</p>
<ul>
<li>溢出加法 <code>&amp;+</code></li>
<li>溢出减法 <code>&amp;-</code></li>
<li>溢出乘法 <code>&amp;*</code></li>
</ul>
<h3 id="数值溢出">数值溢出</h3>
<p>数值有可能出现上溢或者下溢。</p>
<p>这个示例演示了当我们对一个无符号整数使用溢出加法（<code>&amp;+</code>）进行上溢运算时会发生什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow <span class="operator">=</span> <span class="type">UInt8</span>.max</span><br><span class="line"><span class="comment">// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255</span></span><br><span class="line">unsignedOverflow <span class="operator">=</span> unsignedOverflow <span class="operator">&amp;+</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 unsignedOverflow 等于 0</span></span><br></pre></td></tr></table></figure>
<p><code>unsignedOverflow</code> 被初始化为 <code>UInt8</code> 所能容纳的最大整数（<code>255</code>，以二进制表示即 <code>11111111</code>）。然后使用溢出加法运算符（<code>&amp;+</code>）对其进行加 <code>1</code> 运算。这使得它的二进制表示正好超出 <code>UInt8</code> 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，仍然留在 <code>UInt8</code> 边界内的值是 <code>00000000</code>，也就是十进制数值的 <code>0</code>。</p>
<p><img src="https://docs.swift.org/swift-book/_images/overflowAddition_2x.png" alt="Art/overflowAddition_2x.png"></p>
<p>当允许对一个无符号整数进行下溢运算时也会产生类似的情况。这里有一个使用溢出减法运算符（<code>&amp;-</code>）的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow <span class="operator">=</span> <span class="type">UInt8</span>.min</span><br><span class="line"><span class="comment">// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0</span></span><br><span class="line">unsignedOverflow <span class="operator">=</span> unsignedOverflow <span class="operator">&amp;-</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 unsignedOverflow 等于 255</span></span><br></pre></td></tr></table></figure>
<p><code>UInt8</code> 型整数能容纳的最小值是 <code>0</code>，以二进制表示即 <code>00000000</code>。当使用溢出减法运算符对其进行减 <code>1</code> 运算时，数值会产生下溢并被截断为 <code>11111111</code>， 也就是十进制数值的 <code>255</code>。</p>
<p><img src="https://docs.swift.org/swift-book/_images/overflowUnsignedSubtraction_2x.png" alt="Art/overflowUnsignedSubtraction_2x.png"></p>
<p>溢出也会发生在有符号整型上。针对有符号整型的所有溢出加法或者减法运算都是按位运算的方式执行的，符号位也需要参与计算，正如 <a href="#bitwise_left_and_right_shift_operators">按位左移、右移运算符</a> 所描述的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> signedOverflow <span class="operator">=</span> <span class="type">Int8</span>.min</span><br><span class="line"><span class="comment">// signedOverflow 等于 Int8 所能容纳的最小整数 -128</span></span><br><span class="line">signedOverflow <span class="operator">=</span> signedOverflow <span class="operator">&amp;-</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 signedOverflow 等于 127</span></span><br></pre></td></tr></table></figure>
<p><code>Int8</code> 型整数能容纳的最小值是 <code>-128</code>，以二进制表示即 <code>10000000</code>。当使用溢出减法运算符对其进行减 <code>1</code> 运算时，符号位被翻转，得到二进制数值 <code>01111111</code>，也就是十进制数值的 <code>127</code>，这个值也是 <code>Int8</code> 型整所能容纳的最大值。</p>
<p><img src="https://docs.swift.org/swift-book/_images/overflowSignedSubtraction_2x.png" alt="Art/overflowSignedSubtraction_2x.png"></p>
<p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大数。</p>
<h2 id="优先级和结合性">优先级和结合性</h2>
<p>运算符的<em>优先级</em>使得一些运算符优先于其他运算符；它们会先被执行。</p>
<p><em>结合性</em>定义了相同优先级的运算符是如何结合的，也就是说，是与左边结合为一组，还是与右边结合为一组。可以将其理解为“它们是与左边的表达式结合的”，或者“它们是与右边的表达式结合的”。</p>
<p>当考虑一个复合表达式的计算顺序时，运算符的优先级和结合性是非常重要的。举例来说，运算符优先级解释了为什么下面这个表达式的运算结果会是 <code>17</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> <span class="number">3</span> <span class="operator">%</span> <span class="number">4</span> <span class="operator">*</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 结果是 17</span></span><br></pre></td></tr></table></figure>
<p>如果你直接从左到右进行运算，你可能认为运算的过程是这样的：</p>
<ul>
<li>2 + 3 = 5</li>
<li>5 % 4 = 1</li>
<li>1 * 5 = 5</li>
</ul>
<p>但是正确答案是 <code>17</code> 而不是 <code>5</code>。优先级高的运算符要先于优先级低的运算符进行计算。与 C 语言类似，在 Swift 中，乘法运算符（<code>*</code>）与取余运算符（<code>%</code>）的优先级高于加法运算符（<code>+</code>）。因此，它们的计算顺序要先于加法运算。</p>
<p>而乘法运算与取余运算的优先级<em>相同</em>。这时为了得到正确的运算顺序，还需要考虑结合性。乘法运算与取余运算都是左结合的。可以将这考虑成，从它们的左边开始为这两部分表达式都隐式地加上括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> ((<span class="number">3</span> <span class="operator">%</span> <span class="number">4</span>) <span class="operator">*</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>(3 % 4)</code> 等于 <code>3</code>，所以表达式相当于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> (<span class="number">3</span> <span class="operator">*</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>3 * 5</code> 等于 <code>15</code>，所以表达式相当于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="operator">+</span> <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>因此计算结果为 <code>17</code>。</p>
<p>有关 Swift 标准库提供的操作符信息，包括操作符优先级组和结核性设置的完整列表，请参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/operator_declarations">操作符声明</a>。</p>
<blockquote>
<p>注意</p>
<p>相对 C 语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则更加简洁和可预测。但是，这也意味着它们相较于 C 语言及其衍生语言并不是完全一致。在对现有的代码进行移植的时候，要注意确保运算符的行为仍然符合你的预期。</p>
</blockquote>
<h2 id="运算符函数">运算符函数</h2>
<p>类和结构体可以为现有的运算符提供自定义的实现。这通常被称为运算符<em>重载</em>。</p>
<p>下面的例子展示了如何让自定义的结构体支持加法运算符（<code>+</code>）。算术加法运算符是一个<em>二元运算符</em>，因为它是对两个值进行运算，同时它还可以称为<em>中缀</em>运算符，因为它出现在两个值中间。</p>
<p>例子中定义了一个名为 <code>Vector2D</code> 的结构体用来表示二维坐标向量 <code>(x, y)</code>，紧接着定义了一个可以将两个 <code>Vector2D</code> 结构体实例进行相加的<em>运算符函数</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">+</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">+</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该运算符函数被定义为 <code>Vector2D</code> 上的一个类方法，并且函数的名字与它要进行重载的 <code>+</code> 名字一致。因为加法运算并不是一个向量必需的功能，所以这个类方法被定义在 <code>Vector2D</code> 的一个扩展中，而不是 <code>Vector2D</code> 结构体声明内。而算术加法运算符是二元运算符，所以这个运算符函数接收两个类型为 <code>Vector2D</code> 的参数，同时有一个 <code>Vector2D</code> 类型的返回值。</p>
<p>在这个实现中，输入参数分别被命名为 <code>left</code> 和 <code>right</code>，代表在 <code>+</code> 运算符左边和右边的两个 <code>Vector2D</code> 实例。函数返回了一个新的 <code>Vector2D</code> 实例，这个实例的 <code>x</code> 和 <code>y</code> 分别等于作为参数的两个实例的 <code>x</code> 和 <code>y</code> 的值之和。</p>
<p>这个类方法可以在任意两个 <code>Vector2D</code> 实例中间作为中缀运算符来使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> combinedVector <span class="operator">=</span> vector <span class="operator">+</span> anotherVector</span><br><span class="line"><span class="comment">// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)</span></span><br></pre></td></tr></table></figure>
<p>这个例子实现两个向量 <code>(3.0，1.0)</code> 和 <code>(2.0，4.0)</code> 的相加，并得到新的向量 <code>(5.0，5.0)</code>。这个过程如下图示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/vectorAddition_2x.png" alt="Art/vectorAddition_2x.png"></p>
<h3 id="前缀和后缀运算符">前缀和后缀运算符</h3>
<p>上个例子演示了一个二元中缀运算符的自定义实现。类与结构体也能提供标准<em>一元运算符</em>的实现。一元运算符只运算一个值。当运算符出现在值之前时，它就是<em>前缀</em>的（例如 <code>-a</code>），而当它出现在值之后时，它就是<em>后缀</em>的（例如 <code>b!</code>）。</p>
<p>要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 <code>func</code> 关键字之前指定 <code>prefix</code> 或者 <code>postfix</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="keyword">func</span> <span class="title function_">-</span> (<span class="params">vector</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="operator">-</span>vector.x, y: <span class="operator">-</span>vector.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码为 <code>Vector2D</code> 类型实现了一元运算符（<code>-a</code>）。由于该运算符是前缀运算符，所以这个函数需要加上 <code>prefix</code> 修饰符。</p>
<p>对于简单数值，一元负号运算符可以对它们的正负性进行改变。对于 <code>Vector2D</code> 来说，该运算将其 <code>x</code> 和 <code>y</code> 属性的正负性都进行了改变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positive <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> negative <span class="operator">=</span> <span class="operator">-</span>positive</span><br><span class="line"><span class="comment">// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例</span></span><br><span class="line"><span class="keyword">let</span> alsoPositive <span class="operator">=</span> <span class="operator">-</span>negative</span><br><span class="line"><span class="comment">// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例</span></span><br></pre></td></tr></table></figure>
<h3 id="复合赋值运算符">复合赋值运算符</h3>
<p><em>复合赋值运算符</em>将赋值运算符（<code>=</code>）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（<code>+=</code>）。在实现的时候，需要把运算符的左参数设置成 <code>inout</code> 类型，因为这个参数的值会在运算符函数内直接被修改。</p>
<p>在下面的例子中，对 <code>Vector2D</code> 实例实现了一个加法赋值运算符函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">+=</span> (<span class="params">left</span>: <span class="keyword">inout</span> <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) &#123;</span><br><span class="line">        left <span class="operator">=</span> left <span class="operator">+</span> right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> vectorToAdd <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line">original <span class="operator">+=</span> vectorToAdd</span><br><span class="line"><span class="comment">// original 的值现在为 (4.0, 6.0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>不能对默认的赋值运算符（<code>=</code>）进行重载。只有复合赋值运算符可以被重载。同样地，也无法对三元条件运算符 （<code>a ? b : c</code>） 进行重载。</p>
</blockquote>
<h3 id="等价运算符">等价运算符</h3>
<p>通常情况下，自定义的类和结构体没有对<em>等价运算符</em>进行默认实现，等价运算符通常被称为<em>相等</em>运算符（<code>==</code>）与<em>不等</em>运算符（<code>!=</code>）。</p>
<p>为了使用等价运算符对自定义的类型进行判等运算，需要为“相等”运算符提供自定义实现，实现的方法与其它中缀运算符一样, 并且增加对标准库 <code>Equatable</code> 协议的遵循：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (left.x <span class="operator">==</span> right.x) <span class="operator">&amp;&amp;</span> (left.y <span class="operator">==</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实现了“相等”运算符（<code>==</code>）来判断两个 <code>Vector2D</code> 实例是否相等。对于 <code>Vector2D</code> 来说，“相等”意味着“两个实例的 <code>x</code> 和 <code>y</code> 都相等”，这也是代码中用来进行判等的逻辑。如果你已经实现了“相等”运算符，通常情况下你并不需要自己再去实现“不等”运算符（<code>!=</code>）。标准库对于“不等”运算符提供了默认的实现，它简单地将“相等”运算符的结果进行取反后返回。</p>
<p>现在我们可以使用这两个运算符来判断两个 <code>Vector2D</code> 实例是否相等：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThree <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThree <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThree <span class="operator">==</span> anotherTwoThree &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“These two vectors are equivalent.”</span></span><br></pre></td></tr></table></figure>
<p>多数简单情况下，您可以使用 Swift 为您提供的等价运算符默认实现。Swift 为以下数种自定义类型提供等价运算符的默认实现：</p>
<ul>
<li>只拥有存储属性，并且它们全都遵循 <code>Equatable</code> 协议的结构体</li>
<li>只拥有关联类型，并且它们全都遵循 <code>Equatable</code> 协议的枚举</li>
<li>没有关联类型的枚举</li>
</ul>
<p>在类型原始的声明中声明遵循 <code>Equatable</code> 来接收这些默认实现。</p>
<p>下面为三维位置向量 <code>(x, y, z)</code> 定义的 <code>Vector3D</code> 结构体，与 <code>Vector2D</code> 类似。由于 <code>x</code>，<code>y</code> 和 <code>z</code> 属性都是 <code>Equatable</code> 类型，<code>Vector3D</code> 获得了默认的等价运算符实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3D</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span>, z <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> twoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThreeFour <span class="operator">==</span> anotherTwoThreeFour &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are also equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“These two vectors are also equivalent.”</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义运算符">自定义运算符</h2>
<p>除了实现标准运算符，在 Swift 中还可以声明和实现<em>自定义运算符</em>。可以用来自定义运算符的字符列表请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter3/02_Lexical_Structure.html#operators">运算符</a>。</p>
<p>新的运算符要使用 <code>operator</code> 关键字在全局作用域内进行定义，同时还要指定 <code>prefix</code>、<code>infix</code> 或者 <code>postfix</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> <span class="title">+++</span></span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个新的名为 <code>+++</code> 的前缀运算符。对于这个运算符，在 Swift 中并没有已知的意义，因此在针对 <code>Vector2D</code> 实例的特定上下文中，给予了它自定义的意义。对这个示例来讲，<code>+++</code> 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵与自身进行相加，从而让 <code>Vector2D</code> 实例的 <code>x</code> 属性和 <code>y</code> 属性值翻倍。你可以像下面这样通过对 <code>Vector2D</code> 添加一个 <code>+++</code> 类方法，来实现 <code>+++</code> 运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="keyword">func</span> <span class="title function_">+++</span> (<span class="params">vector</span>: <span class="keyword">inout</span> <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        vector <span class="operator">+=</span> vector</span><br><span class="line">        <span class="keyword">return</span> vector</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toBeDoubled <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> afterDoubling <span class="operator">=</span> <span class="operator">+++</span>toBeDoubled</span><br><span class="line"><span class="comment">// toBeDoubled 现在的值为 (2.0, 8.0)</span></span><br><span class="line"><span class="comment">// afterDoubling 现在的值也为 (2.0, 8.0)</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义中缀运算符的优先级">自定义中缀运算符的优先级</h3>
<p>每个自定义中缀运算符都属于某个优先级组。优先级组指定了这个运算符相对于其他中缀运算符的优先级和结合性。<a href="#precedence_and_associativity">优先级和结合性</a> 中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。</p>
<p>而没有明确放入某个优先级组的自定义中缀运算符将会被放到一个默认的优先级组内，其优先级高于三元运算符。</p>
<p>以下例子定义了一个新的自定义中缀运算符 <code>+-</code>，此运算符属于 <code>AdditionPrecedence</code> 优先组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">+-</span>: <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">+-</span> (<span class="params">left</span>: <span class="type">Vector2D</span>, <span class="params">right</span>: <span class="type">Vector2D</span>) -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vector2D</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">-</span> right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> firstVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> secondVector <span class="operator">=</span> <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> plusMinusVector <span class="operator">=</span> firstVector <span class="operator">+-</span> secondVector</span><br><span class="line"><span class="comment">// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)</span></span><br></pre></td></tr></table></figure>
<p>这个运算符把两个向量的 <code>x</code> 值相加，同时从第一个向量的 <code>y</code> 中减去第二个向量的 <code>y</code> 。因为它本质上是属于“相加型”运算符，所以将它放置在 <code>+</code> 和 <code>-</code> 等默认中缀“相加型”运算符相同的优先级组中。关于 Swift 标准库提供的运算符，以及完整的运算符优先级组和结合性设置，请参考 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/operator_declarations">运算符声明</a>。而更多关于优先级组以及自定义操作符和优先级组的语法，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Declarations.md#operator_declaration">运算符声明</a>。</p>
<blockquote>
<p>注意</p>
<p>当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，如果对同一个值同时使用前缀与后缀运算符，则后缀运算符会先参与运算。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/07/14/Swift/swift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/07/13/Swift/swift%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"
                            aria-label=": swift访问控制"
                        >
                            swift访问控制
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-13T10:13:17+08:00">
	
		    2023 年 7 月 13 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="访问控制">访问控制</h2>
<p><em>访问控制</em>可以限定其它源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。</p>
<p>你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。</p>
<p>Swift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都申明显式访问级别。其实，如果只是开发一个单一 target 的应用程序，我们完全可以不用显式声明代码的访问级别。</p>
<blockquote>
<p>注意</p>
<p>为了简单起见，对于代码中可以设置访问级别的特性（属性、基本类型、函数等），在下面的章节中我们会称之为“实体”。</p>
</blockquote>
<h2 id="模块和源文件">模块和源文件</h2>
<p>Swift 中的访问控制模型基于模块和源文件这两个概念。</p>
<p><em>模块</em>指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 <code>import</code> 关键字导入另外一个模块。</p>
<p>在 Swift 中，Xcode 的每个 target（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。</p>
<p><em>源文件</em>就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>
<h2 id="访问级别">访问级别</h2>
<p>Swift 为代码中的实体提供了五种不同的<em>访问级别</em>。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。</p>
<ul>
<li><em>Open</em> 和 <em>Public</em> 级别可以让实体被同一模块源文件中的所有实体访问，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，你会使用 Open 或 Public 级别来指定框架的外部接口。Open 和 Public 的区别在后面会提到。</li>
<li><em>Internal</em> 级别让实体被同一模块源文件中的任何实体访问，但是不能被模块外的实体访问。通常情况下，如果某个接口只在应用程序或框架内部使用，就可以将其设置为 Internal 级别。</li>
<li><em>File-private</em> 限制实体只能在其定义的文件内部访问。如果功能的部分细节只需要在文件内使用时，可以使用 File-private 来将其隐藏。</li>
<li><em>Private</em> 限制实体只能在其定义的作用域，以及同一文件内的 extension 访问。如果功能的部分细节只需要在当前作用域内使用时，可以使用 Private 来将其隐藏。</li>
</ul>
<p>Open 为最高访问级别（限制最少），Private 为最低访问级别（限制最多）。</p>
<p>Open 只能作用于类和类的成员，它和 Public 的区别如下：</p>
<ul>
<li>Public 或者其它更严访问级别的类，只能在其定义的模块内部被继承。</li>
<li>Public 或者其它更严访问级别的类成员，只能在其定义的模块内部的子类中重写。</li>
<li>Open 的类，可以在其定义的模块中被继承，也可以在引用它的模块中被继承。</li>
<li>Open 的类成员，可以在其定义的模块中子类中重写，也可以在引用它的模块中的子类重写。</li>
</ul>
<p>把一个类标记为 <code>open</code>，明确的表示你已经充分考虑过外部模块使用此类作为父类的影响，并且设计好了你的类的代码了。</p>
<h3 id="访问级别基本原则">访问级别基本原则</h3>
<p>Swift 中的访问级别遵循一个基本原则：<em>实体不能定义在具有更低访问级别（更严格）的实体中</em>。</p>
<p>例如：</p>
<ul>
<li>一个 Public 的变量，其类型的访问级别不能是 Internal，File-private 或是 Private。因为无法保证变量的类型在使用变量的地方也具有访问权限。</li>
<li>函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以的情况。</li>
</ul>
<p>关于此原则在各种情况下的具体表现，将在下文有所体现。</p>
<h3 id="默认访问级别">默认访问级别</h3>
<p>如果你没有为代码中的实体显式指定访问级别，那么它们默认为 <code>internal</code> 级别（有一些例外情况，稍后会进行说明）。因此，在大多数情况下，我们不需要显式指定实体的访问级别。</p>
<h3 id="单-target-应用程序的访问级别">单 target 应用程序的访问级别</h3>
<p>当你编写一个单目标应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别 Internal 即可。但是，你也可以使用 <code>fileprivate</code> 访问或 <code>private</code> 访问级别，用于隐藏一些功能的实现细节。</p>
<h3 id="框架的访问级别">框架的访问级别</h3>
<p>当你开发框架时，就需要把一些对外的接口定义为 Open 或 Public，以便使用者导入该框架后可以正常使用其功能。这些被你定义为对外的接口，就是这个框架的 API。</p>
<blockquote>
<p>注意</p>
<p>框架的内部实现仍然可以使用默认的访问级别 <code>internal</code>，当你需要对框架内部其它部分隐藏细节时可以使用 <code>private</code> 或 <code>fileprivate</code>。对于框架的对外 API 部分，你就需要将它们设置为 <code>open</code> 或 <code>public</code> 了。</p>
</blockquote>
<h3 id="单元测试-target-的访问级别">单元测试 target 的访问级别</h3>
<p>当你的应用程序包含单元测试 target 时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有 <code>open</code> 或 <code>public</code> 级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 <code>@testable</code> 特性，然后在允许测试的编译设置（<code>Build Options -&gt; Enable Testability</code>）下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。</p>
<h2 id="访问控制语法">访问控制语法</h2>
<p>通过修饰符 <code>open</code>、<code>public</code>、<code>internal</code>、<code>fileprivate</code>、<code>private</code> 来声明实体的访问级别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomePublicClass</span> &#123;&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">SomeInternalClass</span> &#123;&#125;</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">class</span> <span class="title class_">SomeFilePrivateClass</span> &#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SomePrivateClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> somePublicVariable <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">let</span> someInternalConstant <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someFilePrivateFunction</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">somePrivateFunction</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>除非专门指定，否则实体默认的访问级别为 <code>internal</code>，可以查阅 <a href="#default_access_levels">默认访问级别</a> 这一节。这意味着在不使用修饰符显式声明访问级别的情况下，<code>SomeInternalClass</code> 和 <code>someInternalConstant</code> 仍然拥有隐式的 <code>internal</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeInternalClass</span> &#123;&#125;   <span class="comment">// 隐式 internal</span></span><br><span class="line"><span class="keyword">var</span> someInternalConstant <span class="operator">=</span> <span class="number">0</span> <span class="comment">// 隐式 internal</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义类型">自定义类型</h2>
<p>如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。新类型只能在它的访问级别限制范围内使用。例如，你定义了一个 <code>fileprivate</code> 级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型，等等。</p>
<p>一个类型的访问级别也会影响到类型<em>成员</em>（属性、方法、构造器、下标）的默认访问级别。如果你将类型指定为 <code>private</code> 或者 <code>fileprivate</code> 级别，那么该类型的所有成员的默认访问级别也会变成 <code>private</code> 或者 <code>fileprivate</code> 级别。如果你将类型指定为 <code>internal</code> 或 <code>public</code>（或者不明确指定访问级别，而使用默认的 <code>internal</code> ），那么该类型的所有成员的默认访问级别将是 <code>internal</code>。</p>
<blockquote>
<p>重点</p>
<p>上面提到，一个 <code>public</code> 类型的所有成员的访问级别默认为 <code>internal</code> 级别，而不是 <code>public</code> 级别。如果你想将某个成员指定为 <code>public</code> 级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomePublicClass</span> &#123;                  <span class="comment">// 显式 public 类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> somePublicProperty <span class="operator">=</span> <span class="number">0</span>            <span class="comment">// 显式 public 类成员</span></span><br><span class="line">    <span class="keyword">var</span> someInternalProperty <span class="operator">=</span> <span class="number">0</span>                 <span class="comment">// 隐式 internal 类成员</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someFilePrivateMethod</span>() &#123;&#125;  <span class="comment">// 显式 fileprivate 类成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">somePrivateMethod</span>() &#123;&#125;          <span class="comment">// 显式 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeInternalClass</span> &#123;                       <span class="comment">// 隐式 internal 类</span></span><br><span class="line">    <span class="keyword">var</span> someInternalProperty <span class="operator">=</span> <span class="number">0</span>                 <span class="comment">// 隐式 internal 类成员</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someFilePrivateMethod</span>() &#123;&#125;  <span class="comment">// 显式 fileprivate 类成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">somePrivateMethod</span>() &#123;&#125;          <span class="comment">// 显式 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">class</span> <span class="title class_">SomeFilePrivateClass</span> &#123;        <span class="comment">// 显式 fileprivate 类</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">someFilePrivateMethod</span>() &#123;&#125;              <span class="comment">// 隐式 fileprivate 类成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">somePrivateMethod</span>() &#123;&#125;          <span class="comment">// 显式 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SomePrivateClass</span> &#123;                <span class="comment">// 显式 private 类</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">somePrivateMethod</span>() &#123;&#125;                  <span class="comment">// 隐式 private 类成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元组类型">元组类型</h3>
<p>元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为 <code>internal</code>，另一个类型为 <code>private</code>，那么这个元组的访问级别为 <code>private</code>。</p>
<blockquote>
<p>注意</p>
<p>元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。</p>
</blockquote>
<h3 id="函数类型">函数类型</h3>
<p>函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。</p>
<p>下面的例子定义了一个名为 <code>someFunction()</code> 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函数应该拥有默认的访问级别 <code>internal</code>，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编译：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>() -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处是函数实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅 <a href="#custom_types">自定义类型</a>）。其中一个类的访问级别是 <code>internal</code>，另一个的访问级别是 <code>private</code>，所以根据元组访问级别的原则，该元组的访问级别是 <code>private</code>（元组的访问级别与元组中访问级别最低的类型一致）。</p>
<p>因为该函数返回类型的访问级别是 <code>private</code>，所以你必须使用 <code>private</code> 修饰符，明确指定该函数的访问级别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">someFunction</span>() -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处是函数实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将该函数指定为 <code>public</code> 或 <code>internal</code>，或者使用默认的访问级别 <code>internal</code> 都是错误的，因为如果把该函数当做 <code>public</code> 或 <code>internal</code> 级别来使用的话，可能会无法访问 <code>private</code> 级别的返回值。</p>
<h3 id="枚举类型">枚举类型</h3>
<p>枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。</p>
<p>比如下面的例子，枚举 <code>CompassPoint</code> 被明确指定为 <code>public</code>，那么它的成员 <code>North</code>、<code>South</code>、<code>East</code>、<code>West</code> 的访问级别同样也是 <code>public</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原始值和关联值">原始值和关联值</h4>
<p>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 <code>internal</code> 的枚举中定义 <code>private</code> 的原始值类型。</p>
<h3 id="嵌套类型">嵌套类型</h3>
<p>如果在 <code>private</code> 的类型中定义嵌套类型，那么该嵌套类型就自动拥有 <code>private</code> 访问级别。如果在 <code>public</code> 或者 <code>internal</code> 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 <code>internal</code> 访问级别。如果想让嵌套类型拥有 <code>public</code> 访问级别，那么需要明确指定该嵌套类型的访问级别。</p>
<h2 id="子类">子类</h2>
<p>子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 <code>internal</code>，子类的访问级别就不能是 <code>public</code>。</p>
<p>此外，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。</p>
<p>可以通过重写为继承来的类成员提供更高的访问级别。下面的例子中，类 <code>A</code> 的访问级别是 <code>public</code>，它包含一个方法 <code>someMethod()</code>，访问级别为 <code>private</code>。类 <code>B</code> 继承自类 <code>A</code>，访问级别为 <code>internal</code>，但是在类 <code>B</code> 中重写了类 <code>A</code> 中访问级别为 <code>private</code> 的方法 <code>someMethod()</code>，并重新指定为 <code>internal</code> 级别。通过这种方式，我们就可以将某类中 <code>private</code> 级别的类成员重新指定为更高的访问级别，以便其他人使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">B</span>: <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 <code>private</code> 级别的成员，在同一模块内访问父类 <code>internal</code> 级别的成员）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">B</span>: <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="keyword">func</span> <span class="title function_">someMethod</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.someMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为父类 <code>A</code> 和子类 <code>B</code> 定义在同一个源文件中，所以在子类 <code>B</code> 可以在重写的 <code>someMethod()</code> 方法中调用 <code>super.someMethod()</code>。</p>
<h2 id="常量、变量、属性、下标">常量、变量、属性、下标</h2>
<p>常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 <code>public</code> 级别的属性，但是它的类型却是 <code>private</code> 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。</p>
<p>如果常量、变量、属性、下标的类型是 <code>private</code> 级别的，那么它们必须明确指定访问级别为 <code>private</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> privateInstance <span class="operator">=</span> <span class="type">SomePrivateClass</span>()</span><br></pre></td></tr></table></figure>
<h3 id="Getter-和-Setter">Getter 和 Setter</h3>
<p>常量、变量、属性、下标的 <code>Getters</code> 和 <code>Setters</code> 的访问级别和它们所属类型的访问级别相同。</p>
<p><code>Setter</code> 的访问级别可以低于对应的 <code>Getter</code> 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 <code>var</code> 或 <code>subscript</code> 关键字之前，你可以通过 <code>fileprivate(set)</code>，<code>private(set)</code> 或 <code>internal(set)</code> 为它们的写入权限指定更低的访问级别。</p>
<blockquote>
<p>注意</p>
<p>这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 <code>Getter</code> 和 <code>Setter</code>，Swift 也会隐式地为其创建 <code>Getter</code> 和 <code>Setter</code>，用于访问该属性的后备存储。使用 <code>fileprivate(set)</code>，<code>private(set)</code> 和 <code>internal(set)</code> 可以改变 <code>Setter</code> 的访问级别，这对计算型属性也同样适用。</p>
</blockquote>
<p>下面的例子中定义了一个名为 <code>TrackedString</code> 的结构体，它记录了 <code>value</code> 属性被修改的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrackedString</span> &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> numberOfEdits <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            numberOfEdits <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TrackedString</code> 结构体定义了一个用于存储 <code>String</code> 值的属性 <code>value</code>，并将初始值设为 <code>&quot;&quot;</code>（一个空字符串）。该结构体还定义了另一个用于存储 <code>Int</code> 值的属性 <code>numberOfEdits</code>，它用于记录属性 <code>value</code> 被修改的次数。这个功能通过属性 <code>value</code> 的 <code>didSet</code> 观察器实现，每当给 <code>value</code> 赋新值时就会调用 <code>didSet</code> 方法，然后将 <code>numberOfEdits</code> 的值加一。</p>
<p>结构体 <code>TrackedString</code> 和它的属性 <code>value</code> 都没有显式地指定访问级别，所以它们都是用默认的访问级别 <code>internal</code>。但是该结构体的 <code>numberOfEdits</code> 属性使用了 <code>private(set)</code> 修饰符，这意味着 <code>numberOfEdits</code> 属性只能在结构体的定义中进行赋值。<code>numberOfEdits</code> 属性的 <code>Getter</code> 依然是默认的访问级别 <code>internal</code>，但是 <code>Setter</code> 的访问级别是 <code>private</code>，这表示该属性只能在内部修改，而在结构体的外部则表现为一个只读属性。</p>
<p>如果你实例化 <code>TrackedString</code> 结构体，并多次对 <code>value</code> 属性的值进行修改，你就会看到 <code>numberOfEdits</code> 的值会随着修改次数而变化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringToEdit <span class="operator">=</span> <span class="type">TrackedString</span>()</span><br><span class="line">stringToEdit.value <span class="operator">=</span> <span class="string">&quot;This string will be tracked.&quot;</span></span><br><span class="line">stringToEdit.value <span class="operator">+=</span> <span class="string">&quot; This edit will increment numberOfEdits.&quot;</span></span><br><span class="line">stringToEdit.value <span class="operator">+=</span> <span class="string">&quot; So will this one.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The number of edits is <span class="subst">\(stringToEdit.numberOfEdits)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“The number of edits is 3”</span></span><br></pre></td></tr></table></figure>
<p>虽然你可以在其他的源文件中实例化该结构体并且获取到 <code>numberOfEdits</code> 属性的值，但是你不能对其进行赋值。这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。</p>
<p>你可以在必要时为 <code>Getter</code> 和 <code>Setter</code> 显式指定访问级别。下面的例子将 <code>TrackedString</code> 结构体明确指定为了 <code>public</code> 访问级别。结构体的成员（包括 <code>numberOfEdits</code> 属性）拥有默认的访问级别 <code>internal</code>。你可以结合 <code>public</code> 和 <code>private(set)</code> 修饰符把结构体中的 <code>numberOfEdits</code> 属性的 <code>Getter</code> 的访问级别设置为 <code>public</code>，而 <code>Setter</code> 的访问级别设置为 <code>private</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">TrackedString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> numberOfEdits <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            numberOfEdits <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造器">构造器</h2>
<p>自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#required_initializers">必要构造器</a>，它的访问级别必须和所属类型的访问级别相同。</p>
<p>如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。</p>
<h3 id="默认构造器">默认构造器</h3>
<p>如 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#default_initializers">默认构造器</a> 所述，Swift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。</p>
<p>默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 <code>public</code>。如果一个类型被指定为 <code>public</code> 级别，那么默认构造器的访问级别将为 <code>internal</code>。如果你希望一个 <code>public</code> 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 <code>public</code> 访问级别的无参数构造器。</p>
<h3 id="结构体默认的成员逐一构造器">结构体默认的成员逐一构造器</h3>
<p>如果结构体中任意存储型属性的访问级别为 <code>private</code>，那么该结构体默认的成员逐一构造器的访问级别就是 <code>private</code>。否则，这种构造器的访问级别依然是 <code>internal</code>。</p>
<p>如同前面提到的默认构造器，如果你希望一个 <code>public</code> 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 <code>public</code> 访问级别的成员逐一构造器。</p>
<h2 id="协议">协议</h2>
<p>如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被遵循。</p>
<p>协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意遵循者都将可用。</p>
<blockquote>
<p>注意</p>
<p>如果你定义了一个 <code>public</code> 访问级别的协议，那么该协议的所有实现也会是 <code>public</code> 访问级别。这一点不同于其他类型，例如，当类型是 <code>public</code> 访问级别时，其成员的访问级别却只是 <code>internal</code>。</p>
</blockquote>
<h3 id="协议继承">协议继承</h3>
<p>如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 <code>internal</code> 协议的新协议定义为 <code>public</code> 协议。</p>
<h3 id="协议遵循">协议遵循</h3>
<p>一个类型可以遵循比它级别更低的协议。例如，你可以定义一个 <code>public</code> 级别类型，它能在别的模块中使用，但是如果它遵循一个 <code>internal</code> 协议，这个遵循的部分就只能在这个 <code>internal</code> 协议所在的模块中使用。</p>
<p>遵循协议时的上下文级别是类型和协议中级别最小的那个。如果一个类型是 <code>public</code> 级别，但它要遵循的协议是 <code>internal</code> 级别，那么这个类型对该协议的遵循上下文就是 <code>internal</code> 级别。</p>
<p>当你编写或扩展一个类型让它遵循一个协议时，你必须确保该类型对协议的每一个要求的实现，至少与遵循协议的上下文级别一致。例如，一个 <code>public</code> 类型遵循一个 <code>internal</code> 协议，这个类型对协议的所有实现至少都应是 <code>internal</code> 级别的。</p>
<blockquote>
<p>注意</p>
<p>Swift 和 Objective-C 一样，协议遵循是全局的，也就是说，在同一程序中，一个类型不可能用两种不同的方式实现同一个协议。</p>
</blockquote>
<h2 id="Extension">Extension</h2>
<p>Extension 可以在访问级别允许的情况下对类、结构体、枚举进行扩展。Extension 的成员具有和原始类型成员一致的访问级别。例如，你使用 extension 扩展了一个 <code>public</code> 或者 <code>internal</code> 类型，extension 中的成员就默认使用 <code>internal</code> 访问级别，和原始类型中的成员一致。如果你使用 extension 扩展了一个 <code>private</code> 类型，则 extension 的成员默认使用 <code>private</code> 访问级别。</p>
<p>或者，你可以明确指定 extension 的访问级别（例如，<code>private extension</code>），从而给该 extension 中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖。</p>
<p>如果你使用 extension 来遵循协议的话，就不能显式地声明 extension 的访问级别。extension 每个 protocol 要求的实现都默认使用 protocol 的访问级别。</p>
<h3 id="Extension-的私有成员">Extension 的私有成员</h3>
<p>扩展同一文件内的类，结构体或者枚举，extension 里的代码会表现得跟声明在原类型里的一模一样。也就是说你可以这样：</p>
<ul>
<li>在类型的声明里声明一个私有成员，在同一文件的 extension 里访问。</li>
<li>在 extension 里声明一个私有成员，在同一文件的另一个 extension 里访问。</li>
<li>在 extension 里声明一个私有成员，在同一文件的类型声明里访问。</li>
</ul>
<p>这意味着你可以像组织的代码去使用 extension，而且不受私有成员的影响。例如，给定下面这样一个简单的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用 extension 来遵循协议，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStruct</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> privateVariable <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">SomeStruct</span>: <span class="title class_ inherited__">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(privateVariable)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型">泛型</h2>
<p>泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</p>
<h2 id="类型别名">类型别名</h2>
<p>你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，<code>private</code> 级别的类型别名可以作为 <code>private</code>、<code>file-private</code>、<code>internal</code>、<code>public</code> 或者 <code>open</code> 类型的别名，但是 <code>public</code> 级别的类型别名只能作为 <code>public</code> 类型的别名，不能作为 <code>internal</code>、<code>file-private</code> 或 <code>private</code> 类型的别名。</p>
<blockquote>
<p>注意</p>
<p>这条规则也适用于为满足协议遵循而将类型别名用于关联类型的情况。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/07/13/Swift/swift%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/07/12/Swift/swift%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8/"
                            aria-label=": swift内存安全"
                        >
                            swift内存安全
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-12T10:13:17+08:00">
	
		    2023 年 7 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="内存安全">内存安全</h2>
<p>默认情况下，Swift 会阻止你代码里不安全的行为。例如，Swift 会保证变量在使用之前就完成初始化，在内存被回收之后就无法被访问，并且数组的索引会做越界检查。</p>
<p>Swift 也保证同时访问同一块内存时不会冲突，通过约束代码里对于存储地址的写操作，去获取那一块内存的访问独占权。因为 Swift 自动管理内存，所以大部分时候你完全不需要考虑内存访问的事情。然而，理解潜在的冲突也是很重要的，可以避免你写出访问冲突的代码。而如果你的代码确实存在冲突，那在编译时或者运行时就会得到错误。</p>
<h2 id="理解内存访问冲突">理解内存访问冲突</h2>
<p>内存的访问，会发生在你给变量赋值，或者传递参数给函数时。例如，下面的代码就包含了读和写的访问：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 one 所在的内存区域发起一次写操作</span></span><br><span class="line"><span class="keyword">var</span> one <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 one 所在的内存区域发起一次读操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We&#x27;re number <span class="subst">\(one)</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>内存访问的冲突会发生在你的代码尝试同时访问同一个存储地址的时侯。同一个存储地址的多个访问同时发生会造成不可预计或不一致的行为。在 Swift 里，有很多修改值的行为都会持续好几行代码，在修改值的过程中进行访问是有可能发生的。</p>
<p>你可以思考一下预算表更新的过程，会看到同样的问题。更新预算表总共有两步：首先你把预算项的名字和费用加上，然后再更新总数来反映预算表的现况。在更新之前和之后，你都可以从预算表里读取任何信息并获得正确的答案，就像下面展示的那样。</p>
<p><img src="https://docs.swift.org/swift-book/_images/memory_shopping_2x.png" alt=""></p>
<p>而当你添加预算项进入表里的时候，它只是在一个临时的，错误的状态，因为总数还没有被更新。在添加数据的过程中读取总数就会读取到错误的信息。</p>
<p>这个例子也演示了你在修复内存访问冲突时会遇到的问题：有时修复的方式会有很多种，但哪一种是正确的就不总是那么明显了。在这个例子里，根据你是否需要更新后的总数，$5 和 $320 都可能是正确的值。在你修复访问冲突之前，你需要决定它的倾向。</p>
<blockquote>
<p>注意</p>
<p>如果你写过并发和多线程的代码，内存访问冲突也许是同样的问题。然而，这里访问冲突的讨论是在单线程的情境下讨论的，并没有使用并发或者多线程。</p>
<p>如果你曾经在单线程代码里有访问冲突，Swift 可以保证你在编译或者运行时会得到错误。对于多线程的代码，可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/code_diagnostics/thread_sanitizer">Thread Sanitizer</a> 去帮助检测多线程的冲突。</p>
</blockquote>
<h3 id="内存访问性质">内存访问性质</h3>
<p>内存访问冲突时，要考虑内存访问上下文中的这三个性质：访问是读还是写，访问的时长，以及被访问的存储地址。特别是，冲突会发生在当你有两个访问符合下列的情况：</p>
<ul>
<li>至少有一个是写访问</li>
<li>它们访问的是同一个存储地址</li>
<li>它们的访问在时间线上部分重叠</li>
</ul>
<p>读和写访问的区别很明显：一个写访问会改变存储地址，而读操作不会。存储地址是指向正在访问的东西（例如一个变量，常量或者属性）的位置的值 。内存访问的时长要么是瞬时的，要么是长期的。</p>
<p>如果一个访问不可能在其访问期间被其它代码访问，那么就是一个瞬时访问。正常来说，两个瞬时访问是不可能同时发生的。大多数内存访问都是瞬时的。例如，下面列举的所有读和写访问都是瞬时的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">oneMore</span>(<span class="params">than</span> <span class="params">number</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myNumber <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">myNumber <span class="operator">=</span> oneMore(than: myNumber)</span><br><span class="line"><span class="built_in">print</span>(myNumber)</span><br><span class="line"><span class="comment">// 打印“2”</span></span><br></pre></td></tr></table></figure>
<p>然而，有几种被称为长期访问的内存访问方式，会在别的代码执行时持续进行。瞬时访问和长期访问的区别在于别的代码有没有可能在访问期间同时访问，也就是在时间线上的重叠。一个长期访问可以被别的长期访问或瞬时访问重叠。</p>
<p>重叠的访问主要出现在使用 in-out 参数的函数和方法或者结构体的 mutating 方法里。Swift 代码里典型的长期访问会在后面进行讨论。</p>
<h2 id="In-Out-参数的访问冲突">In-Out 参数的访问冲突</h2>
<p>一个函数会对它所有的 in-out 参数进行长期写访问。in-out 参数的写访问会在所有非 in-out 参数处理完之后开始，直到函数执行完毕为止。如果有多个 in-out 参数，则写访问开始的顺序与参数的顺序一致。</p>
<p>长期访问的存在会造成一个结果，你不能在访问以 in-out 形式传入后的原变量，即使作用域原则和访问权限允许——任何访问原变量的行为都会造成冲突。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stepSize <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">increment</span>(<span class="keyword">_</span> <span class="params">number</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    number <span class="operator">+=</span> stepSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">increment(<span class="operator">&amp;</span>stepSize)</span><br><span class="line"><span class="comment">// 错误：stepSize 访问冲突</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码里，<code>stepSize</code> 是一个全局变量，并且它可以在 <code>increment(_:)</code> 里正常访问。然而，对于 <code>stepSize</code> 的读访问与 <code>number</code> 的写访问重叠了。就像下面展示的那样，<code>number</code> 和 <code>stepSize</code> 都指向了同一个存储地址。同一块内存的读和写访问重叠了，就此产生了冲突。</p>
<p><img src="https://docs.swift.org/swift-book/_images/memory_increment_2x.png" alt=""></p>
<p>解决这个冲突的一种方式，是显示拷贝一份 <code>stepSize</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式拷贝</span></span><br><span class="line"><span class="keyword">var</span> copyOfStepSize <span class="operator">=</span> stepSize</span><br><span class="line">increment(<span class="operator">&amp;</span>copyOfStepSize)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新原来的值</span></span><br><span class="line">stepSize <span class="operator">=</span> copyOfStepSize</span><br><span class="line"><span class="comment">// stepSize 现在的值是 2</span></span><br></pre></td></tr></table></figure>
<p>当你在调用 <code>increment(_:)</code> 之前做一份拷贝，显然 <code>copyOfStepSize</code> 就会根据当前的 <code>stepSize</code> 增加。读访问在写操作之前就已经结束了，所以不会有冲突。</p>
<p>长期写访问的存在还会造成另一种结果，往同一个函数的多个 in-out 参数里传入同一个变量也会产生冲突，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">balance</span>(<span class="keyword">_</span> <span class="params">x</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">y</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum <span class="operator">=</span> x <span class="operator">+</span> y</span><br><span class="line">    x <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    y <span class="operator">=</span> sum <span class="operator">-</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> playerOneScore <span class="operator">=</span> <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> playerTwoScore <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">balance(<span class="operator">&amp;</span>playerOneScore, <span class="operator">&amp;</span>playerTwoScore)  <span class="comment">// 正常</span></span><br><span class="line">balance(<span class="operator">&amp;</span>playerOneScore, <span class="operator">&amp;</span>playerOneScore)</span><br><span class="line"><span class="comment">// 错误：playerOneScore 访问冲突</span></span><br></pre></td></tr></table></figure>
<p>上面的 <code>balance(_:_:)</code> 函数会将传入的两个参数平均化。将 <code>playerOneScore</code> 和 <code>playerTwoScore</code> 作为参数传入不会产生错误 —— 有两个访问重叠了，但它们访问的是不同的内存位置。相反，将 <code>playerOneScore</code> 作为参数同时传入就会产生冲突，因为它会发起两个写访问，同时访问同一个的存储地址。</p>
<blockquote>
<p>注意</p>
<p>因为操作符也是函数，它们也会对 in-out 参数进行长期访问。例如，假设 <code>balance(_:_:)</code> 是一个名为 <code>&lt;^&gt;</code> 的操作符函数，那么 <code>playerOneScore &lt;^&gt; playerOneScore</code> 也会造成像 <code>balance(&amp;playerOneScore, &amp;playerOneScore)</code> 一样的冲突。</p>
</blockquote>
<h2 id="方法里-self-的访问冲突">方法里 self 的访问冲突</h2>
<p>一个结构体的 mutating 方法会在调用期间对 <code>self</code> 进行写访问。例如，想象一下这么一个游戏，每一个玩家都有血量，受攻击时血量会下降，并且有敌人的数量，使用特殊技能时会减少敌人数量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> health: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> energy: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> maxHealth <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">restoreHealth</span>() &#123;</span><br><span class="line">        health <span class="operator">=</span> <span class="type">Player</span>.maxHealth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的 <code>restoreHealth()</code> 方法里，一个对于 <code>self</code> 的写访问会从方法开始直到方法 return。在这种情况下，<code>restoreHealth()</code> 里的其它代码不可以对 <code>Player</code> 实例的属性发起重叠的访问。下面的 <code>shareHealth(with:)</code> 方法接受另一个 <code>Player</code> 的实例作为 in-out 参数，产生了访问重叠的可能性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">shareHealth</span>(<span class="params">with</span> <span class="params">teammate</span>: <span class="keyword">inout</span> <span class="type">Player</span>) &#123;</span><br><span class="line">        balance(<span class="operator">&amp;</span>teammate.health, <span class="operator">&amp;</span>health)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oscar <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Oscar&quot;</span>, health: <span class="number">10</span>, energy: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> maria <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Maria&quot;</span>, health: <span class="number">5</span>, energy: <span class="number">10</span>)</span><br><span class="line">oscar.shareHealth(with: <span class="operator">&amp;</span>maria)  <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure>
<p>上面的例子里，调用 <code>shareHealth(with:)</code> 方法去把 <code>oscar</code> 玩家的血量分享给 <code>maria</code> 玩家并不会造成冲突。在方法调用期间会对 <code>oscar</code> 发起写访问，因为在 mutating 方法里 <code>self</code> 就是 <code>oscar</code>，同时对于 <code>maria</code> 也会发起写访问，因为 <code>maria</code> 作为 in-out 参数传入。过程如下，它们会访问内存的不同位置。即使两个写访问重叠了，它们也不会冲突。</p>
<p><img src="https://docs.swift.org/swift-book/_images/memory_share_health_maria_2x.png" alt=""></p>
<p>当然，如果你将 <code>oscar</code> 作为参数传入 <code>shareHealth(with:)</code> 里，就会产生冲突：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oscar.shareHealth(with: <span class="operator">&amp;</span>oscar)</span><br><span class="line"><span class="comment">// 错误：oscar 访问冲突</span></span><br></pre></td></tr></table></figure>
<p>mutating 方法在调用期间需要对 <code>self</code> 发起写访问，而同时 in-out 参数也需要写访问。在方法里，<code>self</code> 和 <code>teammate</code> 都指向了同一个存储地址——就像下面展示的那样。对于同一块内存同时进行两个写访问，并且它们重叠了，就此产生了冲突。</p>
<p><img src="https://docs.swift.org/swift-book/_images/memory_share_health_oscar_2x.png" alt=""></p>
<h2 id="属性的访问冲突">属性的访问冲突</h2>
<p>如结构体，元组和枚举的类型都是由多个独立的值组成的，例如结构体的属性或元组的元素。因为它们都是值类型，修改值的任何一部分都是对于整个值的修改，意味着其中一个属性的读或写访问都需要访问整一个值。例如，元组元素的写访问重叠会产生冲突：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerInformation <span class="operator">=</span> (health: <span class="number">10</span>, energy: <span class="number">20</span>)</span><br><span class="line">balance(<span class="operator">&amp;</span>playerInformation.health, <span class="operator">&amp;</span>playerInformation.energy)</span><br><span class="line"><span class="comment">// 错误：playerInformation 的属性访问冲突</span></span><br></pre></td></tr></table></figure>
<p>上面的例子里，传入同一元组的元素对 <code>balance(_:_:)</code> 进行调用，产生了冲突，因为 <code>playerInformation</code> 的访问产生了写访问重叠。<code>playerInformation.health</code> 和 <code>playerInformation.energy</code> 都被作为 in-out 参数传入，意味着 <code>balance(_:_:)</code> 需要在函数调用期间对它们发起写访问。任何情况下，对于元组元素的写访问都需要对整个元组发起写访问。这意味着对于 <code>playerInfomation</code> 发起的两个写访问重叠了，造成冲突。</p>
<p>下面的代码展示了一样的错误，对于一个存储在全局变量里的结构体属性的写访问重叠了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> holly <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Holly&quot;</span>, health: <span class="number">10</span>, energy: <span class="number">10</span>)</span><br><span class="line">balance(<span class="operator">&amp;</span>holly.health, <span class="operator">&amp;</span>holly.energy)  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>在实践中，大多数对于结构体属性的访问都会安全的重叠。例如，将上面例子里的变量 <code>holly</code> 改为本地变量而非全局变量，编译器就会可以保证这个重叠访问是安全的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> oscar <span class="operator">=</span> <span class="type">Player</span>(name: <span class="string">&quot;Oscar&quot;</span>, health: <span class="number">10</span>, energy: <span class="number">10</span>)</span><br><span class="line">    balance(<span class="operator">&amp;</span>oscar.health, <span class="operator">&amp;</span>oscar.energy)  <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子里，<code>oscar</code> 的 <code>health</code> 和 <code>energy</code> 都作为 in-out 参数传入了 <code>balance(_:_:)</code> 里。编译器可以保证内存安全，因为两个存储属性任何情况下都不会相互影响。</p>
<p>限制结构体属性的重叠访问对于保证内存安全不是必要的。保证内存安全是必要的，但因为访问独占权的要求比内存安全还要更严格——意味着即使有些代码违反了访问独占权的原则，也是内存安全的，所以如果编译器可以保证这种非专属的访问是安全的，那 Swift 就会允许这种行为的代码运行。特别是当你遵循下面的原则时，它可以保证结构体属性的重叠访问是安全的：</p>
<ul>
<li>你访问的是实例的存储属性，而不是计算属性或类的属性</li>
<li>结构体是本地变量的值，而非全局变量</li>
<li>结构体要么没有被闭包捕获，要么只被非逃逸闭包捕获了</li>
</ul>
<p>如果编译器无法保证访问的安全性，它就不会允许那次访问。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/07/12/Swift/swift%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/07/11/Swift/swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"
                            aria-label=": swift自动引用计数"
                        >
                            swift自动引用计数
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-11T10:13:17+08:00">
	
		    2023 年 7 月 11 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="自动引用计数">自动引用计数</h2>
<p>Swift 使用*自动引用计数（ARC）*机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。</p>
<p>然而在少数情况下，为了能帮助你管理内存，ARC 需要更多的，代码之间关系的信息。本章描述了这些情况，并且为你示范怎样才能使 ARC 来管理你的应用程序的所有内存。在 Swift 使用 ARC 与在 Obejctive-C 中使用 ARC 非常类似，具体请参考 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226">过渡到 ARC 的发布说明</a>。</p>
<blockquote>
<p>注意</p>
<p>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
</blockquote>
<h2 id="自动引用计数的工作机制">自动引用计数的工作机制</h2>
<p>当你每次创建一个类的新的实例的时候，ARC 会分配一块内存来储存该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的存储型属性的值。</p>
<p>此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>
<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。</p>
<p>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为 1，ARC 都不会销毁这个实例。</p>
<p>为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。</p>
<h2 id="自动引用计数实践">自动引用计数实践</h2>
<p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的 <code>Person</code> 类开始，并定义了一个叫 <code>name</code> 的常量属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Person</code> 类有一个构造器，此构造器为实例的 <code>name</code> 属性赋值，并打印一条消息以表明初始化过程生效。<code>Person</code> 类也拥有一个析构器，这个析构器会在实例被销毁时打印一条消息。</p>
<p>接下来的代码片段定义了三个类型为 <code>Person?</code> 的变量，用来按照代码片段中的顺序，为新的 <code>Person</code> 实例建立多个引用。由于这些变量是被定义为可选类型（<code>Person?</code>，而不是 <code>Person</code>），它们的值会被自动初始化为 <code>nil</code>，目前还不会引用到 <code>Person</code> 类的实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reference1: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference2: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference3: <span class="type">Person</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建 <code>Person</code> 类的新实例，并且将它赋值给三个变量中的一个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“John Appleseed is being initialized”</span></span><br></pre></td></tr></table></figure>
<p>应当注意到当你调用 <code>Person</code> 类的构造器的时候，<code>&quot;John Appleseed is being initialized&quot;</code> 会被打印出来。由此可以确定构造器被执行。</p>
<p>由于 <code>Person</code> 类的新实例被赋值给了 <code>reference1</code> 变量，所以 <code>reference1</code> 到 <code>Person</code> 类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证 <code>Person</code> 实例被保持在内存中不被销毁。</p>
<p>如果你将同一个 <code>Person</code> 实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference2 <span class="operator">=</span> reference1</span><br><span class="line">reference3 <span class="operator">=</span> reference1</span><br></pre></td></tr></table></figure>
<p>现在这一个 <code>Person</code> 实例已经有三个强引用了。</p>
<p>如果你通过给其中两个变量赋值 <code>nil</code> 的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，<code>Person</code> 实例不会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">reference2 <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>在你清楚地表明不再使用这个 <code>Person</code> 实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference3 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印“John Appleseed is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<h2 id="类实例之间的循环强引用">类实例之间的循环强引用</h2>
<p>在上面的例子中，ARC 会跟踪你所新创建的 <code>Person</code> 实例的引用数量，并且会在 <code>Person</code> 实例不再被需要时销毁它。</p>
<p>然而，我们可能会写出一个类实例的强引用数<em>永远不能</em>变成 <code>0</code> 的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的<em>循环强引用</em>。</p>
<p>你可以通过定义类之间的关系为弱引用或无主引用，以替代强引用，从而解决循环强引用的问题。具体的过程在 <a href="#resolving_strong_reference_cycles_between_class_instances">解决类实例之间的循环强引用</a> 中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。</p>
<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：<code>Person</code> 和 <code>Apartment</code>，用来建模公寓和它其中的居民：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name <span class="operator">=</span> name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apartment</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">unit</span>: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit <span class="operator">=</span> unit &#125;</span><br><span class="line">    <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Apartment <span class="subst">\(unit)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个 <code>Person</code> 实例有一个类型为 <code>String</code>，名字为 <code>name</code> 的属性，并有一个可选的初始化为 <code>nil</code> 的 <code>apartment</code> 属性。<code>apartment</code> 属性是可选的，因为一个人并不总是拥有公寓。</p>
<p>类似的，每个 <code>Apartment</code> 实例有一个叫 <code>unit</code>，类型为 <code>String</code> 的属性，并有一个可选的初始化为 <code>nil</code> 的 <code>tenant</code> 属性。<code>tenant</code> 属性是可选的，因为一栋公寓并不总是有居民。</p>
<p>这两个类都定义了析构器，用以在类实例被析构的时候输出信息。这让你能够知晓 <code>Person</code> 和 <code>Apartment</code> 的实例是否像预期的那样被销毁。</p>
<p>接下来的代码片段定义了两个可选类型的变量 <code>john</code> 和 <code>unit4A</code>，并分别被设定为下面的 <code>Apartment</code> 和 <code>Person</code> 的实例。这两个变量都被初始化为 <code>nil</code>，这正是可选类型的优点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建特定的 <code>Person</code> 和 <code>Apartment</code> 实例并将赋值给 <code>john</code> 和 <code>unit4A</code> 变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line">unit4A <span class="operator">=</span> <span class="type">Apartment</span>(unit: <span class="string">&quot;4A&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在两个实例被创建和赋值后，下图表现了强引用的关系。变量 <code>john</code> 现在有一个指向 <code>Person</code> 实例的强引用，而变量 <code>unit4A</code> 有一个指向 <code>Apartment</code> 实例的强引用：</p>
<p><img src="https://docs.swift.org/swift-book/_images/referenceCycle01_2x.png" alt=""></p>
<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量 <code>john</code> 和 <code>unit4A</code> 中的实例，这样实例的属性才能被赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john<span class="operator">!</span>.apartment <span class="operator">=</span> unit4A</span><br><span class="line">unit4A<span class="operator">!</span>.tenant <span class="operator">=</span> john</span><br></pre></td></tr></table></figure>
<p>在将两个实例联系在一起之后，强引用的关系如图所示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/referenceCycle02_2x.png" alt=""></p>
<p>不幸的是，这两个实例关联后会产生一个循环强引用。<code>Person</code> 实例现在有了一个指向 <code>Apartment</code> 实例的强引用，而 <code>Apartment</code> 实例也有了一个指向 <code>Person</code> 实例的强引用。因此，当你断开 <code>john</code> 和 <code>unit4A</code> 变量所持有的强引用时，引用计数并不会降为 <code>0</code>，实例也不会被 ARC 销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">unit4A <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>注意，当你把这两个变量设为 <code>nil</code> 时，没有任何一个析构器被调用。循环强引用会一直阻止 <code>Person</code> 和 <code>Apartment</code> 类实例的销毁，这就在你的应用程序中造成了内存泄漏。</p>
<p>在你将 <code>john</code> 和 <code>unit4A</code> 赋值为 <code>nil</code> 后，强引用关系如下图：</p>
<p><img src="https://docs.swift.org/swift-book/_images/referenceCycle03_2x.png" alt=""></p>
<p><code>Person</code> 和 <code>Apartment</code> 实例之间的强引用关系保留了下来并且不会被断开。</p>
<h2 id="解决实例之间的循环强引用">解决实例之间的循环强引用</h2>
<p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。</p>
<p>弱引用和无主引用允许循环引用中的一个实例引用另一个实例而<em>不</em>保持强引用。这样实例能够互相引用而不产生循环强引用。</p>
<p>当其他的实例有更短的生命周期时，使用弱引用，也就是说，当其他实例析构在先时。在上面公寓的例子中，很显然一个公寓在它的生命周期内会在某个时间段没有它的主人，所以一个弱引用就加在公寓类里面，避免循环引用。相比之下，当其他实例有相同的或者更长生命周期时，请使用无主引用。</p>
<h3 id="弱引用">弱引用</h3>
<p><em>弱引用</em>不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上 <code>weak</code> 关键字表明这是一个弱引用。</p>
<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其弱引用赋值为 <code>nil</code>。并且因为弱引用需要在运行时允许被赋值为 <code>nil</code>，所以它们会被定义为可选类型变量，而不是常量。</p>
<p>你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。</p>
<blockquote>
<p>注意</p>
<p>当 ARC 设置弱引用为 <code>nil</code> 时，属性观察不会被触发。</p>
</blockquote>
<p>下面的例子跟上面 <code>Person</code> 和 <code>Apartment</code> 的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code> 的 <code>tenant</code> 属性被声明为弱引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name <span class="operator">=</span> name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apartment</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">unit</span>: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit <span class="operator">=</span> unit &#125;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Apartment <span class="subst">\(unit)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后跟之前一样，建立两个变量（<code>john</code> 和 <code>unit4A</code>）之间的强引用，并关联两个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br><span class="line"></span><br><span class="line">john <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line">unit4A <span class="operator">=</span> <span class="type">Apartment</span>(unit: <span class="string">&quot;4A&quot;</span>)</span><br><span class="line"></span><br><span class="line">john<span class="operator">!</span>.apartment <span class="operator">=</span> unit4A</span><br><span class="line">unit4A<span class="operator">!</span>.tenant <span class="operator">=</span> john</span><br></pre></td></tr></table></figure>
<p>现在，两个关联在一起的实例的引用关系如下图所示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/weakReference01_2x.png" alt=""></p>
<p><code>Person</code> 实例依然保持对 <code>Apartment</code> 实例的强引用，但是 <code>Apartment</code> 实例只持有对 <code>Person</code> 实例的弱引用。这意味着当你通过把 <code>john</code> 变量赋值为 <code>nil</code> 而断开其所保持的强引用时，再也没有指向 <code>Person</code> 实例的强引用了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印“John Appleseed is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>由于再也没有指向 <code>Person</code> 实例的强引用，该实例会被销毁，且 <code>tenant</code> 属性会被赋值为 <code>nil</code>：</p>
<p><img src="https://docs.swift.org/swift-book/_images/weakReference02_2x.png" alt=""></p>
<p>唯一剩下的指向 <code>Apartment</code> 实例的强引用来自于变量 <code>unit4A</code>。如果你断开这个强引用，再也没有指向 <code>Apartment</code> 实例的强引用了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unit4A <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印“Apartment 4A is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>由于再也没有指向 <code>Person</code> 实例的强引用，该实例会被销毁：</p>
<p><img src="https://docs.swift.org/swift-book/_images/weakReference03_2x.png" alt=""></p>
<blockquote>
<p>注意</p>
<p>在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。</p>
</blockquote>
<h3 id="无主引用">无主引用</h3>
<p>和弱引用类似，<em>无主引用</em>不会牢牢保持住引用的实例。和弱引用不同的是，无主引用在其他实例有相同或者更长的生命周期时使用。你可以在声明属性或者变量时，在前面加上关键字 <code>unowned</code> 表示这是一个无主引用。</p>
<p>无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为 <code>nil</code>，因为非可选类型的变量不允许被赋值为 <code>nil</code>。</p>
<blockquote>
<p>重点</p>
<p>使用无主引用，你<em>必须</em>确保引用始终指向一个未销毁的实例。</p>
<p>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。</p>
</blockquote>
<p>下面的例子定义了两个类，<code>Customer</code> 和 <code>CreditCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。</p>
<p><code>Customer</code> 和 <code>CreditCard</code> 之间的关系与前面弱引用例子中 <code>Apartment</code> 和 <code>Person</code> 的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code> 类有一个可选类型的 <code>card</code> 属性，但是 <code>CreditCard</code> 类有一个非可选类型的 <code>customer</code> 属性。</p>
<p>此外，只能通过将一个 <code>number</code> 值和 <code>customer</code> 实例传递给 <code>CreditCard</code> 构造器的方式来创建 <code>CreditCard</code> 实例。这样可以确保当创建 <code>CreditCard</code> 实例时总是有一个 <code>customer</code> 实例与之关联。</p>
<p>由于信用卡总是关联着一个客户，因此将 <code>customer</code> 属性定义为无主引用，用以避免循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCard</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">UInt64</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">number</span>: <span class="type">UInt64</span>, <span class="params">customer</span>: <span class="type">Customer</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number <span class="operator">=</span> number</span><br><span class="line">        <span class="keyword">self</span>.customer <span class="operator">=</span> customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Card #<span class="subst">\(number)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p><code>CreditCard</code> 类的 <code>number</code> 属性被定义为 <code>UInt64</code> 类型而不是 <code>Int</code> 类型，以确保 <code>number</code> 属性的存储量在 32 位和 64 位系统上都能足够容纳 16 位的卡号。</p>
</blockquote>
<p>下面的代码片段定义了一个叫 <code>john</code> 的可选类型 <code>Customer</code> 变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建 <code>Customer</code> 类的实例，用它初始化 <code>CreditCard</code> 实例，并将新创建的 <code>CreditCard</code> 实例赋值为客户的 <code>card</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="type">Customer</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line">john<span class="operator">!</span>.card <span class="operator">=</span> <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john<span class="operator">!</span>)</span><br></pre></td></tr></table></figure>
<p>在你关联两个实例后，它们的引用关系如下图所示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/unownedReference01_2x.png" alt=""></p>
<p><code>Customer</code> 实例持有对 <code>CreditCard</code> 实例的强引用，而 <code>CreditCard</code> 实例持有对 <code>Customer</code> 实例的无主引用。</p>
<p>由于 <code>customer</code> 的无主引用，当你断开 <code>john</code> 变量持有的强引用时，再也没有指向 <code>Customer</code> 实例的强引用了：</p>
<p><img src="https://docs.swift.org/swift-book/_images/unownedReference02_2x.png" alt=""></p>
<p>由于再也没有指向 <code>Customer</code> 实例的强引用，该实例被销毁了。其后，再也没有指向 <code>CreditCard</code> 实例的强引用，该实例也随之被销毁了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印“John Appleseed is being deinitialized”</span></span><br><span class="line"><span class="comment">// 打印“Card #1234567890123456 is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>最后的代码展示了在 <code>john</code> 变量被设为 <code>nil</code> 后 <code>Customer</code> 实例和 <code>CreditCard</code> 实例的析构器都打印出了“销毁”的信息。</p>
<blockquote>
<p>注意</p>
<p>上面的例子展示了如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况（例如，出于性能方面的原因），Swift 还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。 你可以通过 <code>unowned(unsafe)</code> 来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作。</p>
</blockquote>
<h3 id="无主引用和隐式解包可选值属性">无主引用和隐式解包可选值属性</h3>
<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>
<p><code>Person</code> 和 <code>Apartment</code> 的例子展示了两个属性的值都允许为 <code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>
<p><code>Customer</code> 和 <code>CreditCard</code> 的例子展示了一个属性的值允许为 <code>nil</code>，而另一个属性的值不允许为 <code>nil</code>，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>
<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为 <code>nil</code>。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解包可选值属性。</p>
<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>
<p>下面的例子定义了两个类，<code>Country</code> 和 <code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，<code>Country</code> 类拥有一个 <code>capitalCity</code> 属性，而 <code>City</code> 类有一个 <code>country</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capitalCity: <span class="type">City</span>!</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">capitalName</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.capitalCity <span class="operator">=</span> <span class="type">City</span>(name: capitalName, country: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">City</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> country: <span class="type">Country</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">country</span>: <span class="type">Country</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.country <span class="operator">=</span> country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了建立两个类的依赖关系，<code>City</code> 的构造器接受一个 <code>Country</code> 实例作为参数，并且将实例保存到 <code>country</code> 属性。</p>
<p><code>Country</code> 的构造器调用了 <code>City</code> 的构造器。然而，只有 <code>Country</code> 的实例完全初始化后，<code>Country</code> 的构造器才能把 <code>self</code> 传给 <code>City</code> 的构造器。在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#two_phase_initialization">两段式构造过程</a> 中有具体描述。</p>
<p>为了满足这种需求，通过在类型结尾处加上感叹号（<code>City!</code>）的方式，将 <code>Country</code> 的 <code>capitalCity</code> 属性声明为隐式解包可选值类型的属性。这意味着像其他可选类型一样，<code>capitalCity</code> 属性的默认值为 <code>nil</code>，但是不需要展开它的值就能访问它。在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/01_The_Basics.html#implicityly_unwrapped_optionals">隐式解包可选值</a> 中有描述。</p>
<p>由于 <code>capitalCity</code> 默认值为 <code>nil</code>，一旦 <code>Country</code> 的实例在构造器中给 <code>name</code> 属性赋值后，整个初始化过程就完成了。这意味着一旦 <code>name</code> 属性被赋值后，<code>Country</code> 的构造器就能引用并传递隐式的 <code>self</code>。<code>Country</code> 的构造器在赋值 <code>capitalCity</code> 时，就能将 <code>self</code> 作为参数传递给 <code>City</code> 的构造器。</p>
<p>以上的意义在于你可以通过一条语句同时创建 <code>Country</code> 和 <code>City</code> 的实例，而不产生循环强引用，并且 <code>capitalCity</code> 的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> country <span class="operator">=</span> <span class="type">Country</span>(name: <span class="string">&quot;Canada&quot;</span>, capitalName: <span class="string">&quot;Ottawa&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(country.name)</span>&#x27;s capital city is called <span class="subst">\(country.capitalCity.name)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Canada&#x27;s capital city is called Ottawa”</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，使用隐式解包可选值值意味着满足了类的构造器的两个构造阶段的要求。<code>capitalCity</code> 属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。</p>
<h2 id="闭包的循环强引用">闭包的循环强引用</h2>
<p>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。</p>
<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如 <code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如 <code>self.someMethod()</code>。这两种情况都导致了闭包“捕获”<code>self</code>，从而产生了循环强引用。</p>
<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>
<p>Swift 提供了一种优雅的方法来解决这个问题，称之为 <code>闭包捕获列表</code>（closure capture list）。同样的，在学习如何用闭包捕获列表打破循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。</p>
<p>下面的例子为你展示了当一个闭包引用了 <code>self</code> 后是如何产生一个循环强引用的。例子中定义了一个叫 <code>HTMLElement</code> 的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLElement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> asHTML: () -&gt; <span class="type">String</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text <span class="operator">=</span> <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">text</span>: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HTMLElement</code> 类定义了一个 <code>name</code> 属性来表示这个元素的名称，例如代表头部元素的 <code>&quot;h1&quot;</code>，代表段落的 <code>&quot;p&quot;</code>，或者代表换行的 <code>&quot;br&quot;</code>。<code>HTMLElement</code> 还定义了一个可选属性 <code>text</code>，用来设置 HTML 元素呈现的文本。</p>
<p>除了上面的两个属性，<code>HTMLElement</code> 还定义了一个 <code>lazy</code> 属性 <code>asHTML</code>。这个属性引用了一个将 <code>name</code> 和 <code>text</code> 组合成 HTML 字符串片段的闭包。该属性是 <code>Void -&gt; String</code> 类型，或者可以理解为“一个没有参数，返回 <code>String</code> 的函数”。</p>
<p>默认情况下，闭包赋值给了 <code>asHTML</code> 属性，这个闭包返回一个代表 HTML 标签的字符串。如果 <code>text</code> 值存在，该标签就包含可选值 <code>text</code>；如果 <code>text</code> 不存在，该标签就不包含文本。对于段落元素，根据 <code>text</code> 是 <code>&quot;some text&quot;</code> 还是 <code>nil</code>，闭包会返回 <code>&quot;&lt;p&gt;some text&lt;/p&gt;&quot;</code> 或者 <code>&quot;&lt;p /&gt;&quot;</code>。</p>
<p>可以像实例方法那样去命名、使用 <code>asHTML</code> 属性。然而，由于 <code>asHTML</code> 是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。</p>
<p>例如，可以将一个闭包赋值给 <code>asHTML</code> 属性，这个闭包能在 <code>text</code> 属性是 <code>nil</code> 时使用默认文本，这是为了避免返回一个空的 HTML 标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heading <span class="operator">=</span> <span class="type">HTMLElement</span>(name: <span class="string">&quot;h1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> defaultText <span class="operator">=</span> <span class="string">&quot;some default text&quot;</span></span><br><span class="line">heading.asHTML <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(heading.name)</span>&gt;<span class="subst">\(heading.text <span class="operator">??</span> defaultText)</span>&lt;/<span class="subst">\(heading.name)</span>&gt;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(heading.asHTML())</span><br><span class="line"><span class="comment">// 打印“&lt;h1&gt;some default text&lt;/h1&gt;”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p><code>asHTML</code> 声明为 <code>lazy</code> 属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用 <code>asHTML</code>。也就是说，在默认的闭包中可以使用 <code>self</code>，因为只有当初始化完成以及 <code>self</code> 确实存在后，才能访问 <code>lazy</code> 属性。</p>
</blockquote>
<p><code>HTMLElement</code> 类只提供了一个构造器，通过 <code>name</code> 和 <code>text</code>（如果有的话）参数来初始化一个新元素。该类也定义了一个析构器，当 <code>HTMLElement</code> 实例被销毁时，打印一条消息。</p>
<p>下面的代码展示了如何用 <code>HTMLElement</code> 类创建实例并打印消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? <span class="operator">=</span> <span class="type">HTMLElement</span>(name: <span class="string">&quot;p&quot;</span>, text: <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph<span class="operator">!</span>.asHTML())</span><br><span class="line"><span class="comment">// 打印“&lt;p&gt;hello, world&lt;/p&gt;”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>上面的 <code>paragraph</code> 变量定义为可选类型的 <code>HTMLElement</code>，因此我们可以赋值 <code>nil</code> 给它来演示循环强引用。</p>
</blockquote>
<p>不幸的是，上面写的 <code>HTMLElement</code> 类产生了类实例和作为 <code>asHTML</code> 默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/closureReferenceCycle01_2x.png" alt=""></p>
<p>实例的 <code>asHTML</code> 属性持有闭包的强引用。但是，闭包在其闭包体内使用了 <code>self</code>（引用了 <code>self.name</code> 和 <code>self.text</code>），因此闭包捕获了 <code>self</code>，这意味着闭包又反过来持有了 <code>HTMLElement</code> 实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包捕获值的信息，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/07_Closures.html#capturing_values">值捕获</a>）。</p>
<blockquote>
<p>注意</p>
<p>虽然闭包多次使用了 <code>self</code>，它只捕获 <code>HTMLElement</code> 实例的一个强引用。</p>
</blockquote>
<p>如果设置 <code>paragraph</code> 变量为 <code>nil</code>，打破它持有的 <code>HTMLElement</code> 实例的强引用，<code>HTMLElement</code> 实例和它的闭包都不会被销毁，也是因为循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paragraph <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>HTMLElement</code> 的析构器中的消息并没有被打印，证明了 <code>HTMLElement</code> 实例并没有被销毁。</p>
<h2 id="解决闭包的循环强引用">解决闭包的循环强引用</h2>
<p>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>
<blockquote>
<p>注意</p>
<p>Swift 有如下要求：只要在闭包内使用 <code>self</code> 的成员，就要用 <code>self.someProperty</code> 或者 <code>self.someMethod()</code>（而不只是 <code>someProperty</code> 或 <code>someMethod()</code>）。这提醒你可能会一不小心就捕获了 <code>self</code>。</p>
</blockquote>
<h3 id="定义捕获列表">定义捕获列表</h3>
<p>捕获列表中的每一项都由一对元素组成，一个元素是 <code>weak</code> 或 <code>unowned</code> 关键字，另一个元素是类实例的引用（例如 <code>self</code>）或初始化过的变量（如 <code>delegate = self.delegate!</code>）。这些项在方括号中用逗号分开。</p>
<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> someClosure: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="operator">=</span> &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate <span class="operator">=</span> <span class="keyword">self</span>.delegate<span class="operator">!</span>] (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 这里是闭包的函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果闭包没有指明参数列表或者返回类型，它们会通过上下文推断，那么可以把捕获列表和关键字 <code>in</code> 放在闭包最开始的地方：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> someClosure: () -&gt; <span class="type">String</span> <span class="operator">=</span> &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate <span class="operator">=</span> <span class="keyword">self</span>.delegate<span class="operator">!</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 这里是闭包的函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="弱引用和无主引用">弱引用和无主引用</h3>
<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为 <code>无主引用</code>。</p>
<p>相反的，在被捕获的引用可能会变为 <code>nil</code> 时，将闭包内的捕获定义为 <code>弱引用</code>。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为 <code>nil</code>。这使我们可以在闭包体内检查它们是否存在。</p>
<blockquote>
<p>注意</p>
<p>如果被捕获的引用绝对不会变为 <code>nil</code>，应该用无主引用，而不是弱引用。</p>
</blockquote>
<p>前面的 <code>HTMLElement</code> 例子中，无主引用是正确的解决循环强引用的方法。这样编写 <code>HTMLElement</code> 类来避免循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLElement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> asHTML: () -&gt; <span class="type">String</span> <span class="operator">=</span> &#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text <span class="operator">=</span> <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">text</span>: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>HTMLElement</code> 实现和之前的实现一致，除了在 <code>asHTML</code> 闭包中多了一个捕获列表。这里，捕获列表是 <code>[unowned self]</code>，表示“将 <code>self</code> 捕获为无主引用而不是强引用”。</p>
<p>和之前一样，我们可以创建并打印 <code>HTMLElement</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? <span class="operator">=</span> <span class="type">HTMLElement</span>(name: <span class="string">&quot;p&quot;</span>, text: <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph<span class="operator">!</span>.asHTML())</span><br><span class="line"><span class="comment">// 打印“&lt;p&gt;hello, world&lt;/p&gt;”</span></span><br></pre></td></tr></table></figure>
<p>使用捕获列表后引用关系如下图所示：</p>
<p><img src="https://docs.swift.org/swift-book/_images/closureReferenceCycle02_2x.png" alt=""></p>
<p>这一次，闭包以无主引用的形式捕获 <code>self</code>，并不会持有 <code>HTMLElement</code> 实例的强引用。如果将 <code>paragraph</code> 赋值为 <code>nil</code>，<code>HTMLElement</code> 实例将会被销毁，并能看到它的析构器打印出的消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paragraph <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印“p is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>你可以查看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter3/04_Expressions.html">捕获列表</a> 章节，获取更多关于捕获列表的信息。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/07/11/Swift/swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/"
                            aria-label=": swift泛型"
                        >
                            swift泛型
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-10T10:13:17+08:00">
	
		    2023 年 7 月 10 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="泛型">泛型</h2>
<p><em>泛型代码</em>让你能根据自定义的需求，编写出适用于任意类型的、灵活可复用的函数及类型。你可避免编写重复的代码，而是用一种清晰抽象的方式来表达代码的意图。</p>
<p>泛型是 Swift 最强大的特性之一，很多 Swift 标准库是基于泛型代码构建的。实际上，即使你没有意识到，你也一直在<em>语言指南</em>中使用泛型。例如，Swift 的 <code>Array</code> 和 <code>Dictionary</code> 都是泛型集合。你可以创建一个 <code>Int</code> 类型数组，也可创建一个 <code>String</code> 类型数组，甚至可以是任意其他 Swift 类型的数组。同样，你也可以创建一个存储任意指定类型的字典，并对该类型没有限制。</p>
<h2 id="泛型解决的问题">泛型解决的问题</h2>
<p>下面是一个标准的非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个 <code>Int</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数使用输入输出参数（<code>inout</code>）来交换 <code>a</code> 和 <code>b</code> 的值，具体请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#in_out_parameters">输入输出参数</a>。</p>
<p><code>swapTwoInts(_:_:)</code> 函数将 <code>b</code> 的原始值换成了 <code>a</code>，将 <code>a</code> 的原始值换成了 <code>b</code>，你可以调用这个函数来交换两个 <code>Int</code> 类型变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“someInt is now 107, and anotherInt is now 3”</span></span><br></pre></td></tr></table></figure>
<p><code>swapTwoInts(_:_:)</code> 函数很实用，但它只能作用于 <code>Int</code> 类型。如果你想交换两个 <code>String</code> 类型值，或者 <code>Double</code> 类型值，你必须编写对应的函数，类似下面 <code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoStrings</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">String</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoDoubles</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Double</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Double</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能注意到了，<code>swapTwoInts(_:_:‘)</code>、<code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code> 函数体是一样的，唯一的区别是它们接受的参数类型（<code>Int</code>、<code>String</code> 和 <code>Double</code>）。</p>
<p>在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。（这些函数的泛型版本已经在下面定义好了。）</p>
<blockquote>
<p>注意</p>
<p>在上面三个函数中，<code>a</code> 和 <code>b</code> 类型必须相同。如果 <code>a</code> 和 <code>b</code> 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 <code>String</code> 类型的变量和一个 <code>Double</code> 类型的变量互换值。试图这样做将导致编译错误。</p>
</blockquote>
<h2 id="泛型函数">泛型函数</h2>
<p>泛型函数可适用于任意类型，下面是函数 <code>swapTwoInts(_:_:)</code> 的泛型版本，命名为 <code>swapTwoValues(_:_:)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapTwoValues(_:_:)</code> 和 <code>swapTwoInts(_:_:)</code> 函数体内容相同，它们只在第一行不同，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>)</span><br></pre></td></tr></table></figure>
<p>泛型版本的函数使用<code>占位符</code>类型名（这里叫做 <code>T</code> ），而不是 <em>实际</em>类型名（例如 <code>Int</code>、<code>String</code> 或 <code>Double</code>），<code>占位符</code>类型名并不关心 <code>T</code> 具体的类型，但它要求 <code>a</code> 和<code>b</code> 必须是相同的类型，<code>T</code> 的实际类型由每次调用 <code>swapTwoValues(_:_:)</code> 来决定。</p>
<p>泛型函数和非泛型函数的另外一个不同之处在于这个泛型函数名（<code>swapTwoValues(_:_:)</code>）后面跟着占位类型名（<code>T</code>），并用尖括号括起来（<code>&lt;T&gt;</code>）。这个尖括号告诉 Swift 那个 <code>T</code> 是 <code>swapTwoValues(_:_:)</code> 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 <code>T</code>的实际类型。</p>
<p><code>swapTwoValues(_:_:)</code> 函数现在可以像 <code>swapTwoInts(_:_:)</code> 那样调用，不同的是它能接受两个任意类型的值，条件是这两个值有着相同的类型。<code>swapTwoValues(_:_:)</code> 函数被调用时，<code>T</code> 所代表的类型都会由传入的值的类型推断出来。</p>
<p>在下面的两个例子中，<code>T</code> 分别代表 <code>Int</code> 和 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="comment">// someInt 现在是 107，anotherInt 现在是 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someString <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> anotherString <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someString, <span class="operator">&amp;</span>anotherString)</span><br><span class="line"><span class="comment">// someString 现在是“world”，anotherString 现在是“hello”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>上面定义的 <code>swapTwoValues(_:_:)</code> 函数是受 <code>swap(_:_:)</code> 函数启发而实现的。后者存在于 Swift 标准库，你可以在你的应用程序中使用它。如果你在代码中需要类似 <code>swapTwoValues(_:_:)</code> 函数的功能，你可以使用已存在的 <code>swap(_:_:)</code> 函数。</p>
</blockquote>
<h2 id="类型参数">类型参数</h2>
<p>上面 <code>swapTwoValues(_:_:)</code> 例子中，占位类型 <code>T</code> 是一个类型参数的例子，类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <code>&lt;T&gt;</code>）。</p>
<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 <code>swapTwoValues(_:_:)</code> 函数中的参数 <code>a</code> 和 <code>b</code>），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 <code>swapTwoValues(_:_:)</code> 例子中，当函数第一次被调用时，<code>T</code> 被 <code>Int</code> 替换，第二次调用时，被 <code>String</code> 替换。）</p>
<p>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</p>
<h2 id="命名类型参数">命名类型参数</h2>
<p>大多情况下，类型参数具有描述下的名称，例如字典 <code>Dictionary&lt;Key, Value&gt;</code> 中的 <code>Key</code> 和 <code>Value</code> 及数组 <code>Array&lt;Element&gt;</code> 中的 <code>Element</code>，这能告诉阅读代码的人这些参数类型与泛型类型或函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字符来表示，例如 <code>T</code>、<code>U</code>、<code>V</code>，例如上面演示函数 <code>swapTwoValues(_:_:)</code> 中的 <code>T</code>。</p>
<blockquote>
<p>注意</p>
<p>请始终使用大写字母开头的驼峰命名法（例如 <code>T</code> 和 <code>MyTypeParameter</code>）来为类型参数命名，以表明它们是占位类型，而不是一个值。</p>
</blockquote>
<h2 id="泛型类型">泛型类型</h2>
<p>除了泛型函数，Swift 还允许自定义<em>泛型类型</em>。这些自定义类、结构体和枚举可以适用于<em>任意类型</em>，类似于 <code>Array</code> 和 <code>Dictionary</code>。</p>
<p>本节将向你展示如何编写一个名为 <code>Stack</code>（栈）的泛型集合类型。栈是值的有序集合，和数组类似，但比数组有更严格的操作限制。数组允许在其中任意位置插入或是删除元素。而栈只允许在集合的末端添加新的元素（称之为入栈）。类似的，栈也只能从末端移除元素（称之为出栈）。</p>
<blockquote>
<p>注意</p>
<p>栈的概念已被 <code>UINavigationController</code> 类用来构造视图控制器的导航结构。你通过调用 <code>UINavigationController</code> 的 <code>pushViewController(_:animated:)</code> 方法来添加新的视图控制器到导航栈，通过 <code>popViewControllerAnimated(_:)</code> 方法来从导航栈中移除视图控制器。每当你需要一个严格的“后进先出”方式来管理集合，栈都是最实用的模型。</p>
</blockquote>
<p>下图展示了入栈（push）和出栈（pop）的行为：</p>
<p><img src="https://docs.swift.org/swift-book/_images/stackPushPop_2x.png" alt=""></p>
<ol>
<li>现在有三个值在栈中。</li>
<li>第四个值被压入到栈的顶部。</li>
<li>现在栈中有四个值，最近入栈的那个值在顶部。</li>
<li>栈中最顶部的那个值被移除出栈。</li>
<li>一个值移除出栈后，现在栈又只有三个值了。</li>
</ol>
<p>下面展示如何编写一个非泛型版本的栈，以 <code>Int</code> 型的栈为例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IntStack</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体在栈中使用一个名为 <code>items</code> 的数组属性来存储值。栈提供了两个方法：<code>push(_:)</code> 和 <code>pop()</code>，用来向栈中压入值以及从栈中移除值。这些方法被标记为 <code>mutating</code>，因为它们需要修改结构体的 <code>items</code> 数组。</p>
<p>上面的 <code>IntStack</code> 结构体只能用于 <code>Int</code> 类型。不过，可以定义一个泛型 <code>Stack</code> 结构体，从而能够处理任意类型的值。</p>
<p>下面是相同代码的泛型版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>Stack</code> 基本上和 <code>IntStack</code> 相同，只是用占位类型参数 <code>Element</code> 代替了实际的 <code>Int</code> 类型。这个类型参数包裹在紧随结构体名的一对尖括号里（&lt;<code>Element</code>&gt;）。</p>
<p><code>Element</code> 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 <code>Element</code> 来引用。在这个例子中，<code>Element</code> 在如下三个地方被用作占位符：</p>
<ul>
<li>创建 <code>items</code> 属性，使用 <code>Element</code> 类型的空数组对其进行初始化。</li>
<li>指定 <code>push(_:)</code> 方法的唯一参数 <code>item</code> 的类型必须是 <code>Element</code> 类型。</li>
<li>指定 <code>pop()</code> 方法的返回值类型必须是 <code>Element</code> 类型。</li>
</ul>
<p>由于 <code>Stack</code> 是泛型类型，因此可以用来创建适用于 Swift 中任意有效类型的栈，就像 <code>Array</code> 和 <code>Dictionary</code> 那样。</p>
<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个 <code>Stack</code> 实例。例如，要创建一个 <code>String</code> 类型的栈，可以写成 <code>Stack&lt;String&gt;()</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;uno&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;dos&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;tres&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;cuatro&quot;</span>)</span><br><span class="line"><span class="comment">// 栈中现在有 4 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了 <code>stackOfStrings</code> 如何将这四个值压栈：</p>
<p><img src="https://docs.swift.org/swift-book/_images/stackPushedFourStrings_2x.png" alt=""></p>
<p>移除并返回栈顶部的值“cuatro”，即出栈：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fromTheTop <span class="operator">=</span> stackOfStrings.pop()</span><br><span class="line"><span class="comment">// fromTheTop 的值为“cuatro”，现在栈中还有 3 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了如何将顶部的值出栈：</p>
<p><img src="https://docs.swift.org/swift-book/_images/stackPoppedOneString_2x.png" alt=""></p>
<h2 id="泛型扩展">泛型扩展</h2>
<p>当对泛型类型进行扩展时，你并不需要提供类型参数列表作为定义的一部分。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>
<p>下面的例子扩展了泛型类型 <code>Stack</code>，为其添加了一个名为 <code>topItem</code> 的只读计算型属性，它将会返回当前栈顶元素且不会将其从栈中移除：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : items[items.count <span class="operator">-</span> <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>topItem</code> 属性会返回 <code>Element</code> 类型的可选值。当栈为空的时候，<code>topItem</code> 会返回 <code>nil</code>；当栈不为空的时候，<code>topItem</code> 会返回 <code>items</code> 数组中的最后一个元素。</p>
<p>注意：这个扩展并没有定义类型参数列表。相反的，<code>Stack</code> 类型已有的类型参数名称 <code>Element</code>，被用在扩展中来表示计算型属性 <code>topItem</code> 的可选类型。</p>
<p>计算型属性 <code>topItem</code> 现在可以用来访问任意 <code>Stack</code> 实例的顶端元素且不移除它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> topItem <span class="operator">=</span> stackOfStrings.topItem &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The top item on the stack is <span class="subst">\(topItem)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The top item on the stack is tres.”</span></span><br></pre></td></tr></table></figure>
<p>泛型类型的扩展，还可以包括类型扩展需要额外满足的条件，从而对类型添加新功能，这一部分将在<a href="#extensions-with-a-generic-where-clause">具有泛型 Where 子句的扩展</a>中进行讨论。</p>
<h2 id="类型约束">类型约束</h2>
<p><code>swapTwoValues(_:_:)</code> 函数和 <code>Stack</code> 适用于任意类型。不过，如果能对泛型函数或泛型类型中添加特定的<em>类型约束</em>，这将在某些情况下非常有用。类型约束指定类型参数必须继承自指定类、遵循特定的协议或协议组合。</p>
<p>例如，Swift 的 <code>Dictionary</code> 类型对字典的键的类型做了些限制。在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/04_Collection_Types.html#dictionaries">字典的描述</a> 中，字典键的类型必须是可哈希（hashable）的。也就是说，必须有一种方法能够唯一地表示它。字典键之所以要是可哈希的，是为了便于检查字典中是否已经包含某个特定键的值。若没有这个要求，字典将无法判断是否可以插入或替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。</p>
<p>这个要求通过 <code>Dictionary</code> 键类型上的类型约束实现，它指明了键必须遵循 Swift 标准库中定义的 <code>Hashable</code> 协议。所有 Swift 的基本类型（例如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希的。</p>
<p>当自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。像 <code>可哈希（hashable）</code> 这种抽象概念根据它们的概念特征来描述类型，而不是它们的具体类型。</p>
<h3 id="类型约束语法">类型约束语法</h3>
<p>在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束。下面将展示泛型函数约束的基本语法（与泛型类型的语法相同）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>&lt;<span class="type">T</span>: <span class="type">SomeClass</span>, <span class="type">U</span>: <span class="type">SomeProtocol</span>&gt;(<span class="params">someT</span>: <span class="type">T</span>, <span class="params">someU</span>: <span class="type">U</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数有两个类型参数。第一个类型参数 <code>T</code> 必须是 <code>SomeClass</code> 子类；第二个类型参数 <code>U</code> 必须符合 <code>SomeProtocol</code> 协议。</p>
<h3 id="类型约束实践">类型约束实践</h3>
<p>这里有个名为 <code>findIndex(ofString:in:)</code> 的非泛型函数，该函数的功能是在一个 <code>String</code> 数组中查找给定 <code>String</code> 值的索引。若查找到匹配的字符串，<code>findIndex(ofString:in:)</code> 函数返回该字符串在数组中的索引值，否则返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>(<span class="params">ofString</span> <span class="params">valueToFind</span>: <span class="type">String</span>, <span class="params">in</span> <span class="params">array</span>: [<span class="type">String</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findIndex(ofString:in:)</code> 函数可以用于查找字符串数组中的某个字符串值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings <span class="operator">=</span> [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;llama&quot;</span>, <span class="string">&quot;parakeet&quot;</span>, <span class="string">&quot;terrapin&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> foundIndex <span class="operator">=</span> findIndex(ofString: <span class="string">&quot;llama&quot;</span>, in: strings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The index of llama is <span class="subst">\(foundIndex)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The index of llama is 2”</span></span><br></pre></td></tr></table></figure>
<p>如果只能查找字符串在数组中的索引，用处不是很大。不过，你可以用占位类型 <code>T</code> 替换 <code>String</code> 类型来写出具有相同功能的泛型函数 <code>findIndex(_:_:)</code>。</p>
<p>下面展示了 <code>findIndex(ofString:in:)</code> 函数的泛型版本 <code>findIndex(of:in:)</code>。请注意这个函数返回值的类型仍然是 <code>Int?</code>，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因将在后面说明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面所写的函数无法通过编译。问题出在相等性检查上，即 “<code>if value == valueToFind</code>”。不是所有的 Swift 类型都可以用等式符（<code>==</code>）进行比较。例如，如果你自定义类或结构体来描述复杂的数据模型，对于这个类或结构体而言，Swift 无法明确知道“相等”意味着什么。正因如此，这部分代码无法保证适用于任意类型 <code>T</code>，当你试图编译这部分代码时就会出现相应的错误。</p>
<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 <code>Equatable</code> 协议，该协议要求任何遵循该协议的类型必须实现等式符（<code>==</code>）及不等符（<code>!=</code>），从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 <code>Equatable</code> 协议。</p>
<p>遵循 <code>Equatable</code> 协议的类型都可以安全地用于 <code>findIndex(of:in:)</code> 函数，因为其保证支持等式操作符。为了说明这个事情，当定义一个函数时，你可以定义一个 <code>Equatable</code> 类型约束作为类型参数定义的一部分：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findIndex(of:in:)</code> 类型参数写做 <code>T: Equatable</code>，也就意味着“任何符合 <code>Equatable</code> 协议的类型 <code>T</code>”。</p>
<p><code>findIndex(of:in:)</code> 函数现在可以成功编译了，并且适用于任何符合 <code>Equatable</code> 的类型，如 <code>Double</code> 或 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doubleIndex <span class="operator">=</span> findIndex(of: <span class="number">9.3</span>, in: [<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>])</span><br><span class="line"><span class="comment">// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中</span></span><br><span class="line"><span class="keyword">let</span> stringIndex <span class="operator">=</span> findIndex(of: <span class="string">&quot;Andrea&quot;</span>, in: [<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Malcolm&quot;</span>, <span class="string">&quot;Andrea&quot;</span>])</span><br><span class="line"><span class="comment">// stringIndex 类型为 Int?，其值为 2</span></span><br></pre></td></tr></table></figure>
<h2 id="关联类型">关联类型</h2>
<p>定义一个协议时，声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位符名称，其代表的实际类型在协议被遵循时才会被指定。关联类型通过 <code>associatedtype</code> 关键字来指定。</p>
<h3 id="关联类型实践">关联类型实践</h3>
<p>下面例子定义了一个 <code>Container</code> 协议，该协议定义了一个关联类型 <code>Item</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Container</code> 协议定义了三个任何遵循该协议的类型（即容器）必须提供的功能：</p>
<ul>
<li>必须可以通过 <code>append(_:)</code> 方法添加一个新元素到容器里。</li>
<li>必须可以通过 <code>count</code> 属性获取容器中元素的数量，并返回一个 Int 值。</li>
<li>必须可以通过索引值类型为 <code>Int</code> 的下标检索到容器中的每一个元素。</li>
</ul>
<p>该协议没有指定容器中元素该如何存储以及元素类型。该协议只指定了任何遵从 <code>Container</code> 协议的类型必须提供的三个功能。遵从协议的类型在满足这三个条件的情况下，也可以提供其他额外的功能。</p>
<p>任何遵从 <code>Container</code> 协议的类型必须能够指定其存储的元素的类型。具体来说，它必须确保添加到容器内的元素以及下标返回的元素类型是正确的。</p>
<p>为了定义这些条件，<code>Container</code> 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。<code>Container</code> 协议需要指定任何通过 <code>append(_:)</code> 方法添加到容器中的元素和容器内的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。</p>
<p>为此，<code>Container</code> 协议声明了一个关联类型 <code>Item</code>，写作 <code>associatedtype Item</code>。协议没有定义 <code>Item</code> 是什么，这个信息留给遵从协议的类型来提供。尽管如此，<code>Item</code> 别名提供了一种方式来引用 <code>Container</code> 中元素的类型，并将之用于 <code>append(_:)</code> 方法和下标，从而保证任何 <code>Container</code> 的行为都能如预期。</p>
<p>这是前面非泛型版本 <code>IntStack</code> 类型，使其遵循 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IntStack</span>: <span class="title class_ inherited__">Container</span> &#123;</span><br><span class="line">    <span class="comment">// IntStack 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Item</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IntStack</code> 结构体实现了 <code>Container</code> 协议的三个要求，其原有功能也不会和这些要求相冲突。</p>
<p>此外，<code>IntStack</code> 在实现 <code>Container</code> 的要求时，指定 <code>Item</code> 为 <code>Int</code> 类型，即 <code>typealias Item = Int</code>，从而将 <code>Container</code> 协议中抽象的 <code>Item</code> 类型转换为具体的 <code>Int</code> 类型。</p>
<p>由于 Swift 的类型推断，实际上在 <code>IntStack</code> 的定义中不需要声明 <code>Item</code> 为 <code>Int</code>。因为 <code>IntStack</code> 符合 <code>Container</code> 协议的所有要求，Swift 只需通过 <code>append(_:)</code> 方法的 <code>item</code> 参数类型和下标返回值的类型，就可以推断出 <code>Item</code> 的具体类型。事实上，如果你在上面的代码中删除了 <code>typealias Item = Int</code> 这一行，一切也可正常工作，因为 Swift 清楚地知道 <code>Item</code> 应该是哪种类型。</p>
<p>你也可以让泛型 <code>Stack</code> 结构体遵循 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="type">Element</span>&gt;: <span class="title class_ inherited__">Container</span> &#123;</span><br><span class="line">    <span class="comment">// Stack&lt;Element&gt; 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一次，占位类型参数 <code>Element</code> 被用作 <code>append(_:)</code> 方法的 <code>item</code> 参数和下标的返回类型。Swift 可以据此推断出 <code>Element</code> 的类型即是 <code>Item</code> 的类型。</p>
<h3 id="扩展现有类型来指定关联类型">扩展现有类型来指定关联类型</h3>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/21_Protocols.html#adding_protocol_conformance_with_an_extension">在扩展添加协议一致性</a> 中描述了如何利用扩展让一个已存在的类型遵循一个协议，这包括使用了关联类型协议。</p>
<p>Swift 的 <code>Array</code> 类型已经提供 <code>append(_:)</code> 方法，<code>count</code> 属性，以及带有 <code>Int</code> 索引的下标来检索其元素。这三个功能都符合 <code>Container</code> 协议的要求，也就意味着你只需声明 <code>Array</code> 遵循<code>Container</code> 协议，就可以扩展 Array，使其遵从 Container 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_ inherited__">Container</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>Array</code> 的 <code>append(_:)</code> 方法和下标确保了 Swift 可以推断出 <code>Item</code> 具体类型。定义了这个扩展后，你可以将任意 <code>Array</code> 当作 Container 来使用。</p>
<h3 id="给关联类型添加约束">给关联类型添加约束</h3>
<p>你可以在协议里给关联类型添加约束来要求遵循的类型满足约束。例如，下面的代码定义了 <code>Container</code> 协议， 要求关联类型 <code>Item</code> 必须遵循 <code>Equatable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要遵守 <code>Container</code> 协议，<code>Item</code> 类型也必须遵守 <code>Equatable</code> 协议。</p>
<h3 id="在关联类型约束里使用协议">在关联类型约束里使用协议</h3>
<p>协议可以作为它自身的要求出现。例如，有一个协议细化了 <code>Container</code> 协议，添加了一个<code>suffix(_:)</code> 方法。<code>suffix(_:)</code> 方法返回容器中从后往前给定数量的元素，并把它们存储在一个 <code>Suffix</code> 类型的实例里。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SuffixableContainer</span>: <span class="title class_ inherited__">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Suffix</span>: <span class="type">SuffixableContainer</span> <span class="keyword">where</span> <span class="type">Suffix</span>.<span class="type">Item</span> <span class="operator">==</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>) -&gt; <span class="type">Suffix</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个协议里，<code>Suffix</code> 是一个关联类型，就像上边例子中 <code>Container</code> 的 <code>Item</code> 类型一样。<code>Suffix</code> 拥有两个约束：它必须遵循 <code>SuffixableContainer</code> 协议（就是当前定义的协议），以及它的 <code>Item</code> 类型必须是和容器里的 <code>Item</code> 类型相同。<code>Item</code> 的约束是一个 <code>where</code> 分句，它在下面<a href="#extensions-with-a-generic-where-clause">具有泛型 Where 子句的扩展</a>中有讨论。</p>
<p>这是上面 <a href="#generic-types">泛型类型</a> 中 <code>Stack</code> 类型的扩展，它遵循了 SuffixableContainer 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span>: <span class="title class_ inherited__">SuffixableContainer</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>) -&gt; <span class="type">Stack</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> <span class="type">Stack</span>()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> (count<span class="operator">-</span>size)<span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            result.append(<span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推断 suffix 结果是Stack。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stackOfInts <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stackOfInts.append(<span class="number">10</span>)</span><br><span class="line">stackOfInts.append(<span class="number">20</span>)</span><br><span class="line">stackOfInts.append(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">let</span> suffix <span class="operator">=</span> stackOfInts.suffix(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// suffix 包含 20 和 30</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>Suffix</code> 是 <code>Stack</code> 的关联类型，也是 <code>Stack</code> ，所以 <code>Stack</code> 的后缀运算返回另一个 <code>Stack</code> 。另外，遵循 <code>SuffixableContainer</code> 的类型可以拥有一个与它自己不同的 <code>Suffix</code> 类型——也就是说后缀运算可以返回不同的类型。比如说，这里有一个非泛型 <code>IntStack</code> 类型的扩展，它遵循了 <code>SuffixableContainer</code> 协议，使用 <code>Stack&lt;Int&gt;</code> 作为它的后缀类型而不是 <code>IntStack</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">IntStack</span>: <span class="title class_ inherited__">SuffixableContainer</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>) -&gt; <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> (count<span class="operator">-</span>size)<span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            result.append(<span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推断 suffix 结果是 Stack&lt;Int&gt;。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型-Where-语句">泛型 Where 语句</h2>
<p><a href="#type_constraints">类型约束</a> 让你能够为泛型函数、下标、类型的类型参数定义一些强制要求。</p>
<p>对关联类型添加约束通常是非常有用的。你可以通过定义一个泛型 <code>where</code> 子句来实现。通过泛型 <code>where</code> 子句让关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 <code>where</code> 关键字紧跟在类型参数列表后面来定义 <code>where</code> 子句，<code>where</code> 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 <code>where</code> 子句。</p>
<p>下面的例子定义了一个名为 <code>allItemsMatch</code> 的泛型函数，用来检查两个 <code>Container</code> 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>被检查的两个 <code>Container</code> 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 <code>where</code> 子句来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">allItemsMatch</span>&lt;<span class="type">C1</span>: <span class="type">Container</span>, <span class="type">C2</span>: <span class="type">Container</span>&gt;</span><br><span class="line">    (<span class="keyword">_</span> <span class="params">someContainer</span>: <span class="type">C1</span>, <span class="keyword">_</span> <span class="params">anotherContainer</span>: <span class="type">C2</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">C1</span>.<span class="type">Item</span> <span class="operator">==</span> <span class="type">C2</span>.<span class="type">Item</span>, <span class="type">C1</span>.<span class="type">Item</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个容器含有相同数量的元素</span></span><br><span class="line">        <span class="keyword">if</span> someContainer.count <span class="operator">!=</span> anotherContainer.count &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查每一对元素是否相等</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>someContainer.count &#123;</span><br><span class="line">            <span class="keyword">if</span> someContainer[i] <span class="operator">!=</span> anotherContainer[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有元素都匹配，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受 <code>someContainer</code> 和 <code>anotherContainer</code> 两个参数。参数 <code>someContainer</code> 的类型为 <code>C1</code>，参数 <code>anotherContainer</code> 的类型为 <code>C2</code>。<code>C1</code> 和 <code>C2</code> 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型。</p>
<p>这个函数的类型参数列表还定义了对两个类型参数的要求：</p>
<ul>
<li><code>C1</code> 必须符合 <code>Container</code> 协议（写作 <code>C1: Container</code>）。</li>
<li><code>C2</code> 必须符合 <code>Container</code> 协议（写作 <code>C2: Container</code>）。</li>
<li><code>C1</code> 的 <code>Item</code> 必须和 <code>C2</code> 的 <code>Item</code> 类型相同（写作 <code>C1.Item == C2.Item</code>）。</li>
<li><code>C1</code> 的 <code>Item</code> 必须符合 <code>Equatable</code> 协议（写作 <code>C1.Item: Equatable</code>）。</li>
</ul>
<p>前两个要求定义在函数的类型形式参数列表里，后两个要求定义在了函数的泛型 <code>where</code> 分句中。</p>
<p>这些要求意味着：</p>
<ul>
<li><code>someContainer</code> 是一个 <code>C1</code> 类型的容器。</li>
<li><code>anotherContainer</code> 是一个 <code>C2</code> 类型的容器。</li>
<li><code>someContainer</code> 和 <code>anotherContainer</code> 包含相同类型的元素。</li>
<li><code>someContainer</code> 中的元素可以通过不等于操作符（!=）来检查它们是否相同。</li>
</ul>
<p>第三个和第四个要求结合起来意味着 <code>anotherContainer</code> 中的元素也可以通过 <code>!=</code> 操作符来比较，因为它们和 <code>someContainer</code> 中的元素类型相同。</p>
<p>这些要求让 <code>allItemsMatch(_:_:)</code> 函数能够比较两个容器，即使它们的容器类型不同。</p>
<p><code>allItemsMatch(_:_:)</code> 函数首先检查两个容器元素个数是否相同，如果元素个数不同，那么一定不匹配，函数就会返回 <code>false</code>。</p>
<p>进行这项检查之后，通过 <code>for-in</code> 循环和半闭区间操作符（<code>..&lt;</code>）来迭代每个元素，检查 <code>someContainer</code> 中的元素是否不等于 <code>anotherContainer</code> 中的对应元素。如果两个元素不相等，那么两个容器不匹配，函数返回 false。</p>
<p>如果循环体结束后未发现任何不匹配的情况，表明两个容器匹配，函数返回 <code>true</code>。</p>
<p>下面是 <code>allItemsMatch(_:_:)</code> 函数的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;uno&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;dos&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;tres&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayOfStrings <span class="operator">=</span> [<span class="string">&quot;uno&quot;</span>, <span class="string">&quot;dos&quot;</span>, <span class="string">&quot;tres&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All items match.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not all items match.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“All items match.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子创建 <code>Stack</code> 实例来存储 <code>String</code> 值，然后将三个字符串压栈。这个例子还通过数组字面量创建了一个 <code>Array</code> 实例，数组中包含同栈中一样的三个字符串。即使栈和数组是不同的类型，但它们都遵从 <code>Container</code> 协议，而且它们都包含相同类型的值。因此你可以用这两个容器作为参数来调用 <code>allItemsMatch(_:_:)</code> 函数。在上面的例子中，<code>allItemsMatch(_:_:)</code> 函数正确地显示了这两个容器中的所有元素都是相互匹配的。</p>
<h2 id="具有泛型-Where-子句的扩展">具有泛型 Where 子句的扩展</h2>
<p>你也可以使用泛型 <code>where</code> 子句作为扩展的一部分。基于以前的例子，下面的示例扩展了泛型 <code>Stack</code> 结构体，添加一个 <code>isTop(_:)</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isTop</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> topItem <span class="operator">=</span> items.last <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topItem <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个新的 <code>isTop(_:)</code> 方法首先检查这个栈是不是空的，然后比较给定的元素与栈顶部的元素。如果你尝试不用泛型 <code>where</code> 子句，会有一个问题：在 <code>isTop(_:)</code> 里面使用了 <code>==</code> 运算符，但是 <code>Stack</code> 的定义没有要求它的元素是符合 <code>Equatable</code> 协议的，所以使用 <code>==</code> 运算符导致编译时错误。使用泛型 <code>where</code> 子句可以为扩展添加新的条件，因此只有当栈中的元素符合 <code>Equatable</code> 协议时，扩展才会添加 <code>isTop(_:)</code> 方法。</p>
<p>以下是 <code>isTop(_:)</code> 方法的调用方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> stackOfStrings.isTop(<span class="string">&quot;tres&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Top element is tres.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Top element is something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Top element is tres.”</span></span><br></pre></td></tr></table></figure>
<p>如果尝试在其元素不符合 <code>Equatable</code> 协议的栈上调用 <code>isTop(_:)</code> 方法，则会收到编译时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NotEquatable</span> &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> notEquatableStack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">NotEquatable</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> notEquatableValue <span class="operator">=</span> <span class="type">NotEquatable</span>()</span><br><span class="line">notEquatableStack.push(notEquatableValue)</span><br><span class="line">notEquatableStack.isTop(notEquatableValue)  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>你可以使用泛型 <code>where</code> 子句去扩展一个协议。基于以前的示例，下面的示例扩展了 <code>Container</code> 协议，添加一个 <code>startsWith(_:)</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> <span class="keyword">where</span> <span class="type">Item</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startsWith</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count <span class="operator">&gt;=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>[<span class="number">0</span>] <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>startsWith(_:)</code> 方法首先确保容器至少有一个元素，然后检查容器中的第一个元素是否与给定的元素相等。任何符合 <code>Container</code> 协议的类型都可以使用这个新的 <code>startsWith(_:)</code> 方法，包括上面使用的栈和数组，只要容器的元素是符合 <code>Equatable</code> 协议的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>].startsWith(<span class="number">42</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starts with 42.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starts with something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Starts with something else.”</span></span><br></pre></td></tr></table></figure>
<p>上述示例中的泛型 <code>where</code> 子句要求 <code>Item</code> 遵循协议，但也可以编写一个泛型 <code>where</code> 子句去要求 <code>Item</code> 为特定类型。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> <span class="keyword">where</span> <span class="type">Item</span> <span class="operator">==</span> <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">average</span>() -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            sum <span class="operator">+=</span> <span class="keyword">self</span>[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum <span class="operator">/</span> <span class="type">Double</span>(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>([<span class="number">1260.0</span>, <span class="number">1200.0</span>, <span class="number">98.6</span>, <span class="number">37.0</span>].average())</span><br><span class="line"><span class="comment">// 打印“648.9”</span></span><br></pre></td></tr></table></figure>
<p>此示例将一个 <code>average()</code> 方法添加到 <code>Item</code> 类型为 <code>Double</code> 的容器中。此方法遍历容器中的元素将其累加，并除以容器的数量计算平均值。它将数量从 <code>Int</code> 转换为 <code>Double</code> 确保能够进行浮点除法。</p>
<p>就像可以在其他地方写泛型 <code>where</code> 子句一样，你可以在一个泛型 <code>where</code> 子句中包含多个条件作为扩展的一部分。用逗号分隔列表中的每个条件。</p>
<h2 id="具有泛型-Where-子句的关联类型">具有泛型 Where 子句的关联类型</h2>
<p>你可以在关联类型后面加上具有泛型 <code>where</code> 的字句。例如，建立一个包含迭代器（<code>Iterator</code>）的容器，就像是标准库中使用的 <code>Sequence</code> 协议那样。你应该这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span> <span class="keyword">where</span> <span class="type">Iterator</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeIterator</span>() -&gt; <span class="type">Iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器（<code>Iterator</code>）的泛型 <code>where</code> 子句要求：无论迭代器是什么类型，迭代器中的元素类型，必须和容器项目的类型保持一致。<code>makeIterator()</code> 则提供了容器的迭代器的访问接口。</p>
<p>一个协议继承了另一个协议，你通过在协议声明的时候，包含泛型 <code>where</code> 子句，来添加了一个约束到被继承协议的关联类型。例如，下面的代码声明了一个 <code>ComparableContainer</code> 协议，它要求所有的 <code>Item</code> 必须是 <code>Comparable</code> 的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ComparableContainer</span>: <span class="title class_ inherited__">Container</span> <span class="keyword">where</span> <span class="title class_ inherited__">Item</span>: <span class="title class_ inherited__">Comparable</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型下标">泛型下标</h2>
<p>下标可以是泛型，它们能够包含泛型 <code>where</code> 子句。你可以在 <code>subscript</code> 后用尖括号来写占位符类型，你还可以在下标代码块花括号前写 <code>where</code> 子句。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>&lt;<span class="type">Indices</span>: <span class="type">Sequence</span>&gt;(<span class="params">indices</span>: <span class="type">Indices</span>) -&gt; [<span class="type">Item</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Indices</span>.<span class="type">Iterator</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result <span class="operator">=</span> [<span class="type">Item</span>]()</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> indices &#123;</span><br><span class="line">                result.append(<span class="keyword">self</span>[index])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>Container</code> 协议的扩展添加了一个下标方法，接收一个索引的集合，返回每一个索引所在的值的数组。这个泛型下标的约束如下：</p>
<ul>
<li>在尖括号中的泛型参数 <code>Indices</code>，必须是符合标准库中的 <code>Sequence</code> 协议的类型。</li>
<li>下标使用的单一的参数，<code>indices</code>，必须是 <code>Indices</code> 的实例。</li>
<li>泛型 <code>where</code> 子句要求 <code>Sequence（Indices）</code>的迭代器，其所有的元素都是 <code>Int</code> 类型。这样就能确保在序列（<code>Sequence</code>）中的索引和容器（<code>Container</code>）里面的索引类型是一致的。</li>
</ul>
<p>综合一下，这些约束意味着，传入到 <code>indices</code> 下标，是一个整型的序列。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/07/10/Swift/swift%E6%B3%9B%E5%9E%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/07/09/Swift/swift%E5%8D%8F%E8%AE%AE/"
                            aria-label=": swift协议"
                        >
                            swift协议
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-09T10:13:17+08:00">
	
		    2023 年 7 月 9 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="协议">协议</h2>
<p><em>协议</em> 定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。某个类型能够满足某个协议的要求，就可以说该类型<em>遵循</em>这个协议。</p>
<p>除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。</p>
<h2 id="协议语法">协议语法</h2>
<p>协议的定义方式与类、结构体和枚举的定义非常相似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要让自定义类型遵循某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（<code>:</code>）分隔。遵循多个协议时，各协议之间用逗号（<code>,</code>）分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span>: <span class="title class_ inherited__">FirstProtocol</span>, <span class="title class_ inherited__">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是结构体的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若一个拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_ inherited__">SomeSuperClass</span>, <span class="title class_ inherited__">FirstProtocol</span>, <span class="title class_ inherited__">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是类的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性要求">属性要求</h2>
<p>协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储属性还是计算属性，它只指定属性的名称和类型。此外，协议还指定属性是<em>可读</em>的还是<em>可读可写的</em>。</p>
<p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。</p>
<p>协议总是用 <code>var</code> 关键字来声明变量属性，在类型声明后加上 <code>&#123; set get &#125;</code> 来表示属性是<em>可读可写</em>的，<em>可读</em>属性则用 <code>&#123; get &#125;</code> 来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在协议中定义类型属性时，总是使用 <code>static</code> 关键字作为前缀。当类类型遵循协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字来声明类型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> someTypeProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，这是一个只含有一个实例属性要求的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">FullyNamed</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FullyNamed</code> 协议除了要求遵循协议的类型提供 <code>fullName</code> 属性外，并没有其他特别的要求。这个协议表示，任何遵循 <code>FullyNamed</code> 的类型，都必须有一个可读的 <code>String</code> 类型的实例属性 <code>fullName</code>。</p>
<p>下面是一个遵循 <code>FullyNamed</code> 协议的简单结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>: <span class="title class_ inherited__">FullyNamed</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>(fullName: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line"><span class="comment">// john.fullName 为 &quot;John Appleseed&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中定义了一个叫做 <code>Person</code> 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它遵循了 <code>FullyNamed</code> 协议。</p>
<p><code>Person</code> 结构体的每一个实例都有一个 <code>String</code> 类型的存储型属性 <code>fullName</code>。这正好满足了 <code>FullyNamed</code> 协议的要求，也就意味着 <code>Person</code> 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）</p>
<p>下面是一个更为复杂的类，它采纳并遵循了 <code>FullyNamed</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Starship</span>: <span class="title class_ inherited__">FullyNamed</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">prefix</span>: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">prefix</span>: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.prefix <span class="operator">=</span> <span class="keyword">prefix</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">prefix</span> <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="keyword">prefix</span><span class="operator">!</span> <span class="operator">+</span> <span class="string">&quot; &quot;</span> : <span class="string">&quot;&quot;</span>) <span class="operator">+</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ncc1701 <span class="operator">=</span> <span class="type">Starship</span>(name: <span class="string">&quot;Enterprise&quot;</span>, prefix: <span class="string">&quot;USS&quot;</span>)</span><br><span class="line"><span class="comment">// ncc1701.fullName 为 &quot;USS Enterprise&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Starship</code> 类把 <code>fullName</code> 作为只读的计算属性来实现。每一个 <code>Starship</code> 类的实例都有一个名为 <code>name</code> 的非可选属性和一个名为 <code>prefix</code> 的可选属性。 当 <code>prefix</code> 存在时，计算属性 <code>fullName</code> 会将 <code>prefix</code> 插入到 <code>name</code> 之前，从而得到一个带有 <code>prefix</code> 的 <code>fullName</code>。</p>
<h2 id="方法要求">方法要求</h2>
<p>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法提供默认参数。</p>
<p>正如属性要求中所述，在协议中定义类方法的时候，总是使用 <code>static</code> 关键字作为前缀。即使在类实现时，类方法要求使用 <code>class</code> 或 <code>static</code> 作为关键字前缀，前面的规则仍然适用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">someTypeMethod</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子定义了一个只含有一个实例方法的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RandomNumberGenerator</code> 协议要求遵循协议的类型必须拥有一个名为 <code>random</code>， 返回值类型为 <code>Double</code> 的实例方法。尽管这里并未指明，但是我们假设返回值是从 <code>0.0</code> 到（但不包括）<code>1.0</code>。</p>
<p><code>RandomNumberGenerator</code> 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。</p>
<p>如下所示，下边是一个遵循并符合 <code>RandomNumberGenerator</code> 协议的类。该类实现了一个叫做 <em>线性同余生成器（linear congruential generator）</em> 的伪随机数算法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinearCongruentialGenerator</span>: <span class="title class_ inherited__">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lastRandom <span class="operator">=</span> <span class="number">42.0</span></span><br><span class="line">    <span class="keyword">let</span> m <span class="operator">=</span> <span class="number">139968.0</span></span><br><span class="line">    <span class="keyword">let</span> a <span class="operator">=</span> <span class="number">3877.0</span></span><br><span class="line">    <span class="keyword">let</span> c <span class="operator">=</span> <span class="number">29573.0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>() -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        lastRandom <span class="operator">=</span> ((lastRandom <span class="operator">*</span> a <span class="operator">+</span> c).truncatingRemainder(dividingBy:m))</span><br><span class="line">        <span class="keyword">return</span> lastRandom <span class="operator">/</span> m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator <span class="operator">=</span> <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here&#x27;s a random number: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 “Here&#x27;s a random number: 0.37464991998171”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;And another one: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 “And another one: 0.729023776863283”</span></span><br></pre></td></tr></table></figure>
<h2 id="异变方法要求">异变方法要求</h2>
<p>有时需要在方法中改变（或<em>异变</em>）方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 <code>mutating</code> 关键字作为方法的前缀，写在 <code>func</code> 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。这一过程在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/11_Methods.html#modifying_value_types_from_within_instance_methods">在实例方法中修改值类型</a> 章节中有详细描述。</p>
<p>如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 <code>mutating</code> 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。</p>
<blockquote>
<p>注意</p>
<p>实现协议中的 <code>mutating</code> 方法时，若是类类型，则不用写 <code>mutating</code> 关键字。而对于结构体和枚举，则必须写 <code>mutating</code> 关键字。</p>
</blockquote>
<p>如下所示，<code>Togglable</code> 协议只定义了一个名为 <code>toggle</code> 的实例方法。顾名思义，<code>toggle()</code> 方法将改变实例属性，从而切换遵循该协议类型的实例的状态。</p>
<p><code>toggle()</code> 方法在定义的时候，使用 <code>mutating</code> 关键字标记，这表明当它被调用时，该方法将会改变遵循协议的类型的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Togglable</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用枚举或结构体来实现 <code>Togglable</code> 协议时，需要提供一个带有 <code>mutating</code> 前缀的 <code>toggle()</code> 方法。</p>
<p>下面定义了一个名为 <code>OnOffSwitch</code> 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 <code>On</code> 和 <code>Off</code> 表示。枚举的 <code>toggle()</code> 方法被标记为 <code>mutating</code>，以满足 <code>Togglable</code> 协议的要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">OnOffSwitch</span>: <span class="title class_ inherited__">Togglable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> off, on</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>() &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .on</span><br><span class="line">        <span class="keyword">case</span> .on:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lightSwitch <span class="operator">=</span> <span class="type">OnOffSwitch</span>.off</span><br><span class="line">lightSwitch.toggle()</span><br><span class="line"><span class="comment">// lightSwitch 现在的值为 .on</span></span><br></pre></td></tr></table></figure>
<h2 id="构造器要求">构造器要求</h2>
<p>协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="协议构造器要求的类实现">协议构造器要求的类实现</h3>
<p>你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_ inherited__">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>required</code> 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。</p>
<p>关于 <code>required</code> 构造器的更多内容，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#required_initializers">必要构造器</a>。</p>
<blockquote>
<p>注意</p>
<p>如果类已经被标记为 <code>final</code>，那么不需要在协议构造器的实现中使用 <code>required</code> 修饰符，因为 <code>final</code> 类不能有子类。关于 <code>final</code> 修饰符的更多内容，请参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/13_Inheritance.html#preventing_overrides">防止重写</a>。</p>
</blockquote>
<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubClass</span>: <span class="title class_ inherited__">SomeSuperClass</span>, <span class="title class_ inherited__">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 因为遵循协议，需要加上 required</span></span><br><span class="line">    <span class="comment">// 因为继承自父类，需要加上 override</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可失败构造器要求">可失败构造器要求</h3>
<p>协议还可以为遵循协议的类型定义可失败构造器要求，详见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#failable_initializers">可失败构造器</a>。</p>
<p>遵循协议的类型可以通过可失败构造器（<code>init?</code>）或非可失败构造器（<code>init</code>）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（<code>init</code>）或隐式解包可失败构造器（<code>init!</code>）来满足。</p>
<h2 id="协议作为类型">协议作为类型</h2>
<p>尽管协议本身并未实现任何功能，但是协议可以被当做一个功能完备的类型来使用。协议作为类型使用，有时被称作「存在类型」，这个名词来自「存在着一个类型 T，该类型遵循协议 T」。</p>
<p>协议可以像其他普通类型一样使用，使用场景如下：</p>
<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>
<blockquote>
<p>注意</p>
<p>协议是一种类型，因此协议类型的名称应与其他类型（例如 <code>Int</code>，<code>Double</code>，<code>String</code>）的写法相同，使用大写字母开头的驼峰式写法，例如（<code>FullyNamed</code> 和 <code>RandomNumberGenerator</code>）。</p>
</blockquote>
<p>下面是将协议作为类型使用的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dice</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sides: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> generator: <span class="type">RandomNumberGenerator</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sides</span>: <span class="type">Int</span>, <span class="params">generator</span>: <span class="type">RandomNumberGenerator</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sides <span class="operator">=</span> sides</span><br><span class="line">        <span class="keyword">self</span>.generator <span class="operator">=</span> generator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">roll</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(generator.random() <span class="operator">*</span> <span class="type">Double</span>(sides)) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了一个 <code>Dice</code> 类，用来代表桌游中拥有 N 个面的骰子。<code>Dice</code> 的实例含有 <code>sides</code> 和 <code>generator</code> 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。</p>
<p><code>generator</code> 属性的类型为 <code>RandomNumberGenerator</code>，因此任何遵循了 <code>RandomNumberGenerator</code> 协议的类型的实例都可以赋值给 <code>generator</code>，除此之外并无其他要求。并且由于其类型是 <code>RandomNumberGenerator</code>，在 <code>Dice</code> 类中与 <code>generator</code> 交互的代码，必须适用于所有 <code>generator</code> 实例都遵循的方法。这句话的意思是不能使用由 <code>generator</code> 底层类型提供的任何方法或属性。但是你可以通过向下转型，从协议类型转换成底层实现类型，比如从父类向下转型为子类。请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/18_Type_Casting#downcasting">向下转型</a>。</p>
<p><code>Dice</code> 类还有一个构造器，用来设置初始状态。构造器有一个名为 <code>generator</code>，类型为 <code>RandomNumberGenerator</code> 的形参。在调用构造方法创建 <code>Dice</code> 的实例时，可以传入任何遵循 <code>RandomNumberGenerator</code> 协议的实例给 <code>generator</code>。</p>
<p><code>Dice</code> 类提供了一个名为 <code>roll</code> 的实例方法，用来模拟骰子的面值。它先调用 <code>generator</code> 的 <code>random()</code> 方法来生成一个 <code>[0.0,1.0)</code> 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 <code>generator</code> 遵循了 <code>RandomNumberGenerator</code> 协议，可以确保它有个 <code>random()</code> 方法可供调用。</p>
<p>下面的例子展示了如何使用 <code>LinearCongruentialGenerator</code> 的实例作为随机数生成器来创建一个六面骰子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d6 <span class="operator">=</span> <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Random dice roll is <span class="subst">\(d6.roll())</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Random dice roll is 3</span></span><br><span class="line"><span class="comment">// Random dice roll is 5</span></span><br><span class="line"><span class="comment">// Random dice roll is 4</span></span><br><span class="line"><span class="comment">// Random dice roll is 5</span></span><br><span class="line"><span class="comment">// Random dice roll is 4</span></span><br></pre></td></tr></table></figure>
<h2 id="委托">委托</h2>
<p><em>委托</em>是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p>
<p>下面的例子定义了两个基于骰子游戏的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">DiceGame</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dice: <span class="type">Dice</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">play</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">DiceGameDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gameDidStart</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">game</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>, <span class="params">didStartNewTurnWithDiceRoll</span> <span class="params">diceRoll</span>: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gameDidEnd</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DiceGame</code> 协议可以被任意涉及骰子的游戏遵循。</p>
<p><code>DiceGameDelegate</code> 协议可以被任意类型遵循，用来追踪 <code>DiceGame</code> 的游戏过程。为了防止强引用导致的循环引用问题，可以把协议声明为弱引用，更多相关的知识请看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/23_Automatic_Reference_Counting.html#strong_reference_cycles_between_class_instances">类实例之间的循环强引用</a>，当协议标记为类专属可以使 <code>SnakesAndLadders</code> 类在声明协议时强制要使用弱引用。若要声明类专属的协议就必须继承于 <code>AnyObject</code> ，更多请看 <a href="#class_only_protocol">类专属的协议</a>。</p>
<p>如下所示，<code>SnakesAndLadders</code> 是 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html">控制流</a> 章节引入的蛇梯棋游戏的新版本。新版本使用 <code>Dice</code> 实例作为骰子，并且实现了 <code>DiceGame</code> 和 <code>DiceGameDelegate</code> 协议，后者用来记录游戏的过程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnakesAndLadders</span>: <span class="title class_ inherited__">DiceGame</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> finalSquare <span class="operator">=</span> <span class="number">25</span></span><br><span class="line">    <span class="keyword">let</span> dice <span class="operator">=</span> <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line">    <span class="keyword">var</span> square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> board: [<span class="type">Int</span>]</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        board <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0</span>, count: finalSquare <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">        board[<span class="number">03</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">08</span>; board[<span class="number">06</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">11</span>; board[<span class="number">09</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">09</span>; board[<span class="number">10</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">02</span></span><br><span class="line">        board[<span class="number">14</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">10</span>; board[<span class="number">19</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">11</span>; board[<span class="number">22</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">02</span>; board[<span class="number">24</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">08</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">DiceGameDelegate</span>?</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">play</span>() &#123;</span><br><span class="line">        square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        delegate<span class="operator">?</span>.gameDidStart(<span class="keyword">self</span>)</span><br><span class="line">        gameLoop: <span class="keyword">while</span> square <span class="operator">!=</span> finalSquare &#123;</span><br><span class="line">            <span class="keyword">let</span> diceRoll <span class="operator">=</span> dice.roll()</span><br><span class="line">            delegate<span class="operator">?</span>.game(<span class="keyword">self</span>, didStartNewTurnWithDiceRoll: diceRoll)</span><br><span class="line">            <span class="keyword">switch</span> square <span class="operator">+</span> diceRoll &#123;</span><br><span class="line">            <span class="keyword">case</span> finalSquare:</span><br><span class="line">                <span class="keyword">break</span> gameLoop</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare <span class="operator">&gt;</span> finalSquare:</span><br><span class="line">                <span class="keyword">continue</span> gameLoop</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                square <span class="operator">+=</span> diceRoll</span><br><span class="line">                square <span class="operator">+=</span> board[square]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        delegate<span class="operator">?</span>.gameDidEnd(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个<em>蛇梯棋</em>游戏的详细描述请参阅 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html#break">中断（Break）</a>。</p>
<p>这个版本的游戏封装到了 <code>SnakesAndLadders</code> 类中，该类遵循了 <code>DiceGame</code> 协议，并且提供了相应的可读的 <code>dice</code> 属性和 <code>play()</code> 方法。（ <code>dice</code> 属性在构造之后就不再改变，且协议只要求 <code>dice</code> 为可读的，因此将 <code>dice</code> 声明为常量属性。）</p>
<p>游戏使用 <code>SnakesAndLadders</code> 类的 <code>init()</code> 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 <code>play()</code> 方法，<code>play()</code> 方法使用协议要求的 <code>dice</code> 属性提供骰子摇出的值。</p>
<p>注意，<code>delegate</code> 并不是游戏的必备条件，因此 <code>delegate</code> 被定义为 <code>DiceGameDelegate</code> 类型的可选属性。因为 <code>delegate</code> 是可选值，因此会被自动赋予初始值 <code>nil</code>。随后，可以在游戏中为 <code>delegate</code> 设置适当的值。</p>
<p><code>DicegameDelegate</code> 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 <code>play()</code> 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。</p>
<p>因为 <code>delegate</code> 是一个 <code>DiceGameDelegate</code> 类型的可选属性，因此在 <code>play()</code> 方法中通过可选链式调用来调用它的方法。若 <code>delegate</code> 属性为 <code>nil</code>，则调用方法会优雅地失败，并不会产生错误。若 <code>delegate</code> 不为 <code>nil</code>，则方法能够被调用，并传递 <code>SnakesAndLadders</code> 实例作为参数。</p>
<p>如下示例定义了 <code>DiceGameTracker</code> 类，它遵循了 <code>DiceGameDelegate</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiceGameTracker</span>: <span class="title class_ inherited__">DiceGameDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfTurns <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gameDidStart</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>) &#123;</span><br><span class="line">        numberOfTurns <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> game <span class="keyword">is</span> <span class="type">SnakesAndLadders</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Started a new game of Snakes and Ladders&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The game is using a <span class="subst">\(game.dice.sides)</span>-sided dice&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">game</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>, <span class="params">didStartNewTurnWithDiceRoll</span> <span class="params">diceRoll</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        numberOfTurns <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Rolled a <span class="subst">\(diceRoll)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gameDidEnd</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The game lasted for <span class="subst">\(numberOfTurns)</span> turns&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DiceGameTracker</code> 实现了 <code>DiceGameDelegate</code> 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，<code>numberOfTurns</code> 属性被赋值为 <code>0</code>，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。</p>
<p><code>gameDidStart(_:)</code> 方法从 <code>game</code> 参数获取游戏信息并打印。<code>game</code> 参数是 <code>DiceGame</code> 类型而不是 <code>SnakeAndLadders</code> 类型，所以在 <code>gameDidStart(_:)</code> 方法中只能访问 <code>DiceGame</code> 协议中的内容。当然了，<code>SnakeAndLadders</code> 的方法也可以在类型转换之后调用。在上例代码中，通过 <code>is</code> 操作符检查 <code>game</code> 是否为 <code>SnakesAndLadders</code> 类型的实例，如果是，则打印出相应的消息。</p>
<p>无论当前进行的是何种游戏，由于 <code>game</code> 符合 <code>DiceGame</code> 协议，可以确保 <code>game</code> 含有 <code>dice</code> 属性。因此在 <code>gameDidStart(_:)</code> 方法中可以通过传入的 <code>game</code> 参数来访问 <code>dice</code> 属性，进而打印出 <code>dice</code> 的 <code>sides</code> 属性的值。</p>
<p><code>DiceGameTracker</code> 的运行情况如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tracker <span class="operator">=</span> <span class="type">DiceGameTracker</span>()</span><br><span class="line"><span class="keyword">let</span> game <span class="operator">=</span> <span class="type">SnakesAndLadders</span>()</span><br><span class="line">game.delegate <span class="operator">=</span> tracker</span><br><span class="line">game.play()</span><br><span class="line"><span class="comment">// Started a new game of Snakes and Ladders</span></span><br><span class="line"><span class="comment">// The game is using a 6-sided dice</span></span><br><span class="line"><span class="comment">// Rolled a 3</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// Rolled a 4</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// The game lasted for 4 turns</span></span><br></pre></td></tr></table></figure>
<h2 id="在扩展里添加协议遵循">在扩展里添加协议遵循</h2>
<p>即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。详情请在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/20_Extensions.html">扩展</a> 章节中查看。</p>
<blockquote>
<p>注意</p>
<p>通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p>
</blockquote>
<p>例如下面这个 <code>TextRepresentable</code> 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过扩展，令先前提到的 <code>Dice</code> 类可以扩展来采纳和遵循 <code>TextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Dice</span>: <span class="title class_ inherited__">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A <span class="subst">\(sides)</span>-sided dice&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过扩展遵循并采纳协议，和在原始定义中遵循并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。</p>
<p>现在所有 <code>Dice</code> 的实例都可以看做 <code>TextRepresentable</code> 类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d12 <span class="operator">=</span> <span class="type">Dice</span>(sides: <span class="number">12</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="built_in">print</span>(d12.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A 12-sided dice”</span></span><br></pre></td></tr></table></figure>
<p>同样，<code>SnakesAndLadders</code> 类也可以通过扩展来采纳和遵循 <code>TextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SnakesAndLadders</span>: <span class="title class_ inherited__">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A game of Snakes and Ladders with <span class="subst">\(finalSquare)</span> squares&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(game.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A game of Snakes and Ladders with 25 squares”</span></span><br></pre></td></tr></table></figure>
<h2 id="有条件地遵循协议">有条件地遵循协议</h2>
<p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。你可以通过在扩展类型时列出限制让泛型类型有条件地遵循某协议。在你采纳协议的名字后面写泛型 <code>where</code> 分句。更多关于泛型 <code>where</code> 分句，见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/22_Generics.html##where_clauses">泛型 Where 分句</a>。</p>
<p>下面的扩展让 <code>Array</code> 类型只要在存储遵循 <code>TextRepresentable</code> 协议的元素时就遵循 <code>TextRepresentable</code> 协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_ inherited__">TextRepresentable</span> <span class="keyword">where</span> <span class="title class_ inherited__">Element</span>: <span class="title class_ inherited__">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText <span class="operator">=</span> <span class="keyword">self</span>.map &#123; <span class="variable">$0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> <span class="operator">+</span> itemsAsText.joined(separator: <span class="string">&quot;, &quot;</span>) <span class="operator">+</span> <span class="string">&quot;]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDice <span class="operator">=</span> [d6, d12]</span><br><span class="line"><span class="built_in">print</span>(myDice.textualDescription)</span><br><span class="line"><span class="comment">// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="在扩展里声明采纳协议">在扩展里声明采纳协议</h2>
<p>当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空的扩展来让它采纳该协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Hamster</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">       <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A hamster named <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Hamster</span>: <span class="title class_ inherited__">TextRepresentable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从现在起，<code>Hamster</code> 的实例可以作为 <code>TextRepresentable</code> 类型使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simonTheHamster <span class="operator">=</span> <span class="type">Hamster</span>(name: <span class="string">&quot;Simon&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> somethingTextRepresentable: <span class="type">TextRepresentable</span> <span class="operator">=</span> simonTheHamster</span><br><span class="line"><span class="built_in">print</span>(somethingTextRepresentable.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A hamster named Simon”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。</p>
</blockquote>
<h2 id="协议类型的集合">协议类型的集合</h2>
<p>协议类型可以在数组或者字典这样的集合中使用，在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/21_Protocols.html##protocols_as_types">协议类型</a> 提到了这样的用法。下面的例子创建了一个元素类型为 <code>TextRepresentable</code> 的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> things: [<span class="type">TextRepresentable</span>] <span class="operator">=</span> [game, d12, simonTheHamster]</span><br></pre></td></tr></table></figure>
<p>如下所示，可以遍历 <code>things</code> 数组，并打印每个元素的文本表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">    <span class="built_in">print</span>(thing.textualDescription)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A game of Snakes and Ladders with 25 squares</span></span><br><span class="line"><span class="comment">// A 12-sided dice</span></span><br><span class="line"><span class="comment">// A hamster named Simon</span></span><br></pre></td></tr></table></figure>
<p>注意 <code>thing</code> 常量是 <code>TextRepresentable</code> 类型而不是 <code>Dice</code>，<code>DiceGame</code>，<code>Hamster</code> 等类型，即使实例在幕后确实是这些类型中的一种。由于 <code>thing</code> 是 <code>TextRepresentable</code> 类型，任何 <code>TextRepresentable</code> 的实例都有一个 <code>textualDescription</code> 属性，所以在每次循环中可以安全地访问 <code>thing.textualDescription</code>。</p>
<h2 id="协议的继承">协议的继承</h2>
<p>协议能够<em>继承</em>一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">InheritingProtocol</span>: <span class="title class_ inherited__">SomeProtocol</span>, <span class="title class_ inherited__">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，<code>PrettyTextRepresentable</code> 协议继承了 <code>TextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">PrettyTextRepresentable</span>: <span class="title class_ inherited__">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了一个新的协议 <code>PrettyTextRepresentable</code>，它继承自 <code>TextRepresentable</code> 协议。任何遵循 <code>PrettyTextRepresentable</code> 协议的类型在满足该协议的要求时，也必须满足 <code>TextRepresentable</code> 协议的要求。在这个例子中，<code>PrettyTextRepresentable</code> 协议额外要求遵循协议的类型提供一个返回值为 <code>String</code> 类型的 <code>prettyTextualDescription</code> 属性。</p>
<p>如下所示，扩展 <code>SnakesAndLadders</code>，使其遵循并符合 <code>PrettyTextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SnakesAndLadders</span>: <span class="title class_ inherited__">PrettyTextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> textualDescription <span class="operator">+</span> <span class="string">&quot;:<span class="subst">\n</span>&quot;</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>finalSquare &#123;</span><br><span class="line">            <span class="keyword">switch</span> board[index] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> ladder <span class="keyword">where</span> ladder <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;▲ &quot;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> snake <span class="keyword">where</span> snake <span class="operator">&lt;</span> <span class="number">0</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;▼ &quot;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;○ &quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述扩展令 <code>SnakesAndLadders</code> 遵循了 <code>PrettyTextRepresentable</code> 协议，并提供了协议要求的 <code>prettyTextualDescription</code> 属性。每个 <code>PrettyTextRepresentable</code> 类型同时也是 <code>TextRepresentable</code> 类型，所以在 <code>prettyTextualDescription</code> 的实现中，可以访问 <code>textualDescription</code> 属性。然后，拼接上了冒号和换行符。接着，遍历数组中的元素，拼接一个几何图形来表示每个棋盘方格的内容：</p>
<ul>
<li>当从数组中取出的元素的值大于 <code>0</code> 时，用 <code>▲</code> 表示。</li>
<li>当从数组中取出的元素的值小于 <code>0</code> 时，用 <code>▼</code> 表示。</li>
<li>当从数组中取出的元素的值等于 <code>0</code> 时，用 <code>○</code> 表示。</li>
</ul>
<p>任意 <code>SankesAndLadders</code> 的实例都可以使用 <code>prettyTextualDescription</code> 属性来打印一个漂亮的文本描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(game.prettyTextualDescription)</span><br><span class="line"><span class="comment">// A game of Snakes and Ladders with 25 squares:</span></span><br><span class="line"><span class="comment">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span></span><br></pre></td></tr></table></figure>
<h2 id="类专属的协议">类专属的协议</h2>
<p>你通过添加 <code>AnyObject</code> 关键字到协议的继承列表，就可以限制协议只能被类类型采纳（以及非结构体或者非枚举的类型）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeClassOnlyProtocol</span>: <span class="title class_ inherited__">AnyObject</span>, <span class="title class_ inherited__">SomeInheritedProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是类专属协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上例子中，协议 <code>SomeClassOnlyProtocol</code> 只能被类类型采纳。如果尝试让结构体或枚举类型采纳 <code>SomeClassOnlyProtocol</code>，则会导致编译时错误。</p>
<blockquote>
<p>注意</p>
<p>当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。关于引用语义和值语义的更多内容，请查看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/09_Classes_and_Structures.md#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a> 和 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/09_Classes_and_Structures.md#classes_are_reference_types">类是引用类型</a>。</p>
</blockquote>
<h2 id="协议合成">协议合成</h2>
<p>要求一个类型同时遵循多个协议是很有用的。你可以使用<em>协议组合</em>来复合多个协议到一个要求里。协议组合行为就和你定义的临时局部协议一样拥有构成中所有协议的需求。协议组合不定义任何新的协议类型。</p>
<p>协议组合使用 <code>SomeProtocol &amp; AnotherProtocol</code> 的形式。你可以列举任意数量的协议，用和符号（<code>&amp;</code>）分开。除了协议列表，协议组合也能包含类类型，这允许你标明一个需要的父类。</p>
<p>下面的例子中，将 <code>Named</code> 和 <code>Aged</code> 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>: <span class="title class_ inherited__">Named</span>, <span class="title class_ inherited__">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">wishHappyBirthday</span>(<span class="params">to</span> <span class="params">celebrator</span>: <span class="type">Named</span> &amp; <span class="type">Aged</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Happy birthday, <span class="subst">\(celebrator.name)</span>, you&#x27;re <span class="subst">\(celebrator.age)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> birthdayPerson <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Malcolm&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">wishHappyBirthday(to: birthdayPerson)</span><br><span class="line"><span class="comment">// 打印 “Happy birthday Malcolm - you&#x27;re 21!”</span></span><br></pre></td></tr></table></figure>
<p><code>Named</code> 协议包含 <code>String</code> 类型的 <code>name</code> 属性。<code>Aged</code> 协议包含 <code>Int</code> 类型的 <code>age</code> 属性。<code>Person</code> 结构体采纳了这两个协议。</p>
<p><code>wishHappyBirthday(to:)</code> 函数的参数 <code>celebrator</code> 的类型为 <code>Named &amp; Aged</code>， 这意味着“任何同时遵循 Named 和 Aged 的协议”。它不关心参数的具体类型，只要参数符合这两个协议即可。</p>
<p>上面的例子创建了一个名为 <code>birthdayPerson</code> 的 <code>Person</code> 的实例，作为参数传递给了 <code>wishHappyBirthday(to:)</code> 函数。因为 <code>Person</code> 同时符合这两个协议，所以这个参数合法，函数将打印生日问候语。</p>
<p>这里有一个例子：将 Location 类和前面的 Named 协议进行组合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Location</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> latitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> longitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">latitude</span>: <span class="type">Double</span>, <span class="params">longitude</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.latitude <span class="operator">=</span> latitude</span><br><span class="line">        <span class="keyword">self</span>.longitude <span class="operator">=</span> longitude</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">City</span>: <span class="title class_ inherited__">Location</span>, <span class="title class_ inherited__">Named</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">latitude</span>: <span class="type">Double</span>, <span class="params">longitude</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(latitude: latitude, longitude: longitude)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">beginConcert</span>(<span class="params">in</span> <span class="params">location</span>: <span class="type">Location</span> &amp; <span class="type">Named</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(location.name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seattle <span class="operator">=</span> <span class="type">City</span>(name: <span class="string">&quot;Seattle&quot;</span>, latitude: <span class="number">47.6</span>, longitude: <span class="operator">-</span><span class="number">122.3</span>)</span><br><span class="line">beginConcert(in: seattle)</span><br><span class="line"><span class="comment">// 打印 &quot;Hello, Seattle!&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>beginConcert(in:)</code> 函数接受一个类型为 <code>Location &amp; Named</code> 的参数，这意味着“任何 Location 的子类，并且遵循 Named 协议”。例如，City 就满足这样的条件。</p>
<p>将 birthdayPerson 传入 <code>beginConcert(in:)</code> 函数是不合法的，因为 Person 不是 Location 的子类。同理，如果你新建一个类继承于 Location，但是没有遵循 Named 协议，而用这个类的实例去调用 <code>beginConcert(in:)</code> 函数也是非法的。</p>
<h2 id="检查协议一致性">检查协议一致性</h2>
<p>你可以使用 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/18_Type_Casting.html">类型转换</a> 中描述的 <code>is</code> 和 <code>as</code> 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换协议的语法与检查和转换类型是完全一样的：</p>
<ul>
<li><code>is</code> 用来检查实例是否符合某个协议，若符合则返回 <code>true</code>，否则返回 <code>false</code>；</li>
<li><code>as?</code> 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 <code>nil</code>；</li>
<li><code>as!</code> 将实例强制向下转换到某个协议类型，如果强转失败，将触发运行时错误。</li>
</ul>
<p>下面的例子定义了一个 <code>HasArea</code> 协议，该协议定义了一个 <code>Double</code> 类型的可读属性 <code>area</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，<code>Circle</code> 类和 <code>Country</code> 类都遵循了 <code>HasArea</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="title class_ inherited__">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pi <span class="operator">=</span> <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">return</span> pi <span class="operator">*</span> radius <span class="operator">*</span> radius &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">radius</span>: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.radius <span class="operator">=</span> radius &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span>: <span class="title class_ inherited__">HasArea</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">area</span>: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.area <span class="operator">=</span> area &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Circle</code> 类把 <code>area</code> 属性实现为基于存储型属性 <code>radius</code> 的计算型属性。<code>Country</code> 类则把 <code>area</code> 属性实现为存储型属性。这两个类都正确地遵循了 <code>HasArea</code> 协议。</p>
<p>如下所示，<code>Animal</code> 是一个未遵循 <code>HasArea</code> 协议的类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> legs: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">legs</span>: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.legs <span class="operator">=</span> legs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Circle</code>，<code>Country</code>，<code>Animal</code> 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 <code>AnyObject</code> 类型的值，存储在同一个数组中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objects: [<span class="type">AnyObject</span>] <span class="operator">=</span> [</span><br><span class="line">    <span class="type">Circle</span>(radius: <span class="number">2.0</span>),</span><br><span class="line">    <span class="type">Country</span>(area: <span class="number">243_610</span>),</span><br><span class="line">    <span class="type">Animal</span>(legs: <span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>objects</code> 数组使用字面量初始化，数组包含一个 <code>radius</code> 为 <code>2</code> 的 <code>Circle</code> 的实例，一个保存了英国国土面积的 <code>Country</code> 实例和一个 <code>legs</code> 为 <code>4</code> 的 <code>Animal</code> 实例。</p>
<p>如下所示，<code>objects</code> 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 <code>HasArea</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> objectWithArea <span class="operator">=</span> object <span class="keyword">as?</span> <span class="type">HasArea</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Area is <span class="subst">\(objectWithArea.area)</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something that doesn&#x27;t have an area&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Area is 12.5663708</span></span><br><span class="line"><span class="comment">// Area is 243610.0</span></span><br><span class="line"><span class="comment">// Something that doesn&#x27;t have an area</span></span><br></pre></td></tr></table></figure>
<p>当迭代出的元素符合 <code>HasArea</code> 协议时，将 <code>as?</code> 操作符返回的可选值通过可选绑定，绑定到 <code>objectWithArea</code> 常量上。<code>objectWithArea</code> 是 <code>HasArea</code> 协议类型的实例，因此 <code>area</code> 属性可以被访问和打印。</p>
<p><code>objects</code> 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 <code>Circle</code>，<code>Country</code>，<code>Animal</code> 类型。然而，当它们被赋值给 <code>objectWithArea</code> 常量时，只被视为 <code>HasArea</code> 类型，因此只有 <code>area</code> 属性能够被访问。</p>
<h2 id="可选的协议要求">可选的协议要求</h2>
<p>协议可以定义<em>可选要求</em>，遵循协议的类型可以选择是否实现这些要求。在协议中使用 <code>optional</code> 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上 <code>@objc</code> 属性。标记 <code>@objc</code> 特性的协议只能被继承自 Objective-C 类的类或者 <code>@objc</code> 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</p>
<p>使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 <code>(Int) -&gt; String</code> 的方法会变成 <code>((Int) -&gt; String)?</code>。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p>
<p>协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似 <code>someOptionalMethod?(someArgument)</code> 这样，你可以在可选方法名称后加上 <code>?</code> 来调用可选方法。详细内容可在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/16_Optional_Chaining.html">可选链式调用</a> 章节中查看。</p>
<p>下面的例子定义了一个名为 <code>Counter</code> 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 <code>CounterDataSource</code> 协议定义，它包含两个可选要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">CounterDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">optional</span> <span class="keyword">func</span> <span class="title function_">increment</span>(<span class="params">forCount</span> <span class="params">count</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">optional</span> <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CounterDataSource</code> 协议定义了一个可选方法 <code>increment(forCount:)</code> 和一个可选属性 <code>fiexdIncrement</code>，它们使用了不同的方法来从数据源中获取适当的增量值。</p>
<blockquote>
<p>注意</p>
<p>严格来讲，<code>CounterDataSource</code> 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写。</p>
</blockquote>
<p><code>Counter</code> 类含有 <code>CounterDataSource?</code> 类型的可选属性 <code>dataSource</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> dataSource: <span class="type">CounterDataSource</span>?</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> amount <span class="operator">=</span> dataSource<span class="operator">?</span>.increment<span class="operator">?</span>(forCount: count) &#123;</span><br><span class="line">            count <span class="operator">+=</span> amount</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount <span class="operator">=</span> dataSource<span class="operator">?</span>.fixedIncrement &#123;</span><br><span class="line">            count <span class="operator">+=</span> amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Counter</code> 类使用变量属性 <code>count</code> 来存储当前值。该类还定义了一个 <code>increment</code> 方法，每次调用该方法的时候，将会增加 <code>count</code> 的值。</p>
<p><code>increment()</code> 方法首先试图使用 <code>increment(forCount:)</code> 方法来得到每次的增量。<code>increment()</code> 方法使用可选链式调用来尝试调用 <code>increment(forCount:)</code>，并将当前的 <code>count</code> 值作为参数传入。</p>
<p>这里使用了两层可选链式调用。首先，由于 <code>dataSource</code> 可能为 <code>nil</code>，因此在 <code>dataSource</code> 后边加上了 <code>?</code>，以此表明只在 <code>dataSource</code> 非空时才去调用 <code>increment(forCount:)</code> 方法。其次，即使 <code>dataSource</code> 存在，也无法保证其是否实现了 <code>increment(forCount:)</code> 方法，因为这个方法是可选的。因此，<code>increment(forCount:)</code> 方法同样使用可选链式调用进行调用，只有在该方法被实现的情况下才能调用它，所以在 <code>increment(forCount:)</code> 方法后边也加上了 <code>?</code>。</p>
<p>调用 <code>increment(forCount:)</code> 方法在上述两种情形下都有可能失败，所以返回值为 <code>Int?</code> 类型。虽然在 <code>CounterDataSource</code> 协议中，<code>increment(forCount:)</code> 的返回值类型是非可选 <code>Int</code>。另外，即使这里使用了两层可选链式调用，最后的返回结果依旧是单层的可选类型。关于这一点的更多信息，请查阅 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/16_Optional_Chaining">连接多层可选链式调用</a>。</p>
<p>在调用 <code>increment(forCount:)</code> 方法后，<code>Int?</code> 型的返回值通过可选绑定解包并赋值给常量 <code>amount</code>。如果可选值确实包含一个数值，也就是说，数据源和方法都存在，数据源方法返回了一个有效值。之后便将解包后的 <code>amount</code> 加到 <code>count</code> 上，增量操作完成。</p>
<p>如果没有从 <code>increment(forCount:)</code> 方法获取到值，可能由于 <code>dataSource</code> 为 <code>nil</code>，或者它并没有实现 <code>increment(forCount:)</code> 方法，那么 <code>increment()</code> 方法将试图从数据源的 <code>fixedIncrement</code> 属性中获取增量。<code>fixedIncrement</code> 是一个可选属性，因此属性值是一个 <code>Int?</code> 值，即使该属性在 <code>CounterDataSource</code> 协议中的类型是非可选的 <code>Int</code>。</p>
<p>下面的例子展示了 <code>CounterDataSource</code> 的简单实现。<code>ThreeSource</code> 类遵循了 <code>CounterDataSource</code> 协议，它实现了可选属性 <code>fixedIncrement</code>，每次会返回 <code>3</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreeSource</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">CounterDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fixedIncrement <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>ThreeSource</code> 的实例作为 <code>Counter</code> 实例的数据源：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter <span class="operator">=</span> <span class="type">Counter</span>()</span><br><span class="line">counter.dataSource <span class="operator">=</span> <span class="type">ThreeSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">4</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>上述代码新建了一个 <code>Counter</code> 实例，并将它的数据源设置为一个 <code>ThreeSource</code> 的实例，然后调用 <code>increment()</code> 方法 <code>4</code> 次。按照预期预期一样，每次调用都会将 <code>count</code> 的值增加 <code>3</code>.</p>
<p>下面是一个更为复杂的数据源 <code>TowardsZeroSource</code>，它将使得最后的值变为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TowardsZeroSource</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">CounterDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>(<span class="params">forCount</span> <span class="params">count</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> count <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TowardsZeroSource</code> 实现了 <code>CounterDataSource</code> 协议中的 <code>increment(forCount:)</code> 方法，以 <code>count</code> 参数为依据，计算出每次的增量。如果 <code>count</code> 已经为 <code>0</code>，此方法将返回 <code>0</code>，以此表明之后不应再有增量操作发生。</p>
<p>你可以使用 <code>TowardsZeroSource</code> 实例将 <code>Counter</code> 实例来从 <code>-4</code> 增加到 <code>0</code>。一旦增加到 <code>0</code>，数值便不会再有变动：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counter.count <span class="operator">=</span> <span class="operator">-</span><span class="number">4</span></span><br><span class="line">counter.dataSource <span class="operator">=</span> <span class="type">TowardsZeroSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -3</span></span><br><span class="line"><span class="comment">// -2</span></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="协议扩展">协议扩展</h2>
<p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</p>
<p>例如，可以扩展 <code>RandomNumberGenerator</code> 协议来提供 <code>randomBool()</code> 方法。该方法使用协议中定义的 <code>random()</code> 方法来返回一个随机的 <code>Bool</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">randomBool</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random() <span class="operator">&gt;</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现而无需任何额外修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator <span class="operator">=</span> <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here&#x27;s a random number: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 “Here&#x27;s a random number: 0.37464991998171”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;And here&#x27;s a random Boolean: <span class="subst">\(generator.randomBool())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印 “And here&#x27;s a random Boolean: true”</span></span><br></pre></td></tr></table></figure>
<h3 id="提供默认实现">提供默认实现</h3>
<p>可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p>
<blockquote>
<p>注意</p>
<p>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>
</blockquote>
<p>例如，<code>PrettyTextRepresentable</code> 协议继承自 <code>TextRepresentable</code> 协议，可以为其提供一个默认的 <code>prettyTextualDescription</code> 属性来简单地返回 <code>textualDescription</code> 属性的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">PrettyTextRepresentable</span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> textualDescription</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为协议扩展添加限制条件">为协议扩展添加限制条件</h3>
<p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code> 子句来描述，正如 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/22_Generics.html#where_clauses">泛型 Where 子句</a> 中所描述的。</p>
<p>例如，你可以扩展 <code>Collection</code> 协议，适用于集合中的元素遵循了 <code>Equatable</code> 协议的情况。通过限制集合元素遵 <code>Equatable</code> 协议， 作为标准库的一部分， 你可以使用 <code>==</code> 和 <code>!=</code> 操作符来检查两个元素的等价性和非等价性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Collection</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">allEqual</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> element <span class="operator">!=</span> <span class="keyword">self</span>.first &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果集合中的所有元素都一致，<code>allEqual()</code> 方法才返回 <code>true</code>。</p>
<p>看看两个整数数组，一个数组的所有元素都是一样的，另一个不一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> equalNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>]</span><br><span class="line"><span class="keyword">let</span> differentNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br></pre></td></tr></table></figure>
<p>由于数组遵循 <code>Collection</code> 而且整数遵循 <code>Equatable</code>，<code>equalNumbers</code> 和 <code>differentNumbers</code> 都可以使用 <code>allEqual()</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(equalNumbers.allEqual())</span><br><span class="line"><span class="comment">// 打印 &quot;true&quot;</span></span><br><span class="line"><span class="built_in">print</span>(differentNumbers.allEqual())</span><br><span class="line"><span class="comment">// 打印 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>如果一个遵循的类型满足了为同一方法或属性提供实现的多个限制型扩展的要求， Swift 会使用最匹配限制的实现。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/07/09/Swift/swift%E5%8D%8F%E8%AE%AE/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/07/08/Swift/swift%E6%89%A9%E5%B1%95/"
                            aria-label=": swift扩展"
                        >
                            swift扩展
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-08T10:13:17+08:00">
	
		    2023 年 7 月 8 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="扩展">扩展</h2>
<p><em>扩展</em>可以给一个现有的类，结构体，枚举，还有协议添加新的功能。它还拥有不需要访问被扩展类型源代码就能完成扩展的能力（即<em>逆向建模</em>）。扩展和 Objective-C 的分类很相似。（与 Objective-C 分类不同的是，Swift 扩展是没有名字的。）</p>
<p>Swift 中的扩展可以：</p>
<ul>
<li>添加计算型实例属性和计算型类属性</li>
<li>定义实例方法和类方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使已经存在的类型遵循（conform）一个协议</li>
</ul>
<p>在 Swift 中，你甚至可以扩展协议以提供其需要的实现，或者添加额外功能给遵循的类型所使用。你可以从 <a target="_blank" rel="noopener" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID521">协议扩展</a> 获取更多细节。</p>
<blockquote>
<p>注意</p>
<p>扩展可以给一个类型添加新的功能，但是不能重写已经存在的功能。</p>
</blockquote>
<h2 id="扩展的语法">扩展的语法</h2>
<p>使用 <code>extension</code> 关键字声明扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SomeType</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里给 SomeType 添加新的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展可以扩充一个现有的类型，给它添加一个或多个协议。协议名称的写法和类或者结构体一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SomeType</span>: <span class="title class_ inherited__">SomeProtocol</span>, <span class="title class_ inherited__">AnotherProtocol</span> &#123;</span><br><span class="line">  <span class="comment">// 协议所需要的实现写在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种遵循协议的方式在 <a target="_blank" rel="noopener" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID277">使用扩展遵循协议</a> 中有描述。</p>
<p>扩展可以使用在现有范型类型上，就像 <a target="_blank" rel="noopener" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID185">扩展范型类型</a> 中描述的一样。你还可以使用扩展给泛型类型有条件的添加功能，就像 <a target="_blank" rel="noopener" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID553">扩展一个带有 Where 字句的范型</a> 中描述的一样。</p>
<blockquote>
<p>注意</p>
<p>对一个现有的类型，如果你定义了一个扩展来添加新的功能，那么这个类型的所有实例都可以使用这个新功能，包括那些在扩展定义之前就存在的实例。</p>
</blockquote>
<h2 id="计算型属性">计算型属性</h2>
<p>扩展可以给现有类型添加计算型实例属性和计算型类属性。这个例子给 Swift 内建的 <code>Double</code> 类型添加了五个计算型实例属性，从而提供与距离单位相关工作的基本支持：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch <span class="operator">=</span> <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;One inch is <span class="subst">\(oneInch)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“One inch is 0.0254 meters”</span></span><br><span class="line"><span class="keyword">let</span> threeFeet <span class="operator">=</span> <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Three feet is <span class="subst">\(threeFeet)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Three feet is 0.914399970739201 meters”</span></span><br></pre></td></tr></table></figure>
<p>这些计算型属性表示的含义是把一个 <code>Double</code> 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。</p>
<p>在上述例子中，<code>Double</code> 类型的 <code>1.0</code> 代表的是“一米”。这就是为什么计算型属性 <code>m</code> 返回的是 <code>self</code>——表达式 <code>1.m</code> 被认为是计算一个 <code>Double</code> 类型的 <code>1.0</code>。</p>
<p>其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 <code>km</code> 要把值乘以 <code>1_000.00</code> 来实现千米到米的单位换算。类似地，一米有 3.28084 英尺，所以计算型属性 <code>ft</code> 要把对应的 <code>Double</code> 值除以 <code>3.28084</code>，来实现英尺到米的单位换算。</p>
<p>这些属性都是只读的计算型属性，所以为了简便，它们的表达式里面都不包含 <code>get</code> 关键字。它们使用 <code>Double</code> 作为返回值类型，并可用于所有接受 <code>Double</code> 类型的数学计算中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aMarathon <span class="operator">=</span> <span class="number">42</span>.km <span class="operator">+</span> <span class="number">195</span>.m</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A marathon is <span class="subst">\(aMarathon)</span> meters long&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“A marathon is 42195.0 meters long”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>扩展可以添加新的计算属性，但是它们不能添加存储属性，或向现有的属性添加属性观察者。</p>
</blockquote>
<h2 id="构造器">构造器</h2>
<p>扩展可以给现有的类型添加新的构造器。它使你可以把自定义类型作为参数来供其他类型的构造器使用，或者在类型的原始实现上添加额外的构造选项。</p>
<p>扩展可以给一个类添加新的便利构造器，但是它们不能给类添加新的指定构造器或者析构器。指定构造器和析构器必须始终由类的原始实现提供。</p>
<p>如果你使用扩展给一个值类型添加构造器只是用于给所有的存储属性提供默认值，并且没有定义任何自定义构造器，那么你可以在该值类型扩展的构造器中使用默认构造器和成员构造器。如果你把构造器写到了值类型的原始实现中，就像 <a target="_blank" rel="noopener" href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID215">值类型的构造器委托</a> 中所描述的，那么就不属于在扩展中添加构造器。</p>
<p>如果你使用扩展给另一个模块中定义的结构体添加构造器，那么新的构造器直到定义模块中使用一个构造器之前，不能访问 <code>self</code>。</p>
<p>在下面的例子中，自定义了一个的 <code>Rect</code> 结构体用来表示一个几何矩形。这个例子中还定义了两个给予支持的结构体 <code>Size</code> 和 <code>Point</code>，它们都把属性的默认值设置为 <code>0.0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>Rect</code> 结构体给所有的属性都提供了默认值，所以它自动获得了一个默认构造器和一个成员构造器，就像 <a target="_blank" rel="noopener" href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID213">默认构造器</a> 中描述的一样。这些构造器可以用来创建新的 <code>Rect</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultRect <span class="operator">=</span> <span class="type">Rect</span>()</span><br><span class="line"><span class="keyword">let</span> memberwiseRect <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">   size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br></pre></td></tr></table></figure>
<p>你可以通过扩展 <code>Rect</code> 结构体来提供一个允许指定 point 和 size 的构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个新的构造器首先根据提供的 <code>center</code> 和 <code>size</code> 计算一个适当的原点。然后这个构造器调用结构体自带的成员构造器 <code>init(origin:size:)</code>，它会将新的 origin 和 size 值储存在适当的属性中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect <span class="operator">=</span> <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">                      size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect 的 origin 是 (2.5, 2.5) 并且它的 size 是 (3.0, 3.0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>如果你通过扩展提供一个新的构造器，你有责任确保每个通过该构造器创建的实例都是初始化完整的。</p>
</blockquote>
<h2 id="方法">方法</h2>
<p>扩展可以给现有类型添加新的实例方法和类方法。在下面的例子中，给 <code>Int</code> 类型添加了一个新的实例方法叫做 <code>repetitions</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">repetitions</span>(<span class="params">task</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>repetitions(task:)</code> 方法仅接收一个 <code>() -&gt; Void</code> 类型的参数，它表示一个没有参数没有返回值的方法。</p>
<p>定义了这个扩展之后，你可以对任意整形数值调用 <code>repetitions(task:)</code> 方法，来执行对应次数的任务：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>
<h3 id="可变实例方法">可变实例方法</h3>
<p>通过扩展添加的实例方法同样也可以修改（或 <em>mutating（改变）</em>）实例本身。结构体和枚举的方法，若是可以修改 <code>self</code> 或者它自己的属性，则必须将这个实例方法标记为 <code>mutating</code>，就像是改变了方法的原始实现。</p>
<p>在下面的例子中，对 Swift 的 <code>Int</code> 类型添加了一个新的 mutating 方法，叫做 <code>square</code>，它将原始值求平方：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">square</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">someInt.square()</span><br><span class="line"><span class="comment">// someInt 现在是 9</span></span><br></pre></td></tr></table></figure>
<h2 id="下标">下标</h2>
<p>扩展可以给现有的类型添加新的下标。下面的例子中，对 Swift 的 <code>Int</code> 类型添加了一个整数类型的下标。下标 <code>[n]</code> 从数字右侧开始，返回小数点后的第 <code>n</code> 位：</p>
<ul>
<li><code>123456789[0]</code> 返回 <code>9</code></li>
<li><code>123456789[1]</code> 返回 <code>8</code></li>
</ul>
<p>……以此类推：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">digitIndex</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>digitIndex &#123;</span><br><span class="line">            decimalBase <span class="operator">*=</span> <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> <span class="operator">/</span> decimalBase) <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">746381295</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 返回 5</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 返回 9</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 返回 2</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">8</span>]</span><br><span class="line"><span class="comment">// 返回 7</span></span><br></pre></td></tr></table></figure>
<p>如果操作的 <code>Int</code> 值没有足够的位数满足所请求的下标，那么下标的现实将返回 <code>0</code>，将好像在数字的左边补上了 0：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">746381295</span>[<span class="number">9</span>]</span><br><span class="line"><span class="comment">// 返回 0，就好像你进行了这个请求：</span></span><br><span class="line"><span class="number">0746381295</span>[<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h2 id="嵌套类型">嵌套类型</h2>
<p>扩展可以给现有的类，结构体，还有枚举添加新的嵌套类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> negative, zero, positive</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .zero</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .positive</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .negative</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子给 <code>Int</code> 添加了一个新的嵌套枚举。这个枚举叫做 <code>Kind</code>，表示特定整数所代表的数字类型。具体来说，它表示数字是负的、零的还是正的。</p>
<p>这个例子同样给 <code>Int</code> 添加了一个新的计算型实例属性，叫做 <code>kind</code>，它返回被操作整数所对应的 <code>Kind</code> 枚举 case 分支。</p>
<p>现在，任意 <code>Int</code> 的值都可以使用这个嵌套类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printIntegerKinds</span>(<span class="keyword">_</span> <span class="params">numbers</span>: [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">switch</span> number.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> .negative:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .zero:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;0 &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .positive:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;+ &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printIntegerKinds([<span class="number">3</span>, <span class="number">19</span>, <span class="operator">-</span><span class="number">27</span>, <span class="number">0</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment">// 打印“+ + - 0 - 0 + ”</span></span><br></pre></td></tr></table></figure>
<p>方法 <code>printIntegerKinds(_:)</code>，使用一个 <code>Int</code> 类型的数组作为输入，然后依次迭代这些值。对于数组中的每一个整数，方法会检查它的 <code>kind</code> 计算型属性，然后打印适当的描述。</p>
<blockquote>
<p>注意</p>
<p><code>number.kind</code> 已经被认为是 <code>Int.Kind</code> 类型。所以，在 <code>switch</code> 语句中所有的 <code>Int.Kind</code> case 分支可以被缩写，就像使用 <code>.negative</code> 替代 <code>Int.Kind.negative.</code>。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/07/08/Swift/swift%E6%89%A9%E5%B1%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/07/07/Swift/swift%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/"
                            aria-label=": swift嵌套类型"
                        >
                            swift嵌套类型
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-07-07T10:13:17+08:00">
	
		    2023 年 7 月 7 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="嵌套类型">嵌套类型</h2>
<p>枚举常被用于为特定类或结构体实现某些功能。类似地，枚举可以方便的定义工具类或结构体，从而为某个复杂的类型所使用。为了实现这种功能，Swift 允许你定义<em>嵌套类型</em>，可以在支持的类型中定义嵌套的枚举、类和结构体。</p>
<p>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的 <code>&#123;&#125;</code> 内，而且可以根据需要定义多级嵌套。</p>
<h2 id="嵌套类型实践">嵌套类型实践</h2>
<p>下面这个例子定义了一个结构体 <code>BlackjackCard</code>（二十一点），用来模拟 <code>BlackjackCard</code> 中的扑克牌点数。<code>BlackjackCard</code> 结构体包含两个嵌套定义的枚举类型 <code>Suit</code> 和 <code>Rank</code>。</p>
<p>在 <code>BlackjackCard</code> 中，<code>Ace</code> 牌可以表示 <code>1</code> 或者 <code>11</code>，<code>Ace</code> 牌的这一特征通过一个嵌套在 <code>Rank</code> 枚举中的结构体 <code>Values</code> 来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BlackjackCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的 Suit 枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Suit</span>: <span class="title class_ inherited__">Character</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> spades <span class="operator">=</span> <span class="string">&quot;♠&quot;</span>, hearts <span class="operator">=</span> <span class="string">&quot;♡&quot;</span>, diamonds <span class="operator">=</span> <span class="string">&quot;♢&quot;</span>, clubs <span class="operator">=</span> <span class="string">&quot;♣&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的 Rank 枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Rank</span>: <span class="title class_ inherited__">Int</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> two <span class="operator">=</span> <span class="number">2</span>, three, four, five, six, seven, eight, nine, ten</span><br><span class="line">        <span class="keyword">case</span> jack, queen, king, ace</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Values</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> first: <span class="type">Int</span>, second: <span class="type">Int</span>?</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> values: <span class="type">Values</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .ace:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">1</span>, second: <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">case</span> .jack, .queen, .king:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">10</span>, second: <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="keyword">self</span>.rawValue, second: <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlackjackCard 的属性和方法</span></span><br><span class="line">    <span class="keyword">let</span> rank: <span class="type">Rank</span>, suit: <span class="type">Suit</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> <span class="string">&quot;suit is <span class="subst">\(suit.rawValue)</span>,&quot;</span></span><br><span class="line">        output <span class="operator">+=</span> <span class="string">&quot; value is <span class="subst">\(rank.values.first)</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> second <span class="operator">=</span> rank.values.second &#123;</span><br><span class="line">            output <span class="operator">+=</span> <span class="string">&quot; or <span class="subst">\(second)</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Suit</code> 枚举用来描述扑克牌的四种花色，并用一个 <code>Character</code> 类型的原始值表示花色符号。</p>
<p><code>Rank</code> 枚举用来描述扑克牌从 <code>Ace</code>~<code>10</code>，以及 <code>J</code>、<code>Q</code>、<code>K</code>，这 <code>13</code> 种牌，并用一个 <code>Int</code> 类型的原始值表示牌的面值。（这个 <code>Int</code> 类型的原始值未用于 <code>Ace</code>、<code>J</code>、<code>Q</code>、<code>K</code> 这 <code>4</code> 种牌。）</p>
<p>如上所述，<code>Rank</code> 枚举在内部定义了一个嵌套结构体 <code>Values</code>。结构体 <code>Values</code> 中定义了两个属性，用于反映只有 <code>Ace</code> 有两个数值，其余牌都只有一个数值：</p>
<ul>
<li><code>first</code> 的类型为 <code>Int</code></li>
<li><code>second</code> 的类型为 <code>Int?</code>，或者说“可选 <code>Int</code>”</li>
</ul>
<p><code>Rank</code> 还定义了一个计算型属性 <code>values</code>，它将会返回一个 <code>Values</code> 结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化 <code>Values</code> 实例。对于 <code>J</code>、<code>Q</code>、<code>K</code>、<code>Ace</code> 这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的 <code>Int</code> 类型的原始值。</p>
<p><code>BlackjackCard</code> 结构体拥有两个属性——<code>rank</code> 与 <code>suit</code>。它也同样定义了一个计算型属性 <code>description</code>，<code>description</code> 属性用 <code>rank</code> 和 <code>suit</code> 中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型 <code>second</code> 是否有值，若有值，则在原有的描述中增加对 <code>second</code> 的描述。</p>
<p>因为 <code>BlackjackCard</code> 是一个没有自定义构造器的结构体，在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/14_Initialization.html#memberwise_initializers_for_structure_types">结构体的逐一成员构造器</a> 中可知，结构体有默认的成员构造器，所以你可以用默认的构造器去初始化新常量 <code>theAceOfSpades</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> theAceOfSpades <span class="operator">=</span> <span class="type">BlackjackCard</span>(rank: .ace, suit: .spades)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;theAceOfSpades: <span class="subst">\(theAceOfSpades.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“theAceOfSpades: suit is ♠, value is 1 or 11”</span></span><br></pre></td></tr></table></figure>
<p>尽管 <code>Rank</code> 和 <code>Suit</code> 嵌套在 <code>BlackjackCard</code> 中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（<code>.ace</code> 和 <code>.spades</code>）引用枚举实例。在上面的例子中，<code>description</code> 属性正确地反映了黑桃 A 牌具有 <code>1</code> 和 <code>11</code> 两个值。</p>
<h2 id="引用嵌套类型">引用嵌套类型</h2>
<p>在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heartsSymbol <span class="operator">=</span> <span class="type">BlackjackCard</span>.<span class="type">Suit</span>.hearts.rawValue</span><br><span class="line"><span class="comment">// 红心符号为“♡”</span></span><br></pre></td></tr></table></figure>
<p>对于上面这个例子，这样可以使 <code>Suit</code>、<code>Rank</code> 和 <code>Values</code> 的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/07/07/Swift/swift%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../3/"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../5/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 4 頁 共 24 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
