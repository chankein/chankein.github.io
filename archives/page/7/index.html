
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>所有文章 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/archives/page/7/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../#about"
            >
        
        
            <img class="header-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>Kein目前居住在東京和澳門.</br>熱愛旅遊.已探訪日本40多個都道府縣.曾自駕環繞日本半個本州.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/15/cheat-sheet/Linux-cheat-sheet/"
                            aria-label=": Linux cheat sheet"
                        >
                            Linux cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-15T21:37:03+08:00">
	
		    2025 年 5 月 15 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E5%90%8E%E7%AB%AF/">后端</a>, <a class="category-link" href="../../../categories/%E5%90%8E%E7%AB%AF/linux/">linux</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="linux">linux:</h3>
<p><img src="/assets/images/Linux-Commands_Cheat-Sheet.png" alt="image"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/15/cheat-sheet/Linux-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/14/git/git-cheat-sheet/"
                            aria-label=": git cheat sheet"
                        >
                            git cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-14T08:57:44+08:00">
	
		    2025 年 5 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/assets/images/gitcheatsheet.png" alt="image"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/14/git/git-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/12/vim%E6%95%99%E7%A8%8B/"
                            aria-label=": vim教程"
                        >
                            vim教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-12T16:01:20+08:00">
	
		    2025 年 5 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/vim/">vim</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>Vim 编辑器使用笔记整理</h1>
<h2 id="1-退出-Vim">1. 退出 Vim</h2>
<h3 id="命令行模式退出方式">命令行模式退出方式</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:wq</code></td>
<td>保存并退出</td>
</tr>
<tr>
<td><code>:q!</code></td>
<td>强制退出，不保存</td>
</tr>
<tr>
<td><code>:q</code></td>
<td>退出(未修改时)</td>
</tr>
<tr>
<td><code>:wq!</code></td>
<td>强制保存并退出</td>
</tr>
<tr>
<td><code>:w &lt;文件路径&gt;</code></td>
<td>另存为指定文件</td>
</tr>
<tr>
<td><code>:saveas 文件路径</code></td>
<td>另存为指定文件</td>
</tr>
<tr>
<td><code>:x</code></td>
<td>保存并退出(类似:wq)</td>
</tr>
</tbody>
</table>
<h3 id="普通模式退出方式">普通模式退出方式</h3>
<ul>
<li>输入 <code>Shift+zz</code> 即可保存退出</li>
</ul>
<h2 id="2-删除文本">2. 删除文本</h2>
<h3 id="普通模式删除命令">普通模式删除命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>删除游标所在字符</td>
</tr>
<tr>
<td><code>X</code></td>
<td>删除游标前一个字符</td>
</tr>
<tr>
<td><code>Delete</code></td>
<td>同 <code>x</code></td>
</tr>
<tr>
<td><code>dd</code></td>
<td>删除整行</td>
</tr>
<tr>
<td><code>dw</code></td>
<td>删除一个单词(不适用中文)</td>
</tr>
<tr>
<td><code>d$</code> 或 <code>D</code></td>
<td>删除至行尾</td>
</tr>
<tr>
<td><code>d^</code></td>
<td>删除至行首</td>
</tr>
<tr>
<td><code>dG</code></td>
<td>删除到文档结尾</td>
</tr>
<tr>
<td><code>d1G</code></td>
<td>删除至文档开头</td>
</tr>
<tr>
<td><code>:%d</code></td>
<td>清空整个文档内容（删除所有行）</td>
</tr>
<tr>
<td><code>:1,$d</code></td>
<td>同 <code>:%d</code>，删除从第一行到最后一行</td>
</tr>
<tr>
<td><code>ggdG</code></td>
<td>普通模式下清空文档的快捷方式（先跳转到首行，然后删除到末尾）</td>
</tr>
</tbody>
</table>
<p>注意：这些命令会立即生效且不可撤销，使用前请确保已保存重要内容</p>
<h3 id="数字前缀用法">数字前缀用法</h3>
<ul>
<li><code>2dd</code> 表示一次删除2行</li>
<li><code>3dw</code> 表示删除3个单词</li>
</ul>
<h2 id="3-重复执行命令">3. 重复执行命令</h2>
<ul>
<li>普通模式下 <code>.</code> (小数点)表示重复上一次命令</li>
<li>数字前缀：<code>10x</code> 删除10个连续字符</li>
</ul>
<h2 id="4-游标跳转">4. 游标跳转</h2>
<h3 id="行间跳转">行间跳转</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nG</code></td>
<td>跳转到第n行(需先<code>:set nu</code>显示行号)</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>跳转到第一行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>跳转到最后一行</td>
</tr>
</tbody>
</table>
<h3 id="行内跳转">行内跳转</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>w</code></td>
<td>到下一个单词开头</td>
</tr>
<tr>
<td><code>e</code></td>
<td>到当前单词结尾</td>
</tr>
<tr>
<td><code>b</code></td>
<td>到前一个单词开头</td>
</tr>
<tr>
<td><code>ge</code></td>
<td>到前一个单词结尾</td>
</tr>
<tr>
<td><code>0</code> 或 <code>^</code></td>
<td>到行头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>到行尾</td>
</tr>
<tr>
<td><code>f&lt;字母&gt;</code></td>
<td>向后搜索字母并跳转</td>
</tr>
<tr>
<td><code>F&lt;字母&gt;</code></td>
<td>向前搜索字母并跳转</td>
</tr>
<tr>
<td><code>t&lt;字母&gt;</code></td>
<td>向后搜索字母并跳转到匹配前</td>
</tr>
<tr>
<td><code>T&lt;字母&gt;</code></td>
<td>向前搜索字母并跳转到匹配后</td>
</tr>
</tbody>
</table>
<h2 id="5-复制粘贴和剪切">5. 复制粘贴和剪切</h2>
<h3 id="复制命令-yank">复制命令(yank)</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>yy</code></td>
<td>复制整行(3yy复制3行)</td>
</tr>
<tr>
<td><code>y^</code></td>
<td>复制至行首</td>
</tr>
<tr>
<td><code>y$</code></td>
<td>复制至行尾</td>
</tr>
<tr>
<td><code>yw</code></td>
<td>复制一个单词</td>
</tr>
<tr>
<td><code>yG</code></td>
<td>复制至文本末</td>
</tr>
<tr>
<td><code>y1G</code></td>
<td>复制至文本开头</td>
</tr>
</tbody>
</table>
<h3 id="粘贴命令">粘贴命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>p</code></td>
<td>粘贴至光标后</td>
</tr>
<tr>
<td><code>P</code></td>
<td>粘贴至光标前</td>
</tr>
</tbody>
</table>
<h2 id="6-替换和撤销">6. 替换和撤销</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r+&lt;字母&gt;</code></td>
<td>替换游标所在字母</td>
</tr>
<tr>
<td><code>R</code></td>
<td>连续替换(按Esc结束)</td>
</tr>
<tr>
<td><code>cc</code></td>
<td>替换整行</td>
</tr>
<tr>
<td><code>cw</code></td>
<td>替换一个单词</td>
</tr>
<tr>
<td><code>C</code></td>
<td>替换至行末</td>
</tr>
<tr>
<td><code>~</code></td>
<td>反转字母大小写</td>
</tr>
<tr>
<td><code>u</code></td>
<td>撤销操作</td>
</tr>
<tr>
<td><code>U</code></td>
<td>撤销当前行所有修改</td>
</tr>
<tr>
<td><code>Ctrl+r</code></td>
<td>重做(redo)</td>
</tr>
</tbody>
</table>
<h2 id="7-缩进调整">7. 缩进调整</h2>
<h3 id="缩进命令">缩进命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;&gt;</code></td>
<td>整行向右缩进</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>整行向左回退</td>
</tr>
<tr>
<td><code>:set shiftwidth=n</code></td>
<td>设置缩进字符数</td>
</tr>
</tbody>
</table>
<h3 id="文本位置调整">文本位置调整</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:ce</code></td>
<td>本行内容居中</td>
</tr>
<tr>
<td><code>:ri</code></td>
<td>本行文本靠右</td>
</tr>
<tr>
<td><code>:le</code></td>
<td>本行内容靠左</td>
</tr>
</tbody>
</table>
<h2 id="8-查找功能">8. 查找功能</h2>
<h3 id="基本查找">基本查找</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/字符串</code></td>
<td>向下查找</td>
</tr>
<tr>
<td><code>?字符串</code></td>
<td>向上查找</td>
</tr>
<tr>
<td><code>n</code></td>
<td>继续查找</td>
</tr>
<tr>
<td><code>N</code></td>
<td>反向查找</td>
</tr>
</tbody>
</table>
<h3 id="高级查找">高级查找</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>向后查找当前单词</td>
</tr>
<tr>
<td><code>#</code></td>
<td>向前查找当前单词</td>
</tr>
<tr>
<td><code>g*</code></td>
<td>向后查找部分匹配单词</td>
</tr>
<tr>
<td><code>g#</code></td>
<td>向前查找部分匹配单词</td>
</tr>
</tbody>
</table>
<h2 id="9-多文件编辑">9. 多文件编辑</h2>
<h3 id="多文件操作">多文件操作</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:n</code></td>
<td>编辑下一个文件</td>
</tr>
<tr>
<td><code>:N</code></td>
<td>编辑上一个文件</td>
</tr>
<tr>
<td><code>:e 文件名</code></td>
<td>打开新文件</td>
</tr>
<tr>
<td><code>:e#</code></td>
<td>回到前一个文件</td>
</tr>
<tr>
<td><code>:ls</code></td>
<td>列出编辑过的文档</td>
</tr>
<tr>
<td><code>:b 文件名/编号</code></td>
<td>切换到指定文件</td>
</tr>
<tr>
<td><code>:bd 文件名/编号</code></td>
<td>从列表删除文件</td>
</tr>
<tr>
<td><code>:f</code></td>
<td>显示当前文件名</td>
</tr>
</tbody>
</table>
<h3 id="文件恢复">文件恢复</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -r 文件名</span><br><span class="line">:ewcover 文件名</span><br></pre></td></tr></table></figure>
<h2 id="10-可视模式">10. 可视模式</h2>
<h3 id="进入可视模式">进入可视模式</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v</code></td>
<td>字符选择模式</td>
</tr>
<tr>
<td><code>V</code></td>
<td>行选择模式</td>
</tr>
<tr>
<td><code>Ctrl+v</code></td>
<td>区域选择模式</td>
</tr>
</tbody>
</table>
<h3 id="可视模式操作">可视模式操作</h3>
<ul>
<li><code>d</code> 删除选中区域</li>
<li><code>y</code> 复制选中区域</li>
</ul>
<h2 id="11-视窗操作">11. 视窗操作</h2>
<h3 id="窗口分割">窗口分割</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:new</code></td>
<td>新建窗口</td>
</tr>
<tr>
<td><code>:sp 文件名</code></td>
<td>水平分割窗口</td>
</tr>
<tr>
<td><code>:vsp 文件名</code></td>
<td>垂直分割窗口</td>
</tr>
<tr>
<td><code>Ctrl+w s</code></td>
<td>水平分割当前窗口</td>
</tr>
<tr>
<td><code>Ctrl+w v</code></td>
<td>垂直分割当前窗口</td>
</tr>
</tbody>
</table>
<h3 id="窗口切换">窗口切换</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl+w j/k/h/l</code></td>
<td>向下/上/左/右切换窗口</td>
</tr>
<tr>
<td><code>Ctrl+w q</code></td>
<td>关闭当前窗口</td>
</tr>
<tr>
<td><code>Ctrl+w o</code></td>
<td>只保留当前窗口</td>
</tr>
</tbody>
</table>
<h2 id="12-其他功能">12. 其他功能</h2>
<h3 id="文档加密">文档加密</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -x 文件名</span><br></pre></td></tr></table></figure>
<h3 id="执行外部命令">执行外部命令</h3>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:!命令</span><br><span class="line">:<span class="keyword">w</span> 文件名  # 另存为</span><br></pre></td></tr></table></figure>
<h3 id="帮助系统">帮助系统</h3>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:F1        # 打开帮助</span><br><span class="line">:h 主题    # 查看特定帮助</span><br><span class="line">:ver       # 显示版本</span><br></pre></td></tr></table></figure>
<h3 id="功能设定">功能设定</h3>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>    # 显示行号</span><br><span class="line">:<span class="keyword">set</span> ai    # 自动缩进</span><br><span class="line">:<span class="keyword">set</span> aw    # 自动保存</span><br><span class="line">:<span class="keyword">set</span> cin   # C语言风格缩进</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：所有设置可通过修改 <code>~/.vimrc</code> 文件永久保存</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/12/vim%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/08/29/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/"
                            aria-label=": 一文搞懂贝叶斯定理（应用篇）"
                        >
                            一文搞懂贝叶斯定理（应用篇）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-08-29T16:26:57+08:00">
	
		    2023 年 8 月 29 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E5%9F%BA%E7%A1%80/">基础</a>, <a class="category-link" href="../../../categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/">数学</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在统计学里，长期以来，有频率学派和贝叶斯学派两大学派，他们互相鄙视对方，就像华山派的气宗与剑宗之争。</p>
<p>这两大学派最根本的观点在于看待世界的方式不同：</p>
<ul>
<li>频率学派认为世界是客观的，必须通过大量独立采样来获得统计均值，不能先给出一个主观的先验概率（假设）；</li>
<li>贝叶斯学派则认为概率是一种信念度，可以有非常主观的先验概率，然后，通过一次次采样结果修正先验概率，使之逼近客观事实。</li>
</ul>
<p>这两大学派哪个才是正确的？其实都对，只是看待世界的角度不同。但是在现实世界中，除了抛硬币、掷骰子、玩老虎机等少数符合理想数学模型的场景，频率学派才能发挥作用。大多数需要我们估算概率的现实场景，只能用贝叶斯理论来指导实践。</p>
<p>举个例子，假设我住在市区，希望赶上飞机的概率不低于90%，那么我应该提前多久出发呢？我必须试验至少100次，看看样本空间，才能获得一个比较准确的统计均值。然而这是不现实的，因为我一年可能就坐几次飞机。我只能拍脑袋先估一个提前30分钟就够了，结果第三次就没赶上，这说明我必须修正我的先验概率，后续改为提前45分钟，才能提升赶上飞机的概率。</p>
<p>我们再以《狼来了》的故事为例，当小孩第一次喊狼来了，村民听到后可以根据先验概率，比如P(小孩是诚实的)=90%判断赶紧去帮忙，结果发现被骗了，于是大家根据“被骗了”这一证据把后验概率P(小孩是诚实的)调整为60%，第二次又被骗了，于是再次把后验概率调整为20%，等到第三次听见小孩求救时，大家根据P(小孩是诚实的)=20%判断，他大概率还是在说谎，于是没有人去帮忙了。</p>
<p>有的同学会问，你说的这些，都是定性分析，没有定量计算啊！</p>
<p>要把贝叶斯定理用到定量计算，必须得借助计算机。</p>
<p>以吴军老师在中文分词领域举的一个例子来说，对于一个句子：南京市长江大桥，可以有两种划分：</p>
<ul>
<li>南京市 / 长江大桥</li>
<li>南京市长 / 江大桥</li>
</ul>
<p>到底哪一种更合理？我们可以计算条件概率：</p>
<ul>
<li>P(长江大桥|南京市) = 出现“南京市”时，出现“长江大桥”的概率；</li>
<li>P(江大桥|南京市长) = 出现“南京市长”时，出现“江大桥”的概率。</li>
</ul>
<p>提前准备好大量的中文语料，计算出任意两个词的条件概率，我们就可以得出哪种分词更合理。</p>
<p>在互联网领域，凡是遇到“当出现xyz时应该推荐什么”这样的条件概率时，也总是能应用贝叶斯理论。</p>
<p>例如，我们在搜索引擎中输入<code>elon</code>这个单词后，搜索框自动给出了联想补全：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-29-bayes-use/elon.png" alt="elon"></p>
<p>怎么实现这个功能？把用户最近搜索的所有可能的单词列出来，然后计算条件概率：</p>
<ul>
<li>P(mask|elon)=0.5</li>
<li>P(jerk|elon)=0.1</li>
<li>P(university|elon)=0.2</li>
<li>…</li>
</ul>
<p>把它们排个序，选出条件概率最大的几个，就是搜索建议。</p>
<p>诸如反垃圾邮件、电商推荐系统等，都是贝叶斯理论在机器学习中的应用。由于需要大量的计算，贝叶斯理论也只有在计算机时代才能广泛应用。</p>
<h3 id="关于信念">关于信念</h3>
<p>我们再回顾一下贝叶斯定理：</p>
<p>稍微改一下，变为：</p>
<p>P(H)是先验概率，P(H|E)是后验概率，P(E|H)/P(E)被称为调整因子，先验概率乘以调整因子就得到后验概率。</p>
<p>我们发现，如果P(H)=0，则P(H|E)=0；如果P(H)=1，则P(E|H)=P(E)，P(H|E)=1。</p>
<p>也就是说，如果先验概率为0%或100%，那么，无论出现任何证据E，都无法改变后验概率P(H|E)。这对我们看待世界的认知有重大指导意义，因为贝叶斯概率的本质是信念，通过一次次事件，我们可能加强某种信念，也可能减弱某种信念，但如果信念保持100%或0%，则可以做到对外界输入完全“免疫”。</p>
<p>举个例子，十年前许多人都认为比特币是庞氏骗局，如果100%坚定地持有这种信念，那么他将无视用户越来越多、价格上涨、交易量扩大、机构入市等诸多证据，至今仍然会坚信比特币是骗局而错过无数次机会。（注：此处示例不构成任何投资建议）</p>
<p>对于新生事物，每个人都可以有非常主观的先验概率，但只要我们不把先验概率定死为0或100%，就有机会改变自己的信念，从而更有可能接近客观事实，这也是贝叶斯定理的精髓：</p>
<blockquote>
<p>你相信什么并不重要，重要的是你别完全相信它。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/08/29/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"
                            aria-label=": 一文搞懂贝叶斯定理（原理篇）"
                        >
                            一文搞懂贝叶斯定理（原理篇）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-08-27T16:26:10+08:00">
	
		    2023 年 8 月 27 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E5%9F%BA%E7%A1%80/">基础</a>, <a class="category-link" href="../../../categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/">数学</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>托马斯·贝叶斯（Thomas Bayes）是18世纪的英国数学家，也是一位虔诚的牧师。据说他为了反驳对上帝的质疑而推导出贝叶斯定理。贝叶斯定理是一个由结果倒推原因的概率算法，在贝叶斯提出这个条件概率公式后，很长一段时间，大家并没有觉得它有什么作用，并一直受到主流统计学派的排斥。直到计算机诞生后，人们发现，贝叶斯定理可以广泛应用在数据分析、模式识别、统计决策，以及最火的人工智能中，结果，贝叶斯定理是如此有用，以至于不仅应用在计算机上，还广泛应用在经济学、心理学、博弈论等各种领域，可以说，掌握并应用贝叶斯定理，是每个人必备的技能。</p>
<p>这里推荐两个视频，深入浅出地解释了贝叶斯定理：</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Pu675cHJ7bg">Bayes’ Theorem 贝叶斯定理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=HZGCoVF3YvM">Bayes theorem, the geometry of changing beliefs</a></p>
<p>如果你不想花太多时间看视频，可以继续阅读，我把视频内容编译成文字，以便快速学习贝叶斯定理。</p>
<p>为了搞明白贝叶斯定理究竟要解决什么问题，我们先看一个现实生活的例子：</p>
<p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p>
<ul>
<li>如果有病，则准确率是99%（即有1%未检出阳性）；</li>
<li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li>
</ul>
<p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p>
<p>如果我们从大街上随便找一个人，那么他患病的概率就是0.1%，因为这个概率是基于历史统计数据的先验概率。</p>
<p>现在，他做了一次测试，结果为阳性，我们要计算他患病的概率，就是计算条件概率，即：在测试为阳性这一条件下，患病的概率是多少。</p>
<p>从直觉上这个人患病的概率大于0.1%，但也肯定小于99%。究竟是多少，怎么计算，我们先放一放。</p>
<p>为了理解条件概率，我们换一个更简单的例子：掷两次骰子，一共可能出现的结果有6x6=36种：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-all.png" alt="sample space"></p>
<p>这就是所谓的样本空间，每个样本的概率均为1/36，这个很好理解。</p>
<p>如果我们定义事件A为：至少有一个骰子是2，那么事件A的样本空间如下图红色部分所示：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-a.png" alt="Event A"></p>
<p>事件A一共有11种情况，我们计算事件A的概率P(A)：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pa.png" alt="P(A)"></p>
<p>我们再定义事件B：两个骰子之和为7，那么事件B的样本空间如下图绿色部分所示：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-b.png" alt="Event B"></p>
<p>事件B一共有6种情况，我们计算事件B的概率P(B)：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pb.png" alt="P(B)"></p>
<p>接下来我们用P(A∩B)表示A和B同时发生的概率，A∩B就是A和B的交集，如下图蓝色部分所示：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/sample-p-a-and-b.png" alt="P(A∩B)"></p>
<p>显然A∩B只有两种情况，因此，计算P(A∩B)：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b.png" alt="P(A∩B)"></p>
<p>接下来我们就可以讨论条件概率了。我们用P(A|B)表示在B发生的条件下，A发生的概率。由于B已经发生，所以，样本空间就是B的样本数量6，而要发生A则只能是A、B同时发生，即A∩B，有两种情况。</p>
<p>因此，计算P(A|B)如下：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-b.png" alt="P(A|B)"></p>
<p>同理，我们用P(B|A)表示在A发生的条件下，B发生的概率。此时，分子仍然是A∩B的样本数量，但分母变成A的样本数量：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-b-a.png" alt="P(B|A)"></p>
<p>可见，条件概率P(A|B)和P(B|A)是不同的。</p>
<p>我们再回到A、B同时发生的概率，观察P(A∩B)可以改写为：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b-2.png" alt="P(B|A)xP(A)"></p>
<p>同理，P(A∩B)还可以改写为：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/p-a-and-b-3.png" alt="P(A|B)xP(B)"></p>
<p>因此，根据上述两个等式，我们推导出下面的等式：</p>
<p>把左边的<code>P(A∩B)</code>去掉，我们得到等式：</p>
<p>最后，整理一下等式，我们推导出贝叶斯定理如下：</p>
<p>这就是著名的贝叶斯定理，它表示，当出现B时，如何计算A的概率。</p>
<p>很多时候，我们把<code>A</code>改写为<code>H</code>，把<code>B</code>改写为<code>E</code>：</p>
<p>H表示Hypothesis（假设），E表示Evidence（证据），贝叶斯定理的意义就在于，给定一个先验概率P(H)，在出现了证据E的情况下，计算后验概率P(H|E)。</p>
<h3 id="计算">计算</h3>
<p>有了贝叶斯定理，我们就可以回到开头的问题：</p>
<p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p>
<ul>
<li>如果有病，则准确率是99%（即有1%未检出阳性）；</li>
<li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li>
</ul>
<p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p>
<p>用H表示患病，E表示测试为阳性，那么，我们要计算在测试为阳性的条件下，一个人患病的概率，就是计算P(H|E)。根据贝叶斯定理，计算如下：</p>
<p>P(H)表示患病的概率，根据发病率可知，P(H)=0.1%；</p>
<p>P(E|H)表示在患病的情况下，测试为阳性的概率，根据“如果有病，则准确率是99%”可知，P(E|H)=99%；</p>
<p>P(E)表示测试为阳性的概率。这个概率就稍微复杂点，因为它是指对所有人（包含病人和健康人）进行测试，结果阳性的概率。</p>
<p>我们可以把检测人数放大，例如放大到10万人，对10万人进行检测，根据发病率可知：</p>
<ul>
<li>有100人是病人，另外99900是健康人；</li>
<li>对100个病人进行测试，有99人显示阳性，另有1人未检出（阴性）；</li>
<li>对99900个健康人进行测试，有2%=1998人显示阳性（误报），另有98%=97902人为阴性。</li>
</ul>
<p>下图显示了检测为阳性的结果的分布：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">           ┌───────┐</span><br><span class="line">           │100000 │</span><br><span class="line">           └───────┘</span><br><span class="line">               │</span><br><span class="line">       ┌───────┴───────┐</span><br><span class="line">       ▼               ▼</span><br><span class="line">   ┌───────┐       ┌───────┐</span><br><span class="line">   │  100  │       │ 99900 │</span><br><span class="line">   └───────┘       └───────┘</span><br><span class="line">       │               │</span><br><span class="line">   ┌───┴───┐       ┌───┴───┐</span><br><span class="line">   ▼       ▼       ▼       ▼</span><br><span class="line">┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐</span><br><span class="line">│ 99  │ │  1  │ │1998 │ │97902│</span><br><span class="line">└─────┘ └─────┘ └─────┘ └─────┘</span><br><span class="line">   │               │</span><br><span class="line">   ▼               ▼</span><br><span class="line">   +               +</span><br></pre></td></tr></table></figure>
<p>所以，对于10万人的样本空间来说，事件E=显示阳性的概率为(99+1998)/100000=2.097%。</p>
<p>带入贝叶斯定理，计算P(H|E)：</p>
<p>计算结果为患病的概率为4.721%，这个概率远小于99%，且与大多数人的直觉不同，原因在于庞大的健康人群导致的误报数量远多于病人，当出现“检测阳性”的证据时，患病的概率从先验概率0.1%提升到4.721%，还远不足以确诊。</p>
<h3 id="贝叶斯定理的另一种表示">贝叶斯定理的另一种表示</h3>
<p>在上述计算中，我们发现计算P(E)是比较困难的，很多时候，甚至无法知道P(E)。此时，我们需要贝叶斯定理的另一种表示形式。</p>
<p>我们用P(H)表示H发生的概率，用H表示H不发生，P(H)表示H不发生的概率。显然P(H)=1-P(H)。</p>
<p>下图红色部分表示H，红色部分以外则表示H：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/ph.png" alt="P(H)"></p>
<p>事件E用绿色表示：</p>
<p><img src="https://liaoxuefeng.com/blogs/all/2023-08-27-bayes-explain/pe.png" alt="P(E)"></p>
<p>可见，P(E)可以分为两部分，一部分是E和H的交集，另一部分是E和H的交集：</p>
<p>根据上文的公式P(A∩B)=P(A|B)xP(B)，代入可得：</p>
<p>把P(E)替换掉，我们得到贝叶斯定理的另一种写法：</p>
<p>用这个公式来计算，我们就不必计算P(E)了。再次回到开头的问题：</p>
<p>已知有一种疾病，发病率是0.1%。针对这种疾病的测试非常准确：</p>
<ul>
<li>如果有病，则准确率是99%（即有1%未检出阳性）；</li>
<li>如果没有病，则误报率是2%（即有2%误报为阳性）。</li>
</ul>
<p>现在，如果一个人测试显示阳性，请问他患病的概率是多少？</p>
<ul>
<li>P(E|H)表示患病时检测阳性的概率=99%；</li>
<li>P(H)表示患病的概率=0.1%；</li>
<li>P(E|H)表示没有患病但检测阳性的概率=2%；</li>
<li>P(H)表示没有患病的概率=1-P(H)=99.9%。</li>
</ul>
<p>代入公式，计算：</p>
<p>检测为阳性这一证据使得患病的概率从0.1%提升到4.721%。假设这个人又做了一次检测，结果仍然是阳性，那么他患病的概率是多少？</p>
<p>我们仍然使用贝叶斯定理计算，只不过现在先验概率P(H)不再是0.1%，而是4.721%，P(E|H)和P(E|H)仍保持不变，计算新的P(H|E)：</p>
<p>结果为71%，两次检测为阳性的结果使得先验概率从0.1%提升到4.721%再提升到71%，继续第三次检测如果为阳性则概率将提升至99.18%。</p>
<p>可见，贝叶斯定理的核心思想就是不断根据新的证据，将先验概率调整为后验概率，使之更接近客观事实。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/08/27/%E6%95%B0%E5%AD%A6/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                            aria-label=": Astar搜索算法简介及保姆级代码解读"
                        >
                            Astar搜索算法简介及保姆级代码解读
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-14T15:43:00+08:00">
	
		    2023 年 4 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h4 id="A-搜索算法简介及保姆级代码解读">A*搜索算法简介及保姆级代码解读</h4>
<ul>
<li><a href="#1_A_1">1. A*算法简单介绍</a></li>
<li>
<ul>
<li><a href="#11_A_12">1.1 A*算法理论基础</a></li>
<li>
<ul>
<li><a href="#111__31">1.1.1 节点计算</a></li>
<li><a href="#112__60">1.1.2 由计算得出的小结论</a></li>
</ul>
</li>
<li><a href="#12__70">1.2 算法逻辑结构</a></li>
</ul>
</li>
<li><a href="#2__80">2. 代码解析</a></li>
<li>
<ul>
<li><a href="#21__81">2.1 引入地图</a></li>
<li><a href="#22__159">2.2 预处理</a></li>
<li><a href="#23_parent_286">2.3 定义父节点`parent`</a></li>
<li><a href="#24__296">2.4 主循环</a></li>
<li>
<ul>
<li><a href="#241_359">2.4.1</a></li>
<li><a href="#242_364">2.4.2</a></li>
<li><a href="#243_380">2.4.3</a></li>
<li><a href="#244_383">2.4.4</a></li>
<li><a href="#245_396">2.4.5</a></li>
</ul>
</li>
<li><a href="#25__414">2.5 画图</a></li>
</ul>
</li>
<li><a href="#3__427">3. 结果</a></li>
</ul>
<h2 id="1-A-算法简单介绍">1. A*算法简单介绍</h2>
<p>A*算法是一种路径规划算法，和传统的Dijkstra算法有所不同，该算法<strong>有选择</strong>地进行节点搜索，因此比Dijkstra算法更快、搜索的点更少。<br>
阅读本文，不需要掌握Dijkstra算法的知识，请放心食用。<br>
注意：<strong>本文只介绍二维A*算法及相关示例</strong>。</p>
<p><strong>PS</strong>：本文代码编写参考B站up主<br>
<code>小黎的Ally</code>的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Jt4y1z7Ry?from=search&amp;seid=14748520462847442393&amp;spm_id_from=333.337.0.0">路径规划与轨迹跟踪系列算法学习_第4讲_A*算法</a>，讲解详细，本文代码部分是将其代码进行了些许改动并加以解释，在此对up主的辛苦表达感谢！！</p>
<p><strong>PPS</strong>：本文所使用的把地图栅格化的函数来自于博客<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42667352/article/details/98523370">Matlab中将一幅图片做成栅格地图</a>，本文进行了些许改动，再次一并感谢博主的辛苦！</p>
<h3 id="1-1-A-算法理论基础">1.1 A*算法理论基础</h3>
<p>A*算法首先将要搜索的区域划分为若干栅格（grid），并有选择地标识出障碍物（Obstacle）与空白区域。一般地，<strong>栅格划分越细密，搜索点数越多，搜索过程越慢，计算量也越大；栅格划分越稀疏，搜索点数越少，相应地搜索精确性就越低</strong>。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/e5a5e9d6d0f36afb2bf3f1cd9ef378ac.png#pic_center" alt="地图栅格"></p>
<p>如上图，引入地图信息后画出栅格，该图片采用 100 × 100 100 \times 100 100×100的栅格划分，图中黑色区域为障碍物区域。图中绿点为起始点，红点为终点。</p>
<p>对每个节点，在计算时同时考虑两项<strong>代价</strong>指标：<strong>当前节点与起始点的距离</strong>，以及<strong>当前节点与目标点的距离</strong>：<br>
f = g + h f = g + h f=g+h其中 f f f为总代价， g g g为当前节点距离起始点的距离， h h h为当前节点距离目标点的距离。<br>
而在计算距离时，又可以采用两种方式：<br>
<strong>欧氏距离</strong>：<br>
L = ( x 1 − x 2 ) 2 + ( y 1 − y 2 ) 2 L = \sqrt{\left( x_1 - x_2 \right) ^2 + \left( y_1 - y_2 \right) ^2} L=(x1​−x2​)2+(y1​−y2​)2 ​<strong>曼哈顿距离</strong>：<br>
L = ∣ x 1 − x 2 ∣ + ∣ y 1 − y 2 ∣ L = \lvert x_1 - x_2 \rvert + \lvert y_1 - y_2 \rvert L=∣x1​−x2​∣+∣y1​−y2​∣为了计算方便，本文计算 h h h时采用<strong>曼哈顿距离</strong>，这也是A*算法中的一贯做法。<br>
为了方便计数，在计算每一个节点时，在栅格左上角写 f f f值，左下角写 g g g值，右下角写 h h h值。</p>
<h4 id="1-1-1-节点计算">1.1.1 节点计算</h4>
<p>这里举一个例子。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/86fca2663892fb458c7cdef9e81facdf.jpeg#pic_center" alt="节点计算例1"><br>
如图所示，A点为起始点，M点为终点。对于A点来说，对其周边的8个节点进行寻找，A点本身为<strong>父节点</strong>，周边8个点为<strong>子节点</strong>。</p>
<p>假设：</p>
<ul>
<li>格子边长为10，这样水平和竖直位移一格为10，而对角位移一格为14；</li>
<li>从父节点到子节点可以水平、竖直、对角线位移计算 g g g值，而从子节点到目标点只能使用水平、竖直位移计算曼哈顿距离 h h h值。</li>
</ul>
<p>对于点B：从A到B只需右移一格，因此B的 g = 10 g=10 g=10；从B到M需要先右移四格，再上移三格，因此B的 h = 40 + 30 = 70 h = 40+30=70 h=40+30=70。这样B的 f = g + h = 10 + 70 = 80 f=g+h=10+70=80 f=g+h=10+70=80。将三者都记在B格中。<br>
对于点C：从A到C只需向右上方平移一格，因此C的 g = 14 g=14 g=14；从C到M需要先右移四格，再上移两格，因此C的 h = 40 + 20 = 60 h=40+20=60 h=40+20=60，继而C的 f = g + h = 74 f=g+h=74 f=g+h=74。<br>
同理可以计算出D的 g = 14 , h = 80 , f = 94 g=14, h=80,f=94 g=14,h=80,f=94，以及其他几个子节点的值。</p>
<p>将这8个子节点进行对比，可以发现，C点的 f f f值最小，因此选取C点为下一步搜寻的父节点， A C ‾ \overline{AC} AC即为路径迈出的第一步。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/61d8dbfe6ffe8e4eb0d95eb32b2a6032.jpeg#pic_center" alt="节点计算例2"><br>
如图所示，现在将C作为新的父节点。</p>
<p>对于J点：<br>
从C到J只需右移一格，因此J的 g = 10 + g C = 10 + 14 = 24 g=10+g_C =10+14=24 g=10+gC​=10+14=24。需要注意的是，<strong>J点的 g g g值是从C到J的 g g g加上从A到C的 g g g，即当前子节点的 g g g值是从起点到该点的所有 g g g累和</strong>。<br>
从J到M需要先右移三格，再上移两格，因此J的 h = 30 + 20 = 50 h = 30+20=50 h=30+20=50。这样J的 f = g + h = 24 + 50 = 74 f=g+h=24+50=74 f=g+h=24+50=74。将三者都记在J格中。</p>
<p>对于I点：<br>
从C到I只需向右上方平移一格，同样地，<strong>I点的 g g g值是从C到I的 g g g加上从A到C的 g g g，即当前子节点的 g g g值是从起点到该点的所有 g g g累和</strong>，因此I的 g = 14 + g C = 14 + 14 = 28 g=14+g_C =14+14=28 g=14+gC​=14+14=28。<br>
从I到M需要先右移三格，再上移一格，因此I的 h = 30 + 10 = 40 h = 30+10=40 h=30+10=40。这样I的 f = g + h = 28 + 40 = 68 f=g+h=28+40=68 f=g+h=28+40=68。将三者都记在I格中。<br>
同样计算出其他点的值。<br>
可以看出，I点的 f f f值最小，因此选择I点作为路径上的下一个点，此时路径变为 A C I ‾ \overline{ACI} ACI。</p>
<p>如此一步步进行迭代，最后找到最优轨迹。</p>
<h4 id="1-1-2-由计算得出的小结论">1.1.2 由计算得出的小结论</h4>
<ul>
<li>每个节点中需要存储至少3个值： g , h , f g,h,f g,h,f。</li>
<li>当子节点迭代到目标点本身时， h = 0 h=0 h=0，即当前节点到目标点的距离为0.</li>
<li>在算法实施时， g g g的计算可以取10或14，即从父节点到子节点可以水平/竖直位移，也可以沿对角线位移；而 h h h的计算只能取10的倍数，即从当前子节点到目标点只能水平/竖直位移。前者可以采用<strong>欧氏距离</strong>，后者只能采用<strong>曼哈顿距离</strong>。</li>
<li><strong>当某个子节点被选中后，就作为下一次搜索的父节点；并且为了避免节点的重复计算和筛选，在下一次搜索时，需要将上一步选中的节点从“可搜索”列表中删除</strong>。如上图中，当C为父节点时，选中I作为下一次的父节点；那么当第二步I为父节点时，由于C已经在已选轨迹上了，所以I的子节点实际上并不包括C，只计算7个子节点即可。</li>
<li>鉴于上一点，可以预想，算法的具体实施过程中，<strong>需要有两个数组保存“待计算子节点”和“已被选中的节点”。当“待计算子节点”中某个点符合 f f f最小时，就将其加入“已选中的节点”，并在“待计算子节点”中删除该点，防止后续重复计算</strong>。</li>
<li>当算法结束时，<strong>保存在“已选中的节点”中的所有点，按照顺序即为找出的路径</strong>。</li>
<li>算法结束时，<strong>最后一个点的 f f f值，即为从起点到终点所用的距离</strong>。</li>
<li>算法的停止条件：1)当“待计算子节点”中没有点时，即已经没有点可供寻找了；2)当当前父节点恰为目标节点时，即 h = 0 h=0 h=0。</li>
</ul>
<h3 id="1-2-算法逻辑结构">1.2 算法逻辑结构</h3>
<p>A*算法的逻辑结构如下：<br>
1）初始化。导入地图信息，设置障碍物区域，设置起点<code>start</code>、终点<code>target</code>、栅格数量 m × n m \times n m×n等。<br>
2）数据预处理。建立“待计算子节点”的数组<code>openlist</code>，“已选中的节点”的数组<code>closelist</code>，保存路径的数组<code>closelist_path</code>。除此之外，还需建立一个当前子节点集合<code>children</code>，用来保存当前父节点周围8个子节点的坐标，以及父节点本身<code>parent</code>；还有保存代价值 g , h , f g, h,f g,h,f的数组<code>openlist_cost</code>和<code>closelist_cost</code>。<br>
3）对子节点们<code>children</code>中的每个节点<code>child</code>：<br>
若该子节点不在“待计算子节点”节点<code>openlist</code>中，则追加进去；<br>
若在，则计算出该<code>child</code>的 g g g值，该 g g g值是从起点到父节点<code>parent</code>的距离加上父节点到该子节点的距离。若该 g g g值小于之前<code>openlist_cost</code>中的 g g g最小值，那么就将<code>openlist_cost</code>中的最小 g g g值更新；<br>
4）由于该代价最小点已经加入了轨迹，因此将该点加入<code>clost_list</code>和<code>closelist_path</code>，并从<code>openlist</code>中剔除；<br>
5）更新<code>openlist</code>中的最小代价值，并以其为父节点开始新一轮搜索。</p>
<h2 id="2-代码解析">2. 代码解析</h2>
<h3 id="2-1-引入地图">2.1 引入地图</h3>
<p>代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">%% 画地图</span><br><span class="line"></span><br><span class="line">% 栅格地图的行数、列数定义</span><br><span class="line">m = 150;</span><br><span class="line">n = 150;</span><br><span class="line">% 地图m行n列</span><br><span class="line"></span><br><span class="line">start = [10, 20];        % 起始节点</span><br><span class="line">target = [130, 80];       % 终止节点</span><br><span class="line"></span><br><span class="line">obs = TrunToGridMap(m, n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% 画格子</span><br><span class="line">for i = 0 : 5 : m</span><br><span class="line">    plot([0, n], [i, i], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);</span><br><span class="line">    hold on;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for j = 0 : 5 : n</span><br><span class="line">    plot([j, j], [0, m], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">axis equal;</span><br><span class="line">xlim([0, n]);</span><br><span class="line">ylim([0, m]);</span><br><span class="line"></span><br><span class="line">% 绘制障碍物、起止点颜色块</span><br><span class="line">scatter(start(1), start(2), 700, &#x27;pg&#x27;, &#x27;filled&#x27;);</span><br><span class="line">scatter(target(1), target(2), 700, &#x27;pr&#x27;, &#x27;filled&#x27;);</span><br><span class="line"></span><br><span class="line">for i = 1 : size(obs, 1) - 1</span><br><span class="line">    temp = obs(i, :);</span><br><span class="line">    fill([temp(1)-1, temp(1), temp(1), temp(1)-1],...</span><br><span class="line">        [temp(2)-1, temp(2)-1, temp(2), temp(2)], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">temp = obs(size(obs, 1), :);</span><br><span class="line">fill([temp(1)-1, temp(1), temp(1), temp(1)-1],...</span><br><span class="line">    [temp(2)-1, temp(2)-1, temp(2), temp(2)], &#x27;k&#x27;);</span><br></pre></td></tr></table></figure>
<p>绘制一个 150 × 150 150 \times 150 150×150的地图，起点设置为 ( 10 , 20 ) (10,20) (10,20)，终点设置为 ( 130 , 80 ) (130,80) (130,80)。<br>
障碍物的坐标通过函数<code>TrunToGridMap(m, n)</code>获得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function obs = TrunToGridMap(a, b)</span><br><span class="line">    I=imread(&#x27;此处放地图图片的文件名&#x27;);   %读入图片</span><br><span class="line">    I = rgb2gray(I);     %将图片转为灰度图</span><br><span class="line">    I = imrotate(I, -90);</span><br><span class="line"></span><br><span class="line">    l=1;    %网格边长</span><br><span class="line">    B = imresize(I,[a/l b/l]);</span><br><span class="line">    J=floor(B/255); </span><br><span class="line"></span><br><span class="line">    axes(&#x27;GridLineStyle&#x27;, &#x27;-&#x27;);</span><br><span class="line">    axis equal;</span><br><span class="line"></span><br><span class="line">    hold on</span><br><span class="line">    grid on</span><br><span class="line">    axis([0,a,0,b]);</span><br><span class="line">    set(gca,&#x27;xtick&#x27;,0:10:a,&#x27;ytick&#x27;,0:10:b);</span><br><span class="line"></span><br><span class="line">    obs = [];</span><br><span class="line"></span><br><span class="line">    %障碍物填充为黑色</span><br><span class="line">    for i=1:a/l-1</span><br><span class="line">        for j=1:b/l-1</span><br><span class="line">            if(J(i,j)==0)</span><br><span class="line">                obs(end+1, :) = [i, j];</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>该函数读取一个图片文件，将其转化为灰度图像，并将灰度图中黑色色块所在的坐标返回为障碍物坐标。</p>
<h3 id="2-2-预处理">2.2 预处理</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%% 预处理</span><br><span class="line"></span><br><span class="line">% 初始化closelist</span><br><span class="line">closelist = start;</span><br><span class="line">closelist_path = &#123;start, start&#125;;      % 路径，从自身到自身</span><br><span class="line">closelist_cost = 0;</span><br><span class="line">children = child_nodes_cal(start, m, n, obs, closelist);</span><br><span class="line"></span><br><span class="line">% 初始化openlist</span><br><span class="line">openlist = children;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i = 1 : size(openlist, 1)   % i为第i个节点</span><br><span class="line">    openlist_path&#123;i, 1&#125; = openlist(i, :);   % openlist_path的第i行第1列为第i个节点child</span><br><span class="line">    openlist_path&#123;i, 2&#125; = [start; openlist(i, :)]; % openlist_path的第i行第2列为一个列向量，分别是起始节点和当前child</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i = 1 : size(openlist, 1)</span><br><span class="line">    g = norm(start - openlist(i, 1:2));</span><br><span class="line">    h = abs(target(1) - openlist(i, 1)) + abs(target(2) - openlist(i, 2));</span><br><span class="line">    f = g + h;</span><br><span class="line">    openlist_cost(i, :) = [g, h, f];</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这一部分主要做了以下几步：</p>
<ul>
<li>把起点<code>start</code>设为轨迹的第一个点：<code>closelist = start</code>；</li>
<li>路径初始化，即从起点到起点：<code>closelist_path = &#123;start, start&#125;</code>；</li>
<li>代价首先置为0：<code>closelist_cost = 0</code>；</li>
<li>利用<code>child_nodes_cal</code>函数计算当前父节点（即起点）周围的子节点们；</li>
<li>这些子节点们<code>children</code>即为待计算的子节点，也就是<code>openlist</code>；</li>
<li>随后进入一个循环，对每一个子节点i，<code>openlist_path</code>中第i行第1个元素储存第i个节点<code>child</code>，第2个元素为一个<strong>列向量</strong>，分别是第i个<code>child</code>的起点和它本身；</li>
<li>第二个循环则是计算代价的循环，对每一个子节点i，计算 g g g（这里使用<strong>范数</strong><code>norm</code>）， h h h（曼哈顿距离）和 f f f；之后，在代价数组<code>openlist_cost</code>中储存这三个代价值，因此<code>openlist_cost</code>第i行的元素为一个<strong>行向量</strong>；</li>
</ul>
<p>其中用到的子节点计算函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">function child_nodes = child_nodes_cal(parent_node, m, n, obs, closelist)</span><br><span class="line">    child_nodes = [];</span><br><span class="line">    field = [1, 1;</span><br><span class="line">        n, 1;</span><br><span class="line">        n, m;</span><br><span class="line">        1, m];</span><br><span class="line">    </span><br><span class="line">    % 左上子节点</span><br><span class="line">    child_node = [parent_node(1) - 1, parent_node(2) + 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        % [in, on] = inpolygon, 返回 in，以指明 xq 和 yq 所指定的查询点是在 xv 和 </span><br><span class="line">        % yv 定义的多边形区% 域的边缘内部还是在边缘上,in为内部，on为边缘上</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 上子节点</span><br><span class="line">    child_node = [parent_node(1), parent_node(2) + 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 右上子节点</span><br><span class="line">    child_node = [parent_node(1) + 1, parent_node(2) + 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    % 左子节点</span><br><span class="line">    child_node = [parent_node(1) - 1, parent_node(2)];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    %右子节点</span><br><span class="line">    child_node = [parent_node(1) + 1, parent_node(2)];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    %左下子节点</span><br><span class="line">    child_node = [parent_node(1) - 1, parent_node(2) - 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 下子节点</span><br><span class="line">    child_node = [parent_node(1), parent_node(2) - 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 右下子节点</span><br><span class="line">    child_node = [parent_node(1) + 1, parent_node(2) - 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    %% 排除已经存在于closelist的节点</span><br><span class="line">    delete_idx = [];</span><br><span class="line">    for i = 1 : size(child_nodes, 1)</span><br><span class="line">        if ismember(child_nodes(i, :), closelist, &#x27;rows&#x27;)</span><br><span class="line">            delete_idx(end+1, :) = i;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    child_nodes(delete_idx, :) = [];</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="2-3-定义父节点parent">2.3 定义父节点<code>parent</code></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%% 定义父节点</span><br><span class="line">% 从openlist开始搜索移动代价最小的节点</span><br><span class="line">[~, min_idx] = min(openlist_cost(:, 3));    % 看f值最小，min_idx为f最小的那一行</span><br><span class="line">parent = openlist(min_idx, :);% 以min_idx该行的子节点child_node为新的父节点</span><br></pre></td></tr></table></figure>
<p>这一步搜索<code>openlist_cost</code>代价数组中 f f f最小的元素，记下其索引<code>min_idx</code>；<br>
随后该索引对应的<code>openlist</code>中的元素即为“ f f f值最小的待计算子节点”，作为下一步计算的父节点<code>parent</code>。</p>
<h3 id="2-4-主循环">2.4 主循环</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">%% 进入循环</span><br><span class="line">flag = 1;</span><br><span class="line">while flag</span><br><span class="line">    % 找出父节点的忽略closelist的子节点</span><br><span class="line">    children = child_nodes_cal(parent ,m, n, obs, closelist);</span><br><span class="line">    </span><br><span class="line">    % 判断这些子节点是否在openlist中，若在，则更新；没在，则追加到openlist中</span><br><span class="line">    for i = 1 : size(children, 1)</span><br><span class="line">        child = children(i, :);</span><br><span class="line">        [in_flag, openlist_idx] = ismember(child, openlist, &#x27;rows&#x27;);</span><br><span class="line">        % in_flag表示该child_node是否在openlist中</span><br><span class="line">        % openlist_idx表示该child_node在openlist中的行数</span><br><span class="line">        </span><br><span class="line">        g = openlist_cost(min_idx, 1) + norm(parent - child);</span><br><span class="line">        % 原来的g加上新的g</span><br><span class="line">        h = abs(child(1) - target(1)) + abs(child(2) - target(2));</span><br><span class="line">        f = g + h;</span><br><span class="line">        </span><br><span class="line">        if in_flag  % 若在，则比较更新g, f</span><br><span class="line">            if g &lt; openlist_cost(openlist_idx, 1)   </span><br><span class="line">                % openlist_cost(openlist_idx,1)指的是openlist_cost中idx这一行（即child_node所在的一行）的第一个坐标，即g</span><br><span class="line">                openlist_cost(openlist_idx, 1) = g;</span><br><span class="line">                openlist_cost(openlist_idx, 3) = f;</span><br><span class="line">                openlist_path&#123;openlist_idx, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];</span><br><span class="line">                % openlist_path的第i行第2列为一个列向量，分别是起始节点和当前child，此处定义新的起始节点为openlist_path(min_idx,2)， 而openlist_path(min_idx,2)指第min_idx行所对应的 child在openlist_path中对应的路径，相当于把新的child附加到了路径上，延长了路径</span><br><span class="line">            end</span><br><span class="line">        else</span><br><span class="line">            openlist(end+1, :) = child;</span><br><span class="line">            openlist_cost(end+1, :) = [g, h, f];</span><br><span class="line">            openlist_path&#123;end+1, 1&#125; = child;</span><br><span class="line">            openlist_path&#123;end, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 从openlist移除代价最小的节点到closelist</span><br><span class="line">    closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">    closelist_cost(end+1, :) = openlist_cost(min_idx, 3);</span><br><span class="line">    closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">    </span><br><span class="line">    % 同样地，openlist中少了该节点</span><br><span class="line">    openlist(min_idx, :) = [];</span><br><span class="line">    openlist_cost(min_idx, :) = [];</span><br><span class="line">    openlist_path(min_idx, :) = [];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 重新搜索：从openlist搜索移动代价最小的节点，作为新的父节点</span><br><span class="line">    [~, min_idx] = min(openlist_cost(:, 3));</span><br><span class="line">    parent = openlist(min_idx, :);</span><br><span class="line">    </span><br><span class="line">    % 判断是否搜索到终点</span><br><span class="line">    if parent == target</span><br><span class="line">        closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">        closelist_cost(end+1, 1) = openlist_cost(min_idx, 1);</span><br><span class="line">        closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">        flag = 0;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="2-4-1">2.4.1</h4>
<p>对这一部分循环来说，首先利用<code>child_nodes_cal</code>函数得出当前父节点<code>parent</code>周围的子节点们<code>children</code>；<br>
对每一个子节点<code>child</code>，判断其是否在“待计算子节点”<code>openlist</code>列表中——<code>in_flag</code>=1表示在列表中，同时<code>openlist_idx</code>为该子节点在<code>openlist</code>中的索引号。<br>
判断完成后，首先计算该子节点的 g , h , f g,h,f g,h,f值，注意： g g g值为父节点<code>parent</code>的 g g g加上该<code>child</code>子节点的 g g g值。</p>
<h4 id="2-4-2">2.4.2</h4>
<p>计算 g , h , f g,h,f g,h,f之后，再来看子节点在<code>openlist</code>中的情况。<strong>由于循环中查看了<code>parent</code>周围所有子节点的情况，所以一定会存在某个子节点的 g g g比其他子节点的 g g g都小</strong>。如果找到了这样的子节点，那么就更新该子节点在<code>openlist_cost</code>中对应位置的 g , h , f g,h,f g,h,f值。</p>
<p>同时，还要将该子节点加入到路径<code>openlist_path</code>中，即这一句代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openlist_path&#123;openlist_idx, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];</span><br></pre></td></tr></table></figure>
<p>这行代码的含义是：<br>
<code>openlist_idx</code>表示当前子节点<code>child</code>在<code>openlist</code>中的索引，<code>min_idx</code>表示之前所有子节点中代价最小的子节点的索引。之前在<strong>预处理</strong>一节中提到，<code>openlist_path</code>的第i行第2列为一个列向量，分别是父节点和当前child，相当于第2列储存了路径。</p>
<p>而<code>min_idx</code>表示“代价最小的节点”，也就是父节点<code>parent</code>。因此这里<code>openlist_path&#123;min_idx, 2&#125;</code>表示父节点的路径。而<code>[openlist_path&#123;min_idx, 2&#125;; child]</code>则是把新的<code>child</code>附加到这一个列向量上，相当于把新的<code>child</code>附加到路径尾端，把向量长度延长了一个<code>child</code>，延长了路径。</p>
<p>这样，<strong><code>[openlist_path&#123;min_idx, 2&#125;; child]</code>构成了一个“父节点路径-当前child”的新路径</strong>。</p>
<p>把这个新路径赋值给<code>openlist_idx</code>索引所对应的<code>openlist_path</code>上，即为该<code>openlist_idx</code>索引对应的子节点的路径。</p>
<h4 id="2-4-3">2.4.3</h4>
<p>另一方面，如果该<code>child</code>不在<code>openlist</code>中，那么就把该<code>child</code>添加到“待计算子节点”列表中，其 g , h , f g,h,f g,h,f值添加到<code>openlist_cost</code>代价列表中，其路径<code>[openlist_path&#123;min_idx, 2&#125;; child]</code>添加到路径<code>openlist_path</code>中。</p>
<h4 id="2-4-4">2.4.4</h4>
<p>由于移动代价最小的节点已经是路径上的一点了，所以为了避免重复计算，应当把她从“待计算子节点”列表中删除，加入“已计算节点”中，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">closelist_cost(end+1, :) = openlist_cost(min_idx, 3);</span><br><span class="line">closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">% openlist中少了该节点</span><br><span class="line">openlist(min_idx, :) = [];</span><br><span class="line">openlist_cost(min_idx, :) = [];</span><br><span class="line">openlist_path(min_idx, :) = [];</span><br></pre></td></tr></table></figure>
<p>仔细观察不难发现，<code>min_idx</code>对应的正是这一步的<code>parent</code>节点，直到这里，我们才把它加入到“已计算节点”列表中，在之前它一直呆在<code>openlist</code>中。</p>
<h4 id="2-4-5">2.4.5</h4>
<p>父节点加入到了“已计算节点”中了，那么下一步就没有父节点了，所以需要找出新的父节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [~, min_idx] = min(openlist_cost(:, 3));</span><br><span class="line">parent = openlist(min_idx, :);</span><br></pre></td></tr></table></figure>
<p>同时还需要判断一下，是否已经进行到了程序结束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% 判断是否搜索到终点</span><br><span class="line">if parent == target</span><br><span class="line">    closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">    closelist_cost(end+1, 1) = openlist_cost(min_idx, 1);</span><br><span class="line">    closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">    flag = 0;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>需要注意，即使当当前父节点已经是目标点了，也不要忘了把这个父节点加入到“已计算节点”中，相当于把目标点添加入路径中，形成路径上最后一个点。</p>
<h3 id="2-5-画图">2.5 画图</h3>
<p>这一步就是将结果绘制出来了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path_opt = closelist_path&#123;end, 2&#125;;</span><br><span class="line">% closelist_path中第二列存放路径，所以path_opt存放的是路径的(x,y)值</span><br><span class="line">path_opt(:, 1) = path_opt(:, 1) - 0.5;</span><br><span class="line">path_opt(:, 2) = path_opt(:, 2) - 0.5;</span><br><span class="line">plot(path_opt(:, 1), path_opt(:, 2), &#x27;m&#x27;, &#x27;linewidth&#x27;, 1.5);</span><br><span class="line"></span><br><span class="line">title([&#x27;Total length of path: &#x27; num2str(closelist_cost(end, 1))]);</span><br><span class="line">legend(&#x27;Start node&#x27;, &#x27;Target node&#x27;, &#x27;Obstacle&#x27;, &#x27;Path&#x27;, &#x27;location&#x27;, &#x27;northwest&#x27;);</span><br><span class="line">set(gca, &#x27;fontsize&#x27;, 35, &#x27;fontname&#x27;, &#x27;times new roman&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="3-结果">3. 结果</h2>
<p>这里导入稻妻地图作为路径规划的示例，该地图多为岛屿，路径复杂，障碍物分散且数量多，十分适合作为示例使用。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/fcf59433821c1051a8f8714547d79018.png#pic_center" alt="稻妻地图"><br>
将其灰度化得到<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/124b144e99366faa9e582a913fc277e3.jpeg#pic_center" alt="灰度稻妻"><br>
把地图划分为 m × n = 150 × 150 m \times n = 150 \times 150 m×n=150×150的栅格，并设置起点为 ( 10 , 20 ) (10,20) (10,20)，终点为 ( 130 , 80 ) (130,80) (130,80)：<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/50113f38beb35b89434c28535c12ba1b.png#pic_center" alt="稻妻地图栅格"><br>
图中绿色为起点，红色为终点。</p>
<p>路径规划结果：<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/8a875e6b8ffc0c48064351488be0d262.png#pic_center" alt="稻妻路径规划"><br>
可以看出，A* 算法可以找到期望路径。</p>
<p>文件所有代码在笔者的资源<a target="_blank" rel="noopener" href="https://download.csdn.net/download/weixin_58399148/43085850">二维A*算法路径规划matlab代码</a>中可以下载得到。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/04/12/Algorithms/Dijkstra%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"
                            aria-label=": Dijkstra简单介绍"
                        >
                            Dijkstra简单介绍
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-12T22:53:09+08:00">
	
		    2023 年 4 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>不是有个叫迪杰斯特拉(Dijkstra)的算法吗？名字难记不说，加权图的最短路径问题在实际开发中也很少需要自己实现，所以总是很快就忘了。。。</p>
<h2 id="迪杰斯特拉算法是什么"><a href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"></a>迪杰斯特拉算法是什么</h2>
<p>迪杰斯特拉算法是一种用于求解图的最短路径的算法。很多人可能只是听过这个名字。虽然它的原理简单易懂，但初次接触可能有些难以理解，不过只要逐步分析就会发现它其实是一个相当直观的算法。<br>
对于没有权重的迷宫搜索等问题，可以用广度优先搜索(BFS)解决，但如果每条边都有权重，就需要计算所有可能的路径。假设每个顶点只经过一次，且有E条边，那么时间复杂度会是O(E!)，计算量会爆炸式增长。<br>
这样计算起来就很不现实。</p>
<p>而迪杰斯特拉算法正是高效解决这类问题的算法。</p>
<p>需要注意的是，各边的成本必须是非负值（大于等于0）。如果包含负数，则需要使用贝尔曼-福特(Bellman-Ford)等算法。</p>
<h2 id="步骤"><a href="#%E6%AD%A5%E9%AA%A4"></a>步骤</h2>
<p>迪杰斯特拉算法的步骤非常简单：</p>
<ol>
<li>将起点的最短距离设为0</li>
<li>从未访问的点中选择已知最短距离且距离最小的顶点移动</li>
<li>设置该顶点连接的其他顶点的最短距离。如果可以更新更短的距离，则更新。</li>
<li>重复以上步骤，直到所有顶点的最短距离都确定</li>
</ol>
<p>光这么说可能有点抽象，下面我们通过一个具体例子来说明。</p>
<h2 id="示例"><a href="#%E7%A4%BA%E4%BE%8B"></a>示例</h2>
<p>虽然方法很原始，但这是最能表达清楚的方式…<br>
我们来看下面这张图的最短路径：<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F90f90a2f-8991-1bc5-adb4-fb4b053a901f.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b9d055575e737f8a2c459474e25322c7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F90f90a2f-8991-1bc5-adb4-fb4b053a901f.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b9d055575e737f8a2c459474e25322c7" alt="image.png"></a></p>
<p>绿色表示最短路径已确定并已访问的顶点，红色是起点顶点。每个顶点上的数字表示当前的最短路径：<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fae1ddc01-e867-8894-7aee-3940269cfe2e.gif?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=0b8d3bd32321d163185bac4e6ecf4db7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fae1ddc01-e867-8894-7aee-3940269cfe2e.gif?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=0b8d3bd32321d163185bac4e6ecf4db7" alt="dijkstra algo.gif"></a></p>
<p>可以看到，算法从起点开始，每次移动到当前最短路径的顶点，并计算相邻顶点的最短路径。</p>
<h2 id="实现"><a href="#%E5%AE%9E%E7%8E%B0"></a>实现</h2>
<p>接下来我们来实现这个算法。<br>
按照上述步骤直接实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">nodes</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> start = nodes[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 记录已访问的顶点</span></span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">const</span> routesFromStart = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">     <span class="comment">// 记录从起点出发的距离</span></span><br><span class="line"></span><br><span class="line">    routesFromStart.<span class="title function_">set</span>(start, &#123;<span class="attr">distance</span>: <span class="number">0</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> n <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n != start) &#123;</span><br><span class="line">            <span class="comment">// 除起点外所有顶点初始化为无穷大</span></span><br><span class="line">            routesFromStart.<span class="title function_">set</span>(n, &#123;<span class="attr">distance</span>: <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = start</span><br><span class="line">    <span class="keyword">let</span> routes = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">null</span>) &#123;</span><br><span class="line">        visited.<span class="title function_">add</span>(current)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> edge <span class="keyword">of</span> current.<span class="property">edges</span>) &#123;</span><br><span class="line">             <span class="comment">// 计算相邻顶点的最短距离，如果更小则更新</span></span><br><span class="line">            <span class="keyword">if</span>(edge.<span class="property">cost</span> + routesFromStart.<span class="title function_">get</span>(current).<span class="property">distance</span> &lt; routesFromStart.<span class="title function_">get</span>(edge.<span class="property">to</span>).<span class="property">distance</span>) &#123;</span><br><span class="line">                routesFromStart.<span class="title function_">set</span>(edge.<span class="property">to</span>, &#123;<span class="attr">distance</span>: edge.<span class="property">cost</span> + routesFromStart.<span class="title function_">get</span>(current).<span class="property">distance</span>&#125;)</span><br><span class="line">                routes.<span class="title function_">set</span>(current, edge.<span class="property">to</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> cheapestNodeDistance = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span></span><br><span class="line">        current = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 从已计算最短距离的未访问顶点中选择最小的顶点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> city <span class="keyword">of</span> routesFromStart.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.<span class="title function_">has</span>(city) &amp;&amp; cheapestNodeDistance &gt; routesFromStart.<span class="title function_">get</span>(city).<span class="property">distance</span>)&#123;</span><br><span class="line">                cheapestNodeDistance = routesFromStart.<span class="title function_">get</span>(city).<span class="property">distance</span></span><br><span class="line">                current = city</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> routesFromStart.<span class="title function_">get</span>(nodes[nodes.<span class="property">length</span> - <span class="number">1</span>]).<span class="property">distance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设顶点数为V，这段代码在最坏情况下需要遍历所有边，并在内部循环中选择最小顶点，因此时间复杂度是O(V² + E)。空间复杂度需要记录每个顶点，所以是O(V)。</p>
<h2 id="关于使用优先队列的实现"><a href="#%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"></a>关于使用优先队列的实现</h2>
<p>细心的读者可能已经发现，这段代码中选取最小顶点的逻辑可以优化，这就是优先队列(Priority Queue)。<br>
优先队列的插入和取出操作需要O(logN)的时间复杂度，但比线性搜索最小顶点更快。</p>
<p>JavaScript没有内置优先队列，以下是Python实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">nodes</span>):</span><br><span class="line">    start_node = nodes[<span class="number">0</span>]</span><br><span class="line">    routes_from_start = &#123;n: math.inf <span class="keyword">for</span> n <span class="keyword">in</span> nodes&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 起点距离设为0</span></span><br><span class="line">    routes_from_start[start_node] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    minHeap = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加起点</span></span><br><span class="line">    heappush(minHeap, (<span class="number">0</span>, start_node))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直到堆为空</span></span><br><span class="line">    <span class="keyword">while</span> minHeap:</span><br><span class="line">        (cost, current_node) = heappop(minHeap)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查priority key是否重复</span></span><br><span class="line">        <span class="keyword">if</span> cost &gt; routes_from_start[current_node]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> current_node.routes:</span><br><span class="line">            price_info = current_node.routes[node]</span><br><span class="line">            <span class="keyword">if</span> routes_from_start[node] &gt; price_info + routes_from_start[current_node]:</span><br><span class="line">                routes_from_start[node] = price_info + routes_from_start[current_node]</span><br><span class="line">                <span class="comment"># 记录更新最短距离的节点</span></span><br><span class="line">                heappush(minHeap, (price_info + routes_from_start[current_node], node))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> routes_from_start[nodes[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>优先队列的说明我们以后再讨论。<br>
优化后的算法时间复杂度为O(V + ElogE)，比最初的实现更高效。</p>
<h2 id="记录路径"><a href="#%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84"></a>记录路径</h2>
<p>现在我们已经能求出最短成本，但这是&quot;最短路径&quot;问题，我们自然还想知道具体路径。<br>
改进上面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">nodes</span>):</span><br><span class="line">    start_node = nodes[<span class="number">0</span>]</span><br><span class="line">    routes_from_start = &#123;n: math.inf <span class="keyword">for</span> n <span class="keyword">in</span> nodes&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 起点距离设为0</span></span><br><span class="line">    routes_from_start[start_node] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    minHeap = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加起点</span></span><br><span class="line">    heappush(minHeap, (<span class="number">0</span>, start_node))</span><br><span class="line">    path = collections.defaultdict(Node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直到堆为空</span></span><br><span class="line">    <span class="keyword">while</span> minHeap:</span><br><span class="line">        (cost, current_node) = heappop(minHeap)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查priority key是否重复</span></span><br><span class="line">        <span class="keyword">if</span> cost &gt; routes_from_start[current_node]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> current_node.routes:</span><br><span class="line">            price_info = current_node.routes[node]</span><br><span class="line">            <span class="keyword">if</span> routes_from_start[node] &gt; price_info + routes_from_start[current_node]:</span><br><span class="line">                routes_from_start[node] = price_info + routes_from_start[current_node]</span><br><span class="line">                <span class="comment"># 记录更新最短距离的节点</span></span><br><span class="line">                path[node.<span class="built_in">id</span>] = current_node.<span class="built_in">id</span></span><br><span class="line">                heappush(minHeap, (price_info + routes_from_start[current_node], node))</span><br><span class="line"></span><br><span class="line">    current_node = nodes[-<span class="number">1</span>].<span class="built_in">id</span></span><br><span class="line">    path_array = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从终点回溯记录的最短路径节点</span></span><br><span class="line">    <span class="keyword">while</span> current_node:</span><br><span class="line">        path_array.append(current_node)</span><br><span class="line">        <span class="keyword">if</span> current_node <span class="keyword">not</span> <span class="keyword">in</span> path:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        current_node = path[current_node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> routes_from_start[nodes[-<span class="number">1</span>]], path_array[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>迪杰斯特拉算法会记录更新最短距离的节点，最后回溯即可。时间复杂度会增加最短路径节点数的计算量。</p>
<h2 id="为什么这样能求出最短路径"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E8%83%BD%E6%B1%82%E5%87%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"></a>为什么这样能求出最短路径</h2>
<p>看到这里，很多人可能会想：算法本身很简单，实现也不难，但为什么能保证求出最短距离呢？我们简单验证一下：</p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8623f00e-2046-445a-f386-6341b4bef518.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4286b7e1195710b30d6ffb7ab22967c7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8623f00e-2046-445a-f386-6341b4bef518.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4286b7e1195710b30d6ffb7ab22967c7" alt="image.png"></a></p>
<p>假设集合L中的顶点到起点S的最短距离已确定，那么从L连接到的最小顶点也应该是S的最短距离。</p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8eb04095-91e7-85e6-93f1-93cd7f927fa0.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b64897102d0f8dec7ed56385248d0a06"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8eb04095-91e7-85e6-93f1-93cd7f927fa0.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b64897102d0f8dec7ed56385248d0a06" alt="image.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fa10dcc01-c558-6f52-3b6f-906cb3433456.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=57a5fb3ec3b55e91b33e0184905063aa"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fa10dcc01-c558-6f52-3b6f-906cb3433456.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=57a5fb3ec3b55e91b33e0184905063aa" alt="image.png"></a></p>
<p>在集合T中选取最小顶点i，则d[i] = min(T)。对于任意顶点k，最短距离d[k] ≥ d[i]是确定的，因为d[i]是最小值且各边权重非负。<br>
通过归纳法可以证明这一点。</p>
<p>其实这就是一个递推公式：</p>
<p>d[i] = min(k ⊂ T) + i到L中相邻顶点的最短距离</p>
<p>说到递推公式就想到动态规划(DP)。关于DP可以参考这篇文章：<br>
<a target="_blank" rel="noopener" href="https://qiita.com/drken/items/a5e6fe22863b7992efdb">https://qiita.com/drken/items/a5e6fe22863b7992efdb</a></p>
<p>用DP来看值的更新过程：<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F800c0d89-06f7-335a-5195-2f47d85cc22c.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=76478692796218d17f0ab00d2f2651b4"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F800c0d89-06f7-335a-5195-2f47d85cc22c.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=76478692796218d17f0ab00d2f2651b4" alt="image.png"></a></p>
<p>纵轴表示迭代次数，横轴表示顶点。原来迪杰斯特拉算法是DP的一种啊。</p>
<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93"></a>总结</h2>
<p>通过以上分析，迪杰斯特拉算法一旦理解后其实相当简单。以后在算法问题中遇到类似问题时，希望能快速联想到这个算法。<br>
*顺便说一句，我也想写一篇关于DP的文章</p>
<p>讲解视频可以在这里观看：<br>
<a target="_blank" rel="noopener" href="https://youtu.be/jz8b0q5R1Ss">https://youtu.be/jz8b0q5R1Ss</a></p>
<h2 id="参考"><a href="#%E5%8F%82%E8%80%83"></a>参考</h2>
<p><a target="_blank" rel="noopener" href="http://www.lab2.kuis.kyoto-u.ac.jp/~shuichi/algintro/alg-6s.pdf">http://www.lab2.kuis.kyoto-u.ac.jp/~shuichi/algintro/alg-6s.pdf</a><br>
<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=X1AsMlJdiok">https://www.youtube.com/watch?v=X1AsMlJdiok</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/04/12/Algorithms/Dijkstra%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2022/05/23/JAVA/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E6%A0%B8%E5%BF%83%E7%B1%BB/"
                            aria-label=": JAVA-面向对象编程-核心类"
                        >
                            JAVA-面向对象编程-核心类
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-05-23T17:26:47+08:00">
	
		    2022 年 5 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="String">String</h3>
<p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。但是，Java编译器对<code>String</code>有特殊处理，即可以直接用<code>&quot;...&quot;</code>来表示一个字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>因为<code>String</code>太常用了，所以Java提供了<code>&quot;...&quot;</code>这种字符串字面量表示方法。</p>
<p>Java字符串的一个重要特点就是字符串<em>不可变</em>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面代码的输出，试解释字符串内容是否改变。</p>
<h3 id="字符串比较">字符串比较</h3>
<p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code>。</p>
<p>我们看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的。</p>
<p>所以，这种<code>==</code>比较返回<code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：两个字符串比较，必须总是使用<code>equals()</code>方法。</p>
<p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>
<p><code>String</code>类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否包含子串:</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意到<code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>实现的一个接口。</p>
<p>搜索子串的更多的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>提取子串的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意索引号是从<code>0</code>开始的。</p>
<h3 id="去除首尾空白字符">去除首尾空白字符</h3>
<p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p>
<p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure>
<h3 id="替换子串">替换子串</h3>
<p>要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure>
<p>另一种是通过正则表达式替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码通过正则表达式，把匹配的子串统一替换为<code>&quot;,&quot;</code>。关于正则表达式的用法我们会在后面详细讲解。</p>
<h3 id="分割字符串">分割字符串</h3>
<p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="拼接字符串">拼接字符串</h3>
<p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="格式化字符串">格式化字符串</h3>
<p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有：</p>
<ul>
<li><code>%s</code>：显示字符串；</li>
<li><code>%d</code>：显示整数；</li>
<li><code>%x</code>：显示十六进制整数；</li>
<li><code>%f</code>：显示浮点数。</li>
</ul>
<p>占位符还可以带格式，例如<code>%.2f</code>表示显示两位小数。如果你不确定用啥占位符，那就始终用<code>%s</code>，因为<code>%s</code>可以显示任何数据类型。要查看完整的格式化语法，请参考<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Formatter.html#syntax">JDK文档</a>。</p>
<h3 id="类型转换">类型转换</h3>
<p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>
<p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure>
<p>把字符串转换为<code>boolean</code>类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br></pre></td></tr></table></figure>
<h3 id="转换为char">转换为char[]</h3>
<p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>
<p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String &lt;-&gt; char[]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会复制一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p>
<p>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p>
<p>例如，下面的代码设计了一个<code>Score</code>类保存一组学生的成绩：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int[]</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">88</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">66</span> &#125;;</span><br><span class="line">        <span class="type">Score</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(scores);</span><br><span class="line">        s.printScores();</span><br><span class="line">        scores[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        s.printScores();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] scores;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(<span class="type">int</span>[] scores)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scores = scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScores</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Arrays.toString(scores));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察两次输出，由于<code>Score</code>内部直接引用了外部传入的<code>int[]</code>数组，这会造成外部代码对<code>int[]</code>数组的修改，影响到<code>Score</code>类的字段。如果外部代码不可信，这就会造成安全隐患。</p>
<p>请修复<code>Score</code>的构造方法，使得外部代码对数组的修改不影响<code>Score</code>实例的<code>int[]</code>字段。</p>
<h3 id="字符编码">字符编码</h3>
<p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从<code>0</code>到<code>127</code>，最高位始终为<code>0</code>，称为<code>ASCII</code>编码。例如，字符<code>'A'</code>的编码是<code>0x41</code>，字符<code>'1'</code>的编码是<code>0x31</code>。</p>
<p>如果要把汉字也纳入计算机编码，很显然一个字节是不够的。<code>GB2312</code>标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为<code>1</code>，以便和<code>ASCII</code>编码区分开。例如，汉字<code>'中'</code>的<code>GB2312</code>编码是<code>0xd6d0</code>。</p>
<p>类似的，日文有<code>Shift_JIS</code>编码，韩文有<code>EUC-KR</code>编码，这些编码因为标准不统一，同时使用，就会产生冲突。</p>
<p>为了统一全球所有语言的编码，全球统一码联盟发布了<code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p>
<p><code>Unicode</code>编码需要两个或者更多字节表示，我们可以比较中英文字符在<code>ASCII</code>、<code>GB2312</code>和<code>Unicode</code>的编码：</p>
<p>英文字符<code>'A'</code>的<code>ASCII</code>编码和<code>Unicode</code>编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         ┌────┐</span><br><span class="line">ASCII:   │ 41 │</span><br><span class="line">         └────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 00 │ 41 │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure>
<p>英文字符的<code>Unicode</code>编码就是简单地在前面添加一个<code>00</code>字节。</p>
<p>中文字符<code>'中'</code>的<code>GB2312</code>编码和<code>Unicode</code>编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         ┌────┬────┐</span><br><span class="line">GB2312:  │ d6 │ d0 │</span><br><span class="line">         └────┴────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 4e │ 2d │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure>
<p>那我们经常使用的<code>UTF-8</code>又是什么编码呢？因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，包含大量英文的文本会浪费空间，所以，出现了<code>UTF-8</code>编码，它是一种变长编码，用来把固定长度的<code>Unicode</code>编码变成1～4字节的变长编码。通过<code>UTF-8</code>编码，英文字符<code>'A'</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>'中'</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code>。</p>
<p><code>UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p>
<p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure>
<p>注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</p>
<p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] b = ...</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure>
<p>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</p>
<h3 id="延伸阅读">延伸阅读</h3>
<p>对于不同版本的JDK，<code>String</code>类在内存中有不同的优化方式。具体来说，早期JDK版本的<code>String</code>总是以<code>char[]</code>存储，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而较新的JDK版本的<code>String</code>则以<code>byte[]</code>存储：如果<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则，每两个<code>byte</code>存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure>
<p>对于使用者来说，<code>String</code>内部的优化不影响任何已有代码，因为它的<code>public</code>方法签名是不变的。</p>
<h3 id="小结">小结</h3>
<p>Java字符串<code>String</code>是不可变对象；</p>
<p>字符串操作不改变原字符串内容，而是返回新字符串；</p>
<p>常用的字符串操作：提取子串、查找、替换、大小写转换等；</p>
<p>Java使用Unicode编码表示<code>String</code>和<code>char</code>；</p>
<p>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</p>
<p>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</p>
<p>Java编译器对<code>String</code>做了特殊处理，使得我们可以直接用<code>+</code>拼接字符串。</p>
<p>考察下面的循环代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    s = s + <span class="string">&quot;,&quot;</span> + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p>
<p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p><code>StringBuilder</code>还可以进行链式操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们查看<code>StringBuilder</code>的源码，可以发现，进行链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法。</p>
<p>仿照<code>StringBuilder</code>，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adder</span>();</span><br><span class="line">        adder.add(<span class="number">3</span>)</span><br><span class="line">             .add(<span class="number">5</span>)</span><br><span class="line">             .inc()</span><br><span class="line">             .add(<span class="number">10</span>);</span><br><span class="line">        System.out.println(adder.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Adder <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Adder <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        sum ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p>
<p>你可能还听说过<code>StringBuffer</code>，这是Java早期的一个<code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作<code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。</p>
<p><code>StringBuilder</code>和<code>StringBuffer</code>接口完全相同，现在完全没有必要使用<code>StringBuffer</code>。</p>
<h3 id="练习">练习</h3>
<p>请使用<code>StringBuilder</code>构造一个<code>INSERT</code>语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] fields = &#123; <span class="string">&quot;name&quot;</span>, <span class="string">&quot;position&quot;</span>, <span class="string">&quot;salary&quot;</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> <span class="string">&quot;employee&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">insert</span> <span class="operator">=</span> buildInsertSql(table, fields);</span><br><span class="line">        System.out.println(insert);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line">        System.out.println(s.equals(insert) ? <span class="string">&quot;测试成功&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">buildInsertSql</span><span class="params">(String table, String[] fields)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/oop/core/string-builder/core-stringbuilder.zip">下载练习</a></p>
<h3 id="小结-2">小结</h3>
<p><code>StringBuilder</code>是可变对象，用来高效拼接字符串；</p>
<p><code>StringBuilder</code>可以支持链式操作，实现链式操作的关键是返回实例本身；</p>
<p><code>StringBuffer</code>是<code>StringBuilder</code>的线程安全版本，现在很少使用。</p>
<h2 id="StringJoiner">StringJoiner</h2>
<p>要高效拼接字符串，应该使用<code>StringBuilder</code>。</p>
<p>很多时候，我们拼接的字符串像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出: Hello Bob, Alice, Grace!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sb.append(name).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意去掉最后的&quot;, &quot;:</span></span><br><span class="line">        sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">        sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个<code>StringJoiner</code>来干这个事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>慢着！用<code>StringJoiner</code>的结果少了前面的<code>&quot;Hello &quot;</code>和结尾的<code>&quot;!&quot;</code>！遇到这种情况，需要给<code>StringJoiner</code>指定“开头”和“结尾”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-join">String.join()</h3>
<p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>请使用<code>StringJoiner</code>构造一个<code>SELECT</code>语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] fields = &#123; <span class="string">&quot;name&quot;</span>, <span class="string">&quot;position&quot;</span>, <span class="string">&quot;salary&quot;</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> <span class="string">&quot;employee&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">select</span> <span class="operator">=</span> buildSelectSql(table, fields);</span><br><span class="line">        System.out.println(select);</span><br><span class="line">        System.out.println(<span class="string">&quot;SELECT name, position, salary FROM employee&quot;</span>.equals(select) ? <span class="string">&quot;测试成功&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">buildSelectSql</span><span class="params">(String table, String[] fields)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/oop/core/string-joiner/core-stringjoiner.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>用指定分隔符拼接字符串数组时，使用<code>StringJoiner</code>或者<code>String.join()</code>更方便；</p>
<p>用<code>StringJoiner</code>拼接字符串时，还可以额外附加一个“开头”和“结尾”。</p>
<hr>
<hr>
<p>我们已经知道，Java的数据类型分两种：</p>
<ul>
<li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code>；</li>
<li>引用类型：所有<code>class</code>和<code>interface</code>类型。</li>
</ul>
<p>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>
<p>那么，如何把一个基本类型视为对象（引用类型）？</p>
<p>比如，想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper Class）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好了<code>Integer</code>类，我们就可以把<code>int</code>和<code>Integer</code>互相转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> n2.intValue();</span><br></pre></td></tr></table></figure>
<p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的引用类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>java.lang.Byte</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Character</td>
</tr>
</tbody>
</table>
<p>我们可以直接使用，并不需要自己去定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n3</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Auto-Boxing">Auto Boxing</h3>
<p>因为<code>int</code>和<code>Integer</code>可以互相转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n.intValue();</span><br></pre></td></tr></table></figure>
<p>所以，Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure>
<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p>
<p>注意</p>
<p>自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p>
<p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NullPointerException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不变类">不变类</h3>
<p>所有的包装类型都是不变类。我们查看<code>Integer</code>的源码可知，它的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，一旦创建了<code>Integer</code>对象，该对象就是不变的。</p>
<p>对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// == or equals?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">99999</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">99999</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x == y: &quot;</span> + (x==y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m == n: &quot;</span> + (m==n)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x.equals(y): &quot;</span> + x.equals(y)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m.equals(n): &quot;</span> + m.equals(n)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细观察结果的童鞋可以发现，<code>==</code>比较，较小的两个相同的<code>Integer</code>返回<code>true</code>，较大的两个相同的<code>Integer</code>返回<code>false</code>，这是因为<code>Integer</code>是不变类，编译器把<code>Integer x = 127;</code>自动变为<code>Integer x = Integer.valueOf(127);</code>，为了节省内存，<code>Integer.valueOf()</code>对于较小的数，始终返回相同的实例，因此，<code>==</code>比较“恰好”为<code>true</code>，但我们<em>绝不能</em>因为Java标准库的<code>Integer</code>内部有缓存优化就用<code>==</code>比较，必须用<code>equals()</code>方法比较两个<code>Integer</code>。</p>
<p>最佳实践</p>
<p>按照语义编程，而不是针对特定的底层实现去“优化”。</p>
<p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p>
<ul>
<li>方法1：<code>Integer n = new Integer(100);</code></li>
<li>方法2：<code>Integer n = Integer.valueOf(100);</code></li>
</ul>
<p>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p>
<p>我们把能创建“新”对象的静态方法称为静态工厂方法。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p>
<p>最佳实践</p>
<p>创建新对象时，优先选用静态工厂方法而不是new操作符。</p>
<p>如果我们考察<code>Byte.valueOf()</code>方法的源码，可以看到，标准库返回的<code>Byte</code>实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p>
<h3 id="进制转换">进制转换</h3>
<p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure>
<p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// &quot;100&quot;,表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// &quot;2s&quot;,表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// &quot;1100100&quot;,表示为2进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：上述方法的输出都是<code>String</code>，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。<code>int n = 100</code>在内存中总是以4字节的二进制表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌────────┬────────┬────────┬────────┐</span><br><span class="line">│00000000│00000000│00000000│01100100│</span><br><span class="line">└────────┴────────┴────────┴────────┘</span><br></pre></td></tr></table></figure>
<p>我们经常使用的<code>System.out.println(n);</code>是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用<code>Integer.toHexString(n)</code>则通过核心库自动把整数格式化为16进制。</p>
<p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p>
<p>Java的包装类型还定义了一些有用的静态变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">t</span> <span class="operator">=</span> Boolean.TRUE;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">f</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line"><span class="comment">// int可表示的最大/最小值:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// long类型占用的bit和byte数量:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sizeOfLong</span> <span class="operator">=</span> Long.SIZE; <span class="comment">// 64 (bits)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bytesOfLong</span> <span class="operator">=</span> Long.BYTES; <span class="comment">// 8 (bytes)</span></span><br></pre></td></tr></table></figure>
<p>最后，所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上转型为Number:</span></span><br><span class="line"><span class="type">Number</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">999</span>);</span><br><span class="line"><span class="comment">// 获取byte, int, long, float, double:</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> num.byteValue();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.intValue();</span><br><span class="line"><span class="type">long</span> <span class="variable">ln</span> <span class="operator">=</span> num.longValue();</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> num.floatValue();</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> num.doubleValue();</span><br></pre></td></tr></table></figure>
<h3 id="处理无符号整型">处理无符号整型</h3>
<p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p>
<p>例如，byte是有符号整型，范围是<code>-128</code>~<code>+127</code>，但如果把<code>byte</code>看作无符号整型，它的范围就是<code>0</code>~<code>255</code>。我们把一个负的<code>byte</code>按无符号整型转换为<code>int</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Byte</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>byte</code>的<code>-1</code>的二进制表示是<code>11111111</code>，以无符号整型转换后的<code>int</code>就是<code>255</code>。</p>
<p>类似的，可以把一个<code>short</code>按unsigned转换为<code>int</code>，把一个<code>int</code>按unsigned转换为<code>long</code>。</p>
<h3 id="小结-4">小结</h3>
<p>Java核心库提供的包装类型可以把基本类型包装为<code>class</code>；</p>
<p>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</p>
<p>装箱和拆箱会影响执行效率，且拆箱时可能发生<code>NullPointerException</code>；</p>
<p>包装类型的比较必须使用<code>equals()</code>；</p>
<p>整数和浮点数的包装类型都继承自<code>Number</code>；</p>
<p>包装类型提供了大量实用方法。</p>
<p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p>
<ul>
<li>若干<code>private</code>实例字段；</li>
<li>通过<code>public</code>方法来读写实例字段。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果读写方法符合以下这种命名规范：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> Type <span class="title function_">getXyz</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXyz</span><span class="params">(Type value)</span></span><br></pre></td></tr></table></figure>
<p>那么这种<code>class</code>被称为<code>JavaBean</code>：</p>
<p><img src="https://liaoxuefeng.com/books/java/oop/core/javabean/javabean.jpg" alt="java-bean"></p>
<p>上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p>
<p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChild</span><span class="params">(<span class="type">boolean</span> value)</span></span><br></pre></td></tr></table></figure>
<p>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性：</p>
<ul>
<li>对应的读方法是<code>String getName()</code></li>
<li>对应的写方法是<code>setName(String)</code></li>
</ul>
<p>只有<code>getter</code>的属性称为只读属性（read-only），例如，定义一个age只读属性：</p>
<ul>
<li>对应的读方法是<code>int getAge()</code></li>
<li>无对应的写方法<code>setAge(int)</code></li>
</ul>
<p>类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p>
<p>很明显，只读属性很常见，只写属性不常见。</p>
<p>属性只需要定义<code>getter</code>和<code>setter</code>方法，不一定需要对应的字段。例如，<code>child</code>只读属性定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt;= <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>getter</code>和<code>setter</code>也是一种数据封装的方法。</p>
<h3 id="JavaBean的作用">JavaBean的作用</h3>
<p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p>
<p>通过IDE，可以快速生成<code>getter</code>和<code>setter</code>。例如，在Eclipse中，先输入以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成<code>getter</code>和<code>setter</code>方法的字段，点击确定即可由IDE自动完成所有方法代码。</p>
<h3 id="枚举JavaBean属性">枚举JavaBean属性</h3>
<p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BeanInfo</span> <span class="variable">info</span> <span class="operator">=</span> Introspector.getBeanInfo(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以列出所有的属性，以及对应的读写方法。注意<code>class</code>属性是从<code>Object</code>继承的<code>getClass()</code>方法带来的。</p>
<h3 id="小结-5">小结</h3>
<p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p>
<p>属性是一种通用的叫法，并非Java语法规定；</p>
<p>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</p>
<p>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</p>
<p>在Java中，我们可以通过<code>static final</code>来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的<code>int</code>表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUN</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MON</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TUE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WED</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THU</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FRI</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SAT</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用常量的时候，可以这么引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> work at home</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以把常量定义为字符串类型，例如，定义3种颜色的常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="string">&quot;r&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="string">&quot;g&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BLUE</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用常量的时候，可以这么引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="keyword">if</span> (Color.RED.equals(color)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是<code>int</code>常量还是<code>String</code>常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (weekday == <span class="number">6</span> || weekday == <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == Weekday.MON) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码编译和运行均不会报错，但存在两个问题：</p>
<ul>
<li>注意到<code>Weekday</code>定义的常量范围是<code>0</code>~<code>6</code>，并不包含<code>7</code>，编译器无法检查不在枚举中的<code>int</code>值；</li>
<li>定义的常量仍可与其他变量比较，但其用途并非是枚举星期值。</li>
</ul>
<h3 id="enum">enum</h3>
<p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到定义枚举类是通过关键字<code>enum</code>实现的，我们只需依次列出枚举的常量名。</p>
<p>和<code>int</code>定义的常量相比，使用<code>enum</code>定义枚举有如下好处：</p>
<p>首先，<code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (day == Weekday.SUN) &#123; <span class="comment">// Compile error: bad operand types for binary operator &#x27;==&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，不可能引用到非枚举的值，因为无法通过编译。</p>
<p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个<code>Weekday</code>枚举类型的变量赋值为<code>Color</code>枚举类型的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Weekday</span> <span class="variable">x</span> <span class="operator">=</span> Weekday.SUN; <span class="comment">// ok!</span></span><br><span class="line"><span class="type">Weekday</span> <span class="variable">y</span> <span class="operator">=</span> Color.RED; <span class="comment">// Compile error: incompatible types</span></span><br></pre></td></tr></table></figure>
<p>这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</p>
<h3 id="enum的比较">enum的比较</h3>
<p>使用<code>enum</code>定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用<code>equals()</code>方法，如果使用<code>==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用<code>equals()</code>方法，但<code>enum</code>类型可以例外。</p>
<p>这是因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.FRI) &#123; <span class="comment">// ok!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (day.equals(Weekday.SUN)) &#123; <span class="comment">// ok, but more code!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enum类型">enum类型</h3>
<p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？</p>
<p>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>
</ul>
<p>例如，我们定义的<code>Color</code>枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器编译出的<code>class</code>大概就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Color</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123; <span class="comment">// 继承自Enum，标记为final class</span></span><br><span class="line">    <span class="comment">// 每个实例均为全局唯一:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Color</span> <span class="variable">BLUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">    <span class="comment">// private构造方法，确保外部无法调用new操作符:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Color</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，编译后的<code>enum</code>类和普通<code>class</code>并没有任何区别。但是我们自己无法按定义普通<code>class</code>那样来定义<code>enum</code>，必须使用<code>enum</code>关键字，这是Java语法规定的。</p>
<p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例，因此，这些实例有一些方法：</p>
<h4 id="name">name()</h4>
<p>返回常量名，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Weekday.SUN.name(); <span class="comment">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="ordinal">ordinal()</h4>
<p>返回定义的常量的顺序，从0开始计数，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>改变枚举常量定义的顺序就会导致<code>ordinal()</code>返回值发生变化。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的<code>ordinal</code>就是不同的。如果在代码中编写了类似<code>if(x.ordinal()==1)</code>这样的语句，就要保证<code>enum</code>的枚举顺序不能变。新增的常量必须放在最后。</p>
<p>有些童鞋会想，<code>Weekday</code>的枚举常量如果要和<code>int</code>转换，使用<code>ordinal()</code>不是非常方便？比如这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> Weekday.MON.ordinal() + <span class="string">&quot;/ppt&quot;</span>;</span><br><span class="line">saveToFile(task);</span><br></pre></td></tr></table></figure>
<p>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠<code>ordinal()</code>的返回值。因为<code>enum</code>本身是<code>class</code>，所以我们可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<code>int</code>值。</p>
<p>注意</p>
<p>枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！</p>
<p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。我们可以给<code>Weekday</code>添加<code>toString()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue, String chinese)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="built_in">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>覆写<code>toString()</code>的目的是在输出时更有可读性。</p>
<p>注意</p>
<p>判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</p>
<h3 id="switch">switch</h3>
<p>最后，枚举类可以应用在<code>switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比<code>int</code>、<code>String</code>类型更适合用在<code>switch</code>语句中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上<code>default</code>语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</p>
<h3 id="小结-6">小结</h3>
<p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum &#123; … &#125;</code>；</p>
<p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p>
<p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p>
<p>可以为<code>enum</code>编写构造方法、字段和方法</p>
<p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p>
<p><code>enum</code>适合用在<code>switch</code>语句中。</p>
<p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p>
<ol>
<li>定义class时使用<code>final</code>，无法派生子类；</li>
<li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li>
</ol>
<p>假设我们希望定义一个<code>Point</code>类，有<code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保证不变类的比较，还需要正确覆写<code>equals()</code>和<code>hashCode()</code>方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写<code>equals()</code>和<code>hashCode()</code>，这里演示<code>Point</code>不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。</p>
<h3 id="record">record</h3>
<p>从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Record</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>仔细观察<code>Point</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>把上述定义改写为class，相当于以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p>
<p>换句话说，使用<code>record</code>关键字，可以一行写出一个不变类。</p>
<p>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</p>
<h3 id="构造方法">构造方法</h3>
<p>编译器默认按照<code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p>
<p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到方法<code>public Point &#123;...&#125;</code>被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以写出更简洁的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">z</span> <span class="operator">=</span> Point.of();</span><br><span class="line"><span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> Point.of(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>
<h3 id="小结-7">小结</h3>
<p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p>
<ul>
<li>使用<code>record</code>定义的是不变类；</li>
<li>可以编写Compact Constructor对参数进行验证；</li>
<li>可以定义静态方法。</li>
</ul>
<h2 id="BigInteger">BigInteger</h2>
<p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p>
<p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure>
<p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure>
<p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p>
<p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure>
<p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p>
<p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p>
<ul>
<li>转换为<code>byte</code>：<code>byteValue()</code></li>
<li>转换为<code>short</code>：<code>shortValue()</code></li>
<li>转换为<code>int</code>：<code>intValue()</code></li>
<li>转换为<code>long</code>：<code>longValue()</code></li>
<li>转换为<code>float</code>：<code>floatValue()</code></li>
<li>转换为<code>double</code>：<code>doubleValue()</code></li>
</ul>
<p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p>
<p>如果<code>BigInteger</code>的值甚至超过了<code>float</code>的最大范围（3.4x1038），那么返回的float是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BigInteger to float</span></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;999999&quot;</span>).pow(<span class="number">99</span>);</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> n.floatValue();</span><br><span class="line">        System.out.println(f); <span class="comment">// Infinity</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-8">小结</h3>
<p><code>BigInteger</code>用于表示任意大小的整数；</p>
<p><code>BigInteger</code>是不变类，并且继承自<code>Number</code>；</p>
<p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。</p>
<hr>
<hr>
<p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = new BigDecimal(&quot;123.4567&quot;);</span><br><span class="line">System.out.println(bd.multiply(bd)); // 15241.55677489</span><br></pre></td></tr></table></figure>
<p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = new BigDecimal(&quot;123.45&quot;);</span><br><span class="line">BigDecimal d2 = new BigDecimal(&quot;123.4500&quot;);</span><br><span class="line">BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);</span><br><span class="line">System.out.println(d1.scale()); // 2,两位小数</span><br><span class="line">System.out.println(d2.scale()); // 4</span><br><span class="line">System.out.println(d3.scale()); // 0</span><br></pre></td></tr></table></figure>
<p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); // 4</span><br><span class="line">System.out.println(d2.scale()); // 2,因为去掉了00</span><br><span class="line"></span><br><span class="line">BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); // 0</span><br><span class="line">System.out.println(d4.scale()); // -2</span><br></pre></td></tr></table></figure>
<p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p>
<p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.math.RoundingMode;</span><br><span class="line">----</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;);</span><br><span class="line">        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568</span><br><span class="line">        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567</span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);</span><br><span class="line">BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入</span><br><span class="line">BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽</span><br></pre></td></tr></table></figure>
<p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">----</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BigDecimal n = new BigDecimal(&quot;12.345&quot;);</span><br><span class="line">        BigDecimal m = new BigDecimal(&quot;0.12&quot;);</span><br><span class="line">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">        System.out.println(dr[0]); // 102</span><br><span class="line">        System.out.println(dr[1]); // 0.105</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal n = new BigDecimal(&quot;12.75&quot;);</span><br><span class="line">BigDecimal m = new BigDecimal(&quot;0.15&quot;);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">if (dr[1].signum() == 0) &#123;</span><br><span class="line">    // n是m的整数倍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较BigDecimal">比较BigDecimal</h3>
<p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.45600&quot;</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为3</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0 = 相等, -1 = d1 &lt; d2, 1 = d1 &gt; d2</span></span><br></pre></td></tr></table></figure>
<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>
<p>注意</p>
<p>总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p>
<p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimal</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BigDecimal&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p>
<h3 id="小结-9">小结</h3>
<p><code>BigDecimal</code>用于表示精确的小数，常用于财务计算；</p>
<p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code>。</p>
<p>Java的核心库提供了大量的现成的类供我们使用。本节我们介绍几个常用的工具类。</p>
<h3 id="Math">Math</h3>
<p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p>
<p>求绝对值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br></pre></td></tr></table></figure>
<p>取最大或最小值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure>
<p>计算xy次方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br></pre></td></tr></table></figure>
<p>计算 x\sqrt x：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br></pre></td></tr></table></figure>
<p>计算ex次方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.389...</span></span><br></pre></td></tr></table></figure>
<p>计算以e为底的对数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br></pre></td></tr></table></figure>
<p>计算以10为底的对数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>三角函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure>
<p>Math还提供了几个数学常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure>
<p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure>
<p>如果我们要生成一个区间在<code>[MIN, MAX)</code>的随机数，可以借助<code>Math.random()</code>实现，计算如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间在[MIN, MAX)的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.random(); <span class="comment">// x的范围是[0,1)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> x * (max - min) + min; <span class="comment">// y的范围是[10,50)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">long</span>) y; <span class="comment">// n的范围是[10,50)的整数</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些同学可能注意到Java标准库还提供了一个<code>StrictMath</code>，它提供了和<code>Math</code>几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code>保证所有平台计算结果都是完全相同的，而<code>Math</code>会尽量针对平台优化计算速度，所以，绝大多数情况下，使用<code>Math</code>就足够了。</p>
<h3 id="HexFormat">HexFormat</h3>
<p>在处理<code>byte[]</code>数组时，我们经常需要与十六进制字符串转换，自己写起来比较麻烦，用Java标准库提供的<code>HexFormat</code>则可以方便地帮我们转换。</p>
<p>要将<code>byte[]</code>数组转换为十六进制字符串，可以用<code>formatHex()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">HexFormat</span> <span class="variable">hf</span> <span class="operator">=</span> HexFormat.of();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hexData</span> <span class="operator">=</span> hf.formatHex(data); <span class="comment">// 48656c6c6f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要定制转换格式，则使用定制的<code>HexFormat</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分隔符为空格，添加前缀0x，大写字母:</span></span><br><span class="line"><span class="type">HexFormat</span> <span class="variable">hf</span> <span class="operator">=</span> HexFormat.ofDelimiter(<span class="string">&quot; &quot;</span>).withPrefix(<span class="string">&quot;0x&quot;</span>).withUpperCase();</span><br><span class="line">hf.formatHex(<span class="string">&quot;Hello&quot;</span>.getBytes())); <span class="comment">// 0x48 0x65 0x6C 0x6C 0x6F</span></span><br></pre></td></tr></table></figure>
<p>从十六进制字符串到<code>byte[]</code>数组转换，使用<code>parseHex()</code>方法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] bs = HexFormat.of().parseHex(&quot;48656c6c6f&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="Random">Random</h3>
<p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>
<p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure>
<p>有童鞋问，每次运行程序，生成的随机数都是不同的，没看出<em>伪随机数</em>的特性来。</p>
<p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p>
<p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 51, 80, 41, 28, 55...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们使用的<code>Math.random()</code>实际上内部调用了<code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p>
<h3 id="SecureRandom">SecureRandom</h3>
<p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<p><code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法。JDK的<code>SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            sr = <span class="keyword">new</span> <span class="title class_">SecureRandom</span>(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">        sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
<p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用<code>SecureRandom</code>来产生安全的随机数。</p>
<p>注意</p>
<p>需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！</p>
<h3 id="小结-10">小结</h3>
<p>Java提供的常用工具类有：</p>
<ul>
<li>Math：数学计算</li>
<li>HexFormat：格式化十六进制数</li>
<li>Random：生成伪随机数</li>
<li>SecureRandom：生成安全的随机数</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2022/05/23/JAVA/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E6%A0%B8%E5%BF%83%E7%B1%BB/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2021/05/09/oracelBD%E5%9F%BA%E7%A1%80/"
                            aria-label=": oracelBD基础"
                        >
                            oracelBD基础
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-05-09T07:15:08+08:00">
	
		    2021 年 5 月 9 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/database/">database</a>, <a class="category-link" href="../../../categories/database/oracleDB/">oracleDB</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>OracleDB 笔记整理</h1>
<h2 id="1-SQL-分类">1. SQL 分类</h2>
<table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DML</strong> (Data Manipulation Language)</td>
<td>数据操作语言</td>
<td><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>MERGE</code></td>
</tr>
<tr>
<td><strong>DDL</strong> (Data Definition Language)</td>
<td>数据定义语言</td>
<td><code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>RENAME</code>, <code>TRUNCATE</code>, <code>COMMENT</code></td>
</tr>
<tr>
<td><strong>DCL</strong> (Data Control Language)</td>
<td>数据控制语言</td>
<td><code>GRANT</code>, <code>REVOKE</code></td>
</tr>
<tr>
<td><strong>事务</strong> (Transaction)</td>
<td>事务控制</td>
<td><code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code></td>
</tr>
</tbody>
</table>
<h2 id="2-OracleDB-构成">2. OracleDB 构成</h2>
<h3 id="2-1-基本构成">2.1 基本构成</h3>
<p>OracleDB 由 <strong>Oracle实例(instance)</strong> 和 <strong>Database</strong> 构成：</p>
<ul>
<li><strong>实例(Instance)</strong> 由：
<ul>
<li><strong>SGA(System Global Area)</strong>：内存区域</li>
<li><strong>Background Process</strong>：后台进程</li>
</ul>
</li>
<li><strong>Database</strong> 由：
<ul>
<li>控制文件（制御ファイル）</li>
<li>REDO 文件（REDO ログ）</li>
<li>数据文件（データファイル）</li>
</ul>
</li>
</ul>
<h3 id="2-2-进程视角">2.2 进程视角</h3>
<p>除了实例中的 <strong>Background Process</strong>，还包括：</p>
<ul>
<li>用户进程</li>
<li>服务器进程</li>
<li>监听进程</li>
</ul>
<h3 id="2-3-工具列表">2.3 工具列表</h3>
<h4 id="安装和升级相关工具">安装和升级相关工具</h4>
<table>
<thead>
<tr>
<th>工具名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Oracle Universal Installer (OUI)</td>
<td>安装 Oracle 软件</td>
</tr>
<tr>
<td>Oracle Database Configuration Assistant (DBCA)</td>
<td>创建数据库</td>
</tr>
<tr>
<td>Oracle Database Upgrade Assistant (DBUA)</td>
<td>升级现有数据库到新版本</td>
</tr>
</tbody>
</table>
<h4 id="网络相关工具">网络相关工具</h4>
<table>
<thead>
<tr>
<th>工具名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Oracle Net Manager (netmgr)</td>
<td>配置 Oracle 网络</td>
</tr>
<tr>
<td>Oracle Net Configuration Assistant (netca)</td>
<td>配置 Oracle 网络</td>
</tr>
</tbody>
</table>
<h4 id="实例和数据库管理工具">实例和数据库管理工具</h4>
<table>
<thead>
<tr>
<th>工具名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Oracle Enterprise Manager (EM)</td>
<td>管理 Oracle DB</td>
</tr>
<tr>
<td>SQL*Plus</td>
<td>SQL 命令行工具</td>
</tr>
<tr>
<td>SQL Developer</td>
<td>图形化数据库管理工具</td>
</tr>
<tr>
<td>Recovery Manager (RMAN)</td>
<td>数据库备份、恢复、复原</td>
</tr>
<tr>
<td>Oracle Secure Backup</td>
<td>备份管理</td>
</tr>
<tr>
<td>Data Pump</td>
<td>数据库间高速数据传输</td>
</tr>
<tr>
<td>SQL*Loader</td>
<td>外部文件数据批量导入</td>
</tr>
</tbody>
</table>
<h2 id="3-安装">3. 安装</h2>
<h3 id="3-1-OUI-功能">3.1 OUI 功能</h3>
<ul>
<li>显示已安装的 Oracle 软件</li>
<li>安装新软件</li>
<li>删除软件</li>
<li>查看在线帮助</li>
<li>检查安装需求</li>
</ul>
<h3 id="3-2-系统要求">3.2 系统要求</h3>
<ul>
<li><strong>内存</strong>：1GB</li>
<li><strong>SWAP</strong>：1.5GB</li>
<li><strong>硬盘空间</strong>：
<ul>
<li>最小 1GB</li>
<li>一般需要 6.1GB</li>
</ul>
</li>
</ul>
<h3 id="3-3-创建用户和组">3.3 创建用户和组</h3>
<ul>
<li><strong>软件所有者</strong>：Oracle 用户</li>
<li><strong>Oracle Inventory Group</strong>：用于管理 Oracle 软件</li>
<li><strong>DB 管理组</strong>：
<ul>
<li><code>OSDBA</code>：数据库管理员组</li>
<li><code>OSOPER</code>：受限制的数据库管理员组</li>
</ul>
</li>
</ul>
<h3 id="3-4-环境变量">3.4 环境变量</h3>
<table>
<thead>
<tr>
<th>变量名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ORACLE_BASE</code></td>
<td>Oracle 主目录</td>
</tr>
<tr>
<td><code>ORACLE_HOME</code></td>
<td>Oracle 软件安装位置</td>
</tr>
<tr>
<td><code>ORACLE_SID</code></td>
<td>系统标识（实例名）</td>
</tr>
<tr>
<td><code>LD_LIBRARY_PATH</code></td>
<td>共享库路径（如 <code>$ORACLE_HOME/lib</code>）</td>
</tr>
</tbody>
</table>
<h3 id="3-5-安装脚本">3.5 安装脚本</h3>
<table>
<thead>
<tr>
<th>脚本名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>orainstRoot.sh</code></td>
<td>生成 inventory pointer 文件</td>
</tr>
<tr>
<td><code>root.sh</code></td>
<td>生成 <code>oratab</code> 并设置环境变量 (<code>oraenv</code> 和 <code>coraenv</code>)，指定 <code>dbstart</code> 和 <code>dbshut</code> 脚本</td>
</tr>
</tbody>
</table>
<h3 id="3-6-创建数据库（DBCA）">3.6 创建数据库（DBCA）</h3>
<h4 id="3-6-1-指定-Global-DB-名">3.6.1 指定 Global DB 名</h4>
<p>格式：<code>database_name.domain_name</code></p>
<h4 id="3-6-2-Enterprise-Manager-选项">3.6.2 Enterprise Manager 选项</h4>
<ul>
<li><strong>Database Express</strong>：单数据库管理</li>
<li><strong>Cloud Control</strong>：集中管理多个数据库（需预先安装 Cloud Control）</li>
</ul>
<h4 id="3-6-3-存储类型">3.6.3 存储类型</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件系统</td>
<td>使用操作系统文件</td>
</tr>
<tr>
<td>ASM (Automatic Storage Management)</td>
<td>文件存储在 ASM 磁盘组，需额外实例</td>
</tr>
</tbody>
</table>
<h4 id="3-6-4-数据库文件位置">3.6.4 数据库文件位置</h4>
<ul>
<li><strong>使用模板的文件位置</strong></li>
<li><strong>所有数据库文件共享文件夹</strong></li>
<li><strong>Oracle Managed Files</strong>：由 Oracle 直接管理文件</li>
</ul>
<h4 id="3-6-5-模板">3.6.5 模板</h4>
<p>模板包含以下信息：</p>
<ul>
<li>数据库选项</li>
<li>初始化参数</li>
<li>存储属性（数据文件、表空间、控制文件、REDO 日志属性）</li>
</ul>
<h5 id="模板分类">模板分类</h5>
<table>
<thead>
<tr>
<th>模板类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>通用事务处理（默认）</td>
<td>适用于 OLTP 场景</td>
</tr>
<tr>
<td>数据仓库 (Data Warehouse)</td>
<td>适用于复杂查询和大数据处理</td>
</tr>
<tr>
<td>自定义模板</td>
<td>用户自定义配置</td>
</tr>
</tbody>
</table>
<h5 id="模板形式">模板形式</h5>
<table>
<thead>
<tr>
<th>形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sheet Template</td>
<td>包含现有数据库结构和物理文件</td>
</tr>
<tr>
<td>Non-Sheet Template</td>
<td>仅包含数据库特性</td>
</tr>
</tbody>
</table>
<h2 id="4-EM-Express">4. EM Express</h2>
<h3 id="4-1-功能">4.1 功能</h3>
<ul>
<li>提供数据库管理功能（<strong>不包括启动/停止数据库</strong>）</li>
<li>如需启动/停止数据库，需使用 <strong>Oracle Enterprise Manager Cloud Control</strong></li>
</ul>
<h3 id="4-2-手动配置-EM-Express">4.2 手动配置 EM Express</h3>
<ol>
<li><strong>启动监听进程</strong></li>
<li><strong>初始化 <code>DISPATCHERS</code> 参数</strong>（设置 <code>PROTOCOL=TCP</code>）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatchers<span class="operator">=</span>&quot;(PROTOCOL=TCP)(SERVICE=&lt;sid&gt;XDB)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>设置端口</strong>（需 <code>SYSDBA</code> 权限）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> DBMS_XDB_CONFIG.setHTTPSPORT(<span class="number">5500</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-3-使用-EM-Express">4.3 使用 EM Express</h3>
<h4 id="4-3-1-查询-EM-Express-端口">4.3.1 查询 EM Express 端口</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DBMS_XDB_CONFIG.getHTTPSPort <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-权限分配">4.3.2 权限分配</h4>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EM_EXPRESS_BASIC</code></td>
<td>只读模式</td>
</tr>
<tr>
<td><code>EM_EXPRESS_ALL</code></td>
<td>完全权限</td>
</tr>
</tbody>
</table>
<h3 id="4-4-连接数据库">4.4 连接数据库</h3>
<h4 id="4-4-1-SQL-Plus-连接方式">4.4.1 SQL*Plus 连接方式</h4>
<ol>
<li>运行 <code>oraenv</code> 设置环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. oraenv</span><br></pre></td></tr></table></figure>
</li>
<li>启动 SQL*Plus（<code>/nolog</code> 表示不登录数据库）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus /nolog</span><br></pre></td></tr></table></figure>
</li>
<li>连接数据库：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span><span class="operator">/</span><span class="operator">&lt;</span>密码<span class="operator">&gt;</span> [<span class="keyword">AS</span> SYSDBA <span class="operator">|</span> <span class="keyword">AS</span> SYSOPER]</span><br></pre></td></tr></table></figure>
</li>
<li>其他功能：
<ul>
<li>执行 SQL 脚本：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="operator">&lt;</span><span class="keyword">sql</span>文件名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>执行操作系统命令：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST <span class="operator">&lt;</span>命令<span class="operator">&gt;</span>  # 例如：HOST ls</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="4-4-2-SQL-Developer-连接方式">4.4.2 SQL Developer 连接方式</h4>
<ol>
<li>运行 <code>oraenv</code> 设置环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. oraenv</span><br></pre></td></tr></table></figure>
</li>
<li>启动 SQL Developer：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span>/sqldeveloper</span><br><span class="line">sh sqldeveloper.sh</span><br></pre></td></tr></table></figure>
</li>
<li>功能：
<ul>
<li><strong>普通模式</strong>：查看、创建、编辑、删除表、视图等对象</li>
<li><strong>DBA Navigator</strong>：连接 DBA 用户后可启动/停止数据库</li>
</ul>
</li>
</ol>
<h2 id="5-Oracle-网络构成">5. Oracle 网络构成</h2>
<h3 id="5-1-Oracle-Net-概述">5.1 Oracle Net 概述</h3>
<ul>
<li><strong>功能</strong>：提供网络服务</li>
<li><strong>安装方式</strong>：随 Oracle 数据库软件或客户端一同安装</li>
<li><strong>通信模式</strong>：
<ul>
<li><strong>客户端-服务端模式</strong>：两端均需安装 Oracle Net</li>
<li><strong>客户端-Web 服务器-DB 服务器模式</strong>：客户端和 Web 服务器需安装 Oracle Net</li>
</ul>
</li>
</ul>
<h3 id="5-2-通信条件">5.2 通信条件</h3>
<table>
<thead>
<tr>
<th><strong>角色</strong></th>
<th><strong>要求</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DB 服务端</strong></td>
<td>1. 网络服务器在线<br>2. 已安装 Oracle DB<br>3. 支持 TCP/IP 协议<br>4. 监听进程已启动</td>
</tr>
<tr>
<td><strong>客户端</strong></td>
<td>1. 网络服务器在线<br>2. 已安装 Oracle 客户端<br>3. 支持 TCP/IP 协议</td>
</tr>
</tbody>
</table>
<h3 id="5-3-监听进程">5.3 监听进程</h3>
<ul>
<li>
<p><strong>自动安装</strong>：通过 OUI 初始化 DB 时，NetCA 会默认安装监听进程</p>
</li>
<li>
<p><strong>作用</strong>：处理客户端连接请求（连接建立后不再参与通信）</p>
</li>
<li>
<p><strong>关键命令</strong>：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lsnrctl start &lt;监听进程名&gt;</code></td>
<td>启动监听进程</td>
</tr>
<tr>
<td><code>lsnrctl stop &lt;监听进程名&gt;</code></td>
<td>停止监听进程</td>
</tr>
<tr>
<td><code>lsnrctl status &lt;监听进程名&gt;</code></td>
<td>查看状态</td>
</tr>
<tr>
<td><code>lsnrctl services &lt;监听进程名&gt;</code></td>
<td>查看支持的服务</td>
</tr>
<tr>
<td><code>LSNRCTL&gt; set current_listener &lt;名称&gt;</code></td>
<td>切换监听进程（需交互模式）</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="5-4-客户端构成">5.4 客户端构成</h3>
<ul>
<li><strong>数据库连接示例</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> hr@(DESCRIPTION <span class="operator">=</span> </span><br><span class="line">  (ADDRESS <span class="operator">=</span> (PROTOCOL <span class="operator">=</span> TCP)(HOST <span class="operator">=</span> proj1<span class="operator">-</span>sv)(PORT <span class="operator">=</span> <span class="number">1521</span>))</span><br><span class="line">  (CONNECT_DATA <span class="operator">=</span> (SERVICE_NAME <span class="operator">=</span> sales.edifist.com)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-5-命名方法">5.5 命名方法</h3>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>存储位置</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>本地命名</strong></td>
<td>客户端 <code>tnsnames.ora</code></td>
<td>网络服务名映射存储在本地文件</td>
</tr>
<tr>
<td><strong>LDAP 基准</strong></td>
<td>LDAP 服务器</td>
<td>集中管理服务名映射</td>
</tr>
<tr>
<td><strong>简易连接命名</strong></td>
<td>无</td>
<td>直接使用 TCP/IP 连接字符串（如 <code>connect scott@host名/服务名</code>）</td>
</tr>
<tr>
<td><strong>外部命名</strong></td>
<td>第三方命名服务（如 NIS）</td>
<td>依赖非 Oracle 服务</td>
</tr>
</tbody>
</table>
<h4 id="本地命名配置方法">本地命名配置方法</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netca  <span class="comment"># 启动图形化配置工具</span></span><br></pre></td></tr></table></figure>
<h4 id="简易连接示例">简易连接示例</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlplus <span class="operator">/</span>nolog</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">CONNECT</span> hr<span class="operator">/</span>hr<span class="variable">@oracle_sv</span><span class="operator">/</span>orcl.edifist.com</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-数据库服务器架构概要">6. 数据库服务器架构概要</h2>
<h3 id="6-1-核心组件">6.1 核心组件</h3>
<ul>
<li><strong>Oracle 实例</strong>：内存结构（SGA） + 后台进程</li>
<li><strong>Oracle 数据库</strong>：物理文件集合</li>
</ul>
<h3 id="6-2-SGA-System-Global-Area-构成">6.2 SGA (System Global Area) 构成</h3>
<table>
<thead>
<tr>
<th><strong>组件</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据库缓存</strong></td>
<td>存储数据块（Buffer Cache）</td>
</tr>
<tr>
<td><strong>REDO 日志 Buffer</strong></td>
<td>记录数据变更历史</td>
</tr>
<tr>
<td><strong>共享池</strong></td>
<td>缓存 SQL/PLSQL 解析结果、执行计划、数据字典</td>
</tr>
<tr>
<td><strong>Large Pool</strong></td>
<td>可选，用于共享服务器模式、并行查询、RMAN 备份等</td>
</tr>
<tr>
<td><strong>Java Pool</strong></td>
<td>支持 Java 虚拟机（JVM）</td>
</tr>
<tr>
<td><strong>Stream Pool</strong></td>
<td>支持 Oracle Stream 数据复制</td>
</tr>
</tbody>
</table>
<h3 id="6-3-关键后台进程">6.3 关键后台进程</h3>
<table>
<thead>
<tr>
<th><strong>进程</strong></th>
<th><strong>名称</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SMON</strong></td>
<td>System Monitor</td>
<td>实例恢复（如崩溃后自动修复）</td>
</tr>
<tr>
<td><strong>PMON</strong></td>
<td>Process Monitor</td>
<td>清理异常终止的用户进程资源</td>
</tr>
<tr>
<td><strong>DBWn</strong></td>
<td>Database Writer</td>
<td>将脏缓冲区写入数据文件</td>
</tr>
<tr>
<td><strong>CKPT</strong></td>
<td>Checkpoint</td>
<td>触发 DBWn 写入，更新控制文件（用于灾难恢复）</td>
</tr>
<tr>
<td><strong>LGWR</strong></td>
<td>Log Writer</td>
<td>将 REDO 日志缓冲区写入磁盘</td>
</tr>
<tr>
<td><strong>ARCn</strong></td>
<td>Archiver</td>
<td>归档 REDO 日志</td>
</tr>
<tr>
<td><strong>MMON</strong></td>
<td>Manageability Monitor</td>
<td>执行 AWR（自动工作负载仓库）相关任务</td>
</tr>
</tbody>
</table>
<h3 id="6-4-用户与服务器进程">6.4 用户与服务器进程</h3>
<ul>
<li><strong>用户进程</strong>：运行应用程序（如 SQL*Plus）</li>
<li><strong>服务器进程</strong>：处理用户提交的 SQL 查询</li>
</ul>
<h3 id="6-5-PGA-Program-Global-Area">6.5 PGA (Program Global Area)</h3>
<ul>
<li><strong>特点</strong>：非共享内存，仅限单个进程访问</li>
<li><strong>用途</strong>：存储 SQL 执行时的排序区、会话信息等</li>
</ul>
<hr>
<h2 id="7-实例启停">7. 实例启停</h2>
<h3 id="7-1-启动方法">7.1 启动方法</h3>
<ul>
<li>SQL*Plus（<code>STARTUP</code> 命令）</li>
<li>Windows 服务管理器</li>
<li>SQL Developer</li>
<li>Enterprise Manager Cloud Control</li>
</ul>
<h3 id="7-2-启动状态迁移">7.2 启动状态迁移</h3>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NOMOUNT</strong></td>
<td>读取参数文件，分配 SGA，启动后台进程（控制文件未打开）</td>
</tr>
<tr>
<td><strong>MOUNT</strong></td>
<td>打开控制文件（获知数据文件/日志文件路径，但未打开文件）</td>
</tr>
<tr>
<td><strong>OPEN</strong></td>
<td>打开所有数据文件和 REDO 日志，数据库可用</td>
</tr>
</tbody>
</table>
<h3 id="7-3-权限要求">7.3 权限要求</h3>
<table>
<thead>
<tr>
<th><strong>权限</strong></th>
<th><strong>能力</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SYSDBA</strong></td>
<td>完全控制（包括启停实例、用户授权）</td>
</tr>
<tr>
<td><strong>SYSOPER</strong></td>
<td>仅限启停实例（无权管理用户对象）</td>
</tr>
</tbody>
</table>
<h4 id="连接示例">连接示例</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> 用户名<span class="operator">/</span>密码 <span class="keyword">AS</span> &#123;SYSOPER <span class="operator">|</span> SYSDBA&#125;</span><br><span class="line">sqlplus <span class="operator">/</span>nolog</span><br><span class="line"><span class="keyword">CONNECT</span> sys <span class="keyword">AS</span> sysdba</span><br><span class="line">STARTUP</span><br></pre></td></tr></table></figure>
<h3 id="7-4-停止流程">7.4 停止流程</h3>
<ol>
<li><strong>关闭数据库</strong>（OPEN → CLOSED）
<ul>
<li>执行 Checkpoint，写入数据文件和 REDO 日志</li>
<li>关闭数据文件和 REDO 日志（控制文件仍打开）</li>
</ul>
</li>
<li><strong>卸载数据库</strong>（CLOSED → DISMOUNT）
<ul>
<li>实例与数据库分离</li>
</ul>
</li>
<li><strong>停止实例</strong>（DISMOUNT → SHUTDOWN）
<ul>
<li>终止后台进程，释放 SGA 内存</li>
</ul>
</li>
</ol>
<h3 id="7-5-停止模式对比">7.5 停止模式对比</h3>
<table>
<thead>
<tr>
<th><strong>行为</strong></th>
<th>NORMAL</th>
<th>TRANSACTIONAL</th>
<th>IMMEDIATE</th>
<th>ABORT</th>
</tr>
</thead>
<tbody>
<tr>
<td>接受新连接</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>等待当前会话结束</td>
<td>✓</td>
<td>✓</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>等待当前事务结束</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>×</td>
</tr>
<tr>
<td>执行 Checkpoint 后关闭</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>×</td>
</tr>
</tbody>
</table>
<h3 id="7-6-初始化参数文件">7.6 初始化参数文件</h3>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>名称</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>静态</strong></td>
<td>PFILE（文本文件）</td>
<td>手动编辑，需重启生效</td>
</tr>
<tr>
<td><strong>动态</strong></td>
<td>SPFILE（二进制文件）</td>
<td>支持在线修改（<code>ALTER SYSTEM</code>），优先使用</td>
</tr>
</tbody>
</table>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2021/05/09/oracelBD%E5%9F%BA%E7%A1%80/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2021/01/12/VPC/"
                            aria-label=": VPC"
                        >
                            VPC
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2021-01-12T23:15:39+08:00">
	
		    2021 年 1 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E5%90%8E%E7%AB%AF/">后端</a>, <a class="category-link" href="../../../categories/%E5%90%8E%E7%AB%AF/AWS/">AWS</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li>
<p>Security Group(SG):</p>
<ol>
<li>所有设定默认是拒绝，只可以设定许可规则，拒否ルールは指定できません。</li>
<li>特征是不单可以指定CIDR等IP,还可以指定SG</li>
<li>安全组是有状态的 — 如果您从实例发送一个请求，则无论入站安全组规则如何，都将允许该请求的响应流量流入。如果是为响应已允许的入站流量，则该响应可以出站，此时可忽略出站规则。セキュリティグループはステートフルです。</li>
</ol>
</li>
<li>
<p>Access Control List(ACL):</p>
<ol>
<li>VPC 自动带有可修改的默认网络 ACL。默认情况下，它允许所有入站和出站 IPv4 流量以及 IPv6 流量 (如果适用)。</li>
<li>可以创建自定义网络 ACL 并将其与子网相关联。默认情况下，每个自定义网络 ACL 都拒绝所有入站和出站流量，直至您添加规则。</li>
<li>VPC 中的每个子网都必须与一个网络 ACL 相关联。如果您没有明确地将子网与网络 ACL 相关联，则子网将自动与默认网络 ACL 关联。</li>
<li>可以将网络 ACL 与多个子网关联。但是，一个子网一次只能与一个网络 ACL 关联。当您将一个网络 ACL 与一个子网关联时，将删除之前的关联。</li>
<li>网络 ACL 包含规则的编号列表。我们按顺序评估（从编号最小的规则开始）规则，以判断是否允许流量进入或离开任何与网络 ACL 关联的子网。您可以使用的最高规则编号为 32766。我们建议您开始先以增量方式创建规则（例如，以 10 或 100 的增量增加），这样您可以在稍后需要时插入新的规则。</li>
<li>网络 ACL 有单独的入站和出站规则，每项规则都或是允许或是拒绝数据流。</li>
<li>网络 ACL 没有任何状态，这意味着对允许入站数据流的响应会随着出站数据流规则的变化而改变（反之亦然）。(ネットワーク ACL はステートレスです。許可されているインバウンドトラフィックに対する応答は、アウトバウンドトラフィックのルールに従います（その逆の場合も同様です）。)</li>
<li>ルール番号。ルールは、最も低い番号のルールから評価されます。ルールがトラフィックに一致すると、それと相反するより高い数値のルールの有無にかかわらず、すぐに適用されます。</li>
<li>タイプ。トラフィックのタイプ（SSH など）。また、すべてのトラフィックまたはカスタム範囲を指定することもできます。</li>
</ol>
</li>
</ol>
<p>セキュリティグループはステートフルです。（レスポンスでも明示する必要なしで許可。）<br>
ACLはステートレスです。（レスポンスでも明示する必要ある。）</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2021/01/12/VPC/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../6/"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../8/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 7 頁 共 14 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>Kein目前居住在東京和澳門.</br>熱愛旅遊.已探訪日本40多個都道府縣.曾自駕環繞日本半個本州.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macao
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 134 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
