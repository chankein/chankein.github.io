
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>所有文章 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://keinchan.com/archives/page/6/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../#about"
            >
        
        
            <img class="header-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/06/24/Swift/swift%E9%97%AD%E5%8C%85/"
                            aria-label=": swift闭包"
                        >
                            swift闭包
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-24T10:13:17+08:00">
	
		    2023 年 6 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="闭包">闭包</h2>
<p><em>闭包</em>是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的匿名函数（Lambdas）比较相似。</p>
<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为<em>包裹</em>常量和变量。 Swift 会为你管理在捕获过程中涉及到的所有内存操作。</p>
<blockquote>
<p>注意</p>
<p>如果你不熟悉捕获（capturing）这个概念也不用担心，在 <a href="#capturing_values">值捕获</a> 章节有它更详细的介绍。</p>
</blockquote>
<p>在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html">函数</a> 章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采用如下三种形式之一：</p>
<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>
<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>
<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略 <code>return</code> 关键字</li>
<li>参数名称缩写</li>
<li>尾随闭包语法</li>
</ul>
<h2 id="闭包表达式">闭包表达式</h2>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#Nested_Functions">嵌套函数</a> 作为复杂函数的一部分时，它自包含代码块式的定义和命名形式在使用上带来了方便。当然，编写未完整声明和没有函数名的类函数结构代码是很有用的，尤其是在编码中涉及到函数作为参数的那些方法时。</p>
<p><em>闭包表达式</em>是一种构建内联闭包的方式，它的语法简洁。在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式。下面通过对 <code>sorted(by:)</code> 这一个案例的多次迭代改进来展示这个过程，每次迭代都使用了更加简明的方式描述了相同功能。。</p>
<h3 id="排序方法">排序方法</h3>
<p>Swift 标准库提供了名为 <code>sorted(by:)</code> 的方法，它会基于你提供的排序闭包表达式的判断结果对数组中的值（类型确定）进行排序。一旦它完成排序过程，<code>sorted(by:)</code> 方法会返回一个与旧数组类型大小相同类型的新数组，该数组的元素有着正确的排序顺序。原数组不会被 <code>sorted(by:)</code> 方法修改。</p>
<p>下面的闭包表达式示例使用 <code>sorted(by:)</code> 方法对一个 <code>String</code> 类型的数组进行字母逆序排序。以下是初始数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>sorted(by:)</code> 方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值<em>前面</em>，排序闭包函数需要返回 <code>true</code>，反之返回 <code>false</code>。</p>
<p>该例子对一个 <code>String</code> 类型的数组进行排序，因此排序闭包函数类型需为 <code>(String, String) -&gt; Bool</code>。</p>
<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为 <code>sorted(by:)</code> 方法的参数传入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">backward</span>(<span class="keyword">_</span> <span class="params">s1</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">s2</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversedNames <span class="operator">=</span> names.sorted(by: backward)</span><br><span class="line"><span class="comment">// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果第一个字符串（<code>s1</code>）大于第二个字符串（<code>s2</code>），<code>backward(_:_:)</code> 函数会返回 <code>true</code>，表示在新的数组中 <code>s1</code> 应该出现在 <code>s2</code> 前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母 <code>&quot;B&quot;</code> 大于字母 <code>&quot;A&quot;</code> ，字符串 <code>&quot;Tom&quot;</code> 大于字符串 <code>&quot;Tim&quot;</code>。该闭包将进行字母逆序排序，<code>&quot;Barry&quot;</code> 将会排在 <code>&quot;Alex&quot;</code> 之前。</p>
<p>然而，以这种方式来编写一个实际上很简单的表达式（<code>a &gt; b</code>)，确实太过繁琐了。对于这个例子来说，利用闭包表达式语法可以更好地构造一个内联排序闭包。</p>
<h3 id="闭包表达式语法">闭包表达式语法</h3>
<p>闭包表达式语法有如下的一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>闭包表达式参数</em> 可以是 in-out 参数，但不能设定默认值。如果你命名了可变参数，也可以使用此可变参数。元组也可以作为参数和返回值。</p>
<p>下面的例子展示了之前 <code>backward(_:_:)</code> 函数对应的闭包表达式版本的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>需要注意的是内联闭包参数和返回值类型声明与 <code>backward(_:_:)</code> 函数类型声明相同。在这两种方式中，都写成了 <code>(s1: String, s2: String) -&gt; Bool</code>。然而在内联闭包表达式中，函数和返回值类型都写在<em>大括号内</em>，而不是大括号外。</p>
<p>闭包的函数体部分由关键字 <code>in</code> 引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>
<p>由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>该例中 <code>sorted(by:)</code> 方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。</p>
<h3 id="根据上下文推断类型">根据上下文推断类型</h3>
<p>因为排序闭包函数是作为 <code>sorted(by:)</code> 方法的参数传入的，Swift 可以推断其参数和返回值的类型。<code>sorted(by:)</code> 方法被一个字符串数组调用，因此其参数必须是 <code>(String, String) -&gt; Bool</code> 类型的函数。这意味着 <code>(String, String)</code> 和 <code>Bool</code> 类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头（<code>-&gt;</code>）和围绕在参数周围的括号也可以被省略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>实际上，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，你几乎不需要利用完整格式构造内联闭包。</p>
<p>尽管如此，你仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则我们更鼓励采用完整格式的闭包。而在 <code>sorted(by:)</code> 方法这个例子里，显然闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。</p>
<h3 id="单表达式闭包的隐式返回">单表达式闭包的隐式返回</h3>
<p>单行表达式闭包可以通过省略 <code>return</code> 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>sorted(by:)</code> 方法的参数类型明确了闭包必须返回一个 <code>Bool</code> 类型值。因为闭包函数体只包含了一个单一表达式（<code>s1 &gt; s2</code>），该表达式返回 <code>Bool</code> 类型值，因此这里没有歧义，<code>return</code> 关键字可以省略。</p>
<h3 id="参数名称缩写">参数名称缩写</h3>
<p>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 <code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数，以此类推。</p>
<p>如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code> 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125; )</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>$0</code> 和 <code>$1</code> 表示闭包中第一个和第二个 <code>String</code> 类型的参数。</p>
<h3 id="运算符方法">运算符方法</h3>
<p>实际上还有一种更<em>简短的</em>方式来编写上面例子中的闭包表达式。Swift 的 <code>String</code> 类型定义了关于大于号（<code>&gt;</code>）的字符串实现，其作为一个函数接受两个 <code>String</code> 类型的参数并返回 <code>Bool</code> 类型的值。而这正好与 <code>sorted(by:)</code> 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断找到系统自带的那个字符串函数的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: <span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>
<p>更多关于运算符方法的内容请查看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/26_Advanced_Operators.html#operator_methods">运算符方法</a>。</p>
<h2 id="尾随闭包">尾随闭包</h2>
<p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <a href="#closure_expression_syntax">闭包表达式语法</a> 上章节中的字符串排序闭包可以作为尾随包的形式改写在 <code>sorted(by:)</code> 方法圆括号的外面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted() &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 <code>()</code> 省略掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。举例来说，Swift 的 <code>Array</code> 类型有一个 <code>map(_:)</code> 方法，这个方法获取一个闭包表达式作为其唯一参数。该闭包函数会为数组中的每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。</p>
<p>当提供给数组的闭包应用于每个数组元素后，<code>map(_:)</code> 方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。</p>
<p>下例介绍了如何在 <code>map(_:)</code> 方法中使用尾随闭包将 <code>Int</code> 类型数组 <code>[16, 58, 510]</code> 转换为包含对应 <code>String</code> 类型的值的数组 <code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> digitNames <span class="operator">=</span> [</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;Zero&quot;</span>, <span class="number">1</span>: <span class="string">&quot;One&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Two&quot;</span>,   <span class="number">3</span>: <span class="string">&quot;Three&quot;</span>, <span class="number">4</span>: <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">&quot;Five&quot;</span>, <span class="number">6</span>: <span class="string">&quot;Six&quot;</span>, <span class="number">7</span>: <span class="string">&quot;Seven&quot;</span>, <span class="number">8</span>: <span class="string">&quot;Eight&quot;</span>, <span class="number">9</span>: <span class="string">&quot;Nine&quot;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">16</span>, <span class="number">58</span>, <span class="number">510</span>]</span><br></pre></td></tr></table></figure>
<p>如上代码创建了一个整型数位和它们英文版本名字相映射的字典。同时还定义了一个准备转换为字符串数组的整型数组。</p>
<p>你现在可以通过传递一个尾随闭包给 <code>numbers</code> 数组的 <code>map(_:)</code> 方法来创建对应的字符串版本数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings <span class="operator">=</span> numbers.map &#123;</span><br><span class="line">    (number) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> number <span class="operator">=</span> number</span><br><span class="line">    <span class="keyword">var</span> output <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">repeat</span> &#123;</span><br><span class="line">        output <span class="operator">=</span> digitNames[number <span class="operator">%</span> <span class="number">10</span>]<span class="operator">!</span> <span class="operator">+</span> output</span><br><span class="line">        number <span class="operator">/=</span> <span class="number">10</span></span><br><span class="line">    &#125; <span class="keyword">while</span> number <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// strings 常量被推断为字符串类型数组，即 [String]</span></span><br><span class="line"><span class="comment">// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>map(_:)</code> 为数组中每一个元素调用了一次闭包表达式。你不需要指定闭包的输入参数 <code>number</code> 的类型，因为可以通过要映射的数组类型进行推断。</p>
<p>在该例中，局部变量 <code>number</code> 的值由闭包中的 <code>number</code> 参数获得，因此可以在闭包函数体内对其进行修改，(闭包或者函数的参数总是常量)，闭包表达式指定了返回类型为 <code>String</code>，以表明存储映射值的新数组类型为 <code>String</code>。</p>
<p>闭包表达式在每次被调用的时候创建了一个叫做 <code>output</code> 的字符串并返回。其使用求余运算符（<code>number % 10</code>）计算最后一位数字并利用 <code>digitNames</code> 字典获取所映射的字符串。这个闭包能够用于创建任意正整数的字符串表示。</p>
<blockquote>
<p>注意</p>
<p>字典 <code>digitNames</code> 下标后跟着一个叹号（<code>!</code>），因为字典下标返回一个可选值（optional value），表明该键不存在时会查找失败。在上例中，由于可以确定 <code>number % 10</code> 总是 <code>digitNames</code> 字典的有效下标，因此叹号可以用于强制解包（force-unwrap）存储在下标的可选类型的返回值中的 <code>String</code> 类型的值。</p>
</blockquote>
<p>从 <code>digitNames</code> 字典中获取的字符串被添加到 <code>output</code> 的<em>前部</em>，逆序建立了一个字符串版本的数字。（在表达式 <code>number % 10</code> 中，如果 <code>number</code> 为 <code>16</code>，则返回 <code>6</code>，<code>58</code> 返回 <code>8</code>，<code>510</code> 返回 <code>0</code>。）</p>
<p><code>number</code> 变量之后除以 <code>10</code>。因为其是整数，在计算过程中未除尽部分被忽略。因此 <code>16</code> 变成了 <code>1</code>，<code>58</code> 变成了 <code>5</code>，<code>510</code> 变成了 <code>51</code>。</p>
<p>整个过程重复进行，直到 <code>number /= 10</code> 为 <code>0</code>，这时闭包会将字符串 <code>output</code> 返回，而 <code>map(_:)</code> 方法则会将字符串添加到映射数组中。</p>
<p>在上面的例子中，通过尾随闭包语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在 <code>map(_:)</code> 方法的括号内。</p>
<h2 id="值捕获">值捕获</h2>
<p>闭包可以在其被定义的上下文中<em>捕获</em>常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>
<p>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>
<p>举个例子，这有一个叫做 <code>makeIncrementer</code> 的函数，其包含了一个叫做 <code>incrementer</code> 的嵌套函数。嵌套函数 <code>incrementer()</code> 从上下文中捕获了两个值，<code>runningTotal</code> 和 <code>amount</code>。捕获这些值之后，<code>makeIncrementer</code> 将 <code>incrementer</code> 作为闭包返回。每次调用 <code>incrementer</code> 时，其会以 <code>amount</code> 作为增量增加 <code>runningTotal</code> 的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeIncrementer</span>(<span class="params">forIncrement</span> <span class="params">amount</span>: <span class="type">Int</span>) -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal <span class="operator">+=</span> amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makeIncrementer</code> 返回类型为 <code>() -&gt; Int</code>。这意味着其返回的是一个<em>函数</em>，而非一个简单类型的值。该函数在每次调用时不接受参数，只返回一个 <code>Int</code> 类型的值。关于函数返回其他函数的内容，请查看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#function_types_as_return_types">函数类型作为返回类型</a>。</p>
<p><code>makeIncrementer(forIncrement:)</code> 函数定义了一个初始值为 <code>0</code> 的整型变量 <code>runningTotal</code>，用来存储当前总计数值。该值为 <code>incrementer</code> 的返回值。</p>
<p><code>makeIncrementer(forIncrement:)</code> 有一个 <code>Int</code> 类型的参数，其外部参数名为 <code>forIncrement</code>，内部参数名为 <code>amount</code>，该参数表示每次 <code>incrementer</code> 被调用时 <code>runningTotal</code> 将要增加的量。<code>makeIncrementer</code> 函数还定义了一个嵌套函数 <code>incrementer</code>，用来执行实际的增加操作。该函数简单地使 <code>runningTotal</code> 增加 <code>amount</code>，并将其返回。</p>
<p>如果我们单独考虑嵌套函数 <code>incrementer()</code>，会发现它有些不同寻常：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    runningTotal <span class="operator">+=</span> amount</span><br><span class="line">    <span class="keyword">return</span> runningTotal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>incrementer()</code> 函数并没有任何参数，但是在函数体内访问了 <code>runningTotal</code> 和 <code>amount</code> 变量。这是因为它从外围函数捕获了 <code>runningTotal</code> 和 <code>amount</code> 变量的<em>引用</em>。捕获引用保证了 <code>runningTotal</code> 和 <code>amount</code> 变量在调用完 <code>makeIncrementer</code> 后不会消失，并且保证了在下一次执行 <code>incrementer</code> 函数时，<code>runningTotal</code> 依旧存在。</p>
<blockquote>
<p>注意</p>
<p>为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。</p>
<p>Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
</blockquote>
<p>下面是一个使用 <code>makeIncrementer</code> 的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>该例子定义了一个叫做 <code>incrementByTen</code> 的常量，该常量指向一个每次调用会将其 <code>runningTotal</code> 变量增加 <code>10</code> 的 <code>incrementer</code> 函数。调用这个函数多次可以得到以下结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为10</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为20</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为30</span></span><br></pre></td></tr></table></figure>
<p>如果你创建了另一个 <code>incrementer</code>，它会有属于自己的引用，指向一个全新、独立的 <code>runningTotal</code> 变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementBySeven <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()</span><br><span class="line"><span class="comment">// 返回的值为7</span></span><br></pre></td></tr></table></figure>
<p>再次调用原来的 <code>incrementByTen</code> 会继续增加它自己的 <code>runningTotal</code> 变量，该变量和 <code>incrementBySeven</code> 中捕获的变量没有任何联系：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为40</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用。更多信息，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/23_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包引起的循环强引用</a>。</p>
</blockquote>
<h2 id="闭包是引用类型">闭包是引用类型</h2>
<p>上面的例子中，<code>incrementBySeven</code> 和 <code>incrementByTen</code> 都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是<em>引用类型</em>。</p>
<p>无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的<em>引用</em>。上面的例子中，指向闭包的引用 <code>incrementByTen</code> 是一个常量，而并非闭包内容本身。</p>
<p>这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoIncrementByTen <span class="operator">=</span> incrementByTen</span><br><span class="line">alsoIncrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为50</span></span><br></pre></td></tr></table></figure>
<h2 id="逃逸闭包">逃逸闭包</h2>
<p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中<em>逃逸</em>。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 <code>@escaping</code>，用来指明这个闭包是允许“逃逸”出这个函数的。</p>
<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>someFunctionWithEscapingClosure(_:)</code> 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你不将这个参数标记为 <code>@escaping</code>，就会得到一个编译错误。</p>
<p>将一个闭包标记为 <code>@escaping</code> 意味着你必须在闭包中显式地引用 <code>self</code>。比如说，在下面的代码中，传递到 <code>someFunctionWithEscapingClosure(_:)</code> 中的闭包是一个逃逸闭包，这意味着它需要显式地引用 <code>self</code>。相对的，传递到 <code>someFunctionWithNonescapingClosure(_:)</code> 中的闭包是一个非逃逸闭包，这意味着它可以隐式引用 <code>self</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithNonescapingClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x <span class="operator">=</span> <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x <span class="operator">=</span> <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// 打印出“200”</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first<span class="operator">?</span>()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// 打印出“100”</span></span><br></pre></td></tr></table></figure>
<h2 id="自动闭包">自动闭包</h2>
<p><em>自动闭包</em>是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。</p>
<p>我们经常会<em>调用</em>采用自动闭包的函数，但是很少去<em>实现</em>这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code> 函数接受自动闭包作为它的 <code>condition</code> 参数和 <code>message</code> 参数；它的 <code>condition</code> 参数仅会在 debug 模式下被求值，它的 <code>message</code> 参数仅当 <code>condition</code> 参数为 <code>false</code> 时被计算求值。</p>
<p>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。下面的代码展示了闭包如何延时求值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“5”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customerProvider <span class="operator">=</span> &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“5”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Now serving Chris!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“4”</span></span><br></pre></td></tr></table></figure>
<p>尽管在闭包的代码中，<code>customersInLine</code> 的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，<code>customerProvider</code> 的类型不是 <code>String</code>，而是 <code>() -&gt; String</code>，一个没有参数且返回值为 <code>String</code> 的函数。</p>
<p>将闭包作为参数传递给函数时，你能获得同样的延时求值行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )</span><br><span class="line"><span class="comment">// 打印出“Now serving Alex!”</span></span><br></pre></td></tr></table></figure>
<p>上面的 <code>serve(customer:)</code> 函数接受一个返回顾客名字的显式的闭包。下面这个版本的 <code>serve(customer:)</code> 完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 <code>@autoclosure</code> 来接收一个自动闭包。现在你可以将该函数当作接受 <code>String</code> 类型参数（而非闭包）的函数来调用。<code>customerProvider</code> 参数将自动转化为一个闭包，因为该参数被标记了 <code>@autoclosure</code> 特性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 打印“Now serving Ewa!”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>过度使用 <code>autoclosures</code> 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</p>
</blockquote>
<p>如果你想让一个自动闭包可以“逃逸”，则应该同时使用 <code>@autoclosure</code> 和 <code>@escaping</code> 属性。<code>@escaping</code> 属性的讲解见上面的 <a href="#escaping_closures">逃逸闭包</a>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine i= [&quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">collectCustomerProviders</span>(<span class="keyword">_</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Collected <span class="subst">\(customerProviders.count)</span> closures.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Collected 2 closures.”</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Now serving Barry!”</span></span><br><span class="line"><span class="comment">// 打印“Now serving Daniella!”</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>collectCustomerProviders(_:)</code> 函数并没有调用传入的 <code>customerProvider</code> 闭包，而是将闭包追加到了 <code>customerProviders</code> 数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包能够在函数返回之后被调用。因此，<code>customerProvider</code> 参数必须允许“逃逸”出函数作用域。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/06/24/Swift/swift%E9%97%AD%E5%8C%85/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/06/23/Swift/swift%E5%87%BD%E6%95%B0/"
                            aria-label=": swift函数"
                        >
                            swift函数
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-23T10:13:17+08:00">
	
		    2023 年 6 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="函数">函数</h2>
<p><em>函数</em>是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候“调用”这个函数来完成它的任务。</p>
<p>Swift 统一的函数语法非常的灵活，可以用来表示任何函数，包括从最简单的没有参数名字的 C 风格函数，到复杂的带局部和外部参数名的 Objective-C 风格函数。参数可以提供默认值，以简化函数调用。参数也可以既当做传入参数，也当做传出参数，也就是说，一旦函数执行结束，传入的参数值将被修改。</p>
<p>在 Swift 中，每个函数都有一个由函数的参数值类型和返回值类型组成的类型。你可以把函数类型当做任何其他普通变量类型一样处理，这样就可以更简单地把函数当做别的函数的参数，也可以从其他函数中返回函数。函数的定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现功能封装。</p>
<h2 id="函数的定义与调用">函数的定义与调用</h2>
<p>当你定义一个函数时，你可以定义一个或多个有名字和类型的值，作为函数的输入，称为<em>参数</em>，也可以定义某种类型的值作为函数执行结束时的输出，称为<em>返回类型</em>。</p>
<p>每个函数有个<em>函数名</em>，用来描述函数执行的任务。要使用一个函数时，用函数名来“调用”这个函数，并传给它匹配的输入值（称作<em>实参</em>）。函数的实参必须与函数参数表里参数的顺序一致。</p>
<p>下面例子中的函数的名字是 <code>greet(person:)</code>，之所以叫这个名字，是因为这个函数用一个人的名字当做输入，并返回向这个人问候的语句。为了完成这个任务，你需要定义一个输入参数——一个叫做 <code>person</code> 的 <code>String</code> 值，和一个包含给这个人问候语的 <code>String</code> 类型的返回值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的这些信息汇总起来成为函数的<em>定义</em>，并以 <code>func</code> 作为前缀。指定函数返回类型时，用返回箭头 <code>-&gt;</code>（一个连字符后跟一个右尖括号）后跟返回类型的名称的方式来表示。</p>
<p>该定义描述了函数的功能，它期望接收什么作为参数和执行结束时它返回的结果是什么类型。这样的定义使得函数可以在别的地方以一种清晰的方式被调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Anna&quot;</span>))</span><br><span class="line"><span class="comment">// 打印“Hello, Anna!”</span></span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Brian&quot;</span>))</span><br><span class="line"><span class="comment">// 打印“Hello, Brian!”</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>greet(person:)</code> 函数时，在圆括号中传给它一个 <code>String</code> 类型的实参，例如 <code>greet(person: &quot;Anna&quot;)</code>。正如上面所示，因为这个函数返回一个 <code>String</code> 类型的值，所以 <code>greet</code> 可以被包含在 <code>print(_:separator:terminator:)</code> 的调用中，用来输出这个函数的返回值。</p>
<blockquote>
<p>注意</p>
<p><code>print(_:separator:terminator:)</code> 函数的第一个参数并没有设置一个标签，而其他的参数因为已经有了默认值，因此是可选的。关于这些函数语法上的变化详见下方关于 函数参数标签和参数名以及默认参数值。</p>
</blockquote>
<p>在 <code>greet(person:)</code> 的函数体中，先定义了一个新的名为 <code>greeting</code> 的 <code>String</code> 常量，同时，把对 <code>personName</code> 的问候消息赋值给了 <code>greeting</code> 。然后用 <code>return</code> 关键字把这个问候返回出去。一旦 <code>return greeting</code> 被调用，该函数结束它的执行并返回 <code>greeting</code> 的当前值。</p>
<p>你可以用不同的输入值多次调用 <code>greet(person:)</code>。上面的例子展示的是用 <code>&quot;Anna&quot;</code> 和 <code>&quot;Brian&quot;</code> 调用的结果，该函数分别返回了不同的结果。</p>
<p>为了简化这个函数的定义，可以将问候消息的创建和返回写成一句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greetAgain</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello again, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greetAgain(person: <span class="string">&quot;Anna&quot;</span>))</span><br><span class="line"><span class="comment">// 打印“Hello again, Anna!”</span></span><br></pre></td></tr></table></figure>
<h2 id="函数参数与返回值">函数参数与返回值</h2>
<p>函数参数与返回值在 Swift 中非常的灵活。你可以定义任何类型的函数，包括从只带一个未名参数的简单函数到复杂的带有表达性参数名和不同参数选项的复杂函数。</p>
<h3 id="无参数函数">无参数函数</h3>
<p>函数可以没有参数。下面这个函数就是一个无参数函数，当被调用时，它返回固定的 <code>String</code> 消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sayHelloWorld</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHelloWorld())</span><br><span class="line"><span class="comment">// 打印“hello, world”</span></span><br></pre></td></tr></table></figure>
<p>尽管这个函数没有参数，但是定义中在函数名后还是需要一对圆括号。当被调用时，也需要在函数名后写一对圆括号。</p>
<h3 id="多参数函数">多参数函数</h3>
<p>函数可以有多种输入参数，这些参数被包含在函数的括号之中，以逗号分隔。</p>
<p>下面这个函数用一个人名和是否已经打过招呼作为输入，并返回对这个人的适当问候语:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">alreadyGreeted</span>: <span class="type">Bool</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> alreadyGreeted &#123;</span><br><span class="line">        <span class="keyword">return</span> greetAgain(person: person)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> greet(person: person)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Tim&quot;</span>, alreadyGreeted: <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// 打印“Hello again, Tim!”</span></span><br></pre></td></tr></table></figure>
<p>你可以通过在括号内使用逗号分隔来传递一个 <code>String</code> 参数值和一个标识为 <code>alreadyGreeted</code> 的 <code>Bool</code> 值，来调用 <code>greet(person:alreadyGreeted:)</code> 函数。注意这个函数和上面 <code>greet(person:)</code> 是不同的。虽然它们都有着同样的名字 <code>greet</code>，但是 <code>greet(person:alreadyGreeted:)</code> 函数需要两个参数，而 <code>greet(person:)</code> 只需要一个参数。</p>
<h3 id="无返回值函数">无返回值函数</h3>
<p>函数可以没有返回值。下面是 <code>greet(person:)</code> 函数的另一个版本，这个函数直接打印一个 <code>String</code> 值，而不是返回它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(person)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">greet(person: <span class="string">&quot;Dave&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Hello, Dave!”</span></span><br></pre></td></tr></table></figure>
<p>因为这个函数不需要返回值，所以这个函数的定义中没有返回箭头（-&gt;）和返回类型。</p>
<blockquote>
<p>注意</p>
<p>严格地说，即使没有明确定义返回值，该 <code>greet(Person：)</code> 函数仍然返回一个值。没有明确定义返回类型的函数的返回一个 <code>Void</code> 类型特殊值，该值为一个空元组，写成 ()。</p>
</blockquote>
<p>调用函数时，可以忽略该函数的返回值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printAndCount</span>(<span class="params">string</span>: <span class="type">String</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(string)</span><br><span class="line">    <span class="keyword">return</span> string.count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printWithoutCounting</span>(<span class="params">string</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">_</span> <span class="operator">=</span> printAndCount(string: string)</span><br><span class="line">&#125;</span><br><span class="line">printAndCount(string: <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“hello, world”，并且返回值 12</span></span><br><span class="line">printWithoutCounting(string: <span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“hello, world”，但是没有返回任何值</span></span><br></pre></td></tr></table></figure>
<p>第一个函数 <code>printAndCount(string:)</code>，输出一个字符串并返回 <code>Int</code> 类型的字符数。第二个函数 <code>printWithoutCounting(string:)</code> 调用了第一个函数，但是忽略了它的返回值。当第二个函数被调用时，消息依然会由第一个函数输出，但是返回值不会被用到。</p>
<blockquote>
<p>注意</p>
<p>返回值可以被忽略，但定义了有返回值的函数必须返回一个值，如果在函数定义底部没有返回任何值，将导致编译时错误。</p>
</blockquote>
<h3 id="多重返回值函数">多重返回值函数</h3>
<p>你可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。</p>
<p>下例中定义了一个名为 <code>minMax(array:)</code> 的函数，作用是在一个 <code>Int</code> 类型的数组中找出最小值与最大值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">minMax</span>(<span class="params">array</span>: [<span class="type">Int</span>]) -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentMin <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span><span class="operator">..&lt;</span>array.count] &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> currentMin &#123;</span><br><span class="line">            currentMin <span class="operator">=</span> value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&gt;</span> currentMax &#123;</span><br><span class="line">            currentMax <span class="operator">=</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>minMax(array:)</code> 函数返回一个包含两个 <code>Int</code> 值的元组，这些值被标记为 <code>min</code> 和 <code>max</code> ，以便查询函数的返回值时可以通过名字访问它们。</p>
<p>在 <code>minMax(array:)</code> 的函数体中，在开始的时候设置两个工作变量 <code>currentMin</code> 和 <code>currentMax</code> 的值为数组中的第一个数。然后函数会遍历数组中剩余的值并检查该值是否比 <code>currentMin</code> 和 <code>currentMax</code> 更小或更大。最后数组中的最小值与最大值作为一个包含两个 <code>Int</code> 值的元组返回。</p>
<p>因为元组的成员值已被命名，因此可以通过 <code>.</code> 语法来检索找到的最小值与最大值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bounds <span class="operator">=</span> minMax(array: [<span class="number">8</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds.min)</span> and max is <span class="subst">\(bounds.max)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“min is -6 and max is 109”</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，元组的成员不需要在元组从函数中返回时命名，因为它们的名字已经在函数返回类型中指定了。</p>
<h3 id="可选元组返回类型">可选元组返回类型</h3>
<p>如果函数返回的元组类型有可能整个元组都“没有值”，你可以使用<em>可选的</em> 元组返回类型反映整个元组可以是 <code>nil</code> 的事实。你可以通过在元组类型的右括号后放置一个问号来定义一个可选元组，例如 <code>(Int, Int)?</code> 或 <code>(String, Int, Bool)?</code></p>
<blockquote>
<p>注意</p>
<p>可选元组类型如 <code>(Int, Int)?</code> 与元组包含可选类型如 <code>(Int?, Int?)</code> 是不同的。可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p>
</blockquote>
<p>前面的 <code>minMax(array:)</code> 函数返回了一个包含两个 <code>Int</code> 值的元组。但是函数不会对传入的数组执行任何安全检查，如果 <code>array</code> 参数是一个空数组，如上定义的 <code>minMax(array:)</code> 在试图访问 <code>array[0]</code> 时会触发一个运行时错误。</p>
<p>为了安全地处理这个“空数组”问题，将 <code>minMax(array:)</code> 函数改写为使用可选元组返回类型，并且当数组为空时返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">minMax</span>(<span class="params">array</span>: [<span class="type">Int</span>]) -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>)<span class="operator">?</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> currentMin <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span><span class="operator">..&lt;</span>array.count] &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> currentMin &#123;</span><br><span class="line">            currentMin <span class="operator">=</span> value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&gt;</span> currentMax &#123;</span><br><span class="line">            currentMax <span class="operator">=</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用可选绑定来检查 <code>minMax(array:)</code> 函数返回的是一个存在的元组值还是 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bounds <span class="operator">=</span> minMax(array: [<span class="number">8</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>]) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds.min)</span> and max is <span class="subst">\(bounds.max)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“min is -6 and max is 109”</span></span><br></pre></td></tr></table></figure>
<h3 id="隐式返回的函数">隐式返回的函数</h3>
<p>如果一个函数的整个函数体是一个单行表达式，这个函数可以隐式地返回这个表达式。举个例子，以下的函数有着同样的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func greeting(for person: String) -&gt; String &#123;</span><br><span class="line">    &quot;Hello, &quot; + person + &quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(greeting(for: &quot;Dave&quot;))</span><br><span class="line">// 打印 &quot;Hello, Dave!&quot;</span><br><span class="line"></span><br><span class="line">func anotherGreeting(for person: String) -&gt; String &#123;</span><br><span class="line">    return &quot;Hello, &quot; + person + &quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(anotherGreeting(for: &quot;Dave&quot;))</span><br><span class="line">// 打印 &quot;Hello, Dave!&quot;</span><br></pre></td></tr></table></figure>
<p><code>greeting(for:)</code> 函数的完整定义是打招呼内容的返回，这就意味着它能使用隐式返回这样更简短的形式。<code>anothergreeting(for:)</code> 函数返回同样的内容，却因为 <code>return</code> 关键字显得函数更长。任何一个可以被写成一行 <code>return</code> 语句的函数都可以忽略 <code>return</code>。</p>
<p>正如你将会在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/10_Properties.html">简略的 Getter 声明</a> 里看到的， 一个属性的 getter 也可以使用隐式返回的形式。</p>
<h2 id="函数参数标签和参数名称">函数参数标签和参数名称</h2>
<p>每个函数参数都有一个<em>参数标签（argument label）<em>以及一个</em>参数名称（parameter name）</em>。参数标签在调用函数的时候使用；调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用。默认情况下，函数参数使用参数名称来作为它们的参数标签。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">firstParameterName</span>: <span class="type">Int</span>, <span class="params">secondParameterName</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(firstParameterName: <span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>所有的参数都必须有一个独一无二的名字。虽然多个参数拥有同样的参数标签是可能的，但是一个唯一的函数标签能够使你的代码更具可读性。</p>
<h3 id="指定参数标签">指定参数标签</h3>
<p>你可以在参数名称前指定它的参数标签，中间以空格分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">argumentLabel</span> <span class="params">parameterName</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// 在函数体内，parameterName 代表参数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个版本的 <code>greet(person:)</code> 函数，接收一个人的名字和他的家乡，并且返回一句问候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">from</span> <span class="params">hometown</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>!  Glad you could visit from <span class="subst">\(hometown)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Bill&quot;</span>, from: <span class="string">&quot;Cupertino&quot;</span>))</span><br><span class="line"><span class="comment">// 打印“Hello Bill!  Glad you could visit from Cupertino.”</span></span><br></pre></td></tr></table></figure>
<p>参数标签的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。</p>
<h3 id="忽略参数标签">忽略参数标签</h3>
<p>如果你不希望为某个参数添加一个标签，可以使用一个下划线（<code>_</code>）来代替一个明确的参数标签。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="keyword">_</span> <span class="params">firstParameterName</span>: <span class="type">Int</span>, <span class="params">secondParameterName</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="comment">// 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>如果一个参数有一个标签，那么在调用的时候必须使用标签来标记这个参数。</p>
<h3 id="默认参数值">默认参数值</h3>
<p>你可以在函数体中通过给参数赋值来为任意一个参数定义<em>默认值（Deafult Value）</em>。当默认值被定义后，调用这个函数时可以忽略这个参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">parameterWithoutDefault</span>: <span class="type">Int</span>, <span class="params">parameterWithDefault</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">3</span>, parameterWithDefault: <span class="number">6</span>) <span class="comment">// parameterWithDefault = 6</span></span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">4</span>) <span class="comment">// parameterWithDefault = 12</span></span><br></pre></td></tr></table></figure>
<p>将不带有默认值的参数放在函数参数列表的最前。一般来说，没有默认值的参数更加的重要，将不带默认值的参数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更为清晰。</p>
<h3 id="可变参数">可变参数</h3>
<p>一个*可变参数（variadic parameter）*可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入（<code>...</code>）的方式来定义可变参数。</p>
<p>可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 <code>numbers</code> 的 <code>Double...</code> 型可变参数，在函数体内可以当做一个叫 <code>numbers</code> 的 <code>[Double]</code> 型的数组常量。</p>
<p>下面的这个函数用来计算一组任意长度数字的 <em>算术平均数（arithmetic mean)</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">arithmeticMean</span>(<span class="keyword">_</span> <span class="params">numbers</span>: <span class="type">Double</span>...) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">/</span> <span class="type">Double</span>(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 返回 3.0, 是这 5 个数的平均数。</span></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)</span><br><span class="line"><span class="comment">// 返回 10.0, 是这 3 个数的平均数。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>一个函数最多只能拥有一个可变参数。</p>
</blockquote>
<h3 id="输入输出参数">输入输出参数</h3>
<p>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。这意味着你不能错误地更改参数值。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为<em>输入输出参数（In-Out Parameters）</em>。</p>
<p>定义一个输入输出参数时，在参数定义前加 <code>inout</code> 关键字。一个 <code>输入输出参数</code>有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。想获取更多的关于输入输出参数的细节和相关的编译器优化，请查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID545">输入输出参数</a> 一节。</p>
<p>你只能传递变量给输入输出参数。你不能传入常量或者字面量，因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加 <code>&amp;</code> 符，表示这个值可以被函数修改。</p>
<blockquote>
<p>注意</p>
<p>输入输出参数不能有默认值，而且可变参数不能用 <code>inout</code> 标记。</p>
</blockquote>
<p>下例中，<code>swapTwoInts(_:_:)</code> 函数有两个分别叫做 <code>a</code> 和 <code>b</code> 的输入输出参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapTwoInts(_:_:)</code> 函数简单地交换 <code>a</code> 与 <code>b</code> 的值。该函数先将 <code>a</code> 的值存到一个临时常量 <code>temporaryA</code> 中，然后将 <code>b</code> 的值赋给 <code>a</code>，最后将 <code>temporaryA</code> 赋值给 <code>b</code>。</p>
<p>你可以用两个 <code>Int</code> 型的变量来调用 <code>swapTwoInts(_:_:)</code>。需要注意的是，<code>someInt</code> 和 <code>anotherInt</code> 在传入 <code>swapTwoInts(_:_:)</code> 函数前，都加了 <code>&amp;</code> 的前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“someInt is now 107, and anotherInt is now 3”</span></span><br></pre></td></tr></table></figure>
<p>从上面这个例子中，我们可以看到 <code>someInt</code> 和 <code>anotherInt</code> 的原始值在 <code>swapTwoInts(_:_:)</code> 函数中被修改，尽管它们的定义在函数体外。</p>
<blockquote>
<p>注意</p>
<p>输入输出参数和返回值是不一样的。上面的 <code>swapTwoInts</code> 函数并没有定义任何返回值，但仍然修改了 <code>someInt</code> 和 <code>anotherInt</code> 的值。输入输出参数是函数对函数体外产生影响的另一种方式。</p>
</blockquote>
<h2 id="函数类型">函数类型</h2>
<p>每个函数都有种特定的<em>函数类型</em>，函数的类型由函数的参数类型和返回类型组成。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">multiplyTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中定义了两个简单的数学函数：<code>addTwoInts</code> 和 <code>multiplyTwoInts</code>。这两个函数都接受两个 <code>Int</code> 值， 返回一个 <code>Int</code> 值。</p>
<p>这两个函数的类型是 <code>(Int, Int) -&gt; Int</code>，可以解读为:</p>
<p>“这个函数类型有两个 <code>Int</code> 型的参数并返回一个 <code>Int</code> 型的值”。</p>
<p>下面是另一个例子，一个没有参数，也没有返回值的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printHelloWorld</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的类型是：<code>() -&gt; Void</code>，或者叫“没有参数，并返回 <code>Void</code> 类型的函数”。</p>
<h3 id="使用函数类型">使用函数类型</h3>
<p>在 Swift 中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> addTwoInts</span><br></pre></td></tr></table></figure>
<p>这段代码可以被解读为：</p>
<p>”定义一个叫做 <code>mathFunction</code> 的变量，类型是‘一个有两个 <code>Int</code> 型的参数并返回一个 <code>Int</code> 型的值的函数’，并让这个新变量指向 <code>addTwoInts</code> 函数”。</p>
<p><code>addTwoInts</code> 和 <code>mathFunction</code> 有同样的类型，所以这个赋值过程在 Swift 类型检查（type-check）中是允许的。</p>
<p>现在，你可以用 <code>mathFunction</code> 来调用被赋值的函数了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>))</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 5&quot;</span></span><br></pre></td></tr></table></figure>
<p>有相同匹配类型的不同函数可以被赋值给同一个变量，就像非函数类型的变量一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mathFunction <span class="operator">=</span> multiplyTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>))</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 6&quot;</span></span><br></pre></td></tr></table></figure>
<p>就像其他类型一样，当赋值一个函数给常量或变量时，你可以让 Swift 来推断其函数类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherMathFunction <span class="operator">=</span> addTwoInts</span><br><span class="line"><span class="comment">// anotherMathFunction 被推断为 (Int, Int) -&gt; Int 类型</span></span><br></pre></td></tr></table></figure>
<h3 id="函数类型作为参数类型">函数类型作为参数类型</h3>
<p>你可以用 <code>(Int, Int) -&gt; Int</code> 这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给函数的调用者来提供。</p>
<p>下面是另一个例子，正如上面的函数一样，同样是输出某种数学运算结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printMathResult</span>(<span class="keyword">_</span> <span class="params">mathFunction</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(a, b))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 打印“Result: 8”</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了 <code>printMathResult(_:_:_:)</code> 函数，它有三个参数：第一个参数叫 <code>mathFunction</code>，类型是 <code>(Int, Int) -&gt; Int</code>，你可以传入任何这种类型的函数；第二个和第三个参数叫 <code>a</code> 和 <code>b</code>，它们的类型都是 <code>Int</code>，这两个值作为已给出的函数的输入值。</p>
<p>当 <code>printMathResult(_:_:_:)</code> 被调用时，它被传入 <code>addTwoInts</code> 函数和整数 <code>3</code> 和 <code>5</code>。它用传入 <code>3</code> 和 <code>5</code> 调用 <code>addTwoInts</code>，并输出结果：<code>8</code>。</p>
<p><code>printMathResult(_:_:_:)</code> 函数的作用就是输出另一个适当类型的数学函数的调用结果。它不关心传入函数是如何实现的，只关心传入的函数是不是一个正确的类型。这使得 <code>printMathResult(_:_:_:)</code> 能以一种类型安全（type-safe）的方式将一部分功能转给调用者实现。</p>
<h3 id="函数类型作为返回类型">函数类型作为返回类型</h3>
<p>你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（-&gt;）后写一个完整的函数类型。</p>
<p>下面的这个例子中定义了两个简单函数，分别是 <code>stepForward(_:)</code> 和 <code>stepBackward(_:)</code>。<code>stepForward(_:)</code> 函数返回一个比输入值大 <code>1</code> 的值。<code>stepBackward(_:)</code> 函数返回一个比输入值小 <code>1</code> 的值。这两个函数的类型都是 <code>(Int) -&gt; Int</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">stepForward</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">stepBackward</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下名为 <code>chooseStepFunction(backward:)</code> 的函数，它的返回类型是 <code>(Int) -&gt; Int</code> 类型的函数。<code>chooseStepFunction(backward:)</code> 根据布尔值 <code>backwards</code> 来返回 <code>stepForward(_:)</code> 函数或 <code>stepBackward(_:)</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">chooseStepFunction</span>(<span class="params">backward</span>: <span class="type">Bool</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> backward <span class="operator">?</span> stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你现在可以用 <code>chooseStepFunction(backward:)</code> 来获得两个函数其中的一个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentValue <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZero <span class="operator">=</span> chooseStepFunction(backward: currentValue <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line"><span class="comment">// moveNearerToZero 现在指向 stepBackward() 函数。</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子中计算出从 <code>currentValue</code> 逐渐接近到0是需要向正数走还是向负数走。<code>currentValue</code> 的初始值是 <code>3</code>，这意味着 <code>currentValue &gt; 0</code> 为真（true），这将使得 <code>chooseStepFunction(_:)</code> 返回 <code>stepBackward(_:)</code> 函数。一个指向返回的函数的引用保存在了 <code>moveNearerToZero</code> 常量中。</p>
<p>现在，<code>moveNearerToZero</code> 指向了正确的函数，它可以被用来数到零：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Counting to zero:&quot;</span>)</span><br><span class="line"><span class="comment">// Counting to zero:</span></span><br><span class="line"><span class="keyword">while</span> currentValue <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(currentValue)</span>... &quot;</span>)</span><br><span class="line">    currentValue <span class="operator">=</span> moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zero!&quot;</span>)</span><br><span class="line"><span class="comment">// 3...</span></span><br><span class="line"><span class="comment">// 2...</span></span><br><span class="line"><span class="comment">// 1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套函数">嵌套函数</h2>
<p>到目前为止本章中你所见到的所有函数都叫<em>全局函数（global functions）</em>，它们定义在全局域中。你也可以把函数定义在别的函数体中，称作 <em>嵌套函数（nested functions）</em>。</p>
<p>默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>
<p>你可以用返回嵌套函数的方式重写 <code>chooseStepFunction(backward:)</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">chooseStepFunction</span>(<span class="params">backward</span>: <span class="type">Bool</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stepForward</span>(<span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">+</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stepBackward</span>(<span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">-</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> backward <span class="operator">?</span> stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentValue <span class="operator">=</span> <span class="operator">-</span><span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZero <span class="operator">=</span> chooseStepFunction(backward: currentValue <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line"><span class="comment">// moveNearerToZero now refers to the nested stepForward() function</span></span><br><span class="line"><span class="keyword">while</span> currentValue <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(currentValue)</span>... &quot;</span>)</span><br><span class="line">    currentValue <span class="operator">=</span> moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zero!&quot;</span>)</span><br><span class="line"><span class="comment">// -4...</span></span><br><span class="line"><span class="comment">// -3...</span></span><br><span class="line"><span class="comment">// -2...</span></span><br><span class="line"><span class="comment">// -1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/06/23/Swift/swift%E5%87%BD%E6%95%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/06/22/Swift/swift%E6%8E%A7%E5%88%B6%E6%B5%81/"
                            aria-label=": swift控制流"
                        >
                            swift控制流
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-22T10:13:17+08:00">
	
		    2023 年 6 月 22 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="控制流">控制流</h2>
<p>Swift 提供了多种流程控制结构，包括可以多次执行任务的 <code>while</code> 循环，基于特定条件选择执行不同代码分支的 <code>if</code>、<code>guard</code> 和 <code>switch</code> 语句，还有控制流程跳转到其他代码位置的 <code>break</code> 和 <code>continue</code> 语句。</p>
<p>Swift 还提供了 <code>for-in</code> 循环，用来更简单地遍历数组（Array），字典（Dictionary），区间（Range），字符串（String）和其他序列类型。</p>
<p>Swift 的 <code>switch</code> 语句比许多类 C 语言要更加强大。case 还可以匹配很多不同的模式，包括范围匹配，元组（tuple）和特定类型匹配。<code>switch</code> 语句的 case 中匹配的值可以声明为临时常量或变量，在 case 作用域内使用，也可以配合 <code>where</code> 来描述更复杂的匹配条件。</p>
<h2 id="For-In-循环">For-In 循环</h2>
<p>你可以使用 <code>for-in</code> 循环来遍历一个集合中的所有元素，例如数组中的元素、范围内的数字或者字符串中的字符。</p>
<p>以下例子使用 <code>for-in</code> 遍历一个数组所有元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello, Anna!</span></span><br><span class="line"><span class="comment">// Hello, Alex!</span></span><br><span class="line"><span class="comment">// Hello, Brian!</span></span><br><span class="line"><span class="comment">// Hello, Jack!</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过遍历一个字典来访问它的键值对。遍历字典时，字典的每项元素会以 <code>(key, value)</code> 元组的形式返回，你可以在 <code>for-in</code> 循环中使用显式的常量名称来解读 <code>(key, value)</code> 元组。下面的例子中，字典的键声明会为 <code>animalName</code> 常量，字典的值会声明为 <code>legCount</code> 常量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberOfLegs <span class="operator">=</span> [<span class="string">&quot;spider&quot;</span>: <span class="number">8</span>, <span class="string">&quot;ant&quot;</span>: <span class="number">6</span>, <span class="string">&quot;cat&quot;</span>: <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (animalName, legCount) <span class="keyword">in</span> numberOfLegs &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(animalName)</span>s have <span class="subst">\(legCount)</span> legs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cats have 4 legs</span></span><br><span class="line"><span class="comment">// ants have 6 legs</span></span><br><span class="line"><span class="comment">// spiders have 8 legs</span></span><br></pre></td></tr></table></figure>
<p>字典的内容理论上是无序的，遍历元素时的顺序是无法确定的。将元素插入字典的顺序并不会决定它们被遍历的顺序。关于数组和字典的细节，参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/04_Collection_Types.html">集合类型</a>。</p>
<p><code>for-in</code> 循环还可以使用数字范围。下面的例子用来输出乘法表的一部分内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span> times 5 is <span class="subst">\(index <span class="operator">*</span> <span class="number">5</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 times 5 is 5</span></span><br><span class="line"><span class="comment">// 2 times 5 is 10</span></span><br><span class="line"><span class="comment">// 3 times 5 is 15</span></span><br><span class="line"><span class="comment">// 4 times 5 is 20</span></span><br><span class="line"><span class="comment">// 5 times 5 is 25</span></span><br></pre></td></tr></table></figure>
<p>例子中用来进行遍历的元素是使用闭区间操作符（<code>...</code>）表示的从 <code>1</code> 到 <code>5</code> 的数字区间。<code>index</code> 被赋值为闭区间中的第一个数字（<code>1</code>），然后循环中的语句被执行一次。在本例中，这个循环只包含一个语句，用来输出当前 <code>index</code> 值所对应的乘 5 乘法表的结果。该语句执行后，<code>index</code> 的值被更新为闭区间中的第二个数字（<code>2</code>），之后 <code>print(_:separator:terminator:)</code> 函数会再执行一次。整个过程会进行到闭区间结尾为止。</p>
<p>上面的例子中，<code>index</code> 是一个每次循环遍历开始时被自动赋值的常量。这种情况下，<code>index</code> 在使用前不需要声明，只需要将它包含在循环的声明中，就可以对其进行隐式声明，而无需使用 <code>let</code> 关键字声明。</p>
<p>如果你不需要区间序列内每一项的值，你可以使用下划线（<code>_</code>）替代变量名来忽略这个值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> base <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> power <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> answer <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>power &#123;</span><br><span class="line">    answer <span class="operator">*=</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(base)</span> to the power of <span class="subst">\(power)</span> is <span class="subst">\(answer)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“3 to the power of 10 is 59049”</span></span><br></pre></td></tr></table></figure>
<p>这个例子计算 base 这个数的 power 次幂（本例中，是 <code>3</code> 的 <code>10</code> 次幂），从 <code>1</code>（<code>3</code> 的 <code>0</code> 次幂）开始做 <code>3</code> 的乘法， 进行 <code>10</code> 次，使用 <code>1</code> 到 <code>10</code> 的闭区间循环。这个计算并不需要知道每一次循环中计数器具体的值，只需要执行了正确的循环次数即可。下划线符号 <code>_</code> （替代循环中的变量）能够忽略当前值，并且不提供循环遍历时对值的访问。</p>
<p>在某些情况下，你可能不想使用包括两个端点的闭区间。想象一下，你在一个手表上绘制分钟的刻度线。总共 <code>60</code> 个刻度，从 <code>0</code> 分开始。使用半开区间运算符（<code>..&lt;</code>）来表示一个左闭右开的区间。有关区间的更多信息，请参阅 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/02_Basic_Operators.html#range_operators">区间运算符</a>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minutes <span class="operator">=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>minutes &#123;</span><br><span class="line">    <span class="comment">// 每一分钟都渲染一个刻度线（60次）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些用户可能在其 UI 中可能需要较少的刻度。他们可以每 5 分钟作为一个刻度。使用 <code>stride(from:to:by:)</code> 函数跳过不需要的标记。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minuteInterval <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: minutes, by: minuteInterval) &#123;</span><br><span class="line">    <span class="comment">// 每5分钟渲染一个刻度线（0, 5, 10, 15 ... 45, 50, 55）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在闭区间使用 <code>stride(from:through:by:)</code> 起到同样作用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hours <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> hourInterval <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">3</span>, through: hours, by: hourInterval) &#123;</span><br><span class="line">    <span class="comment">// 每3小时渲染一个刻度线（3, 6, 9, 12）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="While-循环">While 循环</h2>
<p><code>while</code> 循环会一直运行一段语句直到条件变成 <code>false</code>。这类循环适合使用在第一次迭代前，迭代次数未知的情况下。Swift 提供两种 <code>while</code> 循环形式：</p>
<ul>
<li><code>while</code> 循环，每次在循环开始时计算条件是否符合；</li>
<li><code>repeat-while</code> 循环，每次在循环结束时计算条件是否符合。</li>
</ul>
<h3 id="While">While</h3>
<p><code>while</code> 循环从计算一个条件开始。如果条件为 <code>true</code>，会重复运行一段语句，直到条件变为 <code>false</code>。</p>
<p>下面是 <code>while</code> 循环的一般格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子来玩一个叫做<em>蛇和梯子</em>（也叫做<em>滑道和梯子</em>）的小游戏：</p>
<p><img src="https://docs.swift.org/swift-book/_images/snakesAndLadders_2x.png" alt="image"></p>
<p>游戏的规则如下：</p>
<ul>
<li>游戏盘面包括 25 个方格，游戏目标是达到或者超过第 25 个方格；</li>
<li>每一轮，你通过掷一个六面体骰子来确定你移动方块的步数，移动的路线由上图中横向的虚线所示；</li>
<li>如果在某轮结束，你移动到了梯子的底部，可以顺着梯子爬上去；</li>
<li>如果在某轮结束，你移动到了蛇的头部，你会顺着蛇的身体滑下去。</li>
</ul>
<p>游戏盘面可以使用一个 <code>Int</code> 数组来表达。数组的长度由一个 <code>finalSquare</code> 常量储存，用来初始化数组和检测最终胜利条件。游戏盘面由 26 个 <code>Int</code> 0 值初始化，而不是 25 个（由 <code>0</code> 到 <code>25</code>，一共 26 个）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare <span class="operator">=</span> <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board <span class="operator">=</span> [<span class="type">Int</span>](repeating: <span class="number">0</span>, count: finalSquare <span class="operator">+</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>一些方格被设置成特定的值来表示有蛇或者梯子。梯子底部的方格是一个正值，使你可以向上移动，蛇头处的方格是一个负值，会让你向下移动：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">board[<span class="number">03</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">08</span>; board[<span class="number">06</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">11</span>; board[<span class="number">09</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">09</span>; board[<span class="number">10</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">10</span>; board[<span class="number">19</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">11</span>; board[<span class="number">22</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">02</span>; board[<span class="number">24</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">08</span></span><br></pre></td></tr></table></figure>
<p>3 号方格是梯子的底部，会让你向上移动到 11 号方格，我们使用 <code>board[03]</code> 等于 <code>+08</code>（来表示 <code>11</code> 和 <code>3</code> 之间的差值）。为了对齐语句，这里使用了一元正运算符（<code>+i</code>）和一元负运算符（<code>-i</code>），并且小于 10 的数字都使用 0 补齐（这些语法的技巧不是必要的，只是为了让代码看起来更加整洁）。</p>
<p>玩家由左下角空白处编号为 0 的方格开始游戏。玩家第一次掷骰子后才会进入游戏盘面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> square <span class="operator">&lt;</span> finalSquare &#123;</span><br><span class="line">    <span class="comment">// 掷骰子</span></span><br><span class="line">    diceRoll <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> diceRoll <span class="operator">==</span> <span class="number">7</span> &#123; diceRoll <span class="operator">=</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="comment">// 根据点数移动</span></span><br><span class="line">    square <span class="operator">+=</span> diceRoll</span><br><span class="line">    <span class="keyword">if</span> square <span class="operator">&lt;</span> board.count &#123;</span><br><span class="line">        <span class="comment">// 如果玩家还在棋盘上，顺着梯子爬上去或者顺着蛇滑下去</span></span><br><span class="line">        square <span class="operator">+=</span> board[square]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Game over!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>本例中使用了最简单的方法来模拟掷骰子。<code>diceRoll</code> 的值并不是一个随机数，而是以 <code>0</code> 为初始值，之后每一次 <code>while</code> 循环，<code>diceRoll</code> 的值增加 1 ，然后检测是否超出了最大值。当 <code>diceRoll</code> 的值等于 7 时，就超过了骰子的最大值，会被重置为 <code>1</code>。所以 <code>diceRoll</code> 的取值顺序会一直是 <code>1</code>，<code>2</code>，<code>3</code>，<code>4</code>，<code>5</code>，<code>6</code>，<code>1</code>，<code>2</code> 等。</p>
<p>掷完骰子后，玩家向前移动 <code>diceRoll</code> 个方格，如果玩家移动超过了第 25 个方格，这个时候游戏将会结束，为了应对这种情况，代码会首先判断 <code>square</code> 的值是否小于 <code>board</code> 的 <code>count</code> 属性，只有小于才会在 <code>board[square]</code> 上增加 <code>square</code>，来向前或向后移动（遇到了梯子或者蛇）。</p>
<blockquote>
<p>注意</p>
<p>如果没有这个检测（<code>square &lt; board.count</code>），<code>board[square]</code> 可能会越界访问 <code>board</code> 数组，导致运行时错误。</p>
</blockquote>
<p>当本轮 <code>while</code> 循环运行完毕，会再检测循环条件是否需要再运行一次循环。如果玩家移动到或者超过第 25 个方格，循环条件结果为 <code>false</code>，此时游戏结束。</p>
<p><code>while</code> 循环比较适合本例中的这种情况，因为在 <code>while</code> 循环开始时，我们并不知道游戏要跑多久，只有在达成指定条件时循环才会结束。</p>
<h3 id="Repeat-While">Repeat-While</h3>
<p><code>while</code> 循环的另外一种形式是 <code>repeat-while</code>，它和 <code>while</code> 的区别是在判断循环条件之前，先执行一次循环的代码块。然后重复循环直到条件为 <code>false</code>。</p>
<blockquote>
<p>注意</p>
<p>Swift 语言的 <code>repeat-while</code> 循环和其他语言中的 <code>do-while</code> 循环是类似的。</p>
</blockquote>
<p>下面是 <code>repeat-while</code> 循环的一般格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">while</span> condition</span><br></pre></td></tr></table></figure>
<p>还是<em>蛇和梯子</em>的游戏，使用 <code>repeat-while</code> 循环来替代 <code>while</code> 循环。<code>finalSquare</code>、<code>board</code>、<code>square</code> 和 <code>diceRoll</code> 的值初始化同 <code>while</code> 循环时一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare <span class="operator">=</span> <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board <span class="operator">=</span> [<span class="type">Int</span>](repeating: <span class="number">0</span>, count: finalSquare <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">board[<span class="number">03</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">08</span>; board[<span class="number">06</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">11</span>; board[<span class="number">09</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">09</span>; board[<span class="number">10</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">10</span>; board[<span class="number">19</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">11</span>; board[<span class="number">22</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">02</span>; board[<span class="number">24</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">08</span></span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>repeat-while</code> 的循环版本，循环中<em>第一步</em>就需要去检测是否在梯子或者蛇的方块上。没有梯子会让玩家直接上到第 25 个方格，所以玩家不会通过梯子直接赢得游戏。这样在循环开始时先检测是否踩在梯子或者蛇上是安全的。</p>
<p>游戏开始时，玩家在第 0 个方格上，<code>board[0]</code> 一直等于 0， 不会有什么影响：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    <span class="comment">// 顺着梯子爬上去或者顺着蛇滑下去</span></span><br><span class="line">    square <span class="operator">+=</span> board[square]</span><br><span class="line">    <span class="comment">// 掷骰子</span></span><br><span class="line">    diceRoll <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> diceRoll <span class="operator">==</span> <span class="number">7</span> &#123; diceRoll <span class="operator">=</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="comment">// 根据点数移动</span></span><br><span class="line">    square <span class="operator">+=</span> diceRoll</span><br><span class="line">&#125; <span class="keyword">while</span> square <span class="operator">&lt;</span> finalSquare</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Game over!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>检测完玩家是否踩在梯子或者蛇上之后，开始掷骰子，然后玩家向前移动 <code>diceRoll</code> 个方格，本轮循环结束。</p>
<p>循环条件（<code>while square &lt; finalSquare</code>）和 <code>while</code> 方式相同，但是只会在循环结束后进行计算。在这个游戏中，<code>repeat-while</code> 表现得比 <code>while</code> 循环更好。<code>repeat-while</code> 方式会在条件判断 <code>square</code> 没有超出后直接运行 <code>square += board[square]</code>，这种方式可以比起前面 <code>while</code> 循环的版本，可以省去数组越界的检查。</p>
<h2 id="条件语句">条件语句</h2>
<p>根据特定的条件执行特定的代码通常是十分有用的。当错误发生时，你可能想运行额外的代码；或者，当值太大或太小时，向用户显示一条消息。要实现这些功能，你就需要使用<em>条件语句</em>。</p>
<p>Swift 提供两种类型的条件语句：<code>if</code> 语句和 <code>switch</code> 语句。通常，当条件较为简单且可能的情况很少时，使用 <code>if</code> 语句。而 <code>switch</code> 语句更适用于条件较复杂、有更多排列组合的时候。并且 <code>switch</code> 在需要用到模式匹配（pattern-matching）的情况下会更有用。</p>
<h3 id="If">If</h3>
<p><code>if</code> 语句最简单的形式就是只包含一个条件，只有该条件为 <code>true</code> 时，才执行相关代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temperatureInFahrenheit <span class="operator">=</span> <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit <span class="operator">&lt;=</span> <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s very cold. Consider wearing a scarf.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“It&#x27;s very cold. Consider wearing a scarf.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子会判断温度是否小于等于 32 华氏度（水的冰点）。如果是，则打印一条消息；否则，不打印任何消息，继续执行 <code>if</code> 块后面的代码。</p>
<p>当然，<code>if</code> 语句允许二选一执行，叫做 <code>else</code> 从句。也就是当条件为 <code>false</code> 时，执行 <em>else 语句</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temperatureInFahrenheit <span class="operator">=</span> <span class="number">40</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit <span class="operator">&lt;=</span> <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s very cold. Consider wearing a scarf.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s not that cold. Wear a t-shirt.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“It&#x27;s not that cold. Wear a t-shirt.”</span></span><br></pre></td></tr></table></figure>
<p>显然，这两条分支中总有一条会被执行。由于温度已升至 40 华氏度，不算太冷，没必要再围围巾。因此，<code>else</code> 分支就被触发了。</p>
<p>你可以把多个 <code>if</code> 语句链接在一起，来实现更多分支：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temperatureInFahrenheit <span class="operator">=</span> <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit <span class="operator">&lt;=</span> <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s very cold. Consider wearing a scarf.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> temperatureInFahrenheit <span class="operator">&gt;=</span> <span class="number">86</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s really warm. Don&#x27;t forget to wear sunscreen.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s not that cold. Wear a t-shirt.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“It&#x27;s really warm. Don&#x27;t forget to wear sunscreen.”</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，额外的 <code>if</code> 语句用于判断是不是特别热。而最后的 <code>else</code> 语句被保留了下来，用于打印既不冷也不热时的消息。</p>
<p>实际上，当不需要完整判断情况的时候，最后的 <code>else</code> 语句是可选的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temperatureInFahrenheit <span class="operator">=</span> <span class="number">72</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit <span class="operator">&lt;=</span> <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s very cold. Consider wearing a scarf.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> temperatureInFahrenheit <span class="operator">&gt;=</span> <span class="number">86</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s really warm. Don&#x27;t forget to wear sunscreen.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，由于既不冷也不热，所以不会触发 <code>if</code> 或 <code>else if</code> 分支，也就不会打印任何消息。</p>
<h3 id="Switch">Switch</h3>
<p><code>switch</code> 语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，<code>switch</code> 语句会执行对应的代码。当有可能的情况较多时，通常用 <code>switch</code> 语句替换 <code>if</code> 语句。</p>
<p><code>switch</code> 语句最简单的形式就是把某个值与一个或若干个相同类型的值作比较：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="keyword">some</span> value to consider &#123;</span><br><span class="line"><span class="keyword">case</span> value <span class="number">1</span>:</span><br><span class="line">    respond to value <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> value <span class="number">2</span>,</span><br><span class="line">    value <span class="number">3</span>:</span><br><span class="line">    respond to value <span class="number">2</span> or <span class="number">3</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    otherwise, <span class="keyword">do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code> 语句由<em>多个 case</em> 构成，每个由 <code>case</code> 关键字开始。为了匹配某些更特定的值，Swift 提供了几种方法来进行更复杂的模式匹配，这些模式将在本节的稍后部分提到。</p>
<p>与 <code>if</code> 语句类似，每一个 case 都是代码执行的一条分支。<code>switch</code> 语句会决定哪一条分支应该被执行，这个流程被称作根据给定的值<em>切换（switching）</em>。</p>
<p><code>switch</code> 语句必须是完备的。这就是说，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值的情况下，你可以使用默认（<code>default</code>）分支来涵盖其它所有没有对应的值，这个默认分支必须在 <code>switch</code> 语句的最后面。</p>
<p>下面的例子使用 <code>switch</code> 语句来匹配一个名为 <code>someCharacter</code> 的小写字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;z&quot;</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first letter of the alphabet&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;z&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The last letter of the alphabet&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Some other character&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“The last letter of the alphabet”</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一个 case 分支用于匹配第一个英文字母 <code>a</code>，第二个 case 分支用于匹配最后一个字母 <code>z</code>。因为 <code>switch</code> 语句必须有一个 case 分支用于覆盖所有可能的字符，而不仅仅是所有的英文字母，所以 switch 语句使用 <code>default</code> 分支来匹配除了 <code>a</code> 和 <code>z</code> 外的所有值，这个分支保证了 swith 语句的完备性。</p>
<h4 id="不存在隐式的贯穿">不存在隐式的贯穿</h4>
<p>与 C 和 Objective-C 中的 <code>switch</code> 语句不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止 <code>switch</code> 语句，而不会继续执行下一个 case 分支。这也就是说，不需要在 case 分支中显式地使用 <code>break</code> 语句。这使得 <code>switch</code> 语句更安全、更易用，也避免了漏写 <code>break</code> 语句导致多个语言被执行的错误。</p>
<blockquote>
<p>注意</p>
<p>虽然在 Swift 中 <code>break</code> 不是必须的，但你依然可以在 case 分支中的代码执行完毕前使用 <code>break</code> 跳出，详情请参见 <a href="#break_in_a_switch_statement">Switch 语句中的 break</a>。</p>
</blockquote>
<p>每一个 case 分支都<em>必须</em>包含至少一条语句。像下面这样书写代码是无效的，因为第一个 case 分支是空的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>: <span class="comment">// 无效，这个分支下面没有语句</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letter A&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not the letter A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码会报编译错误</span></span><br></pre></td></tr></table></figure>
<p>不像 C 语言里的 <code>switch</code> 语句，在 Swift 中，<code>switch</code> 语句不会一起匹配 <code>&quot;a&quot;</code> 和 <code>&quot;A&quot;</code>。相反的，上面的代码会引起编译期错误：<code>case &quot;a&quot;: 不包含任何可执行语句</code>——这就避免了意外地从一个 case 分支贯穿到另外一个，使得代码更安全、也更直观。</p>
<p>为了让单个 case 同时匹配 <code>a</code> 和 <code>A</code>，可以将这个两个值组合成一个复合匹配，并且用逗号分开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letter A&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not the letter A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“The letter A”</span></span><br></pre></td></tr></table></figure>
<p>为了可读性，符合匹配可以写成多行形式，详情请参考 <a href="#compound_cases">复合匹配</a></p>
<blockquote>
<p>注意</p>
<p>如果想要显式贯穿 case 分支，请使用 <code>fallthrough</code> 语句，详情请参考 <a href="#fallthrough">贯穿</a>。</p>
</blockquote>
<h4 id="区间匹配">区间匹配</h4>
<p>case 分支的模式也可以是一个值的区间。下面的例子展示了如何使用区间匹配来输出任意数字对应的自然语言格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> approximateCount <span class="operator">=</span> <span class="number">62</span></span><br><span class="line"><span class="keyword">let</span> countedThings <span class="operator">=</span> <span class="string">&quot;moons orbiting Saturn&quot;</span></span><br><span class="line"><span class="keyword">let</span> naturalCount: <span class="type">String</span></span><br><span class="line"><span class="keyword">switch</span> approximateCount &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;no&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span><span class="operator">..&lt;</span><span class="number">5</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;a few&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span><span class="operator">..&lt;</span><span class="number">12</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;several&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span><span class="operator">..&lt;</span><span class="number">100</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;dozens of&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span><span class="operator">..&lt;</span><span class="number">1000</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;hundreds of&quot;</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    naturalCount <span class="operator">=</span> <span class="string">&quot;many&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are <span class="subst">\(naturalCount)</span> <span class="subst">\(countedThings)</span>.&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“There are dozens of moons orbiting Saturn.”</span></span><br></pre></td></tr></table></figure>
<p>在上例中，<code>approximateCount</code> 在一个 <code>switch</code> 声明中被评估。每一个 <code>case</code> 都与之进行比较。因为 <code>approximateCount</code> 落在了 12 到 100 的区间，所以 <code>naturalCount</code> 等于 <code>&quot;dozens of&quot;</code> 值，并且此后的执行跳出了 <code>switch</code> 语句。</p>
<h4 id="元组">元组</h4>
<p>我们可以使用元组在同一个 <code>switch</code> 语句中测试多个值。元组中的元素可以是值，也可以是区间。另外，使用下划线（<code>_</code>）来匹配所有可能的值。</p>
<p>下面的例子展示了如何使用一个 <code>(Int, Int)</code> 类型的元组来分类下图中的点 (x, y)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somePoint <span class="operator">=</span> (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> somePoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is at the origin&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">_</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is on the x-axis&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is on the y-axis&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="operator">-</span><span class="number">2</span><span class="operator">...</span><span class="number">2</span>, <span class="operator">-</span><span class="number">2</span><span class="operator">...</span><span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is inside the box&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(somePoint)</span> is outside of the box&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“(1, 1) is inside the box”</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.swift.org/swift-book/_images/coordinateGraphSimple_2x.png" alt="image"></p>
<p>在上面的例子中，<code>switch</code> 语句会判断某个点是否是原点 (0, 0)，是否在红色的 x 轴上，是否在橘黄色的 y 轴上，是否在一个以原点为中心的4x4的蓝色矩形里，或者在这个矩形外面。</p>
<p>不像 C 语言，Swift 允许多个 case 匹配同一个值。实际上，在这个例子中，点 (0, 0)可以匹配所有<em>四个 case</em>。但是，如果存在多个匹配，那么只会执行第一个被匹配到的 case 分支。考虑点 (0, 0)会首先匹配 <code>case (0, 0)</code>，因此剩下的能够匹配的分支都会被忽视掉。</p>
<h4 id="值绑定（Value-Bindings）">值绑定（Value Bindings）</h4>
<p>case 分支允许将匹配的值声明为临时常量或变量，并且在 case 分支体内使用 —— 这种行为被称为<em>值绑定</em>（value binding），因为匹配的值在 case 分支体内，与临时的常量或变量绑定。</p>
<p>下面的例子将下图中的点 (x, y)，使用 <code>(Int, Int)</code> 类型的元组表示，然后分类表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint <span class="operator">=</span> (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the x-axis with an x value of <span class="subst">\(x)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the y-axis with a y value of <span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“on the x-axis with an x value of 2”</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.swift.org/swift-book/_images/coordinateGraphMedium_2x.png" alt="image"></p>
<p>在上面的例子中，<code>switch</code> 语句会判断某个点是否在红色的 x 轴上，是否在橘黄色的 y 轴上，或者不在坐标轴上。</p>
<p>这三个 case 都声明了常量 <code>x</code> 和 <code>y</code> 的占位符，用于临时获取元组 <code>anotherPoint</code> 的一个或两个值。第一个 case ——<code>case (let x, 0)</code> 将匹配一个纵坐标为 <code>0</code> 的点，并把这个点的横坐标赋给临时的常量 <code>x</code>。类似的，第二个 case ——<code>case (0, let y)</code> 将匹配一个横坐标为 <code>0</code> 的点，并把这个点的纵坐标赋给临时的常量 <code>y</code>。</p>
<p>一旦声明了这些临时的常量，它们就可以在其对应的 case 分支里使用。在这个例子中，它们用于打印给定点的类型。</p>
<p>请注意，这个 <code>switch</code> 语句不包含默认分支。这是因为最后一个 case ——<code>case let(x, y)</code> 声明了一个可以匹配余下所有值的元组。这使得 <code>switch</code> 语句已经完备了，因此不需要再书写默认分支。</p>
<h4 id="Where">Where</h4>
<p>case 分支的模式可以使用 <code>where</code> 语句来判断额外的条件。</p>
<p>下面的例子把下图中的点 (x, y)进行了分类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint <span class="operator">=</span> (<span class="number">1</span>, <span class="operator">-</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> <span class="operator">-</span>y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“(1, -1) is on the line x == -y”</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.swift.org/swift-book/_images/coordinateGraphComplex_2x.png" alt="image"></p>
<p>在上面的例子中，<code>switch</code> 语句会判断某个点是否在绿色的对角线 <code>x == y</code> 上，是否在紫色的对角线 <code>x == -y</code> 上，或者不在对角线上。</p>
<p>这三个 case 都声明了常量 <code>x</code> 和 <code>y</code> 的占位符，用于临时获取元组 <code>yetAnotherPoint</code> 的两个值。这两个常量被用作 <code>where</code> 语句的一部分，从而创建一个动态的过滤器（filter）。当且仅当 <code>where</code> 语句的条件为 <code>true</code> 时，匹配到的 case 分支才会被执行。</p>
<p>就像是值绑定中的例子，由于最后一个 case 分支匹配了余下所有可能的值，<code>switch</code> 语句就已经完备了，因此不需要再书写默认分支。</p>
<h4 id="复合型-Cases">复合型 Cases</h4>
<p>当多个条件可以使用同一种方法来处理时，可以将这几种可能放在同一个 <code>case</code> 后面，并且用逗号隔开。当 case 后面的任意一种模式匹配的时候，这条分支就会被匹配。并且，如果匹配列表过长，还可以分行书写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(someCharacter)</span> is a vowel&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;m&quot;</span>,</span><br><span class="line">     <span class="string">&quot;n&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(someCharacter)</span> is a consonant&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(someCharacter)</span> is not a vowel or a consonant&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“e is a vowel”</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>switch</code> 语句中的第一个 case，匹配了英语中的五个小写元音字母。相似的，第二个 case 匹配了英语中所有的小写辅音字母。最终，<code>default</code> 分支匹配了其它所有字符。</p>
<p>复合匹配同样可以包含值绑定。复合匹配里所有的匹配模式，都必须包含相同的值绑定。并且每一个绑定都必须获取到相同类型的值。这保证了，无论复合匹配中的哪个模式发生了匹配，分支体内的代码，都能获取到绑定的值，并且绑定的值都有一样的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stillAnotherPoint <span class="operator">=</span> (<span class="number">9</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> stillAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> distance, <span class="number">0</span>), (<span class="number">0</span>, <span class="keyword">let</span> distance):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;On an axis, <span class="subst">\(distance)</span> from the origin&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not on an axis&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“On an axis, 9 from the origin”</span></span><br></pre></td></tr></table></figure>
<p>上面的 case 有两个模式：<code>(let distance, 0)</code> 匹配了在 x 轴上的值，<code>(0, let distance)</code> 匹配了在 y 轴上的值。两个模式都绑定了 <code>distance</code>，并且 <code>distance</code> 在两种模式下，都是整型——这意味着分支体内的代码，只要 case 匹配，都可以获取到 <code>distance</code> 值。</p>
<h2 id="控制转移语句">控制转移语句</h2>
<p>控制转移语句改变你代码的执行顺序，通过它可以实现代码的跳转。Swift 有五种控制转移语句：</p>
<ul>
<li><code>continue</code></li>
<li><code>break</code></li>
<li><code>fallthrough</code></li>
<li><code>return</code></li>
<li><code>throw</code></li>
</ul>
<p>我们将会在下面讨论 <code>continue</code>、<code>break</code> 和 <code>fallthrough</code> 语句。<code>return</code> 语句将会在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html">函数</a> 章节讨论，<code>throw</code> 语句会在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/18_Error_Handling.md#throwing_errors">错误抛出</a> 章节讨论。</p>
<h3 id="Continue">Continue</h3>
<p><code>continue</code> 语句告诉一个循环体立刻停止本次循环，重新开始下次循环。就好像在说“本次循环我已经执行完了”，但是并不会离开整个循环体。</p>
<p>下面的例子把一个小写字符串中的元音字母和空格字符移除，生成了一个含义模糊的短句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> puzzleInput <span class="operator">=</span> <span class="string">&quot;great minds think alike&quot;</span></span><br><span class="line"><span class="keyword">var</span> puzzleOutput <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> puzzleInput &#123;</span><br><span class="line">    <span class="keyword">switch</span> character &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot; &quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        puzzleOutput.append(character)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(puzzleOutput)</span><br><span class="line">    <span class="comment">// 输出“grtmndsthnklk”</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，只要匹配到元音字母或者空格字符，就调用 <code>continue</code> 语句，使本次循环结束，重新开始下次循环。这种行为使 <code>switch</code> 匹配到元音字母和空格字符时不做处理，而不是让每一个匹配到的字符都被打印。</p>
<h3 id="Break">Break</h3>
<p><code>break</code> 语句会立刻结束整个控制流的执行。<code>break</code> 可以在 <code>switch</code> 或循环语句中使用，用来提前结束 <code>switch</code> 或循环语句。</p>
<h4 id="循环语句中的-break">循环语句中的 break</h4>
<p>当在一个循环体中使用 <code>break</code> 时，会立刻中断该循环体的执行，然后跳转到表示循环体结束的大括号（<code>&#125;</code>）后的第一行代码。不会再有本次循环的代码被执行，也不会再有下次的循环产生。</p>
<h4 id="Switch-语句中的-break">Switch 语句中的 break</h4>
<p>当在一个 <code>switch</code> 代码块中使用 <code>break</code> 时，会立即中断该 <code>switch</code> 代码块的执行，并且跳转到表示 <code>switch</code> 代码块结束的大括号（<code>&#125;</code>）后的第一行代码。</p>
<p>这种特性可以被用来匹配或者忽略一个或多个分支。因为 Swift 的 <code>switch</code> 需要包含所有的分支而且不允许有为空的分支，有时为了使你的意图更明显，需要特意匹配或者忽略某个分支。那么当你想忽略某个分支时，可以在该分支内写上 <code>break</code> 语句。当那个分支被匹配到时，分支内的 <code>break</code> 语句立即结束 <code>switch</code> 代码块。</p>
<blockquote>
<p>注意</p>
<p>当一个 <code>switch</code> 分支仅仅包含注释时，会被报编译时错误。注释不是代码语句而且也不能让 <code>switch</code> 分支达到被忽略的效果。你应该使用 <code>break</code> 来忽略某个分支。</p>
</blockquote>
<p>下面的例子通过 <code>switch</code> 来判断一个 <code>Character</code> 值是否代表下面四种语言之一。为了简洁，多个值被包含在了同一个分支情况中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberSymbol: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;三&quot;</span>  <span class="comment">// 简体中文里的数字 3</span></span><br><span class="line"><span class="keyword">var</span> possibleIntegerValue: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">switch</span> numberSymbol &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;1&quot;</span>, <span class="string">&quot;١&quot;</span>, <span class="string">&quot;一&quot;</span>, <span class="string">&quot;๑&quot;</span>:</span><br><span class="line">    possibleIntegerValue <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;2&quot;</span>, <span class="string">&quot;٢&quot;</span>, <span class="string">&quot;二&quot;</span>, <span class="string">&quot;๒&quot;</span>:</span><br><span class="line">    possibleIntegerValue <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;3&quot;</span>, <span class="string">&quot;٣&quot;</span>, <span class="string">&quot;三&quot;</span>, <span class="string">&quot;๓&quot;</span>:</span><br><span class="line">    possibleIntegerValue <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;4&quot;</span>, <span class="string">&quot;٤&quot;</span>, <span class="string">&quot;四&quot;</span>, <span class="string">&quot;๔&quot;</span>:</span><br><span class="line">    possibleIntegerValue <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> integerValue <span class="operator">=</span> possibleIntegerValue &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The integer value of <span class="subst">\(numberSymbol)</span> is <span class="subst">\(integerValue)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;An integer value could not be found for <span class="subst">\(numberSymbol)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“The integer value of 三 is 3.”</span></span><br></pre></td></tr></table></figure>
<p>这个例子检查 <code>numberSymbol</code> 是否是拉丁，阿拉伯，中文或者泰语中的 <code>1</code> 到 <code>4</code> 之一。如果被匹配到，该 <code>switch</code> 分支语句给 <code>Int?</code> 类型变量 <code>possibleIntegerValue</code> 设置一个整数值。</p>
<p>当 <code>switch</code> 代码块执行完后，接下来的代码通过使用可选绑定来判断 <code>possibleIntegerValue</code> 是否曾经被设置过值。因为是可选类型的缘故，<code>possibleIntegerValue</code> 有一个隐式的初始值 <code>nil</code>，所以仅仅当 <code>possibleIntegerValue</code> 曾被 <code>switch</code> 代码块的前四个分支中的某个设置过一个值时，可选的绑定才会被判定为成功。</p>
<p>在上面的例子中，想要把 <code>Character</code> 所有的的可能性都枚举出来是不现实的，所以使用 <code>default</code> 分支来包含所有上面没有匹配到字符的情况。由于这个 <code>default</code> 分支不需要执行任何动作，所以它只写了一条 <code>break</code> 语句。一旦落入到 <code>default</code> 分支中后，<code>break</code> 语句就完成了该分支的所有代码操作，代码继续向下，开始执行 <code>if let</code> 语句。</p>
<h3 id="贯穿（Fallthrough）">贯穿（Fallthrough）</h3>
<p>在 Swift 里，<code>switch</code> 语句不会从上一个 case 分支跳转到下一个 case 分支中。相反，只要第一个匹配到的 case 分支完成了它需要执行的语句，整个 <code>switch</code> 代码块完成了它的执行。相比之下，C 语言要求你显式地插入 <code>break</code> 语句到每个 case 分支的末尾来阻止自动落入到下一个 case 分支中。Swift 的这种避免默认落入到下一个分支中的特性意味着它的 <code>switch</code> 功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 case 分支从而引发的错误。</p>
<p>如果你确实需要 C 风格的贯穿的特性，你可以在每个需要该特性的 case 分支中使用 <code>fallthrough</code> 关键字。下面的例子使用 <code>fallthrough</code> 来创建一个数字的描述语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description <span class="operator">=</span> <span class="string">&quot;The number <span class="subst">\(integerToDescribe)</span> is&quot;</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; a prime number, and also&quot;</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; an integer.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(description)</span><br><span class="line"><span class="comment">// 输出“The number 5 is a prime number, and also an integer.”</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个 <code>String</code> 类型的变量 <code>description</code> 并且给它设置了一个初始值。函数使用 <code>switch</code> 逻辑来判断 <code>integerToDescribe</code> 变量的值。当 <code>integerToDescribe</code> 的值属于列表中的质数之一时，该函数在 <code>description</code> 后添加一段文字，来表明这个数字是一个质数。然后它使用 <code>fallthrough</code> 关键字来“贯穿”到 <code>default</code> 分支中。<code>default</code> 分支在 <code>description</code> 的最后添加一段额外的文字，至此 <code>switch</code> 代码块执行完了。</p>
<p>如果 <code>integerToDescribe</code> 的值不属于列表中的任何质数，那么它不会匹配到第一个 <code>switch</code> 分支。而这里没有其他特别的分支情况，所以 <code>integerToDescribe</code> 匹配到 <code>default</code> 分支中。</p>
<p>当 <code>switch</code> 代码块执行完后，使用 <code>print(_:separator:terminator:)</code> 函数打印该数字的描述。在这个例子中，数字 <code>5</code> 被准确的识别为了一个质数。</p>
<blockquote>
<p>注意</p>
<p><code>fallthrough</code> 关键字不会检查它下一个将会落入执行的 case 中的匹配条件。<code>fallthrough</code> 简单地使代码继续连接到下一个 case 中的代码，这和 C 语言标准中的 <code>switch</code> 语句特性是一样的。</p>
</blockquote>
<h3 id="带标签的语句">带标签的语句</h3>
<p>在 Swift 中，你可以在循环体和条件语句中嵌套循环体和条件语句来创造复杂的控制流结构。并且，循环体和条件语句都可以使用 <code>break</code> 语句来提前结束整个代码块。因此，显式地指明 <code>break</code> 语句想要终止的是哪个循环体或者条件语句，会很有用。类似地，如果你有许多嵌套的循环体，显式指明 <code>continue</code> 语句想要影响哪一个循环体也会非常有用。</p>
<p>为了实现这个目的，你可以使用标签（<em>statement label</em>）来标记一个循环体或者条件语句，对于一个条件语句，你可以使用 <code>break</code> 加标签的方式，来结束这个被标记的语句。对于一个循环语句，你可以使用 <code>break</code> 或者 <code>continue</code> 加标签，来结束或者继续这条被标记语句的执行。</p>
<p>声明一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签，作为这个语句的前导关键字（introducor keyword），并且该标签后面跟随一个冒号。下面是一个针对 <code>while</code> 循环体的标签语法，同样的规则适用于所有的循环体和条件语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label name: <span class="keyword">while</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子是前面章节中<em>蛇和梯子</em>的适配版本，在此版本中，我们将使用一个带有标签的 <code>while</code> 循环体中调用 <code>break</code> 和 <code>continue</code> 语句。这次，游戏增加了一条额外的规则：</p>
<ul>
<li>为了获胜，你必须<em>刚好</em>落在第 25 个方块中。</li>
</ul>
<p>如果某次掷骰子使你的移动超出第 25 个方块，你必须重新掷骰子，直到你掷出的骰子数刚好使你能落在第 25 个方块中。</p>
<p>游戏的棋盘和之前一样：</p>
<p><img src="https://docs.swift.org/swift-book/_images/snakesAndLadders_2x.png" alt="image"></p>
<p><code>finalSquare</code>、<code>board</code>、<code>square</code> 和 <code>diceRoll</code> 值被和之前一样的方式初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare <span class="operator">=</span> <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board <span class="operator">=</span> [<span class="type">Int</span>](repeating: <span class="number">0</span>, count: finalSquare <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">board[<span class="number">03</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">08</span>; board[<span class="number">06</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">11</span>; board[<span class="number">09</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">09</span>; board[<span class="number">10</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">10</span>; board[<span class="number">19</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">11</span>; board[<span class="number">22</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">02</span>; board[<span class="number">24</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">08</span></span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个版本的游戏使用 <code>while</code> 循环和 <code>switch</code> 语句来实现游戏的逻辑。<code>while</code> 循环有一个标签名 <code>gameLoop</code>，来表明它是游戏的主循环。</p>
<p>该 <code>while</code> 循环体的条件判断语句是 <code>while square !=finalSquare</code>，这表明你必须刚好落在方格25中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gameLoop: <span class="keyword">while</span> square <span class="operator">!=</span> finalSquare &#123;</span><br><span class="line">    diceRoll <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> diceRoll <span class="operator">==</span> <span class="number">7</span> &#123; diceRoll <span class="operator">=</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">switch</span> square <span class="operator">+</span> diceRoll &#123;</span><br><span class="line">    <span class="keyword">case</span> finalSquare:</span><br><span class="line">        <span class="comment">// 骰子数刚好使玩家移动到最终的方格里，游戏结束。</span></span><br><span class="line">        <span class="keyword">break</span> gameLoop</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare <span class="operator">&gt;</span> finalSquare:</span><br><span class="line">        <span class="comment">// 骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子</span></span><br><span class="line">        <span class="keyword">continue</span> gameLoop</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 合法移动，做正常的处理</span></span><br><span class="line">        square <span class="operator">+=</span> diceRoll</span><br><span class="line">        square <span class="operator">+=</span> board[square]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Game over!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>每次循环迭代开始时掷骰子。与之前玩家掷完骰子就立即移动不同，这里使用了 <code>switch</code> 语句来考虑每次移动可能产生的结果，从而决定玩家本次是否能够移动。</p>
<ul>
<li>如果骰子数刚好使玩家移动到最终的方格里，游戏结束。<code>break gameLoop</code> 语句跳转控制去执行 <code>while</code> 循环体后的第一行代码，意味着游戏结束。</li>
<li>如果骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子。<code>continue gameLoop</code> 语句结束本次 <code>while</code> 循环，开始下一次循环。</li>
<li>在剩余的所有情况中，骰子数产生的都是合法的移动。玩家向前移动 <code>diceRoll</code> 个方格，然后游戏逻辑再处理玩家当前是否处于蛇头或者梯子的底部。接着本次循环结束，控制跳转到 <code>while</code> 循环体的条件判断语句处，再决定是否需要继续执行下次循环。</li>
</ul>
<blockquote>
<p>注意</p>
<p>如果上述的 <code>break</code> 语句没有使用 <code>gameLoop</code> 标签，那么它将会中断 <code>switch</code> 语句而不是 <code>while</code> 循环。使用 <code>gameLoop</code> 标签清晰的表明了 <code>break</code> 想要中断的是哪个代码块。</p>
<p>同时请注意，当调用 <code>continue gameLoop</code> 去跳转到下一次循环迭代时，这里使用 <code>gameLoop</code> 标签并不是严格必须的。因为在这个游戏中，只有一个循环体，所以 <code>continue</code> 语句会影响到哪个循环体是没有歧义的。然而，<code>continue</code> 语句使用 <code>gameLoop</code> 标签也是没有危害的。这样做符合标签的使用规则，同时参照旁边的 <code>break gameLoop</code>，能够使游戏的逻辑更加清晰和易于理解。</p>
</blockquote>
<h2 id="提前退出">提前退出</h2>
<p>像 <code>if</code> 语句一样，<code>guard</code> 的执行取决于一个表达式的布尔值。我们可以使用 <code>guard</code> 语句来要求条件必须为真时，以执行 <code>guard</code> 语句后的代码。不同于 <code>if</code> 语句，一个 <code>guard</code> 语句总是有一个 <code>else</code> 从句，如果条件不为真则执行 <code>else</code> 从句中的代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: [<span class="params">String</span>: <span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name <span class="operator">=</span> person[<span class="string">&quot;name&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> location <span class="operator">=</span> person[<span class="string">&quot;location&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice near you.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice in <span class="subst">\(location)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(person: [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>])</span><br><span class="line"><span class="comment">// 输出“Hello John!”</span></span><br><span class="line"><span class="comment">// 输出“I hope the weather is nice near you.”</span></span><br><span class="line">greet(person: [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;location&quot;</span>: <span class="string">&quot;Cupertino&quot;</span>])</span><br><span class="line"><span class="comment">// 输出“Hello Jane!”</span></span><br><span class="line"><span class="comment">// 输出“I hope the weather is nice in Cupertino.”</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>guard</code> 语句的条件被满足，则继续执行 <code>guard</code> 语句大括号后的代码。将变量或者常量的可选绑定作为 <code>guard</code> 语句的条件，都可以保护 <code>guard</code> 语句后面的代码。</p>
<p>如果条件不被满足，在 <code>else</code> 分支上的代码就会被执行。这个分支必须转移控制以退出 <code>guard</code> 语句出现的代码段。它可以用控制转移语句如 <code>return</code>、<code>break</code>、<code>continue</code> 或者 <code>throw</code> 做这件事，或者调用一个不返回的方法或函数，例如 <code>fatalError()</code>。</p>
<p>相比于可以实现同样功能的 <code>if</code> 语句，按需使用 <code>guard</code> 语句会提升我们代码的可读性。它可以使你的代码连贯的被执行而不需要将它包在 <code>else</code> 块中，它可以使你在紧邻条件判断的地方，处理违规的情况。</p>
<h2 id="检测-API-可用性">检测 API 可用性</h2>
<p>Swift 内置支持检查 API 可用性，这可以确保我们不会在当前部署机器上，不小心地使用了不可用的 API。</p>
<p>编译器使用 SDK 中的可用信息来验证我们的代码中使用的所有 API 在项目指定的部署目标上是否可用。如果我们尝试使用一个不可用的 API，Swift 会在编译时报错。</p>
<p>我们在 <code>if</code> 或 <code>guard</code> 语句中使用 <code>可用性条件（availability condition)</code>去有条件的执行一段代码，来在运行时判断调用的 API 是否可用。编译器使用从可用性条件语句中获取的信息去验证，在这个代码块中调用的 API 是否可用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">10</span>, <span class="keyword">macOS</span> <span class="number">10.12</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">    <span class="comment">// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用先前版本的 iOS 和 macOS 的 API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上可用性条件指定，<code>if</code> 语句的代码块仅仅在 iOS 10 或 macOS 10.12 及更高版本才运行。最后一个参数，<code>*</code>，是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本，if 语句的代码块将会运行。</p>
<p>在它一般的形式中，可用性条件使用了一个平台名字和版本的列表。平台名字可以是 <code>iOS</code>，<code>macOS</code>，<code>watchOS</code> 和 <code>tvOS</code>——请访问 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter3/06_Attributes.html">声明属性</a> 来获取完整列表。除了指定像 iOS 8 或 macOS 10.10 的大版本号，也可以指定像 iOS 11.2.6 以及 macOS 10.13.3 的小版本号。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">#available</span>(平台名称 版本号, <span class="operator">...</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">    <span class="type">APIs</span> 可用，语句将执行</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">APIs</span> 不可用，语句将不执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/06/22/Swift/swift%E6%8E%A7%E5%88%B6%E6%B5%81/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/06/21/Swift/swift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"
                            aria-label=": swift集合类型"
                        >
                            swift集合类型
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-21T10:13:17+08:00">
	
		    2023 年 6 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="集合类型">集合类型</h2>
<p>Swift 语言提供 <code>Arrays</code>、<code>Sets</code> 和 <code>Dictionaries</code> 三种基本的<em>集合类型</em>用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。</p>
<p><img src="https://docs.swift.org/swift-book/_images/CollectionTypes_intro_2x.png" alt=""></p>
<p>Swift 语言中的 <code>Arrays</code>、<code>Sets</code> 和 <code>Dictionaries</code> 中存储的数据值类型必须明确。这意味着我们不能把错误的数据类型插入其中。同时这也说明你完全可以对取回值的类型非常放心。</p>
<blockquote>
<p>注意</p>
<p>Swift 的 <code>Arrays</code>、<code>Sets</code> 和 <code>Dictionaries</code> 类型被实现为<em>泛型集合</em>。更多关于泛型类型和集合，参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/23_Generics.md">泛型</a> 章节。</p>
</blockquote>
<h2 id="集合的可变性">集合的可变性</h2>
<p>如果创建一个 <code>Arrays</code>、<code>Sets</code> 或 <code>Dictionaries</code> 并且把它分配成一个变量，这个集合将会是<em>可变的</em>。这意味着你可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把 <code>Arrays</code>、<code>Sets</code> 或 <code>Dictionaries</code> 分配成常量，那么它就是<em>不可变的</em>，它的大小和内容都不能被改变。</p>
<blockquote>
<p>注意</p>
<p>在我们不需要改变集合的时候创建不可变集合是很好的实践。如此 Swift 编译器可以优化我们创建的集合。</p>
</blockquote>
<h2 id="数组（Arrays）">数组（Arrays）</h2>
<p><em>数组</em>使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。</p>
<blockquote>
<p>注意</p>
<p>Swift 的 <code>Array</code> 类型被桥接到 <code>Foundation</code> 中的 <code>NSArray</code> 类。更多关于在 <code>Foundation</code> 和 <code>Cocoa</code> 中使用 <code>Array</code> 的信息，参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216"><em>Using Swift with Cocoa and Obejective-C(Swift 4.1)</em></a> 中 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6">使用 Cocoa 数据类型</a> 部分。</p>
</blockquote>
<h3 id="数组的简单语法">数组的简单语法</h3>
<p>写 Swift 数组应该遵循像 <code>Array&lt;Element&gt;</code> 这样的形式，其中 <code>Element</code> 是这个数组中唯一允许存在的数据类型。我们也可以使用像 <code>[Element]</code> 这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。</p>
<h3 id="创建一个空数组">创建一个空数组</h3>
<p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInts is of type [Int] with <span class="subst">\(someInts.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“someInts is of type [Int] with 0 items.”</span></span><br></pre></td></tr></table></figure>
<p>注意，通过构造函数的类型，<code>someInts</code> 的值类型被推断为 <code>[Int]</code>。</p>
<p>或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：<code>[]</code>（一对空方括号）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someInts.append(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// someInts 现在包含一个 Int 值</span></span><br><span class="line">someInts <span class="operator">=</span> []</span><br><span class="line"><span class="comment">// someInts 现在是空数组，但是仍然是 [Int] 类型的。</span></span><br></pre></td></tr></table></figure>
<h3 id="创建一个带有默认值的数组">创建一个带有默认值的数组</h3>
<p>Swift 中的 <code>Array</code> 类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（<code>count</code>）和适当类型的初始值（<code>repeating</code>）传入数组构造函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDoubles <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.0</span>, count: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</span></span><br></pre></td></tr></table></figure>
<h3 id="通过两个数组相加创建一个数组">通过两个数组相加创建一个数组</h3>
<p>我们可以使用加法操作符（<code>+</code>）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherThreeDoubles <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">2.5</span>, count: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sixDoubles <span class="operator">=</span> threeDoubles <span class="operator">+</span> anotherThreeDoubles</span><br><span class="line"><span class="comment">// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></span><br></pre></td></tr></table></figure>
<h3 id="用数组字面量构造数组">用数组字面量构造数组</h3>
<p>我们可以使用<em>数组字面量</em>来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。数组字面量是一系列由逗号分割并由方括号包含的数值：</p>
<p><code>[value 1, value 2, value 3]</code>。</p>
<p>下面这个例子创建了一个叫做 <code>shoppingList</code> 并且存储 <code>String</code> 的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;Eggs&quot;</span>, <span class="string">&quot;Milk&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList 已经被构造并且拥有两个初始项。</span></span><br></pre></td></tr></table></figure>
<p><code>shoppingList</code> 变量被声明为“字符串值类型的数组“，记作 <code>[String]</code>。 因为这个数组被规定只有 <code>String</code> 一种数据结构，所以只有 <code>String</code> 类型可以在其中被存取。 在这里，<code>shoppingList</code> 数组由两个 <code>String</code> 值（<code>&quot;Eggs&quot;</code> 和 <code>&quot;Milk&quot;</code>）构造，并且由数组字面量定义。</p>
<blockquote>
<p>注意</p>
<p><code>shoppingList</code> 数组被声明为变量（<code>var</code> 关键字创建）而不是常量（<code>let</code> 创建）是因为以后可能会有更多的数据项被插入其中。</p>
</blockquote>
<p>在这个例子中，字面量仅仅包含两个 <code>String</code> 值。匹配了该数组的变量声明（只能包含 <code>String</code> 的数组），所以这个字面量的分配过程可以作为用两个初始项来构造 <code>shoppingList</code> 的一种方式。</p>
<p>由于 Swift 的类型推断机制，当我们用字面量构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。<code>shoppingList</code> 的构造也可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList <span class="operator">=</span> [<span class="string">&quot;Eggs&quot;</span>, <span class="string">&quot;Milk&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>因为所有数组字面量中的值都是相同的类型，Swift 可以推断出 <code>[String]</code> 是 <code>shoppingList</code> 中变量的正确类型。</p>
<h3 id="访问和修改数组">访问和修改数组</h3>
<p>我们可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。</p>
<p>可以使用数组的只读属性 <code>count</code> 来获取数组中的数据项数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The shopping list contains <span class="subst">\(shoppingList.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The shopping list contains 2 items.”（这个数组有2个项）</span></span><br></pre></td></tr></table></figure>
<p>使用布尔属性 <code>isEmpty</code> 作为一个缩写形式去检查 <code>count</code> 属性是否为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> shoppingList.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The shopping list is empty.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The shopping list is not empty.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The shopping list is not empty.”（shoppinglist 不是空的）</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>append(_:)</code> 方法在数组后面添加新的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.append(<span class="string">&quot;Flour&quot;</span>)</span><br><span class="line"><span class="comment">// shoppingList 现在有3个数据项，有人在摊煎饼</span></span><br></pre></td></tr></table></figure>
<p>除此之外，使用加法赋值运算符（<code>+=</code>）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shoppingList <span class="operator">+=</span> [<span class="string">&quot;Baking Powder&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有四项了</span></span><br><span class="line">shoppingList <span class="operator">+=</span> [<span class="string">&quot;Chocolate Spread&quot;</span>, <span class="string">&quot;Cheese&quot;</span>, <span class="string">&quot;Butter&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有七项了</span></span><br></pre></td></tr></table></figure>
<p>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstItem <span class="operator">=</span> shoppingList[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 第一项是“Eggs”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>第一项在数组中的索引值是 <code>0</code> 而不是 <code>1</code>。 Swift 中的数组索引总是从零开始。</p>
</blockquote>
<p>我们也可以用下标来改变某个已有索引值对应的数据值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList[<span class="number">0</span>] <span class="operator">=</span> <span class="string">&quot;Six eggs&quot;</span></span><br><span class="line"><span class="comment">// 其中的第一项现在是“Six eggs”而不是“Eggs”</span></span><br></pre></td></tr></table></figure>
<p>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把 <code>&quot;Chocolate Spread&quot;</code>、<code>&quot;Cheese&quot;</code> 和 <code>&quot;Butter&quot;</code> 替换为 <code>&quot;Bananas&quot;</code> 和 <code>&quot;Apples&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList[<span class="number">4</span><span class="operator">...</span><span class="number">6</span>] <span class="operator">=</span> [<span class="string">&quot;Bananas&quot;</span>, <span class="string">&quot;Apples&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有6项</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>不可以用下标访问的形式去在数组尾部添加新项。</p>
</blockquote>
<p>调用数组的 <code>insert(_:at:)</code> 方法来在某个具体索引值之前添加数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.insert(<span class="string">&quot;Maple Syrup&quot;</span>, at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// shoppingList 现在有7项</span></span><br><span class="line"><span class="comment">// 现在是这个列表中的第一项是“Maple Syrup”</span></span><br></pre></td></tr></table></figure>
<p>这次 <code>insert(_:at:)</code> 方法调用把值为 <code>&quot;Maple Syrup&quot;</code> 的新数据项插入列表的最开始位置，并且使用 <code>0</code> 作为索引值。</p>
<p>类似的我们可以使用 <code>remove(at:)</code> 方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleSyrup <span class="operator">=</span> shoppingList.remove(at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 索引值为0的数据项被移除</span></span><br><span class="line"><span class="comment">// shoppingList 现在只有6项，而且不包括 Maple Syrup</span></span><br><span class="line"><span class="comment">// mapleSyrup 常量的值等于被移除数据项“Maple Syrup”的值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>如果我们试着对索引越界的数据进行检索或者设置新值的操作，会引发一个运行期错误。我们可以使用索引值和数组的 <code>count</code> 属性进行比较来在使用某个索引之前先检验是否有效。除了当 <code>count</code> 等于 0 时（说明这是个空数组），最大索引值一直是 <code>count - 1</code>，因为数组都是零起索引。</p>
</blockquote>
<p>数据项被移除后数组中的空出项会被自动填补，所以现在索引值为 <code>0</code> 的数据项的值再次等于 <code>&quot;Six eggs&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firstItem <span class="operator">=</span> shoppingList[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// firstItem 现在等于“Six eggs”</span></span><br></pre></td></tr></table></figure>
<p>如果我们只想把数组中的最后一项移除，可以使用 <code>removeLast()</code> 方法而不是 <code>remove(at:)</code> 方法来避免我们需要获取数组的 <code>count</code> 属性。就像后者一样，前者也会返回被移除的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples <span class="operator">=</span> shoppingList.removeLast()</span><br><span class="line"><span class="comment">// 数组的最后一项被移除了</span></span><br><span class="line"><span class="comment">// shoppingList 现在只有5项，不包括 Apples</span></span><br><span class="line"><span class="comment">// apples 常量的值现在等于“Apples”字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="数组的遍历">数组的遍历</h3>
<p>我们可以使用 <code>for-in</code> 循环来遍历所有数组中的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Six eggs</span></span><br><span class="line"><span class="comment">// Milk</span></span><br><span class="line"><span class="comment">// Flour</span></span><br><span class="line"><span class="comment">// Baking Powder</span></span><br><span class="line"><span class="comment">// Bananas</span></span><br></pre></td></tr></table></figure>
<p>如果我们同时需要每个数据项的值和索引值，可以使用 <code>enumerated()</code> 方法来进行数组遍历。<code>enumerated()</code> 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item <span class="subst">\(String(index <span class="operator">+</span> <span class="number">1</span>))</span>: <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Item 1: Six eggs</span></span><br><span class="line"><span class="comment">// Item 2: Milk</span></span><br><span class="line"><span class="comment">// Item 3: Flour</span></span><br><span class="line"><span class="comment">// Item 4: Baking Powder</span></span><br><span class="line"><span class="comment">// Item 5: Bananas</span></span><br></pre></td></tr></table></figure>
<p>更多关于 <code>for-in</code> 循环的介绍请参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html#for_loops">For 循环</a>。</p>
<h2 id="集合（Sets）">集合（Sets）</h2>
<p>*集合（Set）*用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。</p>
<blockquote>
<p>注意 Swift 的 <code>Set</code> 类型被桥接到 <code>Foundation</code> 中的 <code>NSSet</code> 类。</p>
<p>关于使用 <code>Foundation</code> 和 <code>Cocoa</code> 中 <code>Set</code> 的知识，参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216"><em>Using Swift with Cocoa and Obejective-C(Swift 4.1)</em></a> 中<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6">使用 Cocoa 数据类型</a>部分。</p>
</blockquote>
<h3 id="集合类型的哈希值">集合类型的哈希值</h3>
<p>一个类型为了存储在集合中，该类型必须是<em>可哈希化</em>的——也就是说，该类型必须提供一个方法来计算它的<em>哈希值</em>。一个哈希值是 <code>Int</code> 类型的，相等的对象哈希值必须相同，比如 <code>a==b</code>,因此必须 <code>a.hashValue == b.hashValue</code>。</p>
<p>Swift 的所有基本类型（比如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值（在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/08_Enumerations.html">枚举</a> 有讲述）默认也是可哈希化的。</p>
<blockquote>
<p>注意</p>
<p>你可以使用你自定义的类型作为集合的值的类型或者是字典的键的类型，但你需要使你的自定义类型遵循 Swift 标准库中的 <code>Hashable</code> 协议。遵循 <code>Hashable</code> 协议的类型需要提供一个类型为 <code>Int</code> 的可读属性 <code>hashValue</code>。由类型的 <code>hashValue</code> 属性返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。</p>
<p>因为 <code>Hashable</code> 协议遵循 <code>Equatable</code> 协议，所以遵循该协议的类型也必须提供一个“是否相等”运算符（<code>==</code>）的实现。这个 <code>Equatable</code> 协议要求任何遵循 <code>==</code> 实现的实例间都是一种相等的关系。也就是说，对于 <code>a,b,c</code> 三个值来说，<code>==</code> 的实现必须满足下面三种情况：</p>
<ul>
<li><code>a == a</code>(自反性)</li>
<li><code>a == b</code> 意味着 <code>b == a</code>(对称性)</li>
<li><code>a == b &amp;&amp; b == c</code> 意味着 <code>a == c</code>(传递性)</li>
</ul>
</blockquote>
<p>关于遵循协议的更多信息，请看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/22_Protocols.md">协议</a>。</p>
<h3 id="集合类型语法">集合类型语法</h3>
<p>Swift 中的 <code>Set</code> 类型被写为 <code>Set&lt;Element&gt;</code>，这里的 <code>Element</code> 表示 <code>Set</code> 中允许存储的类型，和数组不同的是，集合没有等价的简化形式。</p>
<h3 id="创建和构造一个空的集合">创建和构造一个空的集合</h3>
<p>你可以通过构造器语法创建一个特定类型的空集合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“letters is of type Set&lt;Character&gt; with 0 items.”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>通过构造器，这里的 <code>letters</code> 变量的类型被推断为 <code>Set&lt;Character&gt;</code>。</p>
</blockquote>
<p>此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的 <code>Set</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters.insert(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">// letters 现在含有1个 Character 类型的值</span></span><br><span class="line">letters <span class="operator">=</span> []</span><br><span class="line"><span class="comment">// letters 现在是一个空的 Set，但是它依然是 Set&lt;Character&gt; 类型</span></span><br></pre></td></tr></table></figure>
<h3 id="用数组字面量创建集合">用数组字面量创建集合</h3>
<p>你可以使用数组字面量来构造集合，并且可以使用简化形式写一个或者多个值作为集合元素。</p>
<p>下面的例子创建一个称之为 <code>favoriteGenres</code> 的集合来存储 <code>String</code> 类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;Rock&quot;</span>, <span class="string">&quot;Classical&quot;</span>, <span class="string">&quot;Hip hop&quot;</span>]</span><br><span class="line"><span class="comment">// favoriteGenres 被构造成含有三个初始值的集合</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>favoriteGenres</code> 变量被声明为“一个 <code>String</code> 值的集合”，写为 <code>Set&lt;String&gt;</code>。由于这个特定的集合含有指定 <code>String</code> 类型的值，所以它只允许存储 <code>String</code> 类型值。这里的 <code>favoriteGenres</code> 变量有三个 <code>String</code> 类型的初始值（<code>&quot;Rock&quot;</code>，<code>&quot;Classical&quot;</code> 和 <code>&quot;Hip hop&quot;</code>），并以数组字面量的方式出现。</p>
<blockquote>
<p>注意</p>
<p><code>favoriteGenres</code> 被声明为一个变量（拥有 <code>var</code> 标示符）而不是一个常量（拥有 <code>let</code> 标示符）,因为它里面的元素将会在下面的例子中被增加或者移除。</p>
</blockquote>
<p>一个 <code>Set</code> 类型不能从数组字面量中被单独推断出来，因此 <code>Set</code> 类型必须显式声明。然而，由于 Swift 的类型推断功能，如果你想使用一个数组字面量构造一个 <code>Set</code> 并且该数组字面量中的所有元素类型相同，那么你无须写出 <code>Set</code> 的具体类型。<code>favoriteGenres</code> 的构造形式可以采用简化的方式代替：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;Rock&quot;</span>, <span class="string">&quot;Classical&quot;</span>, <span class="string">&quot;Hip hop&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>由于数组字面量中的所有元素类型相同，Swift 可以推断出 <code>Set&lt;String&gt;</code> 作为 <code>favoriteGenres</code> 变量的正确类型。</p>
<h3 id="访问和修改一个集合">访问和修改一个集合</h3>
<p>你可以通过 <code>Set</code> 的属性和方法来访问和修改一个 <code>Set</code>。</p>
<p>为了找出一个 <code>Set</code> 中元素的数量，可以使用其只读属性 <code>count</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I have <span class="subst">\(favoriteGenres.count)</span> favorite music genres.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“I have 3 favorite music genres.”</span></span><br></pre></td></tr></table></figure>
<p>使用布尔属性 <code>isEmpty</code> 作为一个缩写形式去检查 <code>count</code> 属性是否为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> favoriteGenres.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;As far as music goes, I&#x27;m not picky.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I have particular music preferences.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“I have particular music preferences.”</span></span><br></pre></td></tr></table></figure>
<p>你可以通过调用 <code>Set</code> 的 <code>insert(_:)</code> 方法来添加一个新元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">favoriteGenres.insert(<span class="string">&quot;Jazz&quot;</span>)</span><br><span class="line"><span class="comment">// favoriteGenres 现在包含4个元素</span></span><br></pre></td></tr></table></figure>
<p>你可以通过调用 <code>Set</code> 的 <code>remove(_:)</code> 方法去删除一个元素，如果该值是该 <code>Set</code> 的一个元素则删除该元素并且返回被删除的元素值，否则如果该 <code>Set</code> 不包含该值，则返回 <code>nil</code>。另外，<code>Set</code> 中的所有元素可以通过它的 <code>removeAll()</code> 方法删除。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedGenre <span class="operator">=</span> favoriteGenres.remove(<span class="string">&quot;Rock&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(removedGenre)</span>? I&#x27;m over it.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I never much cared for that.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Rock? I&#x27;m over it.”</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>contains(_:)</code> 方法去检查 <code>Set</code> 中是否包含一个特定的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> favoriteGenres.contains(<span class="string">&quot;Funk&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I get up on the good foot.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s too funky in here.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“It&#x27;s too funky in here.”</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历一个集合">遍历一个集合</h3>
<p>你可以在一个 <code>for-in</code> 循环中遍历一个 <code>Set</code> 中的所有值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(genre)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Classical</span></span><br><span class="line"><span class="comment">// Jazz</span></span><br><span class="line"><span class="comment">// Hip hop</span></span><br></pre></td></tr></table></figure>
<p>更多关于 <code>for-in</code> 循环的信息，参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html#for_loops">For 循环</a>。</p>
<p>Swift 的 <code>Set</code> 类型没有确定的顺序，为了按照特定顺序来遍历一个 <code>Set</code> 中的值可以使用 <code>sorted()</code> 方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符’&lt;'对元素进行比较的结果来确定。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres.sorted() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(genre)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Classical</span></span><br><span class="line"><span class="comment">// Hip hop</span></span><br><span class="line"><span class="comment">// Jazz</span></span><br></pre></td></tr></table></figure>
<h2 id="集合操作">集合操作</h2>
<p>你可以高效地完成 <code>Set</code> 的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。</p>
<h3 id="基本集合操作">基本集合操作</h3>
<p>下面的插图描述了两个集合 <code>a</code> 和 <code>b</code>，以及通过阴影部分的区域显示集合各种操作的结果。</p>
<p><img src="https://docs.swift.org/swift-book/_images/setVennDiagram_2x.png" alt=""></p>
<ul>
<li>使用 <code>intersection(_:)</code> 方法根据两个集合中都包含的值创建的一个新的集合。</li>
<li>使用 <code>symmetricDifference(_:)</code> 方法根据在一个集合中但不在两个集合中的值创建一个新的集合。</li>
<li>使用 <code>union(_:)</code> 方法根据两个集合的值创建一个新的集合。</li>
<li>使用 <code>subtracting(_:)</code> 方法根据不在该集合中的值创建一个新的集合。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">oddDigits.union(evenDigits).sorted()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">oddDigits.intersection(evenDigits).sorted()</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">oddDigits.subtracting(singleDigitPrimeNumbers).sorted()</span><br><span class="line"><span class="comment">// [1, 9]</span></span><br><span class="line">oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()</span><br><span class="line"><span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure>
<h3 id="集合成员关系和相等">集合成员关系和相等</h3>
<p>下面的插图描述了三个集合 <code>a</code>、<code>b</code> 和 <code>c</code>,以及通过重叠区域表述集合间共享的元素。集合 <code>a</code> 是集合 <code>b</code> 的父集合，因为 <code>a</code> 包含了 <code>b</code> 中所有的元素，相反的，集合 <code>b</code> 是集合 <code>a</code> 的子集合，因为属于 <code>b</code> 的元素也被 <code>a</code> 包含。集合 <code>b</code> 和集合 <code>c</code> 彼此不关联，因为它们之间没有共同的元素。</p>
<p><img src="https://docs.swift.org/swift-book/_images/setEulerDiagram_2x.png" alt=""></p>
<ul>
<li>使用“是否相等”运算符（<code>==</code>）来判断两个集合是否包含全部相同的值。</li>
<li>使用 <code>isSubset(of:)</code> 方法来判断一个集合中的值是否也被包含在另外一个集合中。</li>
<li>使用 <code>isSuperset(of:)</code> 方法来判断一个集合中包含另一个集合中所有的值。</li>
<li>使用 <code>isStrictSubset(of:)</code> 或者 <code>isStrictSuperset(of:)</code> 方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。</li>
<li>使用 <code>isDisjoint(with:)</code> 方法来判断两个集合是否不含有相同的值（是否没有交集）。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> houseAnimals: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> farmAnimals: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;🐮&quot;</span>, <span class="string">&quot;🐔&quot;</span>, <span class="string">&quot;🐑&quot;</span>, <span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> cityAnimals: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;🐦&quot;</span>, <span class="string">&quot;🐭&quot;</span>]</span><br><span class="line"></span><br><span class="line">houseAnimals.isSubset(of: farmAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isSuperset(of: houseAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isDisjoint(with: cityAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="字典">字典</h2>
<p><em>字典</em>是一种存储多个相同类型的值的容器。每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>
<blockquote>
<p>注意</p>
<p>Swift 的 <code>Dictionary</code> 类型被桥接到 <code>Foundation</code> 的 <code>NSDictionary</code> 类。</p>
<p>更多关于在 <code>Foundation</code> 和 <code>Cocoa</code> 中使用 <code>Dictionary</code> 类型的信息，参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216"><em>Using Swift with Cocoa and Obejective-C(Swift 4.1)</em></a> 中 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6">使用 Cocoa 数据类型</a> 部分。</p>
</blockquote>
<h3 id="字典类型简化语法">字典类型简化语法</h3>
<p>Swift 的字典使用 <code>Dictionary&lt;Key, Value&gt;</code> 定义，其中 <code>Key</code> 是字典中键的数据类型，<code>Value</code> 是字典中对应于这些键所存储值的数据类型。</p>
<blockquote>
<p>注意</p>
<p>一个字典的 <code>Key</code> 类型必须遵循 <code>Hashable</code> 协议，就像 <code>Set</code> 的值类型。</p>
</blockquote>
<p>我们也可以用 <code>[Key: Value]</code> 这样简化的形式去创建一个字典类型。虽然这两种形式功能上相同，但是后者是首选，并且这本指导书涉及到字典类型时通篇采用后者。</p>
<h3 id="创建一个空字典">创建一个空字典</h3>
<p>我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namesOfIntegers <span class="operator">=</span> [<span class="type">Int</span>: <span class="type">String</span>]()</span><br><span class="line"><span class="comment">// namesOfIntegers 是一个空的 [Int: String] 字典</span></span><br></pre></td></tr></table></figure>
<p>这个例子创建了一个 <code>[Int: String]</code> 类型的空字典来储存整数的英语命名。它的键是 <code>Int</code> 型，值是 <code>String</code> 型。</p>
<p>如果上下文已经提供了类型信息，我们可以使用空字典字面量来创建一个空字典，记作 <code>[:]</code>（中括号中放一个冒号）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namesOfIntegers[<span class="number">16</span>] <span class="operator">=</span> <span class="string">&quot;sixteen&quot;</span></span><br><span class="line"><span class="comment">// namesOfIntegers 现在包含一个键值对</span></span><br><span class="line">namesOfIntegers <span class="operator">=</span> [:]</span><br><span class="line"><span class="comment">// namesOfIntegers 又成为了一个 [Int: String] 类型的空字典</span></span><br></pre></td></tr></table></figure>
<h3 id="用字典字面量创建字典">用字典字面量创建字典</h3>
<p>我们可以使用<em>字典字面量</em>来构造字典，这和我们刚才介绍过的数组字面量拥有相似语法。字典字面量是一种将一个或多个键值对写作 <code>Dictionary</code> 集合的快捷途径。</p>
<p>一个键值对是一个 <code>key</code> 和一个 <code>value</code> 的结合体。在字典字面量中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含、由逗号分割：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[key <span class="number">1</span>: value <span class="number">1</span>, key <span class="number">2</span>: value <span class="number">2</span>, key <span class="number">3</span>: value <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>: <span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;YYZ&quot;</span>: <span class="string">&quot;Toronto Pearson&quot;</span>, <span class="string">&quot;DUB&quot;</span>: <span class="string">&quot;Dublin&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>airports</code> 字典被声明为一种 <code>[String: String]</code> 类型，这意味着这个字典的键和值都是 <code>String</code> 类型。</p>
<blockquote>
<p>注意</p>
<p><code>airports</code> 字典被声明为变量（用 <code>var</code> 关键字）而不是常量（<code>let</code> 关键字）因为后来更多的机场信息会被添加到这个示例字典中。</p>
</blockquote>
<p><code>airports</code> 字典使用字典字面量初始化，包含两个键值对。第一对的键是 <code>YYZ</code>，值是 <code>Toronto Pearson</code>。第二对的键是 <code>DUB</code>，值是 <code>Dublin</code>。</p>
<p>这个字典语句包含了两个 <code>String: String</code> 类型的键值对。它们对应 <code>airports</code> 变量声明的类型（一个只有 <code>String</code> 键和 <code>String</code> 值的字典）所以这个字典字面量的任务是构造拥有两个初始数据项的 <code>airport</code> 字典。</p>
<p>和数组一样，我们在用字典字面量构造字典时，如果它的键和值都有各自一致的类型，那么就不必写出字典的类型。 <code>airports</code> 字典也可以用这种简短方式定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports <span class="operator">=</span> [<span class="string">&quot;YYZ&quot;</span>: <span class="string">&quot;Toronto Pearson&quot;</span>, <span class="string">&quot;DUB&quot;</span>: <span class="string">&quot;Dublin&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>因为这个语句中所有的键和值都各自拥有相同的数据类型，Swift 可以推断出 <code>Dictionary&lt;String, String&gt;</code> 是 <code>airports</code> 字典的正确类型。</p>
<h3 id="访问和修改字典">访问和修改字典</h3>
<p>我们可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。</p>
<p>和数组一样，我们可以通过字典的只读属性 <code>count</code> 来获取某个字典的数据项数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The dictionary of airports contains <span class="subst">\(airports.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“The dictionary of airports contains 2 items.”（这个字典有两个数据项）</span></span><br></pre></td></tr></table></figure>
<p>使用布尔属性 <code>isEmpty</code> 作为一个缩写形式去检查 <code>count</code> 属性是否为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> airports.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The airports dictionary is empty.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The airports dictionary is not empty.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The airports dictionary is not empty.”</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个恰当类型的键作为下标索引，并且分配恰当类型的新值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">&quot;LHR&quot;</span>] <span class="operator">=</span> <span class="string">&quot;London&quot;</span></span><br><span class="line"><span class="comment">// airports 字典现在有三个数据项</span></span><br></pre></td></tr></table></figure>
<p>我们也可以使用下标语法来改变特定键对应的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">&quot;LHR&quot;</span>] <span class="operator">=</span> <span class="string">&quot;London Heathrow&quot;</span></span><br><span class="line"><span class="comment">// “LHR”对应的值被改为“London Heathrow”</span></span><br></pre></td></tr></table></figure>
<p>作为另一种下标方法，字典的 <code>updateValue(_:forKey:)</code> 方法可以设置或者更新特定键对应的值。就像上面所示的下标示例，<code>updateValue(_:forKey:)</code> 方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和上面的下标方法不同的，<code>updateValue(_:forKey:)</code> 这个方法返回更新值之前的原值。这样使得我们可以检查更新是否成功。</p>
<p><code>updateValue(_:forKey:)</code> 方法会返回对应值的类型的可选值。举例来说：对于存储 <code>String</code> 值的字典，这个函数会返回一个 <code>String?</code> 或者“可选 <code>String</code>”类型的值。</p>
<p>如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue <span class="operator">=</span> airports.updateValue(<span class="string">&quot;Dublin Airport&quot;</span>, forKey: <span class="string">&quot;DUB&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The old value for DUB was <span class="subst">\(oldValue)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“The old value for DUB was Dublin.”</span></span><br></pre></td></tr></table></figure>
<p>我们也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回对应值的类型的可选值。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选值，否则将返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> airportName <span class="operator">=</span> airports[<span class="string">&quot;DUB&quot;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The name of the airport is <span class="subst">\(airportName)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;That airport is not in the airports dictionary.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The name of the airport is Dublin Airport.”</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用下标语法来通过给某个键的对应值赋值为 <code>nil</code> 来从字典里移除一个键值对：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">&quot;APL&quot;</span>] <span class="operator">=</span> <span class="string">&quot;Apple Internation&quot;</span></span><br><span class="line"><span class="comment">// “Apple Internation”不是真的 APL 机场，删除它</span></span><br><span class="line">airports[<span class="string">&quot;APL&quot;</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// APL 现在被移除了</span></span><br></pre></td></tr></table></figure>
<p>此外，<code>removeValue(forKey:)</code> 方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有值的情况下返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue <span class="operator">=</span> airports.removeValue(forKey: <span class="string">&quot;DUB&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The removed airport&#x27;s name is <span class="subst">\(removedValue)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The airports dictionary does not contain a value for DUB.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“The removed airport&#x27;s name is Dublin Airport.”</span></span><br></pre></td></tr></table></figure>
<h3 id="字典遍历">字典遍历</h3>
<p>我们可以使用 <code>for-in</code> 循环来遍历某个字典中的键值对。每一个字典中的数据项都以 <code>(key, value)</code> 元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(airportCode)</span>: <span class="subst">\(airportName)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// YYZ: Toronto Pearson</span></span><br><span class="line"><span class="comment">// LHR: London Heathrow</span></span><br></pre></td></tr></table></figure>
<p>更多关于 <code>for-in</code> 循环的信息，参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html#for_loops">For 循环</a>。</p>
<p>通过访问 <code>keys</code> 或者 <code>values</code> 属性，我们也可以遍历字典的键或者值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Airport code: <span class="subst">\(airportCode)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport code: YYZ</span></span><br><span class="line"><span class="comment">// Airport code: LHR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Airport name: <span class="subst">\(airportName)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport name: Toronto Pearson</span></span><br><span class="line"><span class="comment">// Airport name: London Heathrow</span></span><br></pre></td></tr></table></figure>
<p>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受 <code>Array</code> 实例的 API 的参数，可以直接使用 <code>keys</code> 或者 <code>values</code> 属性构造一个新数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> airportCodes <span class="operator">=</span> [<span class="type">String</span>](airports.keys)</span><br><span class="line"><span class="comment">// airportCodes 是 [&quot;YYZ&quot;, &quot;LHR&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> airportNames <span class="operator">=</span> [<span class="type">String</span>](airports.values)</span><br><span class="line"><span class="comment">// airportNames 是 [&quot;Toronto Pearson&quot;, &quot;London Heathrow&quot;]</span></span><br></pre></td></tr></table></figure>
<p>Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的 <code>keys</code> 或 <code>values</code> 属性使用 <code>sorted()</code> 方法。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/06/21/Swift/swift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/06/20/Swift/swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6/"
                            aria-label=": swift字符串和字符"
                        >
                            swift字符串和字符
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-20T10:13:17+08:00">
	
		    2023 年 6 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="字符串和字符">字符串和字符</h2>
<p><em>字符串</em>是是一系列字符的集合，例如 <code>&quot;hello, world&quot;</code>，<code>&quot;albatross&quot;</code>。Swift 的字符串通过 <code>String</code> 类型来表示。而 <code>String</code> 内容的访问方式有多种，例如以 <code>Character</code> 值的集合。</p>
<p>Swift 的 <code>String</code> 和 <code>Character</code> 类型提供了一种快速且兼容 Unicode 的方式来处理代码中的文本内容。创建和操作字符串的语法与 C 语言中字符串操作相似，轻量并且易读。通过 <code>+</code> 符号就可以非常简单的实现两个字符串的拼接操作。与 Swift 中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。你可以在已有字符串中插入常量、变量、字面量和表达式从而形成更长的字符串，这一过程也被成为字符串插值。尤其是在为显示、存储和打印创建自定义字符串值时，字符串插值操作尤其有用。</p>
<p>尽管语法简易，但 Swift 中的 <code>String</code> 类型的实现却很快速和现代化。每一个字符串都是由编码无关的 Unicode 字符组成，并支持访问字符的多种 Unicode 表示形式。</p>
<blockquote>
<p>注意</p>
<p>Swift 的 <code>String</code> 类型与 Foundation <code>NSString</code> 类进行了无缝桥接。Foundation 还对 <code>String</code> 进行扩展使其可以访问 <code>NSString</code> 类型中定义的方法。这意味着调用那些 <code>NSString</code> 的方法，你无需进行任何类型转换。</p>
<p>更多关于在 Foundation 和 Cocoa 中使用 <code>String</code> 的信息请查看 <em><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/string#2919514">Bridging Between String and NSString</a></em>。</p>
</blockquote>
<h2 id="字符串字面量">字符串字面量</h2>
<p>你可以在代码里使用一段预定义的字符串值作为字符串字面量。字符串字面量是由一对双引号包裹着的具有固定顺序的字符集。</p>
<p>字符串字面量可以用于为常量和变量提供初始值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someString <span class="operator">=</span> <span class="string">&quot;Some string literal value&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，Swift 之所以推断 <code>someString</code> 常量为字符串类型，是因为它使用了字面量方式进行初始化。</p>
<h3 id="多行字符串字面量">多行字符串字面量</h3>
<p>如果你需要一个字符串是跨越多行的，那就使用多行字符串字面量 — 由一对三个双引号包裹着的具有固定顺序的文本字符集：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">The White Rabbit put on his spectacles.  &quot;Where shall I begin,</span></span><br><span class="line"><span class="string">please your Majesty?&quot; he asked.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on</span></span><br><span class="line"><span class="string">till you come to the end; then stop.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>一个多行字符串字面量包含了所有的在开启和关闭引号（<code>&quot;&quot;&quot;</code>）中的行。这个字符从开启引号（<code>&quot;&quot;&quot;</code>）之后的第一行开始，到关闭引号（<code>&quot;&quot;&quot;</code>）之前为止。这就意味着字符串开启引号之后（<code>&quot;&quot;&quot;</code>）或者结束引号（<code>&quot;&quot;&quot;</code>）之前都没有换行符号。（译者：下面两个字符串其实是一样的，虽然第二个使用了多行字符串的形式）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleLineString <span class="operator">=</span> <span class="string">&quot;These are the same.&quot;</span></span><br><span class="line"><span class="keyword">let</span> multilineString <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">These are the same.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果你的代码中，多行字符串字面量包含换行符的话，则多行字符串字面量中也会包含换行符。如果你想换行，以便加强代码的可读性，但是你又不想在你的多行字符串字面量中出现换行符的话，你可以用在行尾写一个反斜杠（<code>\</code>）作为续行符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> softWrappedQuotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">The White Rabbit put on his spectacles.  &quot;Where shall I begin, <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>please your Majesty?&quot; he asked.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>till you come to the end; then stop.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>为了让一个多行字符串字面量开始和结束于换行符，请将换行写在第一行和最后一行，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lineBreaks <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This string starts with a line break.</span></span><br><span class="line"><span class="string">It also ends with a line break.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>一个多行字符串字面量能够缩进来匹配周围的代码。关闭引号（<code>&quot;&quot;&quot;</code>）之前的空白字符串告诉 Swift 编译器其他各行多少空白字符串需要忽略。然而，如果你在某行的前面写的空白字符串超出了关闭引号（<code>&quot;&quot;&quot;</code>）之前的空白字符串，则超出部分将被包含在多行字符串字面量中。</p>
<p><img src="https://docs.swift.org/swift-book/_images/multilineStringWhitespace_2x.png" alt=""></p>
<p>在上面的例子中，尽管整个多行字符串字面量都是缩进的（源代码缩进），第一行和最后一行没有以空白字符串开始（实际的变量值）。中间一行的缩进用空白字符串（源代码缩进）比关闭引号（<code>&quot;&quot;&quot;</code>）之前的空白字符串多，所以，它的行首将有4个空格。</p>
<h3 id="字符串字面量的特殊字符">字符串字面量的特殊字符</h3>
<p>字符串字面量可以包含以下特殊字符：</p>
<ul>
<li>转义字符 <code>\0</code>(空字符)、<code>\\</code>(反斜线)、<code>\t</code>(水平制表符)、<code>\n</code>(换行符)、<code>\r</code>(回车符)、<code>\&quot;</code>(双引号)、<code>\'</code>(单引号)。</li>
<li>Unicode 标量，写成 <code>\u&#123;n&#125;</code>(u 为小写)，其中 <code>n</code> 为任意一到八位十六进制数且可用的 Unicode 位码。</li>
</ul>
<p>下面的代码为各种特殊字符的使用示例。 <code>wiseWords</code> 常量包含了两个双引号。 <code>dollarSign</code>、<code>blackHeart</code> 和 <code>sparklingHeart</code> 常量演示了三种不同格式的 Unicode 标量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wiseWords <span class="operator">=</span> <span class="string">&quot;<span class="subst">\&quot;</span>Imagination is more important than knowledge<span class="subst">\&quot;</span> - Einstein&quot;</span></span><br><span class="line"><span class="comment">// &quot;Imageination is more important than knowledge&quot; - Enistein</span></span><br><span class="line"><span class="keyword">let</span> dollarSign <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;24&#125;</span>&quot;</span>             <span class="comment">// $，Unicode 标量 U+0024</span></span><br><span class="line"><span class="keyword">let</span> blackHeart <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;2665&#125;</span>&quot;</span>           <span class="comment">// ♥，Unicode 标量 U+2665</span></span><br><span class="line"><span class="keyword">let</span> sparklingHeart <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;1F496&#125;</span>&quot;</span>      <span class="comment">// 💖，Unicode 标量 U+1F496</span></span><br></pre></td></tr></table></figure>
<p>由于多行字符串字面量使用了三个双引号，而不是一个，所以你可以在多行字符串字面量里直接使用双引号（<code>&quot;</code>）而不必加上转义符（<code>\</code>）。要在多行字符串字面量中使用 <code>&quot;&quot;&quot;</code> 的话，就需要使用至少一个转义符（<code>\</code>）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> threeDoubleQuotes <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Escaping the first quote <span class="subst">\&quot;</span>&quot;&quot;</span></span><br><span class="line"><span class="string">Escaping all three quotes <span class="subst">\&quot;</span><span class="subst">\&quot;</span><span class="subst">\&quot;</span></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展字符串分隔符">扩展字符串分隔符</h3>
<p>您可以将字符串文字放在扩展分隔符中，这样字符串中的特殊字符将会被直接包含而非转义后的效果。将字符串放在引号（<strong>&quot;</strong>）中并用数字符号（<strong>＃</strong>）括起来。例如，打印字符串文字 <strong>＃“Line 1 \ nLine 2”＃</strong> 打印换行符转义序列（<strong>\n</strong>）而不是进行换行打印。</p>
<p>如果需要字符串文字中字符的特殊效果，请匹配转义字符（<strong>\</strong>）后面添加与起始位置个数相匹配的 <strong>#</strong> 符。 例如，如果您的字符串是 <strong>＃“Line 1 \ nLine 2”＃</strong> 并且您想要换行，则可以使用 <strong>＃“Line 1 \ #nLine 2”＃</strong> 来代替。 同样，<strong>###“Line1 \ ### nLine2”###</strong> 也可以实现换行效果。</p>
<p>扩展分隔符创建的字符串文字也可以是多行字符串文字。 您可以使用扩展分隔符在多行字符串中包含文本 <strong>“”&quot;</strong>，覆盖原有的结束文字的默认行为。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> threeMoreDoubleQuotationMarks <span class="operator">=</span> <span class="string">#&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Here are three more double quotes: &quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;#</span></span><br></pre></td></tr></table></figure>
<h2 id="初始化空字符串">初始化空字符串</h2>
<p>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的 <code>String</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyString <span class="operator">=</span> <span class="string">&quot;&quot;</span>               <span class="comment">// 空字符串字面量</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString <span class="operator">=</span> <span class="type">String</span>()  <span class="comment">// 初始化方法</span></span><br><span class="line"><span class="comment">// 两个字符串均为空并等价。</span></span><br></pre></td></tr></table></figure>
<p>你可以通过检查 <code>Bool</code> 类型的 <code>isEmpty</code> 属性来判断该字符串是否为空：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Nothing to see here&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出：“Nothing to see here”</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串可变性">字符串可变性</h2>
<p>你可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variableString <span class="operator">=</span> <span class="string">&quot;Horse&quot;</span></span><br><span class="line">variableString <span class="operator">+=</span> <span class="string">&quot; and carriage&quot;</span></span><br><span class="line"><span class="comment">// variableString 现在为 &quot;Horse and carriage&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> constantString <span class="operator">=</span> <span class="string">&quot;Highlander&quot;</span></span><br><span class="line">constantString <span class="operator">+=</span> <span class="string">&quot; and another Highlander&quot;</span></span><br><span class="line"><span class="comment">// 这会报告一个编译错误（compile-time error） - 常量字符串不可以被修改。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>在 Objective-C 和 Cocoa 中，需要通过选择两个不同的类（<code>NSString</code> 和 <code>NSMutableString</code>）来指定字符串是否可以被修改。</p>
</blockquote>
<h2 id="字符串是值类型">字符串是值类型</h2>
<p>在 Swift 中 <code>String</code> 类型是<em>值类型</em>。如果你创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。在前述任一情况下，都会对已有字符串值创建新副本，并对该新副本而非原始字符串进行传递或赋值操作。值类型在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/09_Classes_and_Structures.md#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a> 中进行了详细描述。</p>
<p>Swift 默认拷贝字符串的行为保证了在函数/方法向你传递的字符串所属权属于你，无论该值来自于哪里。你可以确信传递的字符串不会被修改，除非你自己去修改它。</p>
<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着你将字符串作为值类型的同时可以获得极高的性能。</p>
<h2 id="使用字符">使用字符</h2>
<p>你可通过 <code>for-in</code> 循环来遍历字符串，获取字符串中每一个字符的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">&quot;Dog!🐶&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// !</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>
<p><code>for-in</code> 循环在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html#for_loops">For 循环</a> 中进行了详细描述。</p>
<p>另外，通过标明一个 <code>Character</code> 类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span></span><br></pre></td></tr></table></figure>
<p>字符串可以通过传递一个值类型为 <code>Character</code> 的数组作为自变量来初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] <span class="operator">=</span> [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> catString <span class="operator">=</span> <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)</span><br><span class="line"><span class="comment">// 打印输出：“Cat!🐱”</span></span><br></pre></td></tr></table></figure>
<h2 id="连接字符串和字符">连接字符串和字符</h2>
<p>字符串可以通过加法运算符（<code>+</code>）相加在一起（或称“连接”）创建一个新的字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> string2 <span class="operator">=</span> <span class="string">&quot; there&quot;</span></span><br><span class="line"><span class="keyword">var</span> welcome <span class="operator">=</span> string1 <span class="operator">+</span> string2</span><br><span class="line"><span class="comment">// welcome 现在等于 &quot;hello there&quot;</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过加法赋值运算符（<code>+=</code>）将一个字符串添加到一个已经存在字符串变量上：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instruction <span class="operator">=</span> <span class="string">&quot;look over&quot;</span></span><br><span class="line">instruction <span class="operator">+=</span> string2</span><br><span class="line"><span class="comment">// instruction 现在等于 &quot;look over there&quot;</span></span><br></pre></td></tr></table></figure>
<p>你可以用 <code>append()</code> 方法将一个字符附加到一个字符串变量的尾部：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">welcome.append(exclamationMark)</span><br><span class="line"><span class="comment">// welcome 现在等于 &quot;hello there!&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>你不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。</p>
</blockquote>
<p>如果你需要使用多行字符串字面量来拼接字符串，并且你需要字符串每一行都以换行符结尾，包括最后一行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> badStart <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one</span></span><br><span class="line"><span class="string">two</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> end <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">three</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(badStart <span class="operator">+</span> end)</span><br><span class="line"><span class="comment">// 打印两行:</span></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// twothree</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> goodStart <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">one</span></span><br><span class="line"><span class="string">two</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(goodStart <span class="operator">+</span> end)</span><br><span class="line"><span class="comment">// 打印三行:</span></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，把 <code>badStart</code> 和 <code>end</code> 拼接起来的字符串非我们想要的结果。因为 <code>badStart</code> 最后一行没有换行符，它与 <code>end</code> 的第一行结合到了一起。相反的，<code>goodStart</code> 的每一行都以换行符结尾，所以它与 <code>end</code> 拼接的字符串总共有三行，正如我们期望的那样。</p>
<h2 id="字符串插值">字符串插值</h2>
<p><em>字符串插值</em>是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。<strong>字符串字面量</strong>和<strong>多行字符串字面量</strong>都可以使用字符串插值。你插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiplier <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> message <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(multiplier)</span> times 2.5 is <span class="subst">\(Double(multiplier) <span class="operator">*</span> <span class="number">2.5</span>)</span>&quot;</span></span><br><span class="line"><span class="comment">// message 是 &quot;3 times 2.5 is 7.5&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>multiplier</code> 作为 <code>\(multiplier)</code> 被插入到一个字符串常量量中。当创建字符串执行插值计算时此占位符会被替换为 <code>multiplier</code> 实际的值。</p>
<p><code>multiplier</code> 的值也作为字符串中后面表达式的一部分。该表达式计算 <code>Double(multiplier) * 2.5</code> 的值并将结果（<code>7.5</code>）插入到字符串中。在这个例子中，表达式写为 <code>\(Double(multiplier) * 2.5)</code> 并包含在字符串字面量中。</p>
<blockquote>
<p>注意</p>
<p>插值字符串中写在括号中的表达式不能包含非转义反斜杠（<code>\</code>），并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p>
</blockquote>
<h2 id="Unicode">Unicode</h2>
<p><em>Unicode</em>是一个用于在不同书写系统中对文本进行编码、表示和处理的国际标准。它使你可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。Swift 的 <code>String</code> 和 <code>Character</code> 类型是完全兼容 Unicode 标准的。</p>
<h3 id="Unicode-标量">Unicode 标量</h3>
<p>Swift 的 <code>String</code> 类型是基于 <em>Unicode 标量</em> 建立的。Unicode 标量是对应字符或者修饰符的唯一的 21 位数字，例如 <code>U+0061</code> 表示小写的拉丁字母（<code>LATIN SMALL LETTER A</code>）（“<code>a</code>”），<code>U+1F425</code> 表示小鸡表情（<code>FRONT-FACING BABY CHICK</code>）（“<code>🐥</code>”）。</p>
<p>请注意，并非所有 21 位 Unicode 标量值都分配给字符，某些标量被保留用于将来分配或用于 UTF-16 编码。已分配的标量值通常也有一个名称，例如上面示例中的 LATIN SMALL LETTER A 和 FRONT-FACING BABY CHICK。</p>
<h3 id="可扩展的字形群集">可扩展的字形群集</h3>
<p>每一个 Swift 的 <code>Character</code> 类型代表一个<em>可扩展的字形群</em>。而一个可扩展的字形群构成了人类可读的单个字符，它由一个或多个（当组合时） Unicode 标量的序列组成。</p>
<p>举个例子，字母 <code>é</code> 可以用单一的 Unicode 标量 <code>é</code>(<code>LATIN SMALL LETTER E WITH ACUTE</code>, 或者 <code>U+00E9</code>)来表示。然而一个标准的字母 <code>e</code>(<code>LATIN SMALL LETTER E</code> 或者 <code>U+0065</code>) 加上一个急促重音（<code>COMBINING ACTUE ACCENT</code>）的标量（<code>U+0301</code>），这样一对标量就表示了同样的字母 <code>é</code>。 这个急促重音的标量形象的将 <code>e</code> 转换成了 <code>é</code>。</p>
<p>在这两种情况中，字母 <code>é</code> 代表了一个单一的 Swift 的 <code>Character</code> 值，同时代表了一个可扩展的字形群。在第一种情况，这个字形群包含一个单一标量；而在第二种情况，它是包含两个标量的字形群：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;E9&#125;</span>&quot;</span>                         <span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;65&#125;</span><span class="subst">\u&#123;301&#125;</span>&quot;</span>          <span class="comment">// e 后面加上  ́</span></span><br><span class="line"><span class="comment">// eAcute 是 é, combinedEAcute 是 é</span></span><br></pre></td></tr></table></figure>
<p>可扩展的字形集是一个将许多复杂的脚本字符表示为单个字符值的灵活方式。例如，来自朝鲜语字母表的韩语音节能表示为组合或分解的有序排列。在 Swift 都会表示为同一个单一的 <code>Character</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> precomposed: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;D55C&#125;</span>&quot;</span>                  <span class="comment">// 한</span></span><br><span class="line"><span class="keyword">let</span> decomposed: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;1112&#125;</span><span class="subst">\u&#123;1161&#125;</span><span class="subst">\u&#123;11AB&#125;</span>&quot;</span>   <span class="comment">// ᄒ, ᅡ, ᆫ</span></span><br><span class="line"><span class="comment">// precomposed 是 한, decomposed 是 한</span></span><br></pre></td></tr></table></figure>
<p>可拓展的字符群集可以使包围记号（例如 <code>COMBINING ENCLOSING CIRCLE</code> 或者 <code>U+20DD</code>）的标量包围其他 Unicode 标量，作为一个单一的 <code>Character</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enclosedEAcute: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;E9&#125;</span><span class="subst">\u&#123;20DD&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">// enclosedEAcute 是 é⃝</span></span><br></pre></td></tr></table></figure>
<p>地域性指示符号的 Unicode 标量可以组合成一个单一的 <code>Character</code> 值，例如 <code>REGIONAL INDICATOR SYMBOL LETTER U</code>(<code>U+1F1FA</code>)和 <code>REGIONAL INDICATOR SYMBOL LETTER S</code>(<code>U+1F1F8</code>)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regionalIndicatorForUS: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;1F1FA&#125;</span><span class="subst">\u&#123;1F1F8&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">// regionalIndicatorForUS 是 🇺🇸</span></span><br></pre></td></tr></table></figure>
<h2 id="计算字符数量">计算字符数量</h2>
<p>如果想要获得一个字符串中 <code>Character</code> 值的数量，可以使用 <code>count</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusualMenagerie <span class="operator">=</span> <span class="string">&quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;unusualMenagerie has <span class="subst">\(unusualMenagerie.count)</span> characters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印输出“unusualMenagerie has 40 characters”</span></span><br></pre></td></tr></table></figure>
<p>注意在 Swift 中，使用可拓展的字符群集作为 <code>Character</code> 值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>
<p>例如，如果你用四个字符的单词 <code>cafe</code> 初始化一个新的字符串，然后添加一个 <code>COMBINING ACTUE ACCENT</code>(<code>U+0301</code>)作为字符串的结尾。最终这个字符串的字符数量仍然是 <code>4</code>，因为第四个字符是 <code>é</code>，而不是 <code>e</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word <span class="operator">=</span> <span class="string">&quot;cafe&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.count)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印输出“the number of characters in cafe is 4”</span></span><br><span class="line"></span><br><span class="line">word <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;301&#125;</span>&quot;</span>    <span class="comment">// 拼接一个重音，U+0301</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.count)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印输出“the number of characters in café is 4”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>可扩展的字形群可以由多个 Unicode 标量组成。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果你正在处理一个长字符串，需要注意 <code>count</code> 属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。</p>
<p>另外需要注意的是通过 <code>count</code> 属性返回的字符数量并不总是与包含相同字符的 <code>NSString</code> 的 <code>length</code> 属性相同。<code>NSString</code> 的 <code>length</code> 属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。</p>
</blockquote>
<h2 id="访问和修改字符串">访问和修改字符串</h2>
<p>你可以通过字符串的属性和方法来访问和修改它，当然也可以用下标语法完成。</p>
<h3 id="字符串索引">字符串索引</h3>
<p>每一个 <code>String</code> 值都有一个关联的索引（<em>index</em>）类型，<code>String.Index</code>，它对应着字符串中的每一个 <code>Character</code> 的位置。</p>
<p>前面提到，不同的字符可能会占用不同数量的内存空间，所以要知道 <code>Character</code> 的确定位置，就必须从 <code>String</code> 开头遍历每一个 Unicode 标量直到结尾。因此，Swift 的字符串不能用整数（integer）做索引。</p>
<p>使用 <code>startIndex</code> 属性可以获取一个 <code>String</code> 的第一个 <code>Character</code> 的索引。使用 <code>endIndex</code> 属性可以获取最后一个 <code>Character</code> 的后一个位置的索引。因此，<code>endIndex</code> 属性不能作为一个字符串的有效下标。如果 <code>String</code> 是空串，<code>startIndex</code> 和 <code>endIndex</code> 是相等的。</p>
<p>通过调用 <code>String</code> 的 <code>index(before:)</code> 或 <code>index(after:)</code> 方法，可以立即得到前面或后面的一个索引。你还可以通过调用 <code>index(_:offsetBy:)</code> 方法来获取对应偏移量的索引，这种方式可以避免多次调用 <code>index(before:)</code> 或 <code>index(after:)</code> 方法。</p>
<p>你可以使用下标语法来访问 <code>String</code> 特定索引的 <code>Character</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Guten Tag!&quot;</span></span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line"><span class="comment">// !</span></span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line"><span class="comment">// u</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.index(greeting.startIndex, offsetBy: <span class="number">7</span>)</span><br><span class="line">greeting[index]</span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>
<p>试图获取越界索引对应的 <code>Character</code>，将引发一个运行时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greeting[greeting.endIndex] <span class="comment">// error</span></span><br><span class="line">greeting.index(after: endIndex) <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>indices</code> 属性会创建一个包含全部索引的范围（<code>Range</code>），用来在一个字符串中访问单个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.indices &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(greeting[index])</span> &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出“G u t e n   T a g ! ”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>你可以使用 <code>startIndex</code> 和 <code>endIndex</code> 属性或者 <code>index(before:)</code> 、<code>index(after:)</code> 和 <code>index(_:offsetBy:)</code> 方法在任意一个确认的并遵循 <code>Collection</code> 协议的类型里面，如上文所示是使用在 <code>String</code> 中，你也可以使用在 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中。</p>
</blockquote>
<h3 id="插入和删除">插入和删除</h3>
<p>调用 <code>insert(_:at:)</code> 方法可以在一个字符串的指定索引插入一个字符，调用 <code>insert(contentsOf:at:)</code> 方法可以在一个字符串的指定索引插入一个段字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">welcome.insert(<span class="string">&quot;!&quot;</span>, at: welcome.endIndex)</span><br><span class="line"><span class="comment">// welcome 变量现在等于 &quot;hello!&quot;</span></span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf:<span class="string">&quot; there&quot;</span>, at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="comment">// welcome 变量现在等于 &quot;hello there!&quot;</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>remove(at:)</code> 方法可以在一个字符串的指定索引删除一个字符，调用 <code>removeSubrange(_:)</code> 方法可以在一个字符串的指定索引删除一个子字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="comment">// welcome 现在等于 &quot;hello there&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> range <span class="operator">=</span> welcome.index(welcome.endIndex, offsetBy: <span class="operator">-</span><span class="number">6</span>)<span class="operator">..&lt;</span>welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line"><span class="comment">// welcome 现在等于 &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>你可以使用 <code>insert(_:at:)</code>、<code>insert(contentsOf:at:)</code>、<code>remove(at:)</code> 和 <code>removeSubrange(_:)</code> 方法在任意一个确认的并遵循 <code>RangeReplaceableCollection</code> 协议的类型里面，如上文所示是使用在 <code>String</code> 中，你也可以使用在 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中。</p>
</blockquote>
<h2 id="子字符串">子字符串</h2>
<p>当你从字符串中获取一个子字符串 —— 例如，使用下标或者 <code>prefix(_:)</code> 之类的方法 —— 就可以得到一个 <code>SubString</code> 的实例，而非另外一个 <code>String</code>。Swift 里的 <code>SubString</code> 绝大部分函数都跟 <code>String</code> 一样，意味着你可以使用同样的方式去操作 <code>SubString</code> 和 <code>String</code>。然而，跟 <code>String</code> 不同的是，你只有在短时间内需要操作字符串时，才会使用 <code>SubString</code>。当你需要长时间保存结果时，就把 <code>SubString</code> 转化为 <code>String</code> 的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.firstIndex(of: <span class="string">&quot;,&quot;</span>) <span class="operator">??</span> greeting.endIndex</span><br><span class="line"><span class="keyword">let</span> beginning <span class="operator">=</span> greeting[<span class="operator">..&lt;</span>index]</span><br><span class="line"><span class="comment">// beginning 的值为 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把结果转化为 String 以便长期存储。</span></span><br><span class="line"><span class="keyword">let</span> newString <span class="operator">=</span> <span class="type">String</span>(beginning)</span><br></pre></td></tr></table></figure>
<p>就像 <code>String</code>，每一个 <code>SubString</code> 都会在内存里保存字符集。而 <code>String</code> 和 <code>SubString</code> 的区别在于性能优化上，<code>SubString</code> 可以重用原 <code>String</code> 的内存空间，或者另一个 <code>SubString</code> 的内存空间（<code>String</code> 也有同样的优化，但如果两个 <code>String</code> 共享内存的话，它们就会相等）。这一优化意味着你在修改 <code>String</code> 和 <code>SubString</code> 之前都不需要消耗性能去复制内存。就像前面说的那样，<code>SubString</code> 不适合长期存储 —— 因为它重用了原 <code>String</code> 的内存空间，原 <code>String</code> 的内存空间必须保留直到它的 <code>SubString</code> 不再被使用为止。</p>
<p>上面的例子，<code>greeting</code> 是一个 <code>String</code>，意味着它在内存里有一片空间保存字符集。而由于 <code>beginning</code> 是 <code>greeting</code> 的 <code>SubString</code>，它重用了 <code>greeting</code> 的内存空间。相反，<code>newString</code> 是一个 <code>String</code> —— 它是使用 <code>SubString</code> 创建的，拥有一片自己的内存空间。下面的图展示了他们之间的关系：</p>
<p><img src="https://docs.swift.org/swift-book/_images/stringSubstring_2x.png" alt=""></p>
<blockquote>
<p>注意</p>
<p><code>String</code> 和 <code>SubString</code> 都遵循 <code>StringProtocol&lt;//apple_ref/swift/intf/s:s14StringProtocolP&gt;</code> 协议，这意味着操作字符串的函数使用 <code>StringProtocol</code> 会更加方便。你可以传入 <code>String</code> 或 <code>SubString</code> 去调用函数。</p>
</blockquote>
<h2 id="比较字符串">比较字符串</h2>
<p>Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。</p>
<h3 id="字符串-字符相等">字符串/字符相等</h3>
<p>字符串/字符可以用等于操作符（<code>==</code>）和不等于操作符（<code>!=</code>），详细描述在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/02_Basic_Operators.html#comparison_operators">比较运算符</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation <span class="operator">=</span> <span class="string">&quot;We&#x27;re a lot alike, you and I.&quot;</span></span><br><span class="line"><span class="keyword">let</span> sameQuotation <span class="operator">=</span> <span class="string">&quot;We&#x27;re a lot alike, you and I.&quot;</span></span><br><span class="line"><span class="keyword">if</span> quotation <span class="operator">==</span> sameQuotation &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two strings are considered equal&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出“These two strings are considered equal”</span></span><br></pre></td></tr></table></figure>
<p>如果两个字符串（或者两个字符）的可扩展的字形群集是标准相等，那就认为它们是相等的。只要可扩展的字形群集有同样的语言意义和外观则认为它们标准相等，即使它们是由不同的 Unicode 标量构成。</p>
<p>例如，<code>LATIN SMALL LETTER E WITH ACUTE</code>(<code>U+00E9</code>)就是标准相等于 <code>LATIN SMALL LETTER E</code>(<code>U+0065</code>)后面加上 <code>COMBINING ACUTE ACCENT</code>(<code>U+0301</code>)。这两个字符群集都是表示字符 <code>é</code> 的有效方式，所以它们被认为是标准相等的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;Voulez-vous un café?&quot; 使用 LATIN SMALL LETTER E WITH ACUTE</span></span><br><span class="line"><span class="keyword">let</span> eAcuteQuestion <span class="operator">=</span> <span class="string">&quot;Voulez-vous un caf<span class="subst">\u&#123;E9&#125;</span>?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Voulez-vous un café?&quot; 使用 LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcuteQuestion <span class="operator">=</span> <span class="string">&quot;Voulez-vous un caf<span class="subst">\u&#123;65&#125;</span><span class="subst">\u&#123;301&#125;</span>?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> eAcuteQuestion <span class="operator">==</span> combinedEAcuteQuestion &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two strings are considered equal&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出“These two strings are considered equal”</span></span><br></pre></td></tr></table></figure>
<p>相反，英语中的 <code>LATIN CAPITAL LETTER A</code>(<code>U+0041</code>，或者 <code>A</code>)不等于俄语中的 <code>CYRILLIC CAPITAL LETTER A</code>(<code>U+0410</code>，或者 <code>A</code>)。两个字符看着是一样的，但却有不同的语言意义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> latinCapitalLetterA: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;41&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cyrillicCapitalLetterA: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;0410&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> latinCapitalLetterA <span class="operator">!=</span> cyrillicCapitalLetterA &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two characters are not equivalent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“These two characters are not equivalent”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>在 Swift 中，字符串和字符并不区分地域（not locale-sensitive）。</p>
</blockquote>
<h3 id="前缀-后缀相等">前缀/后缀相等</h3>
<p>通过调用字符串的 <code>hasPrefix(_:)</code>/<code>hasSuffix(_:)</code> 方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个 <code>String</code> 类型的参数，并返回一个布尔值。</p>
<p>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> romeoAndJuliet <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 1: Verona, A public place&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 2: Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 3: A room in Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 4: A street outside Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 1 Scene 5: The Great Hall in Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 1: Outside Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 2: Capulet&#x27;s orchard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 3: Outside Friar Lawrence&#x27;s cell&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 4: A street in Verona&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 5: Capulet&#x27;s mansion&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Act 2 Scene 6: Friar Lawrence&#x27;s cell&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>你可以调用 <code>hasPrefix(_:)</code> 方法来计算话剧中第一幕的场景数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> act1SceneCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasPrefix(<span class="string">&quot;Act 1 &quot;</span>) &#123;</span><br><span class="line">        act1SceneCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are <span class="subst">\(act1SceneCount)</span> scenes in Act 1&quot;</span>)</span><br><span class="line"><span class="comment">// 打印输出“There are 5 scenes in Act 1”</span></span><br></pre></td></tr></table></figure>
<p>相似地，你可以用 <code>hasSuffix(_:)</code> 方法来计算发生在不同地方的场景数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mansionCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> cellCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasSuffix(<span class="string">&quot;Capulet&#x27;s mansion&quot;</span>) &#123;</span><br><span class="line">        mansionCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> scene.hasSuffix(<span class="string">&quot;Friar Lawrence&#x27;s cell&quot;</span>) &#123;</span><br><span class="line">        cellCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(mansionCount)</span> mansion scenes; <span class="subst">\(cellCount)</span> cell scenes&quot;</span>)</span><br><span class="line"><span class="comment">// 打印输出“6 mansion scenes; 2 cell scenes”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p><code>hasPrefix(_:)</code> 和 <code>hasSuffix(_:)</code> 方法都是在每个字符串中逐字符比较其可扩展的字符群集是否标准相等，详细描述在 <a href="#string_and_character_equality">字符串/字符相等</a>。</p>
</blockquote>
<h2 id="字符串的-Unicode-表示形式">字符串的 Unicode 表示形式</h2>
<p>当一个 Unicode 字符串被写进文本文件或者其他储存时，字符串中的 Unicode 标量会用 Unicode 定义的几种 <code>编码格式</code>（encoding forms）编码。每一个字符串中的小块编码都被称 <code>代码单元</code>（code units）。这些包括 UTF-8 编码格式（编码字符串为 8 位的代码单元）， UTF-16 编码格式（编码字符串位 16 位的代码单元），以及 UTF-32 编码格式（编码字符串32位的代码单元）。</p>
<p>Swift 提供了几种不同的方式来访问字符串的 Unicode 表示形式。你可以利用 <code>for-in</code> 来对字符串进行遍历，从而以 Unicode 可扩展的字符群集的方式访问每一个 <code>Character</code> 值。该过程在 <a href="#working_with_characters">使用字符</a> 中进行了描述。</p>
<p>另外，能够以其他三种 Unicode 兼容的方式访问字符串的值：</p>
<ul>
<li>UTF-8 代码单元集合（利用字符串的 <code>utf8</code> 属性进行访问）</li>
<li>UTF-16 代码单元集合（利用字符串的 <code>utf16</code> 属性进行访问）</li>
<li>21 位的 Unicode 标量值集合，也就是字符串的 UTF-32 编码格式（利用字符串的 <code>unicodeScalars</code> 属性进行访问）</li>
</ul>
<p>下面由 <code>D</code>,<code>o</code>,<code>g</code>,<code>‼</code>(<code>DOUBLE EXCLAMATION MARK</code>, Unicode 标量 <code>U+203C</code>)和 <code>🐶</code>(<code>DOG FACE</code>，Unicode 标量为 <code>U+1F436</code>)组成的字符串中的每一个字符代表着一种不同的表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dogString <span class="operator">=</span> <span class="string">&quot;Dog‼🐶&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="UTF-8-表示">UTF-8 表示</h3>
<p>你可以通过遍历 <code>String</code> 的 <code>utf8</code> 属性来访问它的 <code>UTF-8</code> 表示。其为 <code>String.UTF8View</code> 类型的属性，<code>UTF8View</code> 是无符号 8 位（<code>UInt8</code>）值的集合，每一个 <code>UInt8</code> 值都是一个字符的 UTF-8 表示：</p>
<table><tbody><tr height="77"><td>Character</td><td>D<br>U+0044</td><td>o<br>U+006F</td><td>g<br>U+0067</td><td colspan="3">‼<br>U+203C</td><td colspan="4">🐶<br>U+1F436</td></tr><tr height="77"><td>UTF-8<br>Code Unit</td><td>68</td><td>111</td><td>103</td><td>226</td><td>128</td><td>188</td><td>240</td><td>159</td><td>144</td><td>182</td></tr><tr><td>Position</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf8 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(codeUnit)</span> &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 68 111 103 226 128 188 240 159 144 182</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，前三个 10 进制 <code>codeUnit</code> 值（<code>68</code>、<code>111</code>、<code>103</code>）代表了字符 <code>D</code>、<code>o</code> 和 <code>g</code>，它们的 UTF-8 表示与 ASCII 表示相同。接下来的三个 10 进制 <code>codeUnit</code> 值（<code>226</code>、<code>128</code>、<code>188</code>）是 <code>DOUBLE EXCLAMATION MARK</code> 的3字节 UTF-8 表示。最后的四个 <code>codeUnit</code> 值（<code>240</code>、<code>159</code>、<code>144</code>、<code>182</code>）是 <code>DOG FACE</code> 的4字节 UTF-8 表示。</p>
<h3 id="UTF-16-表示">UTF-16 表示</h3>
<p>你可以通过遍历 <code>String</code> 的 <code>utf16</code> 属性来访问它的 <code>UTF-16</code> 表示。其为 <code>String.UTF16View</code> 类型的属性，<code>UTF16View</code> 是无符号16位（<code>UInt16</code>）值的集合，每一个 <code>UInt16</code> 都是一个字符的 UTF-16 表示：</p>
<table><tbody><tr height="77"><td>Character</td><td>D<br>U+0044</td><td>o<br>U+006F</td><td>g<br>U+0067</td><td>‼<br>U+203C</td><td colspan="2">🐶<br>U+1F436</td></tr><tr height="77"><td>UTF-16<br>Code Unit</td><td>68</td><td>111</td><td>103</td><td>8252</td><td>55357</td><td>56374</td></tr><tr><td>Position</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr></tbody></table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf16 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(codeUnit)</span> &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 68 111 103 8252 55357 56374</span></span><br></pre></td></tr></table></figure>
<p>同样，前三个 <code>codeUnit</code> 值（<code>68</code>、<code>111</code>、<code>103</code>）代表了字符 <code>D</code>、<code>o</code> 和 <code>g</code>，它们的 UTF-16 代码单元和 UTF-8 完全相同（因为这些 Unicode 标量表示 ASCII 字符）。</p>
<p>第四个 <code>codeUnit</code> 值（<code>8252</code>）是一个等于十六进制 <code>203C</code> 的的十进制值。这个代表了 <code>DOUBLE EXCLAMATION MARK</code> 字符的 Unicode 标量值 <code>U+203C</code>。这个字符在 UTF-16 中可以用一个代码单元表示。</p>
<p>第五和第六个 <code>codeUnit</code> 值（<code>55357</code> 和 <code>56374</code>）是 <code>DOG FACE</code> 字符的 UTF-16 表示。第一个值为 <code>U+D83D</code>(十进制值为 <code>55357</code>)，第二个值为 <code>U+DC36</code>(十进制值为 <code>56374</code>)。</p>
<h3 id="Unicode-标量表示">Unicode 标量表示</h3>
<p>你可以通过遍历 <code>String</code> 值的 <code>unicodeScalars</code> 属性来访问它的 Unicode 标量表示。其为 <code>UnicodeScalarView</code> 类型的属性，<code>UnicodeScalarView</code> 是 <code>UnicodeScalar</code> 类型的值的集合。</p>
<p>每一个 <code>UnicodeScalar</code> 拥有一个 <code>value</code> 属性，可以返回对应的 21 位数值，用 <code>UInt32</code> 来表示：</p>
<table><tbody><tr height="77"><td>Character</td><td>D<br>U+0044</td><td>o<br>U+006F</td><td>g<br>U+0067</td><td>‼<br>U+203C</td><td>🐶<br>U+1F436</td></tr><tr height="77"><td>Unicode Scalar<br>Code Unit</td><td>68</td><td>111</td><td>103</td><td>8252</td><td>128054</td></tr><tr><td>Position</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(scalar.value)</span> &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 68 111 103 8252 128054</span></span><br></pre></td></tr></table></figure>
<p>前三个 <code>UnicodeScalar</code> 值（<code>68</code>、<code>111</code>、<code>103</code>）的 <code>value</code> 属性仍然代表字符 <code>D</code>、<code>o</code> 和 <code>g</code>。</p>
<p>第四个 <code>codeUnit</code> 值（<code>8252</code>）仍然是一个等于十六进制 <code>203C</code> 的十进制值。这个代表了 <code>DOUBLE EXCLAMATION MARK</code> 字符的 Unicode 标量 <code>U+203C</code>。</p>
<p>第五个 <code>UnicodeScalar</code> 值的 <code>value</code> 属性，<code>128054</code>，是一个十六进制 <code>1F436</code> 的十进制表示。其等同于 <code>DOG FACE</code> 的 Unicode 标量 <code>U+1F436</code>。</p>
<p>作为查询它们的 <code>value</code> 属性的一种替代方法，每个 <code>UnicodeScalar</code> 值也可以用来构建一个新的 <code>String</code> 值，比如在字符串插值中使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(scalar)</span> &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// ‼</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/06/20/Swift/swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/06/19/Swift/swift%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E7%AC%A6/"
                            aria-label=": swift基础运算符"
                        >
                            swift基础运算符
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-19T10:13:17+08:00">
	
		    2023 年 6 月 19 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="基本运算符">基本运算符</h2>
<p><em>运算符</em>是检查、改变、合并值的特殊符号或短语。例如，加号（<code>+</code>）将两个数相加（如 <code>let i = 1 + 2</code>）。更复杂的运算例子包括逻辑与运算符 <code>&amp;&amp;</code>（如 <code>if enteredDoorCode &amp;&amp; passedRetinaScan</code>）。</p>
<p>Swift 支持大部分标准 C 语言的运算符，且为了减少常见编码错误做了部分改进。如：赋值符（<code>=</code>）不再有返回值，这样就消除了手误将判等运算符（<code>==</code>）写成赋值符导致代码错误的缺陷。算术运算符（<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code> 等）的结果会被检测并禁止值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。当然允许你使用 Swift 的溢出运算符来实现溢出。详情参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/26_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>
<p>Swift 还提供了 C 语言没有的区间运算符，例如 <code>a..&lt;b</code> 或 <code>a...b</code>，这方便我们表达一个区间内的数值。</p>
<p>本章节只描述了 Swift 中的基本运算符，<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/26_Advanced_Operators.html">高级运算符</a> 这章会包含 Swift 中的高级运算符，及如何自定义运算符，及如何进行自定义类型的运算符重载。</p>
<h2 id="术语">术语</h2>
<p>运算符分为一元、二元和三元运算符:</p>
<ul>
<li><em>一元</em>运算符对单一操作对象操作（如 <code>-a</code>）。一元运算符分前置运算符和后置运算符，<em>前置运算符</em>需紧跟在操作对象之前（如 <code>!b</code>），<em>后置运算符</em>需紧跟在操作对象之后（如 <code>c!</code>）。</li>
<li><em>二元</em>运算符操作两个操作对象（如 <code>2 + 3</code>），是<em>中置</em>的，因为它们出现在两个操作对象之间。</li>
<li><em>三元</em>运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三目运算符（<code>a ? b : c</code>）。</li>
</ul>
<p>受运算符影响的值叫<em>操作数</em>，在表达式 <code>1 + 2</code> 中，加号 <code>+</code> 是二元运算符，它的两个操作数是值 <code>1</code> 和 <code>2</code>。</p>
<h2 id="赋值运算符">赋值运算符</h2>
<p><em>赋值运算符</em>（<code>a = b</code>），表示用 <code>b</code> 的值来初始化或更新 <code>a</code> 的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">a <span class="operator">=</span> b</span><br><span class="line"><span class="comment">// a 现在等于 10</span></span><br></pre></td></tr></table></figure>
<p>如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) <span class="operator">=</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 现在 x 等于 1，y 等于 2</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以下面语句是无效的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x <span class="operator">=</span> y &#123;</span><br><span class="line">    <span class="comment">// 此句错误，因为 x = y 并不返回任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将 <code>if x = y</code> 标记为无效语句，Swift 能帮你避免把 （<code>==</code>）错写成（<code>=</code>）这类错误的出现。</p>
<h2 id="算术运算符">算术运算符</h2>
<p>Swift 中所有数值类型都支持了基本的四则<em>算术运算符</em>：</p>
<ul>
<li>加法（<code>+</code>）</li>
<li>减法（<code>-</code>）</li>
<li>乘法（<code>*</code>）</li>
<li>除法（<code>/</code>）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="operator">+</span> <span class="number">2</span>       <span class="comment">// 等于 3</span></span><br><span class="line"><span class="number">5</span> <span class="operator">-</span> <span class="number">3</span>       <span class="comment">// 等于 2</span></span><br><span class="line"><span class="number">2</span> <span class="operator">*</span> <span class="number">3</span>       <span class="comment">// 等于 6</span></span><br><span class="line"><span class="number">10.0</span> <span class="operator">/</span> <span class="number">2.5</span>  <span class="comment">// 等于 4.0</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言和 Objective-C 不同的是，Swift 默认情况下不允许在数值运算中出现溢出情况。但是你可以使用 Swift 的溢出运算符来实现溢出运算（如 <code>a &amp;+ b</code>）。详情参见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/26_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>
<p>加法运算符也可用于 <code>String</code> 的拼接：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello, &quot;</span> <span class="operator">+</span> <span class="string">&quot;world&quot;</span>  <span class="comment">// 等于 &quot;hello, world&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="求余运算符">求余运算符</h3>
<p><em>求余运算符</em>（<code>a % b</code>）是计算 <code>b</code> 的多少倍刚刚好可以容入 <code>a</code>，返回多出来的那部分（余数）。</p>
<blockquote>
<p>注意</p>
<p>求余运算符（<code>%</code>）在其他语言也叫<em>取模运算符</em>。但是严格说来，我们看该运算符对负数的操作结果，「求余」比「取模」更合适些。</p>
</blockquote>
<p>我们来谈谈取余是怎么回事，计算 <code>9 % 4</code>，你先计算出 <code>4</code> 的多少倍会刚好可以容入 <code>9</code> 中：</p>
<p><img src="https://docs.swift.org/swift-book/_images/remainderInteger_2x.png" alt="Art/remainderInteger_2x.png" title="Art/remainderInteger_2x.png"></p>
<p>你可以在 <code>9</code> 中放入两个 <code>4</code>，那余数是 1（用橙色标出）。</p>
<p>在 Swift 中可以表达为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="operator">%</span> <span class="number">4</span>    <span class="comment">// 等于 1</span></span><br></pre></td></tr></table></figure>
<p>为了得到 <code>a % b</code> 的结果，<code>%</code> 计算了以下等式，并输出 <code>余数</code>作为结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (b × 倍数) + 余数</span><br></pre></td></tr></table></figure>
<p>当 <code>倍数</code>取最大值的时候，就会刚好可以容入 <code>a</code> 中。</p>
<p>把 <code>9</code> 和 <code>4</code> 代入等式中，我们得 <code>1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 = (4 × 2) + 1</span><br></pre></td></tr></table></figure>
<p>同样的方法，我们来计算 <code>-9 % 4</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span><span class="number">9</span> <span class="operator">%</span> <span class="number">4</span>   <span class="comment">// 等于 -1</span></span><br></pre></td></tr></table></figure>
<p>把 <code>-9</code> 和 <code>4</code> 代入等式，<code>-2</code> 是取到的最大整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-9 = (4 × -2) + -1</span><br></pre></td></tr></table></figure>
<p>余数是 <code>-1</code>。</p>
<p>在对负数 <code>b</code> 求余时，<code>b</code> 的符号会被忽略。这意味着 <code>a % b</code> 和 <code>a % -b</code> 的结果是相同的。</p>
<h3 id="一元负号运算符">一元负号运算符</h3>
<p>数值的正负号可以使用前缀 <code>-</code>（即<em>一元负号符</em>）来切换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> minusThree <span class="operator">=</span> <span class="operator">-</span>three       <span class="comment">// minusThree 等于 -3</span></span><br><span class="line"><span class="keyword">let</span> plusThree <span class="operator">=</span> <span class="operator">-</span>minusThree   <span class="comment">// plusThree 等于 3, 或 &quot;负负3&quot;</span></span><br></pre></td></tr></table></figure>
<p>一元负号符（<code>-</code>）写在操作数之前，中间没有空格。</p>
<h3 id="一元正号运算符">一元正号运算符</h3>
<p><em>一元正号符</em>（<code>+</code>）不做任何改变地返回操作数的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minusSix <span class="operator">=</span> <span class="operator">-</span><span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> alsoMinusSix <span class="operator">=</span> <span class="operator">+</span>minusSix  <span class="comment">// alsoMinusSix 等于 -6</span></span><br></pre></td></tr></table></figure>
<p>虽然一元正号符什么都不会改变，但当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，如此你的代码会具有对称美。</p>
<h2 id="组合赋值运算符">组合赋值运算符</h2>
<p>如同 C 语言，Swift 也提供把其他运算符和赋值运算（<code>=</code>）组合的<em>组合赋值运算符</em>，组合加运算（<code>+=</code>）是其中一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">a <span class="operator">+=</span> <span class="number">2</span></span><br><span class="line"><span class="comment">// a 现在是 3</span></span><br></pre></td></tr></table></figure>
<p>表达式 <code>a += 2</code> 是 <code>a = a + 2</code> 的简写，一个组合加运算就是把加法运算和赋值运算组合成进一个运算符里，同时完成两个运算任务。</p>
<blockquote>
<p>注意</p>
<p>复合赋值运算没有返回值，<code>let b = a += 2</code> 这类代码是错误。这不同于上面提到的自增和自减运算符。</p>
</blockquote>
<p>更多 Swift 标准库运算符的信息，请看 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/operator_declarations">运算符声明</a>。 ‌</p>
<h2 id="比较运算符（Comparison-Operators）">比较运算符（Comparison Operators）</h2>
<p>所有标准 C 语言中的<em>比较运算符</em>都可以在 Swift 中使用：</p>
<ul>
<li>等于（<code>a == b</code>）</li>
<li>不等于（<code>a != b</code>）</li>
<li>大于（<code>a &gt; b</code>）</li>
<li>小于（<code>a &lt; b</code>）</li>
<li>大于等于（<code>a &gt;= b</code>）</li>
<li>小于等于（<code>a &lt;= b</code>）</li>
</ul>
<blockquote>
<p>注意</p>
<p>Swift 也提供恒等（<code>===</code>）和不恒等（<code>!==</code>）这两个比较符来判断两个对象是否引用同一个对象实例。更多细节在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/09_Classes_and_Structures.md">类与结构</a> 章节的 <strong>Identity Operators</strong> 部分。</p>
</blockquote>
<p>每个比较运算都返回了一个标识表达式是否成立的布尔值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="operator">==</span> <span class="number">1</span>   <span class="comment">// true, 因为 1 等于 1</span></span><br><span class="line"><span class="number">2</span> <span class="operator">!=</span> <span class="number">1</span>   <span class="comment">// true, 因为 2 不等于 1</span></span><br><span class="line"><span class="number">2</span> <span class="operator">&gt;</span> <span class="number">1</span>    <span class="comment">// true, 因为 2 大于 1</span></span><br><span class="line"><span class="number">1</span> <span class="operator">&lt;</span> <span class="number">2</span>    <span class="comment">// true, 因为 1 小于2</span></span><br><span class="line"><span class="number">1</span> <span class="operator">&gt;=</span> <span class="number">1</span>   <span class="comment">// true, 因为 1 大于等于 1</span></span><br><span class="line"><span class="number">2</span> <span class="operator">&lt;=</span> <span class="number">1</span>   <span class="comment">// false, 因为 2 并不小于等于 1</span></span><br></pre></td></tr></table></figure>
<p>比较运算多用于条件语句，如 <code>if</code> 条件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="keyword">if</span> name <span class="operator">==</span> <span class="string">&quot;world&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m sorry <span class="subst">\(name)</span>, but I don&#x27;t recognize you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“hello, world&quot;, 因为 `name` 就是等于 &quot;world”</span></span><br></pre></td></tr></table></figure>
<p>关于 <code>if</code> 语句，请看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html">控制流</a>。</p>
<p>如果两个元组的元素相同，且长度相同的话，元组就可以被比较。比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&quot;zebra&quot;</span>) <span class="operator">&lt;</span> (<span class="number">2</span>, <span class="string">&quot;apple&quot;</span>)   <span class="comment">// true，因为 1 小于 2</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">&quot;apple&quot;</span>) <span class="operator">&lt;</span> (<span class="number">3</span>, <span class="string">&quot;bird&quot;</span>)    <span class="comment">// true，因为 3 等于 3，但是 apple 小于 bird</span></span><br><span class="line">(<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>) <span class="operator">==</span> (<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>)      <span class="comment">// true，因为 4 等于 4，dog 等于 dog</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，你可以看到，在第一行中从左到右的比较行为。因为 <code>1</code> 小于 <code>2</code>，所以 <code>(1, &quot;zebra&quot;)</code> 小于 <code>(2, &quot;apple&quot;)</code>，不管元组剩下的值如何。所以 <code>&quot;zebra&quot;</code> 大于 <code>&quot;apple&quot;</code> 对结果没有任何影响，因为元组的比较结果已经被第一个元素决定了。不过，当元组的第一个元素相同时候，第二个元素将会用作比较-第二行和第三行代码就发生了这样的比较。</p>
<p>当元组中的元素都可以被比较时，你也可以使用这些运算符来比较它们的大小。例如，像下面展示的代码，你可以比较两个类型为 <code>(String, Int)</code> 的元组，因为 <code>Int</code> 和 <code>String</code> 类型的值可以比较。相反，<code>Bool</code> 不能被比较，也意味着存有布尔类型的元组不能被比较。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&quot;blue&quot;</span>, <span class="operator">-</span><span class="number">1</span>) <span class="operator">&lt;</span> (<span class="string">&quot;purple&quot;</span>, <span class="number">1</span>)       <span class="comment">// 正常，比较的结果为 true</span></span><br><span class="line">(<span class="string">&quot;blue&quot;</span>, <span class="literal">false</span>) <span class="operator">&lt;</span> (<span class="string">&quot;purple&quot;</span>, <span class="literal">true</span>) <span class="comment">// 错误，因为 &lt; 不能比较布尔类型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算符。</p>
</blockquote>
<h2 id="三元运算符（Ternary-Conditional-Operator）">三元运算符（Ternary Conditional Operator）</h2>
<p><em>三元运算符</em>的特殊在于它是有三个操作数的运算符，它的形式是 <code>问题 ? 答案 1 : 答案 2</code>。它简洁地表达根据 <code>问题</code>成立与否作出二选一的操作。如果 <code>问题</code> 成立，返回 <code>答案 1</code> 的结果；反之返回 <code>答案 2</code> 的结果。</p>
<p>三元运算符是以下代码的缩写形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> question &#123;</span><br><span class="line">    answer1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    answer2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个计算表格行高的例子。如果有表头，那行高应比内容高度要高出 50 点；如果没有表头，只需高出 20 点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight <span class="operator">=</span> <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight <span class="operator">=</span> contentHeight <span class="operator">+</span> (hasHeader <span class="operator">?</span> <span class="number">50</span> : <span class="number">20</span>)</span><br><span class="line"><span class="comment">// rowHeight 现在是 90</span></span><br></pre></td></tr></table></figure>
<p>上面的写法比下面的代码更简洁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight <span class="operator">=</span> <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> rowHeight <span class="operator">=</span> contentHeight</span><br><span class="line"><span class="keyword">if</span> hasHeader &#123;</span><br><span class="line">    rowHeight <span class="operator">=</span> rowHeight <span class="operator">+</span> <span class="number">50</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rowHeight <span class="operator">=</span> rowHeight <span class="operator">+</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rowHeight 现在是 90</span></span><br></pre></td></tr></table></figure>
<p>第一段代码例子使用了三元运算，所以一行代码就能让我们得到正确答案。这比第二段代码简洁得多，无需将 <code>rowHeight</code> 定义成变量，因为它的值无需在 <code>if</code> 语句中改变。</p>
<p>三元运算为二选一场景提供了一个非常便捷的表达形式。不过需要注意的是，滥用三元运算符会降低代码可读性。所以我们应避免在一个复合语句中使用多个三元运算符。</p>
<h2 id="空合运算符（Nil-Coalescing-Operator）">空合运算符（Nil Coalescing Operator）</h2>
<p><em>空合运算符</em>（<code>a ?? b</code>）将对可选类型 <code>a</code> 进行空判断，如果 <code>a</code> 包含一个值就进行解包，否则就返回一个默认值 <code>b</code>。表达式 <code>a</code> 必须是 Optional 类型。默认值 <code>b</code> 的类型必须要和 <code>a</code> 存储值的类型保持一致。</p>
<p>空合运算符是对以下代码的简短表达方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">?</span> a<span class="operator">!</span> : b</span><br></pre></td></tr></table></figure>
<p>上述代码使用了三元运算符。当可选类型 <code>a</code> 的值不为空时，进行强制解封（<code>a!</code>），访问 <code>a</code> 中的值；反之返回默认值 <code>b</code>。无疑空合运算符（<code>??</code>）提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以及更具可读性。</p>
<blockquote>
<p>注意</p>
<p>如果 <code>a</code> 为非空值（<code>non-nil</code>），那么值 <code>b</code> 将不会被计算。这也就是所谓的<em>短路求值</em>。</p>
</blockquote>
<p>下文例子采用空合运算符，实现了在默认颜色名和可选自定义颜色名之间抉择：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName <span class="operator">=</span> <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">//默认值为 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse <span class="operator">=</span> userDefinedColorName <span class="operator">??</span> defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 &quot;red&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>userDefinedColorName</code> 变量被定义为一个可选的 <code>String</code> 类型，默认值为 <code>nil</code>。由于 <code>userDefinedColorName</code> 是一个可选类型，我们可以使用空合运算符去判断其值。在上一个例子中，通过空合运算符为一个名为 <code>colorNameToUse</code> 的变量赋予一个字符串类型初始值。 由于 <code>userDefinedColorName</code> 值为空，因此表达式 <code>userDefinedColorName ?? defaultColorName</code> 返回 <code>defaultColorName</code> 的值，即 <code>red</code>。</p>
<p>如果你分配一个非空值（<code>non-nil</code>）给 <code>userDefinedColorName</code>，再次执行空合运算，运算结果为封包在 <code>userDefaultColorName</code> 中的值，而非默认值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userDefinedColorName <span class="operator">=</span> <span class="string">&quot;green&quot;</span></span><br><span class="line">colorNameToUse <span class="operator">=</span> userDefinedColorName <span class="operator">??</span> defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 非空，因此 colorNameToUse 的值为 &quot;green&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="区间运算符（Range-Operators）">区间运算符（Range Operators）</h2>
<p>Swift 提供了几种方便表达一个区间的值的<em>区间运算符</em>。</p>
<h3 id="闭区间运算符">闭区间运算符</h3>
<p><em>闭区间运算符</em>（<code>a...b</code>）定义一个包含从 <code>a</code> 到 <code>b</code>（包括 <code>a</code> 和 <code>b</code>）的所有值的区间。<code>a</code> 的值不能超过 <code>b</code>。</p>
<p>闭区间运算符在迭代一个区间的所有值时是非常有用的，如在 <code>for-in</code> 循环中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span> * 5 = <span class="subst">\(index <span class="operator">*</span> <span class="number">5</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 * 5 = 5</span></span><br><span class="line"><span class="comment">// 2 * 5 = 10</span></span><br><span class="line"><span class="comment">// 3 * 5 = 15</span></span><br><span class="line"><span class="comment">// 4 * 5 = 20</span></span><br><span class="line"><span class="comment">// 5 * 5 = 25</span></span><br></pre></td></tr></table></figure>
<p>关于 <code>for-in</code> 循环，请看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html">控制流</a>。</p>
<h3 id="半开区间运算符">半开区间运算符</h3>
<p><em>半开区间运算符</em>（<code>a..&lt;b</code>）定义一个从 <code>a</code> 到 <code>b</code> 但不包括 <code>b</code> 的区间。 之所以称为<em>半开区间</em>，是因为该区间包含第一个值而不包括最后的值。</p>
<p>半开区间的实用性在于当你使用一个从 0 开始的列表（如数组）时，非常方便地从0数到列表的长度。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> names.count</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第 <span class="subst">\(i <span class="operator">+</span> <span class="number">1</span>)</span> 个人叫 <span class="subst">\(names[i])</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 1 个人叫 Anna</span></span><br><span class="line"><span class="comment">// 第 2 个人叫 Alex</span></span><br><span class="line"><span class="comment">// 第 3 个人叫 Brian</span></span><br><span class="line"><span class="comment">// 第 4 个人叫 Jack</span></span><br></pre></td></tr></table></figure>
<p>数组有 4 个元素，但 <code>0..&lt;count</code> 只数到3（最后一个元素的下标），因为它是半开区间。关于数组，请查阅 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/04_Collection_Types.html#arrays">数组</a>。</p>
<h3 id="单侧区间">单侧区间</h3>
<p>闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间 —— 例如，一个包含了数组从索引 2 到结尾的所有值的区间。在这些情况下，你可以省略掉区间操作符一侧的值。这种区间叫做单侧区间，因为操作符只有一侧有值。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">2</span><span class="operator">...</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Brian</span></span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="operator">...</span><span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br><span class="line"><span class="comment">// Brian</span></span><br></pre></td></tr></table></figure>
<p>半开区间操作符也有单侧表达形式，附带上它的最终值。就像你使用区间去包含一个值，最终值并不会落在区间内。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="operator">..&lt;</span><span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br></pre></td></tr></table></figure>
<p>单侧区间不止可以在下标里使用，也可以在别的情境下使用。你不能遍历省略了初始值的单侧区间，因为遍历的开端并不明显。你可以遍历一个省略最终值的单侧区间；然而，由于这种区间无限延伸的特性，请保证你在循环里有一个结束循环的分支。你也可以查看一个单侧区间是否包含某个特定的值，就像下面展示的那样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range <span class="operator">=</span> <span class="operator">...</span><span class="number">5</span></span><br><span class="line">range.contains(<span class="number">7</span>)   <span class="comment">// false</span></span><br><span class="line">range.contains(<span class="number">4</span>)   <span class="comment">// true</span></span><br><span class="line">range.contains(<span class="operator">-</span><span class="number">1</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符（Logical-Operators）">逻辑运算符（Logical Operators）</h2>
<p><em>逻辑运算符</em>的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。</p>
<ul>
<li>逻辑非（<code>!a</code>）</li>
<li>逻辑与（<code>a &amp;&amp; b</code>）</li>
<li>逻辑或（<code>a || b</code>）</li>
</ul>
<h3 id="逻辑非运算符">逻辑非运算符</h3>
<p><em>逻辑非运算符</em>（<code>!a</code>）对一个布尔值取反，使得 <code>true</code> 变 <code>false</code>，<code>false</code> 变 <code>true</code>。</p>
<p>它是一个前置运算符，需紧跟在操作数之前，且不加空格。读作 <code>非 a</code> ，例子如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> allowedEntry <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> <span class="operator">!</span>allowedEntry &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“ACCESS DENIED”</span></span><br></pre></td></tr></table></figure>
<p><code>if !allowedEntry</code> 语句可以读作「如果非 allowedEntry」，接下一行代码只有在「非 allowedEntry」为 <code>true</code>，即 <code>allowEntry</code> 为 <code>false</code> 时被执行。</p>
<p>在示例代码中，小心地选择布尔常量或变量有助于代码的可读性，并且避免使用双重逻辑非运算，或混乱的逻辑语句。</p>
<h3 id="逻辑与运算符-logical-and-operator">逻辑与运算符 #{logical_and_operator}</h3>
<p><em>逻辑与运算符</em>（<code>a &amp;&amp; b</code>）表达了只有 <code>a</code> 和 <code>b</code> 的值都为 <code>true</code> 时，整个表达式的值才会是 <code>true</code>。</p>
<p>只要任意一个值为 <code>false</code>，整个表达式的值就为 <code>false</code>。事实上，如果第一个值为 <code>false</code>，那么是不去计算第二个值的，因为它已经不可能影响整个表达式的结果了。这被称做<em>短路计算（short-circuit evaluation）</em>。</p>
<p>以下例子，只有两个 <code>Bool</code> 值都为 <code>true</code> 的时候才允许进入 if：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enteredDoorCode <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> passedRetinaScan <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> enteredDoorCode <span class="operator">&amp;&amp;</span> passedRetinaScan &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“ACCESS DENIED”</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑或运算符-logical-or-operator">逻辑或运算符 #{logical_or_operator}</h3>
<p>逻辑或运算符（<code>a || b</code>）是一个由两个连续的 <code>|</code> 组成的中置运算符。它表示了两个逻辑表达式的其中一个为 <code>true</code>，整个表达式就为 <code>true</code>。</p>
<p>同逻辑与运算符类似，逻辑或也是「短路计算」的，当左端的表达式为 <code>true</code> 时，将不计算右边的表达式了，因为它不可能改变整个表达式的值了。</p>
<p>以下示例代码中，第一个布尔值（<code>hasDoorKey</code>）为 <code>false</code>，但第二个值（<code>knowsOverridePassword</code>）为 <code>true</code>，所以整个表达是 <code>true</code>，于是允许进入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasDoorKey <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> knowsOverridePassword <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> hasDoorKey <span class="operator">||</span> knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“Welcome!”</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符组合计算">逻辑运算符组合计算</h3>
<p>我们可以组合多个逻辑运算符来表达一个复合逻辑：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> enteredDoorCode <span class="operator">&amp;&amp;</span> passedRetinaScan <span class="operator">||</span> hasDoorKey <span class="operator">||</span> knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“Welcome!”</span></span><br></pre></td></tr></table></figure>
<p>这个例子使用了含多个 <code>&amp;&amp;</code> 和 <code>||</code> 的复合逻辑。但无论怎样，<code>&amp;&amp;</code> 和 <code>||</code> 始终只能操作两个值。所以这实际是三个简单逻辑连续操作的结果。我们来解读一下：</p>
<p>如果我们输入了正确的密码并通过了视网膜扫描，或者我们有一把有效的钥匙，又或者我们知道紧急情况下重置的密码，我们就能把门打开进入。</p>
<p>前两种情况，我们都不满足，所以前两个简单逻辑的结果是 <code>false</code>，但是我们是知道紧急情况下重置的密码的，所以整个复杂表达式的值还是 <code>true</code>。</p>
<blockquote>
<p>注意</p>
<p>Swift 逻辑操作符 <code>&amp;&amp;</code> 和 <code>||</code> 是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。</p>
</blockquote>
<h3 id="使用括号来明确优先级">使用括号来明确优先级</h3>
<p>为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的。在上个关于门的权限的例子中，我们给第一个部分加个括号，使它看起来逻辑更明确：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (enteredDoorCode <span class="operator">&amp;&amp;</span> passedRetinaScan) <span class="operator">||</span> hasDoorKey <span class="operator">||</span> knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“Welcome!”</span></span><br></pre></td></tr></table></figure>
<p>这括号使得前两个值被看成整个逻辑表达中独立的一个部分。虽然有括号和没括号的输出结果是一样的，但对于读代码的人来说有括号的代码更清晰。可读性比简洁性更重要，请在可以让你代码变清晰的地方加个括号吧！</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/06/19/Swift/swift%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E7%AC%A6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/06/18/Swift/swift%E5%9F%BA%E7%A1%80/"
                            aria-label=": swift基础"
                        >
                            swift基础
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-06-18T10:13:17+08:00">
	
		    2023 年 6 月 18 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/">swift</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="基础部分">基础部分</h2>
<p>Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</p>
<p>Swift 包含了 C 和 Objective-C 上所有基础数据类型，<code>Int</code> 表示整型值； <code>Double</code> 和 <code>Float</code> 表示浮点型值； <code>Bool</code> 是布尔型值；<code>String</code> 是文本型数据。 Swift 还提供了三个基本的集合类型，<code>Array</code>、<code>Set</code> 和 <code>Dictionary</code> ，详见 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/04_Collection_Types.html">集合类型</a>。</p>
<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰地表达你的意图。</p>
<p>除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>
<p>Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示 “那儿有一个值，并且它等于 <em>x</em> ” 或者 “那儿没有值” 。可选有点像在 Objective-C 中使用 <code>nil</code> ，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的 <code>nil</code> 指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>
<p>Swift 是一门<em>类型安全</em>的语言，这意味着 Swift 可以让你清楚地知道值的类型。如果你的代码需要一个 <code>String</code> ，类型安全会阻止你不小心传入一个 <code>Int</code> 。同样的，如果你的代码需要一个 <code>String</code>，类型安全会阻止你意外传入一个可选的 <code>String</code> 。类型安全可以帮助你在开发阶段尽早发现并修正错误。</p>
<h2 id="常量和变量">常量和变量</h2>
<p>常量和变量把一个名字（比如 <code>maximumNumberOfLoginAttempts</code> 或者 <code>welcomeMessage</code> ）和一个指定类型的值（比如数字 <code>10</code> 或者字符串 <code>&quot;Hello&quot;</code> ）关联起来。<em>常量</em>的值一旦设定就不能改变，而<em>变量</em>的值可以随意更改。</p>
<h3 id="声明常量和变量">声明常量和变量</h3>
<p>常量和变量必须在使用前声明，用 <code>let</code> 来声明常量，用 <code>var</code> 来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maximumNumberOfLoginAttempts <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> currentLoginAttempt <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这两行代码可以被理解为：</p>
<p>“声明一个名字是 <code>maximumNumberOfLoginAttempts</code> 的新常量，并给它一个值 <code>10</code> 。然后，声明一个名字是 <code>currentLoginAttempt</code> 的变量并将它的值初始化为 <code>0</code> 。”</p>
<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>
<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span>, z <span class="operator">=</span> <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>如果你的代码中有不需要改变的值，请使用 <code>let</code> 关键字将它声明为常量。只将需要改变的值声明为变量。</p>
</blockquote>
<h3 id="类型注解">类型注解</h3>
<p>当你声明常量或者变量的时候可以加上<em>类型注解（type annotation）</em>，说明常量或者变量中要存储的值的类型。如果要添加类型注解，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>
<p>这个例子给 <code>welcomeMessage</code> 变量添加了类型注解，表示这个变量可以存储 <code>String</code> 类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>声明中的冒号代表着*“是…类型”*，所以这行代码可以被理解为：</p>
<p>“声明一个类型为 <code>String</code> ，名字为 <code>welcomeMessage</code> 的变量。”</p>
<p>“类型为 <code>String</code> ”的意思是“可以存储任意 <code>String</code> 类型的值。”</p>
<p><code>welcomeMessage</code> 变量现在可以被设置成任意字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">welcomeMessage <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型注解：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>一般来说你很少需要写类型注解。如果你在声明常量或者变量的时候赋了一个初始值，Swift 可以推断出这个常量或者变量的类型，请参考 <a href="#type-safety-and-type-inference">类型安全和类型推断</a>。在上面的例子中，没有给 <code>welcomeMessage</code> 赋初始值，所以变量 <code>welcomeMessage</code> 的类型是通过一个类型注解指定的，而不是通过初始值推断的。</p>
</blockquote>
<h3 id="常量和变量的命名">常量和变量的命名</h3>
<p>常量和变量名可以包含任何字符，包括 Unicode 字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> π <span class="operator">=</span> <span class="number">3.14159</span></span><br><span class="line"><span class="keyword">let</span> 你好 <span class="operator">=</span> <span class="string">&quot;你好世界&quot;</span></span><br><span class="line"><span class="keyword">let</span> 🐶🐮 <span class="operator">=</span> <span class="string">&quot;dogcow&quot;</span></span><br></pre></td></tr></table></figure>
<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>
<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</p>
<blockquote>
<p>注意</p>
<p>如果你需要使用与 Swift 保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。</p>
</blockquote>
<p>你可以更改现有的变量值为其他同类型的值，在下面的例子中，<code>friendlyWelcome</code> 的值从 <code>&quot;Hello!&quot;</code> 改为了 <code>&quot;Bonjour!&quot;</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friendlyWelcome <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">friendlyWelcome <span class="operator">=</span> <span class="string">&quot;Bonjour!&quot;</span></span><br><span class="line"><span class="comment">// friendlyWelcome 现在是 &quot;Bonjour!&quot;</span></span><br></pre></td></tr></table></figure>
<p>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> languageName <span class="operator">=</span> <span class="string">&quot;Swift&quot;</span></span><br><span class="line">languageName <span class="operator">=</span> <span class="string">&quot;Swift++&quot;</span></span><br><span class="line"><span class="comment">// 这会报编译时错误 - languageName 不可改变</span></span><br></pre></td></tr></table></figure>
<h3 id="输出常量和变量">输出常量和变量</h3>
<p>你可以用 <code>print(_:separator:terminator:)</code> 函数来输出当前常量或变量的值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(friendlyWelcome)</span><br><span class="line"><span class="comment">// 输出“Bonjour!”</span></span><br></pre></td></tr></table></figure>
<p><code>print(_:separator:terminator:)</code> 是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，<code>print(_:separator:terminator:)</code> 将会输出内容到“console”面板上。<code>separator</code> 和 <code>terminator</code> 参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给 <code>terminator</code> 参数–例如，<code>print(someValue, terminator:&quot;&quot;)</code> 。关于参数默认值的更多信息，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#default_parameter_values">默认参数值</a>。</p>
<p>Swift 用*字符串插值（string interpolation）*的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The current value of friendlyWelcome is <span class="subst">\(friendlyWelcome)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The current value of friendlyWelcome is Bonjour!”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>字符串插值所有可用的选项，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/03_Strings_and_Characters.html#string_interpolation">字符串插值</a>。</p>
</blockquote>
<h2 id="注释">注释</h2>
<p>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>
<p>Swift 中的注释与 C 语言的注释非常相似。单行注释以双正斜杠（<code>//</code>）作为起始标记:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个注释</span></span><br></pre></td></tr></table></figure>
<p>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号（<code>/*</code>），终止标记为一个星号后跟随单个正斜杠（<code>*/</code>）:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这也是一个注释，</span></span><br><span class="line"><span class="comment">但是是多行的 */</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是第一个多行注释的开头</span></span><br><span class="line"><span class="comment"><span class="comment">/* 这是第二个被嵌套的多行注释 */</span></span></span><br><span class="line"><span class="comment">这是第一个多行注释的结尾 */</span></span><br></pre></td></tr></table></figure>
<p>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>
<h2 id="分号">分号</h2>
<p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（<code>;</code>），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat <span class="operator">=</span> <span class="string">&quot;🐱&quot;</span>; <span class="built_in">print</span>(cat)</span><br><span class="line"><span class="comment">// 输出“🐱”</span></span><br></pre></td></tr></table></figure>
<h2 id="整数">整数</h2>
<p>整数就是没有小数部分的数字，比如 <code>42</code> 和 <code>-23</code> 。整数可以是 <code>有符号</code>（正、负、零）或者 <code>无符号</code>（正、零）。</p>
<p>Swift 提供了8、16、32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是 <code>UInt8</code>，32位有符号整数类型是 <code>Int32</code> 。就像 Swift 的其他类型一样，整数类型采用大写命名法。</p>
<h3 id="整数范围">整数范围</h3>
<p>你可以访问不同整数类型的 <code>min</code> 和 <code>max</code> 属性来获取对应类型的最小值和最大值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minValue <span class="operator">=</span> <span class="type">UInt8</span>.min  <span class="comment">// minValue 为 0，是 UInt8 类型</span></span><br><span class="line"><span class="keyword">let</span> maxValue <span class="operator">=</span> <span class="type">UInt8</span>.max  <span class="comment">// maxValue 为 255，是 UInt8 类型</span></span><br></pre></td></tr></table></figure>
<p><code>min</code> 和 <code>max</code> 所传回值的类型，正是其所对的整数类型（如上例 UInt8, 所传回的类型是 UInt8），可用在表达式中相同类型值旁。</p>
<h3 id="Int">Int</h3>
<p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型 <code>Int</code>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，<code>Int</code> 和 <code>Int32</code> 长度相同。</li>
<li>在64位平台上，<code>Int</code> 和 <code>Int64</code> 长度相同。</li>
</ul>
<p>除非你需要特定长度的整数，一般来说使用 <code>Int</code> 就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，<code>Int</code> 可以存储的整数范围也可以达到 <code>-2,147,483,648</code> ~ <code>2,147,483,647</code>，大多数时候这已经足够大了。</p>
<h3 id="UInt">UInt</h3>
<p>Swift 也提供了一个特殊的无符号类型 <code>UInt</code>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，<code>UInt</code> 和 <code>UInt32</code> 长度相同。</li>
<li>在64位平台上，<code>UInt</code> 和 <code>UInt64</code> 长度相同。</li>
</ul>
<blockquote>
<p>注意</p>
<p>尽量不要使用 <code>UInt</code>，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用 <code>Int</code>，即使你要存储的值已知是非负的。统一使用 <code>Int</code> 可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断，请参考 <a href="#type_safety_and_type_inference">类型安全和类型推断</a>。</p>
</blockquote>
<h2 id="浮点数">浮点数</h2>
<p>浮点数是有小数部分的数字，比如 <code>3.14159</code>、<code>0.1</code> 和 <code>-273.15</code>。</p>
<p>浮点类型比整数类型表示的范围更大，可以存储比 <code>Int</code> 类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>
<ul>
<li><code>Double</code> 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li><code>Float</code> 表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>
<blockquote>
<p>注意</p>
<p><code>Double</code> 精确度很高，至少有15位数字，而 <code>Float</code> 只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择 <code>Double</code>。</p>
</blockquote>
<h2 id="类型安全和类型推断">类型安全和类型推断</h2>
<p>Swift 是一个*类型安全（type safe）*的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个 <code>String</code>，你绝对不可能不小心传进去一个 <code>Int</code>。</p>
<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行<em>类型检查（type checks）</em>，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用*类型推断（type inference）*来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。</p>
<p>因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>
<p>当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如 <code>42</code> 和 <code>3.14159</code> 。）</p>
<p>例如，如果你给一个新常量赋值 <code>42</code> 并且没有标明类型，Swift 可以推断出常量类型是 <code>Int</code> ，因为你给它赋的初始值看起来像一个整数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meaningOfLife <span class="operator">=</span> <span class="number">42</span></span><br><span class="line"><span class="comment">// meaningOfLife 会被推测为 Int 类型</span></span><br></pre></td></tr></table></figure>
<p>同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是 <code>Double</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pi <span class="operator">=</span> <span class="number">3.14159</span></span><br><span class="line"><span class="comment">// pi 会被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>当推断浮点数的类型时，Swift 总是会选择 <code>Double</code> 而不是 <code>Float</code>。</p>
<p>如果表达式中同时出现了整数和浮点数，会被推断为 <code>Double</code> 类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPi <span class="operator">=</span> <span class="number">3</span> <span class="operator">+</span> <span class="number">0.14159</span></span><br><span class="line"><span class="comment">// anotherPi 会被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>原始值 <code>3</code> 没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为 <code>Double</code> 类型。</p>
<h2 id="数值型字面量">数值型字面量</h2>
<p>整数字面量可以被写作：</p>
<ul>
<li>一个<em>十进制</em>数，没有前缀</li>
<li>一个<em>二进制</em>数，前缀是 <code>0b</code></li>
<li>一个<em>八进制</em>数，前缀是 <code>0o</code></li>
<li>一个<em>十六进制</em>数，前缀是 <code>0x</code></li>
</ul>
<p>下面的所有整数字面量的十进制值都是 <code>17</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalInteger <span class="operator">=</span> <span class="number">17</span></span><br><span class="line"><span class="keyword">let</span> binaryInteger <span class="operator">=</span> <span class="number">0b10001</span>       <span class="comment">// 二进制的17</span></span><br><span class="line"><span class="keyword">let</span> octalInteger <span class="operator">=</span> <span class="number">0o21</span>           <span class="comment">// 八进制的17</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger <span class="operator">=</span> <span class="number">0x11</span>     <span class="comment">// 十六进制的17</span></span><br></pre></td></tr></table></figure>
<p>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是 <code>0x</code> ）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 <code>e</code> 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 <code>p</code> 来指定。</p>
<p>如果一个十进制数的指数为 <code>exp</code>，那这个数相当于基数和10^exp 的乘积：</p>
<ul>
<li><code>1.25e2</code> 表示 1.25 × 10^2，等于 <code>125.0</code>。</li>
<li><code>1.25e-2</code> 表示 1.25 × 10^-2，等于 <code>0.0125</code>。</li>
</ul>
<p>如果一个十六进制数的指数为 <code>exp</code>，那这个数相当于基数和2^exp 的乘积：</p>
<ul>
<li><code>0xFp2</code> 表示 15 × 2^2，等于 <code>60.0</code>。</li>
<li><code>0xFp-2</code> 表示 15 × 2^-2，等于 <code>3.75</code>。</li>
</ul>
<p>下面的这些浮点字面量都等于十进制的 <code>12.1875</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalDouble <span class="operator">=</span> <span class="number">12.1875</span></span><br><span class="line"><span class="keyword">let</span> exponentDouble <span class="operator">=</span> <span class="number">1.21875e1</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalDouble <span class="operator">=</span> <span class="number">0xC.3p0</span></span><br></pre></td></tr></table></figure>
<p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> paddedDouble <span class="operator">=</span> <span class="number">000123.456</span></span><br><span class="line"><span class="keyword">let</span> oneMillion <span class="operator">=</span> <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> justOverOneMillion <span class="operator">=</span> <span class="number">1_000_000.000_000_1</span></span><br></pre></td></tr></table></figure>
<h2 id="数值型类型转换">数值型类型转换</h2>
<p>通常来讲，即使代码中的整数常量和变量已知非负，也请使用 <code>Int</code> 类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。</p>
<p>只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>
<h3 id="整数转换">整数转换</h3>
<p>不同整数类型的变量和常量可以存储不同范围的数字。<code>Int8</code> 类型的常量或者变量可以存储的数字范围是 <code>-128</code>~<code>127</code>，而 <code>UInt8</code> 类型的常量或者变量能存储的数字范围是 <code>0</code>~<code>255</code>。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cannotBeNegative: <span class="type">UInt8</span> <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line"><span class="comment">// UInt8 类型不能存储负数，所以会报错</span></span><br><span class="line"><span class="keyword">let</span> tooBig: <span class="type">Int8</span> <span class="operator">=</span> <span class="type">Int8</span>.max <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// Int8 类型不能存储超过最大值的数，所以会报错</span></span><br></pre></td></tr></table></figure>
<p>由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>
<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量 <code>twoThousand</code> 是 <code>UInt16</code> 类型，然而常量 <code>one</code> 是 <code>UInt8</code> 类型。它们不能直接相加，因为它们类型不同。所以要调用 <code>UInt16(one)</code> 来创建一个新的 <code>UInt16</code> 数字并用 <code>one</code> 的值来初始化，然后使用这个新数字来计算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThousand: <span class="type">UInt16</span> <span class="operator">=</span> <span class="number">2_000</span></span><br><span class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> twoThousandAndOne <span class="operator">=</span> twoThousand <span class="operator">+</span> <span class="type">UInt16</span>(one)</span><br></pre></td></tr></table></figure>
<p>现在两个数字的类型都是 <code>UInt16</code>，可以进行相加。目标常量 <code>twoThousandAndOne</code> 的类型被推断为 <code>UInt16</code>，因为它是两个 <code>UInt16</code> 值的和。</p>
<p><code>SomeType(ofInitialValue)</code> 是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，<code>UInt16</code> 有一个构造器，可以接受一个 <code>UInt8</code> 类型的值，所以这个构造器可以用现有的 <code>UInt8</code> 来创建一个新的 <code>UInt16</code>。注意，你并不能传入任意类型的值，只能传入 <code>UInt16</code> 内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/20_Extensions.html">扩展</a>。</p>
<h3 id="整数和浮点数转换">整数和浮点数转换</h3>
<p>整数和浮点数的转换必须显式指定类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointOneFourOneFiveNine <span class="operator">=</span> <span class="number">0.14159</span></span><br><span class="line"><span class="keyword">let</span> pi <span class="operator">=</span> <span class="type">Double</span>(three) <span class="operator">+</span> pointOneFourOneFiveNine</span><br><span class="line"><span class="comment">// pi 等于 3.14159，所以被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，常量 <code>three</code> 的值被用来创建一个 <code>Double</code> 类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。</p>
<p>浮点数到整数的反向转换同样行，整数类型可以用 <code>Double</code> 或者 <code>Float</code> 类型来初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerPi <span class="operator">=</span> <span class="type">Int</span>(pi)</span><br><span class="line"><span class="comment">// integerPi 等于 3，所以被推测为 Int 类型</span></span><br></pre></td></tr></table></figure>
<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说 <code>4.75</code> 会变成 <code>4</code>，<code>-3.9</code> 会变成 <code>-3</code>。</p>
<blockquote>
<p>注意</p>
<p>结合数字类常量和变量不同于结合数字类字面量。字面量 <code>3</code> 可以直接和字面量 <code>0.14159</code> 相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。</p>
</blockquote>
<h2 id="类型别名">类型别名</h2>
<p>*类型别名（type aliases）*就是给现有类型定义另一个名字。你可以使用 <code>typealias</code> 关键字来定义类型别名。</p>
<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> <span class="operator">=</span> <span class="type">UInt16</span></span><br></pre></td></tr></table></figure>
<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxAmplitudeFound <span class="operator">=</span> <span class="type">AudioSample</span>.min</span><br><span class="line"><span class="comment">// maxAmplitudeFound 现在是 0</span></span><br></pre></td></tr></table></figure>
<p>本例中，<code>AudioSample</code> 被定义为 <code>UInt16</code> 的一个别名。因为它是别名，<code>AudioSample.min</code> 实际上是 <code>UInt16.min</code>，所以会给 <code>maxAmplitudeFound</code> 赋一个初值 <code>0</code>。</p>
<h2 id="布尔值">布尔值</h2>
<p>Swift 有一个基本的<em>布尔（Boolean）类型</em>，叫做 <code>Bool</code>。布尔值指<em>逻辑</em>上的值，因为它们只能是真或者假。Swift 有两个布尔常量，<code>true</code> 和 <code>false</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> orangesAreOrange <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> turnipsAreDelicious <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>orangesAreOrange</code> 和 <code>turnipsAreDelicious</code> 的类型会被推断为 <code>Bool</code>，因为它们的初值是布尔字面量。就像之前提到的 <code>Int</code> 和 <code>Double</code> 一样，如果你创建变量的时候给它们赋值 <code>true</code> 或者 <code>false</code>，那你不需要将常量或者变量声明为 <code>Bool</code> 类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，这让 Swift 代码更加简洁并且可读性更高。</p>
<p>当你编写条件语句比如 <code>if</code> 语句的时候，布尔值非常有用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> turnipsAreDelicious &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Mmm, tasty turnips!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Eww, turnips are horrible.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“Eww, turnips are horrible.”</span></span><br></pre></td></tr></table></figure>
<p>条件语句，例如 <code>if</code>，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html">控制流</a>。</p>
<p>如果你在需要使用 <code>Bool</code> 类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i &#123;</span><br><span class="line">    <span class="comment">// 这个例子不会通过编译，会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，下面的例子是合法的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子会编译成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>i == 1</code> 的比较结果是 <code>Bool</code> 类型，所以第二个例子可以通过类型检查。类似 <code>i == 1</code> 这样的比较，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html">基本操作符</a>。</p>
<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。</p>
<h2 id="元组">元组</h2>
<p>*元组（tuples）*把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>
<p>下面这个例子中，<code>(404, &quot;Not Found&quot;)</code> 是一个描述 *HTTP 状态码（HTTP status code）*的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个 <code>404 Not Found</code> 状态码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error <span class="operator">=</span> (<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="comment">// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)</span></span><br></pre></td></tr></table></figure>
<p><code>(404, &quot;Not Found&quot;)</code> 元组把一个 <code>Int</code> 值和一个 <code>String</code> 值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为 <code>(Int, String)</code> 的元组”。</p>
<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为 <code>(Int, Int, Int)</code> 或者 <code>(String, Bool)</code> 或者其他任何你想要的组合的元组。</p>
<p>你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) <span class="operator">=</span> http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(statusCode)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status code is 404”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is <span class="subst">\(statusMessage)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status message is Not Found”</span></span><br></pre></td></tr></table></figure>
<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<code>_</code>）标记：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="keyword">_</span>) <span class="operator">=</span> http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(justTheStatusCode)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status code is 404”</span></span><br></pre></td></tr></table></figure>
<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(http404Error.<span class="number">0</span>)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status code is 404”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is <span class="subst">\(http404Error.<span class="number">1</span>)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status message is Not Found”</span></span><br></pre></td></tr></table></figure>
<p>你可以在定义元组的时候给单个元素命名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http200Status <span class="operator">=</span> (statusCode: <span class="number">200</span>, description: <span class="string">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(http200Status.statusCode)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status code is 200”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is <span class="subst">\(http200Status.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status message is OK”</span></span><br></pre></td></tr></table></figure>
<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个 <code>(Int, String)</code> 元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/06_Functions.html#Function_Parameters_and_Return_Values">函数参数与返回值</a>。</p>
<blockquote>
<p>注意</p>
<p>当遇到一些相关值的简单分组时，元组是很有用的。元组不适合用来创建复杂的数据结构。如果你的数据结构比较复杂，不要使用元组，用类或结构体去建模。欲获得更多信息，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/09_Classes_and_Structures.md">结构体和类</a>。</p>
</blockquote>
<h2 id="可选类型">可选类型</h2>
<p>使用*可选类型（optionals）*来处理值可能缺失的情况。可选类型表示两种可能： 或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。</p>
<blockquote>
<p>注意</p>
<p>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回 <code>nil</code>，<code>nil</code> 表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如 <code>NSNotFound</code>）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示<em>任意类型</em>的值缺失，并不需要一个特殊值。</p>
</blockquote>
<p>来看一个例子。Swift 的 <code>Int</code> 类型有一种构造器，作用是将一个 <code>String</code> 值转换成一个 <code>Int</code> 值。然而，并不是所有的字符串都可以转换成一个整数。字符串 <code>&quot;123&quot;</code> 可以被转换成数字 <code>123</code> ，但是字符串 <code>&quot;hello, world&quot;</code> 不行。</p>
<p>下面的例子使用这种构造器来尝试将一个 <code>String</code> 转换成 <code>Int</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber <span class="operator">=</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为该构造器可能会失败，所以它返回一个<em>可选类型</em>（optional）<code>Int</code>，而不是一个 <code>Int</code>。一个可选的 <code>Int</code> 被写作 <code>Int?</code> 而不是 <code>Int</code>。问号暗示包含的值是可选类型，也就是说可能包含 <code>Int</code> 值也可能<em>不包含值</em>。（不能包含其他任何值比如 <code>Bool</code> 值或者 <code>String</code> 值。只能是 <code>Int</code> 或者什么都没有。）</p>
<h3 id="nil">nil</h3>
<p>你可以给可选变量赋值为 <code>nil</code> 来表示它没有值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? <span class="operator">=</span> <span class="number">404</span></span><br><span class="line"><span class="comment">// serverResponseCode 包含一个可选的 Int 值 404</span></span><br><span class="line">serverResponseCode <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// serverResponseCode 现在不包含值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p><code>nil</code> 不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>
<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String</span>?</span><br><span class="line"><span class="comment">// surveyAnswer 被自动设置为 nil</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>Swift 的 <code>nil</code> 和 Objective-C 中的 <code>nil</code> 并不一样。在 Objective-C 中，<code>nil</code> 是一个指向不存在对象的指针。在 Swift 中，<code>nil</code> 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 <code>nil</code>，不只是对象类型。</p>
</blockquote>
<h3 id="if-语句以及强制解析">if 语句以及强制解析</h3>
<p>你可以使用 <code>if</code> 语句和 <code>nil</code> 比较来判断一个可选值是否包含值。你可以使用“相等”(<code>==</code>)或“不等”(<code>!=</code>)来执行比较。</p>
<p>如果可选类型有值，它将不等于 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;convertedNumber contains some integer value.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“convertedNumber contains some integer value.”</span></span><br></pre></td></tr></table></figure>
<p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（<code>!</code>）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的<em>强制解析（forced unwrapping）</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;convertedNumber has an integer value of <span class="subst">\(convertedNumber<span class="operator">!</span>)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“convertedNumber has an integer value of 123.”</span></span><br></pre></td></tr></table></figure>
<p>更多关于 <code>if</code> 语句的内容，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html">控制流</a>。</p>
<blockquote>
<p>注意</p>
<p>使用 <code>!</code> 来获取一个不存在的可选值会导致运行时错误。使用 <code>!</code> 来强制解析值之前，一定要确定可选包含一个非 <code>nil</code> 的值。</p>
</blockquote>
<h3 id="可选绑定">可选绑定</h3>
<p>使用*可选绑定（optional binding）*来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 <code>if</code> 和 <code>while</code> 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。<code>if</code> 和 <code>while</code> 语句，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html">控制流</a>。</p>
<p>像下面这样在 <code>if</code> 语句中写一个可选绑定：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName <span class="operator">=</span> someOptional &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像上面这样使用可选绑定来重写 在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/01_The_Basics.html#optionals">可选类型</a> 举出的 <code>possibleNumber</code> 例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&#x27;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&#x27;</span> has an integer value of <span class="subst">\(actualNumber)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&#x27;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&#x27;</span> could not be converted to an integer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“&#x27;123&#x27; has an integer value of 123”</span></span><br></pre></td></tr></table></figure>
<p>这段代码可以被理解为：</p>
<p>“如果 <code>Int(possibleNumber)</code> 返回的可选 <code>Int</code> 包含一个值，创建一个叫做 <code>actualNumber</code> 的新常量并将可选包含的值赋给它。”</p>
<p>如果转换成功，<code>actualNumber</code> 常量可以在 <code>if</code> 语句的第一个分支中使用。它已经被可选类型 <em>包含的</em> 值初始化过，所以不需要再使用 <code>!</code> 后缀来获取它的值。在这个例子中，<code>actualNumber</code> 只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在 <code>if</code> 语句的第一个分支中操作 <code>actualNumber</code> 的值，你可以改成 <code>if var actualNumber</code>，这样可选类型包含的值就会被赋给一个变量而非常量。</p>
<p>你可以包含多个可选绑定或多个布尔条件在一个 <code>if</code> 语句中，只要使用逗号分开就行。只要有任意一个可选绑定的值为 <code>nil</code>，或者任意一个布尔条件为 <code>false</code>，则整个 <code>if</code> 条件判断为 <code>false</code>，这时你就需要使用嵌套 <code>if</code> 条件语句来处理，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>), <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>), firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“4 &lt; 42 &lt; 100”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“4 &lt; 42 &lt; 100”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>在 <code>if</code> 条件语句中使用常量和变量来创建一个可选绑定，仅在 <code>if</code> 语句的句中（<code>body</code>）中才能获取到值。相反，在 <code>guard</code> 语句中使用常量和变量来创建一个可选绑定，仅在 <code>guard</code> 语句外且在语句后才能获取到值，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/05_Control_Flow.html#early_exit">提前退出</a>。</p>
</blockquote>
<h3 id="隐式解析可选类型">隐式解析可选类型</h3>
<p>如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过 <code>if</code> 语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型<em>总会</em>有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>
<p>这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（<code>String?</code>）改成感叹号（<code>String!</code>）来声明一个隐式解析可选类型。</p>
<p>当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中，请参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/23_Automatic_Reference_Counting.html#unowned_references_and_implicitly_unwrapped_optional_properties">无主引用以及隐式解析可选属性</a>。</p>
<p>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型 <code>String</code> 和隐式解析可选类型 <code>String</code> 之间的区别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;An optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> <span class="operator">=</span> possibleString<span class="operator">!</span> <span class="comment">// 需要感叹号来获取值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! <span class="operator">=</span> <span class="string">&quot;An implicitly unwrapped optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> <span class="operator">=</span> assumedString  <span class="comment">// 不需要感叹号</span></span><br></pre></td></tr></table></figure>
<p>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>
<blockquote>
<p>注意</p>
<p>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。</p>
</blockquote>
<p>你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> assumedString <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(assumedString<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“An implicitly unwrapped optional string.”</span></span><br></pre></td></tr></table></figure>
<p>你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> definiteString <span class="operator">=</span> assumedString &#123;</span><br><span class="line">    <span class="built_in">print</span>(definiteString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“An implicitly unwrapped optional string.”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>如果一个变量之后可能变成 <code>nil</code> 的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是 <code>nil</code> 的话，请使用普通可选类型。</p>
</blockquote>
<h2 id="错误处理">错误处理</h2>
<p>你可以使用 <em>错误处理（error handling）</em> 来应对程序执行中可能会遇到的错误条件。</p>
<p>相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。</p>
<p>当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">canThrowAnError</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 这个函数有可能抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数可以通过在声明中添加 <code>throws</code> 关键词来抛出错误消息。当你的函数能抛出错误消息时，你应该在表达式中前置 <code>try</code> 关键词。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> canThrowAnError()</span><br><span class="line">    <span class="comment">// 没有错误消息抛出</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// 有一个错误消息抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 <code>do</code> 语句创建了一个新的包含作用域，使得错误能被传播到一个或多个 <code>catch</code> 从句。</p>
<p>这里有一个错误处理如何用来应对不同错误条件的例子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeASandwich</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> makeASandwich()</span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.outOfCleanDishes &#123;</span><br><span class="line">    washDishes()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.missingIngredients(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    buyGroceries(ingredients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此例中，<code>makeASandwich()</code>（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为 <code>makeASandwich()</code> 抛出错误，函数调用被包裹在 <code>try</code> 表达式中。将函数包裹在一个 <code>do</code> 语句中，任何被抛出的错误会被传播到提供的 <code>catch</code> 从句中。</p>
<p>如果没有错误被抛出，<code>eatASandwich()</code> 函数会被调用。如果一个匹配 <code>SandwichError.outOfCleanDishes</code> 的错误被抛出，<code>washDishes()</code> 函数会被调用。如果一个匹配 <code>SandwichError.missingIngredients</code> 的错误被抛出，<code>buyGroceries(_:)</code> 函数会被调用，并且使用 <code>catch</code> 所捕捉到的关联值 <code>[String]</code> 作为参数。</p>
<p>抛出，捕捉，以及传播错误会在 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/17_Error_Handling.html">错误处理</a> 章节详细说明。</p>
<h2 id="断言和先决条件">断言和先决条件</h2>
<p>断言和先决条件是在运行时所做的检查。你可以用他们来检查在执行后续代码之前是否一个必要的条件已经被满足了。如果断言或者先决条件中的布尔条件评估的结果为 true（真），则代码像往常一样继续执行。如果布尔条件评估结果为 false（假），程序的当前状态是无效的，则代码执行结束，应用程序中止。</p>
<p>你使用断言和先决条件来表达你所做的假设和你在编码时候的期望。你可以将这些包含在你的代码中。断言帮助你在开发阶段找到错误和不正确的假设，先决条件帮助你在生产环境中探测到存在的问题。</p>
<p>除了在运行时验证你的期望值，断言和先决条件也变成了一个在你的代码中的有用的文档形式。和在上面讨论过的 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/gitbook/swift5/source/_book/chapter2/17_Error_Handling.html">错误处理</a> 不同，断言和先决条件并不是用来处理可以恢复的或者可预期的错误。因为一个断言失败表明了程序正处于一个无效的状态，没有办法去捕获一个失败的断言。</p>
<p>使用断言和先决条件不是一个能够避免出现程序出现无效状态的编码方法。然而，如果一个无效状态程序产生了，断言和先决条件可以强制检查你的数据和程序状态，使得你的程序可预测的中止（译者：不是系统强制的，被动的中止），并帮助使这个问题更容易调试。一旦探测到无效的状态，执行则被中止，防止无效的状态导致的进一步对于系统的伤害。</p>
<p>断言和先决条件的不同点是，他们什么时候进行状态检测：断言仅在调试环境运行，而先决条件则在调试环境和生产环境中运行。在生产环境中，断言的条件将不会进行评估。这个意味着你可以使用很多断言在你的开发阶段，但是这些断言在生产环境中不会产生任何影响。</p>
<h3 id="使用断言进行调试">使用断言进行调试</h3>
<p>你可以调用 Swift 标准库的 <code>assert(_:_:file:line:)</code> 函数来写一个断言。向这个函数传入一个结果为 <code>true</code> 或者 <code>false</code> 的表达式以及一条信息，当表达式的结果为 <code>false</code> 的时候这条信息会被显示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age <span class="operator">=</span> <span class="operator">-</span><span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age <span class="operator">&gt;=</span> <span class="number">0</span>, <span class="string">&quot;A person&#x27;s age cannot be less than zero&quot;</span>)</span><br><span class="line"><span class="comment">// 因为 age &lt; 0，所以断言会触发</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，只有 <code>age &gt;= 0</code> 为 <code>true</code> 时，即 <code>age</code> 的值非负的时候，代码才会继续执行。如果 <code>age</code> 的值是负数，就像代码中那样，<code>age &gt;= 0</code> 为 <code>false</code>，断言被触发，终止应用。</p>
<p>如果不需要断言信息，可以就像这样忽略掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(age <span class="operator">&gt;=</span> <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如果代码已经检查了条件，你可以使用 <code>assertionFailure(_:file:line:)</code> 函数来表明断言失败了，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age <span class="operator">&gt;</span> <span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can ride the roller-coaster or the ferris wheel.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> age <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can ride the ferris wheel.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assertionFailure</span>(<span class="string">&quot;A person&#x27;s age can&#x27;t be less than zero.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="强制执行先决条件">强制执行先决条件</h3>
<p>当一个条件可能为假，但是继续执行代码要求条件必须为真的时候，需要使用先决条件。例如使用先决条件来检查是否下标越界，或者来检查是否将一个正确的参数传给函数。</p>
<p>你可以使用全局 <code>precondition(_:_:file:line:)</code> 函数来写一个先决条件。向这个函数传入一个结果为 <code>true</code> 或者 <code>false</code> 的表达式以及一条信息，当表达式的结果为 <code>false</code> 的时候这条信息会被显示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个下标的实现里...</span></span><br><span class="line"><span class="built_in">precondition</span>(index <span class="operator">&gt;</span> <span class="number">0</span>, <span class="string">&quot;Index must be greater than zero.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>你可以调用　<code>preconditionFailure(_:file:line:)</code> 方法来表明出现了一个错误，例如，switch 进入了 default 分支，但是所有的有效值应该被任意一个其他分支（非 default 分支）处理。</p>
<blockquote>
<p>注意</p>
<p>如果你使用 unchecked 模式（-Ounchecked）编译代码，先决条件将不会进行检查。编译器假设所有的先决条件总是为 true（真），他将优化你的代码。然而，<code>fatalError(_:file:line:)</code> 函数总是中断执行，无论你怎么进行优化设定。</p>
<p>你能使用 <code>fatalError(_:file:line:)</code> 函数在设计原型和早期开发阶段，这个阶段只有方法的声明，但是没有具体实现，你可以在方法体中写上 fatalError(“Unimplemented”)作为具体实现。因为 fatalError 不会像断言和先决条件那样被优化掉，所以你可以确保当代码执行到一个没有被实现的方法时，程序会被中断。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/06/18/Swift/swift%E5%9F%BA%E7%A1%80/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"
                            aria-label=": Astar搜索算法简介及保姆级代码解读"
                        >
                            Astar搜索算法简介及保姆级代码解读
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-14T15:43:00+08:00">
	
		    2023 年 4 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h4 id="A-搜索算法简介及保姆级代码解读">A*搜索算法简介及保姆级代码解读</h4>
<ul>
<li><a href="#1_A_1">1. A*算法简单介绍</a></li>
<li>
<ul>
<li><a href="#11_A_12">1.1 A*算法理论基础</a></li>
<li>
<ul>
<li><a href="#111__31">1.1.1 节点计算</a></li>
<li><a href="#112__60">1.1.2 由计算得出的小结论</a></li>
</ul>
</li>
<li><a href="#12__70">1.2 算法逻辑结构</a></li>
</ul>
</li>
<li><a href="#2__80">2. 代码解析</a></li>
<li>
<ul>
<li><a href="#21__81">2.1 引入地图</a></li>
<li><a href="#22__159">2.2 预处理</a></li>
<li><a href="#23_parent_286">2.3 定义父节点`parent`</a></li>
<li><a href="#24__296">2.4 主循环</a></li>
<li>
<ul>
<li><a href="#241_359">2.4.1</a></li>
<li><a href="#242_364">2.4.2</a></li>
<li><a href="#243_380">2.4.3</a></li>
<li><a href="#244_383">2.4.4</a></li>
<li><a href="#245_396">2.4.5</a></li>
</ul>
</li>
<li><a href="#25__414">2.5 画图</a></li>
</ul>
</li>
<li><a href="#3__427">3. 结果</a></li>
</ul>
<h2 id="1-A-算法简单介绍">1. A*算法简单介绍</h2>
<p>A*算法是一种路径规划算法，和传统的Dijkstra算法有所不同，该算法<strong>有选择</strong>地进行节点搜索，因此比Dijkstra算法更快、搜索的点更少。<br>
阅读本文，不需要掌握Dijkstra算法的知识，请放心食用。<br>
注意：<strong>本文只介绍二维A*算法及相关示例</strong>。</p>
<p><strong>PS</strong>：本文代码编写参考B站up主<br>
<code>小黎的Ally</code>的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Jt4y1z7Ry?from=search&amp;seid=14748520462847442393&amp;spm_id_from=333.337.0.0">路径规划与轨迹跟踪系列算法学习_第4讲_A*算法</a>，讲解详细，本文代码部分是将其代码进行了些许改动并加以解释，在此对up主的辛苦表达感谢！！</p>
<p><strong>PPS</strong>：本文所使用的把地图栅格化的函数来自于博客<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42667352/article/details/98523370">Matlab中将一幅图片做成栅格地图</a>，本文进行了些许改动，再次一并感谢博主的辛苦！</p>
<h3 id="1-1-A-算法理论基础">1.1 A*算法理论基础</h3>
<p>A*算法首先将要搜索的区域划分为若干栅格（grid），并有选择地标识出障碍物（Obstacle）与空白区域。一般地，<strong>栅格划分越细密，搜索点数越多，搜索过程越慢，计算量也越大；栅格划分越稀疏，搜索点数越少，相应地搜索精确性就越低</strong>。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/e5a5e9d6d0f36afb2bf3f1cd9ef378ac.png#pic_center" alt="地图栅格"></p>
<p>如上图，引入地图信息后画出栅格，该图片采用 100 × 100 100 \times 100 100×100的栅格划分，图中黑色区域为障碍物区域。图中绿点为起始点，红点为终点。</p>
<p>对每个节点，在计算时同时考虑两项<strong>代价</strong>指标：<strong>当前节点与起始点的距离</strong>，以及<strong>当前节点与目标点的距离</strong>：<br>
f = g + h f = g + h f=g+h其中 f f f为总代价， g g g为当前节点距离起始点的距离， h h h为当前节点距离目标点的距离。<br>
而在计算距离时，又可以采用两种方式：<br>
<strong>欧氏距离</strong>：<br>
L = ( x 1 − x 2 ) 2 + ( y 1 − y 2 ) 2 L = \sqrt{\left( x_1 - x_2 \right) ^2 + \left( y_1 - y_2 \right) ^2} L=(x1​−x2​)2+(y1​−y2​)2 ​<strong>曼哈顿距离</strong>：<br>
L = ∣ x 1 − x 2 ∣ + ∣ y 1 − y 2 ∣ L = \lvert x_1 - x_2 \rvert + \lvert y_1 - y_2 \rvert L=∣x1​−x2​∣+∣y1​−y2​∣为了计算方便，本文计算 h h h时采用<strong>曼哈顿距离</strong>，这也是A*算法中的一贯做法。<br>
为了方便计数，在计算每一个节点时，在栅格左上角写 f f f值，左下角写 g g g值，右下角写 h h h值。</p>
<h4 id="1-1-1-节点计算">1.1.1 节点计算</h4>
<p>这里举一个例子。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/86fca2663892fb458c7cdef9e81facdf.jpeg#pic_center" alt="节点计算例1"><br>
如图所示，A点为起始点，M点为终点。对于A点来说，对其周边的8个节点进行寻找，A点本身为<strong>父节点</strong>，周边8个点为<strong>子节点</strong>。</p>
<p>假设：</p>
<ul>
<li>格子边长为10，这样水平和竖直位移一格为10，而对角位移一格为14；</li>
<li>从父节点到子节点可以水平、竖直、对角线位移计算 g g g值，而从子节点到目标点只能使用水平、竖直位移计算曼哈顿距离 h h h值。</li>
</ul>
<p>对于点B：从A到B只需右移一格，因此B的 g = 10 g=10 g=10；从B到M需要先右移四格，再上移三格，因此B的 h = 40 + 30 = 70 h = 40+30=70 h=40+30=70。这样B的 f = g + h = 10 + 70 = 80 f=g+h=10+70=80 f=g+h=10+70=80。将三者都记在B格中。<br>
对于点C：从A到C只需向右上方平移一格，因此C的 g = 14 g=14 g=14；从C到M需要先右移四格，再上移两格，因此C的 h = 40 + 20 = 60 h=40+20=60 h=40+20=60，继而C的 f = g + h = 74 f=g+h=74 f=g+h=74。<br>
同理可以计算出D的 g = 14 , h = 80 , f = 94 g=14, h=80,f=94 g=14,h=80,f=94，以及其他几个子节点的值。</p>
<p>将这8个子节点进行对比，可以发现，C点的 f f f值最小，因此选取C点为下一步搜寻的父节点， A C ‾ \overline{AC} AC即为路径迈出的第一步。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/61d8dbfe6ffe8e4eb0d95eb32b2a6032.jpeg#pic_center" alt="节点计算例2"><br>
如图所示，现在将C作为新的父节点。</p>
<p>对于J点：<br>
从C到J只需右移一格，因此J的 g = 10 + g C = 10 + 14 = 24 g=10+g_C =10+14=24 g=10+gC​=10+14=24。需要注意的是，<strong>J点的 g g g值是从C到J的 g g g加上从A到C的 g g g，即当前子节点的 g g g值是从起点到该点的所有 g g g累和</strong>。<br>
从J到M需要先右移三格，再上移两格，因此J的 h = 30 + 20 = 50 h = 30+20=50 h=30+20=50。这样J的 f = g + h = 24 + 50 = 74 f=g+h=24+50=74 f=g+h=24+50=74。将三者都记在J格中。</p>
<p>对于I点：<br>
从C到I只需向右上方平移一格，同样地，<strong>I点的 g g g值是从C到I的 g g g加上从A到C的 g g g，即当前子节点的 g g g值是从起点到该点的所有 g g g累和</strong>，因此I的 g = 14 + g C = 14 + 14 = 28 g=14+g_C =14+14=28 g=14+gC​=14+14=28。<br>
从I到M需要先右移三格，再上移一格，因此I的 h = 30 + 10 = 40 h = 30+10=40 h=30+10=40。这样I的 f = g + h = 28 + 40 = 68 f=g+h=28+40=68 f=g+h=28+40=68。将三者都记在I格中。<br>
同样计算出其他点的值。<br>
可以看出，I点的 f f f值最小，因此选择I点作为路径上的下一个点，此时路径变为 A C I ‾ \overline{ACI} ACI。</p>
<p>如此一步步进行迭代，最后找到最优轨迹。</p>
<h4 id="1-1-2-由计算得出的小结论">1.1.2 由计算得出的小结论</h4>
<ul>
<li>每个节点中需要存储至少3个值： g , h , f g,h,f g,h,f。</li>
<li>当子节点迭代到目标点本身时， h = 0 h=0 h=0，即当前节点到目标点的距离为0.</li>
<li>在算法实施时， g g g的计算可以取10或14，即从父节点到子节点可以水平/竖直位移，也可以沿对角线位移；而 h h h的计算只能取10的倍数，即从当前子节点到目标点只能水平/竖直位移。前者可以采用<strong>欧氏距离</strong>，后者只能采用<strong>曼哈顿距离</strong>。</li>
<li><strong>当某个子节点被选中后，就作为下一次搜索的父节点；并且为了避免节点的重复计算和筛选，在下一次搜索时，需要将上一步选中的节点从“可搜索”列表中删除</strong>。如上图中，当C为父节点时，选中I作为下一次的父节点；那么当第二步I为父节点时，由于C已经在已选轨迹上了，所以I的子节点实际上并不包括C，只计算7个子节点即可。</li>
<li>鉴于上一点，可以预想，算法的具体实施过程中，<strong>需要有两个数组保存“待计算子节点”和“已被选中的节点”。当“待计算子节点”中某个点符合 f f f最小时，就将其加入“已选中的节点”，并在“待计算子节点”中删除该点，防止后续重复计算</strong>。</li>
<li>当算法结束时，<strong>保存在“已选中的节点”中的所有点，按照顺序即为找出的路径</strong>。</li>
<li>算法结束时，<strong>最后一个点的 f f f值，即为从起点到终点所用的距离</strong>。</li>
<li>算法的停止条件：1)当“待计算子节点”中没有点时，即已经没有点可供寻找了；2)当当前父节点恰为目标节点时，即 h = 0 h=0 h=0。</li>
</ul>
<h3 id="1-2-算法逻辑结构">1.2 算法逻辑结构</h3>
<p>A*算法的逻辑结构如下：<br>
1）初始化。导入地图信息，设置障碍物区域，设置起点<code>start</code>、终点<code>target</code>、栅格数量 m × n m \times n m×n等。<br>
2）数据预处理。建立“待计算子节点”的数组<code>openlist</code>，“已选中的节点”的数组<code>closelist</code>，保存路径的数组<code>closelist_path</code>。除此之外，还需建立一个当前子节点集合<code>children</code>，用来保存当前父节点周围8个子节点的坐标，以及父节点本身<code>parent</code>；还有保存代价值 g , h , f g, h,f g,h,f的数组<code>openlist_cost</code>和<code>closelist_cost</code>。<br>
3）对子节点们<code>children</code>中的每个节点<code>child</code>：<br>
若该子节点不在“待计算子节点”节点<code>openlist</code>中，则追加进去；<br>
若在，则计算出该<code>child</code>的 g g g值，该 g g g值是从起点到父节点<code>parent</code>的距离加上父节点到该子节点的距离。若该 g g g值小于之前<code>openlist_cost</code>中的 g g g最小值，那么就将<code>openlist_cost</code>中的最小 g g g值更新；<br>
4）由于该代价最小点已经加入了轨迹，因此将该点加入<code>clost_list</code>和<code>closelist_path</code>，并从<code>openlist</code>中剔除；<br>
5）更新<code>openlist</code>中的最小代价值，并以其为父节点开始新一轮搜索。</p>
<h2 id="2-代码解析">2. 代码解析</h2>
<h3 id="2-1-引入地图">2.1 引入地图</h3>
<p>代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">%% 画地图</span><br><span class="line"></span><br><span class="line">% 栅格地图的行数、列数定义</span><br><span class="line">m = 150;</span><br><span class="line">n = 150;</span><br><span class="line">% 地图m行n列</span><br><span class="line"></span><br><span class="line">start = [10, 20];        % 起始节点</span><br><span class="line">target = [130, 80];       % 终止节点</span><br><span class="line"></span><br><span class="line">obs = TrunToGridMap(m, n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% 画格子</span><br><span class="line">for i = 0 : 5 : m</span><br><span class="line">    plot([0, n], [i, i], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);</span><br><span class="line">    hold on;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for j = 0 : 5 : n</span><br><span class="line">    plot([j, j], [0, m], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">axis equal;</span><br><span class="line">xlim([0, n]);</span><br><span class="line">ylim([0, m]);</span><br><span class="line"></span><br><span class="line">% 绘制障碍物、起止点颜色块</span><br><span class="line">scatter(start(1), start(2), 700, &#x27;pg&#x27;, &#x27;filled&#x27;);</span><br><span class="line">scatter(target(1), target(2), 700, &#x27;pr&#x27;, &#x27;filled&#x27;);</span><br><span class="line"></span><br><span class="line">for i = 1 : size(obs, 1) - 1</span><br><span class="line">    temp = obs(i, :);</span><br><span class="line">    fill([temp(1)-1, temp(1), temp(1), temp(1)-1],...</span><br><span class="line">        [temp(2)-1, temp(2)-1, temp(2), temp(2)], &#x27;k&#x27;, &#x27;handlevisibility&#x27;, &#x27;off&#x27;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">temp = obs(size(obs, 1), :);</span><br><span class="line">fill([temp(1)-1, temp(1), temp(1), temp(1)-1],...</span><br><span class="line">    [temp(2)-1, temp(2)-1, temp(2), temp(2)], &#x27;k&#x27;);</span><br></pre></td></tr></table></figure>
<p>绘制一个 150 × 150 150 \times 150 150×150的地图，起点设置为 ( 10 , 20 ) (10,20) (10,20)，终点设置为 ( 130 , 80 ) (130,80) (130,80)。<br>
障碍物的坐标通过函数<code>TrunToGridMap(m, n)</code>获得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function obs = TrunToGridMap(a, b)</span><br><span class="line">    I=imread(&#x27;此处放地图图片的文件名&#x27;);   %读入图片</span><br><span class="line">    I = rgb2gray(I);     %将图片转为灰度图</span><br><span class="line">    I = imrotate(I, -90);</span><br><span class="line"></span><br><span class="line">    l=1;    %网格边长</span><br><span class="line">    B = imresize(I,[a/l b/l]);</span><br><span class="line">    J=floor(B/255); </span><br><span class="line"></span><br><span class="line">    axes(&#x27;GridLineStyle&#x27;, &#x27;-&#x27;);</span><br><span class="line">    axis equal;</span><br><span class="line"></span><br><span class="line">    hold on</span><br><span class="line">    grid on</span><br><span class="line">    axis([0,a,0,b]);</span><br><span class="line">    set(gca,&#x27;xtick&#x27;,0:10:a,&#x27;ytick&#x27;,0:10:b);</span><br><span class="line"></span><br><span class="line">    obs = [];</span><br><span class="line"></span><br><span class="line">    %障碍物填充为黑色</span><br><span class="line">    for i=1:a/l-1</span><br><span class="line">        for j=1:b/l-1</span><br><span class="line">            if(J(i,j)==0)</span><br><span class="line">                obs(end+1, :) = [i, j];</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>该函数读取一个图片文件，将其转化为灰度图像，并将灰度图中黑色色块所在的坐标返回为障碍物坐标。</p>
<h3 id="2-2-预处理">2.2 预处理</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%% 预处理</span><br><span class="line"></span><br><span class="line">% 初始化closelist</span><br><span class="line">closelist = start;</span><br><span class="line">closelist_path = &#123;start, start&#125;;      % 路径，从自身到自身</span><br><span class="line">closelist_cost = 0;</span><br><span class="line">children = child_nodes_cal(start, m, n, obs, closelist);</span><br><span class="line"></span><br><span class="line">% 初始化openlist</span><br><span class="line">openlist = children;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i = 1 : size(openlist, 1)   % i为第i个节点</span><br><span class="line">    openlist_path&#123;i, 1&#125; = openlist(i, :);   % openlist_path的第i行第1列为第i个节点child</span><br><span class="line">    openlist_path&#123;i, 2&#125; = [start; openlist(i, :)]; % openlist_path的第i行第2列为一个列向量，分别是起始节点和当前child</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i = 1 : size(openlist, 1)</span><br><span class="line">    g = norm(start - openlist(i, 1:2));</span><br><span class="line">    h = abs(target(1) - openlist(i, 1)) + abs(target(2) - openlist(i, 2));</span><br><span class="line">    f = g + h;</span><br><span class="line">    openlist_cost(i, :) = [g, h, f];</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这一部分主要做了以下几步：</p>
<ul>
<li>把起点<code>start</code>设为轨迹的第一个点：<code>closelist = start</code>；</li>
<li>路径初始化，即从起点到起点：<code>closelist_path = &#123;start, start&#125;</code>；</li>
<li>代价首先置为0：<code>closelist_cost = 0</code>；</li>
<li>利用<code>child_nodes_cal</code>函数计算当前父节点（即起点）周围的子节点们；</li>
<li>这些子节点们<code>children</code>即为待计算的子节点，也就是<code>openlist</code>；</li>
<li>随后进入一个循环，对每一个子节点i，<code>openlist_path</code>中第i行第1个元素储存第i个节点<code>child</code>，第2个元素为一个<strong>列向量</strong>，分别是第i个<code>child</code>的起点和它本身；</li>
<li>第二个循环则是计算代价的循环，对每一个子节点i，计算 g g g（这里使用<strong>范数</strong><code>norm</code>）， h h h（曼哈顿距离）和 f f f；之后，在代价数组<code>openlist_cost</code>中储存这三个代价值，因此<code>openlist_cost</code>第i行的元素为一个<strong>行向量</strong>；</li>
</ul>
<p>其中用到的子节点计算函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">function child_nodes = child_nodes_cal(parent_node, m, n, obs, closelist)</span><br><span class="line">    child_nodes = [];</span><br><span class="line">    field = [1, 1;</span><br><span class="line">        n, 1;</span><br><span class="line">        n, m;</span><br><span class="line">        1, m];</span><br><span class="line">    </span><br><span class="line">    % 左上子节点</span><br><span class="line">    child_node = [parent_node(1) - 1, parent_node(2) + 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        % [in, on] = inpolygon, 返回 in，以指明 xq 和 yq 所指定的查询点是在 xv 和 </span><br><span class="line">        % yv 定义的多边形区% 域的边缘内部还是在边缘上,in为内部，on为边缘上</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 上子节点</span><br><span class="line">    child_node = [parent_node(1), parent_node(2) + 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 右上子节点</span><br><span class="line">    child_node = [parent_node(1) + 1, parent_node(2) + 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    % 左子节点</span><br><span class="line">    child_node = [parent_node(1) - 1, parent_node(2)];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    %右子节点</span><br><span class="line">    child_node = [parent_node(1) + 1, parent_node(2)];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    %左下子节点</span><br><span class="line">    child_node = [parent_node(1) - 1, parent_node(2) - 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 下子节点</span><br><span class="line">    child_node = [parent_node(1), parent_node(2) - 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 右下子节点</span><br><span class="line">    child_node = [parent_node(1) + 1, parent_node(2) - 1];</span><br><span class="line">    if inpolygon(child_node(1), child_node(2), field(:, 1), field(:, 2))</span><br><span class="line">        if ~ismember(child_node, obs, &#x27;rows&#x27;)</span><br><span class="line">            child_nodes = [child_nodes; child_node];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    %% 排除已经存在于closelist的节点</span><br><span class="line">    delete_idx = [];</span><br><span class="line">    for i = 1 : size(child_nodes, 1)</span><br><span class="line">        if ismember(child_nodes(i, :), closelist, &#x27;rows&#x27;)</span><br><span class="line">            delete_idx(end+1, :) = i;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    child_nodes(delete_idx, :) = [];</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="2-3-定义父节点parent">2.3 定义父节点<code>parent</code></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%% 定义父节点</span><br><span class="line">% 从openlist开始搜索移动代价最小的节点</span><br><span class="line">[~, min_idx] = min(openlist_cost(:, 3));    % 看f值最小，min_idx为f最小的那一行</span><br><span class="line">parent = openlist(min_idx, :);% 以min_idx该行的子节点child_node为新的父节点</span><br></pre></td></tr></table></figure>
<p>这一步搜索<code>openlist_cost</code>代价数组中 f f f最小的元素，记下其索引<code>min_idx</code>；<br>
随后该索引对应的<code>openlist</code>中的元素即为“ f f f值最小的待计算子节点”，作为下一步计算的父节点<code>parent</code>。</p>
<h3 id="2-4-主循环">2.4 主循环</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">%% 进入循环</span><br><span class="line">flag = 1;</span><br><span class="line">while flag</span><br><span class="line">    % 找出父节点的忽略closelist的子节点</span><br><span class="line">    children = child_nodes_cal(parent ,m, n, obs, closelist);</span><br><span class="line">    </span><br><span class="line">    % 判断这些子节点是否在openlist中，若在，则更新；没在，则追加到openlist中</span><br><span class="line">    for i = 1 : size(children, 1)</span><br><span class="line">        child = children(i, :);</span><br><span class="line">        [in_flag, openlist_idx] = ismember(child, openlist, &#x27;rows&#x27;);</span><br><span class="line">        % in_flag表示该child_node是否在openlist中</span><br><span class="line">        % openlist_idx表示该child_node在openlist中的行数</span><br><span class="line">        </span><br><span class="line">        g = openlist_cost(min_idx, 1) + norm(parent - child);</span><br><span class="line">        % 原来的g加上新的g</span><br><span class="line">        h = abs(child(1) - target(1)) + abs(child(2) - target(2));</span><br><span class="line">        f = g + h;</span><br><span class="line">        </span><br><span class="line">        if in_flag  % 若在，则比较更新g, f</span><br><span class="line">            if g &lt; openlist_cost(openlist_idx, 1)   </span><br><span class="line">                % openlist_cost(openlist_idx,1)指的是openlist_cost中idx这一行（即child_node所在的一行）的第一个坐标，即g</span><br><span class="line">                openlist_cost(openlist_idx, 1) = g;</span><br><span class="line">                openlist_cost(openlist_idx, 3) = f;</span><br><span class="line">                openlist_path&#123;openlist_idx, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];</span><br><span class="line">                % openlist_path的第i行第2列为一个列向量，分别是起始节点和当前child，此处定义新的起始节点为openlist_path(min_idx,2)， 而openlist_path(min_idx,2)指第min_idx行所对应的 child在openlist_path中对应的路径，相当于把新的child附加到了路径上，延长了路径</span><br><span class="line">            end</span><br><span class="line">        else</span><br><span class="line">            openlist(end+1, :) = child;</span><br><span class="line">            openlist_cost(end+1, :) = [g, h, f];</span><br><span class="line">            openlist_path&#123;end+1, 1&#125; = child;</span><br><span class="line">            openlist_path&#123;end, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 从openlist移除代价最小的节点到closelist</span><br><span class="line">    closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">    closelist_cost(end+1, :) = openlist_cost(min_idx, 3);</span><br><span class="line">    closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">    </span><br><span class="line">    % 同样地，openlist中少了该节点</span><br><span class="line">    openlist(min_idx, :) = [];</span><br><span class="line">    openlist_cost(min_idx, :) = [];</span><br><span class="line">    openlist_path(min_idx, :) = [];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    % 重新搜索：从openlist搜索移动代价最小的节点，作为新的父节点</span><br><span class="line">    [~, min_idx] = min(openlist_cost(:, 3));</span><br><span class="line">    parent = openlist(min_idx, :);</span><br><span class="line">    </span><br><span class="line">    % 判断是否搜索到终点</span><br><span class="line">    if parent == target</span><br><span class="line">        closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">        closelist_cost(end+1, 1) = openlist_cost(min_idx, 1);</span><br><span class="line">        closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">        flag = 0;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="2-4-1">2.4.1</h4>
<p>对这一部分循环来说，首先利用<code>child_nodes_cal</code>函数得出当前父节点<code>parent</code>周围的子节点们<code>children</code>；<br>
对每一个子节点<code>child</code>，判断其是否在“待计算子节点”<code>openlist</code>列表中——<code>in_flag</code>=1表示在列表中，同时<code>openlist_idx</code>为该子节点在<code>openlist</code>中的索引号。<br>
判断完成后，首先计算该子节点的 g , h , f g,h,f g,h,f值，注意： g g g值为父节点<code>parent</code>的 g g g加上该<code>child</code>子节点的 g g g值。</p>
<h4 id="2-4-2">2.4.2</h4>
<p>计算 g , h , f g,h,f g,h,f之后，再来看子节点在<code>openlist</code>中的情况。<strong>由于循环中查看了<code>parent</code>周围所有子节点的情况，所以一定会存在某个子节点的 g g g比其他子节点的 g g g都小</strong>。如果找到了这样的子节点，那么就更新该子节点在<code>openlist_cost</code>中对应位置的 g , h , f g,h,f g,h,f值。</p>
<p>同时，还要将该子节点加入到路径<code>openlist_path</code>中，即这一句代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openlist_path&#123;openlist_idx, 2&#125; = [openlist_path&#123;min_idx, 2&#125;; child];</span><br></pre></td></tr></table></figure>
<p>这行代码的含义是：<br>
<code>openlist_idx</code>表示当前子节点<code>child</code>在<code>openlist</code>中的索引，<code>min_idx</code>表示之前所有子节点中代价最小的子节点的索引。之前在<strong>预处理</strong>一节中提到，<code>openlist_path</code>的第i行第2列为一个列向量，分别是父节点和当前child，相当于第2列储存了路径。</p>
<p>而<code>min_idx</code>表示“代价最小的节点”，也就是父节点<code>parent</code>。因此这里<code>openlist_path&#123;min_idx, 2&#125;</code>表示父节点的路径。而<code>[openlist_path&#123;min_idx, 2&#125;; child]</code>则是把新的<code>child</code>附加到这一个列向量上，相当于把新的<code>child</code>附加到路径尾端，把向量长度延长了一个<code>child</code>，延长了路径。</p>
<p>这样，<strong><code>[openlist_path&#123;min_idx, 2&#125;; child]</code>构成了一个“父节点路径-当前child”的新路径</strong>。</p>
<p>把这个新路径赋值给<code>openlist_idx</code>索引所对应的<code>openlist_path</code>上，即为该<code>openlist_idx</code>索引对应的子节点的路径。</p>
<h4 id="2-4-3">2.4.3</h4>
<p>另一方面，如果该<code>child</code>不在<code>openlist</code>中，那么就把该<code>child</code>添加到“待计算子节点”列表中，其 g , h , f g,h,f g,h,f值添加到<code>openlist_cost</code>代价列表中，其路径<code>[openlist_path&#123;min_idx, 2&#125;; child]</code>添加到路径<code>openlist_path</code>中。</p>
<h4 id="2-4-4">2.4.4</h4>
<p>由于移动代价最小的节点已经是路径上的一点了，所以为了避免重复计算，应当把她从“待计算子节点”列表中删除，加入“已计算节点”中，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">closelist_cost(end+1, :) = openlist_cost(min_idx, 3);</span><br><span class="line">closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">% openlist中少了该节点</span><br><span class="line">openlist(min_idx, :) = [];</span><br><span class="line">openlist_cost(min_idx, :) = [];</span><br><span class="line">openlist_path(min_idx, :) = [];</span><br></pre></td></tr></table></figure>
<p>仔细观察不难发现，<code>min_idx</code>对应的正是这一步的<code>parent</code>节点，直到这里，我们才把它加入到“已计算节点”列表中，在之前它一直呆在<code>openlist</code>中。</p>
<h4 id="2-4-5">2.4.5</h4>
<p>父节点加入到了“已计算节点”中了，那么下一步就没有父节点了，所以需要找出新的父节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [~, min_idx] = min(openlist_cost(:, 3));</span><br><span class="line">parent = openlist(min_idx, :);</span><br></pre></td></tr></table></figure>
<p>同时还需要判断一下，是否已经进行到了程序结束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% 判断是否搜索到终点</span><br><span class="line">if parent == target</span><br><span class="line">    closelist(end+1, :) = openlist(min_idx, :);</span><br><span class="line">    closelist_cost(end+1, 1) = openlist_cost(min_idx, 1);</span><br><span class="line">    closelist_path(end+1, :) = openlist_path(min_idx, :);</span><br><span class="line">    flag = 0;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>需要注意，即使当当前父节点已经是目标点了，也不要忘了把这个父节点加入到“已计算节点”中，相当于把目标点添加入路径中，形成路径上最后一个点。</p>
<h3 id="2-5-画图">2.5 画图</h3>
<p>这一步就是将结果绘制出来了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path_opt = closelist_path&#123;end, 2&#125;;</span><br><span class="line">% closelist_path中第二列存放路径，所以path_opt存放的是路径的(x,y)值</span><br><span class="line">path_opt(:, 1) = path_opt(:, 1) - 0.5;</span><br><span class="line">path_opt(:, 2) = path_opt(:, 2) - 0.5;</span><br><span class="line">plot(path_opt(:, 1), path_opt(:, 2), &#x27;m&#x27;, &#x27;linewidth&#x27;, 1.5);</span><br><span class="line"></span><br><span class="line">title([&#x27;Total length of path: &#x27; num2str(closelist_cost(end, 1))]);</span><br><span class="line">legend(&#x27;Start node&#x27;, &#x27;Target node&#x27;, &#x27;Obstacle&#x27;, &#x27;Path&#x27;, &#x27;location&#x27;, &#x27;northwest&#x27;);</span><br><span class="line">set(gca, &#x27;fontsize&#x27;, 35, &#x27;fontname&#x27;, &#x27;times new roman&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="3-结果">3. 结果</h2>
<p>这里导入稻妻地图作为路径规划的示例，该地图多为岛屿，路径复杂，障碍物分散且数量多，十分适合作为示例使用。<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/fcf59433821c1051a8f8714547d79018.png#pic_center" alt="稻妻地图"><br>
将其灰度化得到<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/124b144e99366faa9e582a913fc277e3.jpeg#pic_center" alt="灰度稻妻"><br>
把地图划分为 m × n = 150 × 150 m \times n = 150 \times 150 m×n=150×150的栅格，并设置起点为 ( 10 , 20 ) (10,20) (10,20)，终点为 ( 130 , 80 ) (130,80) (130,80)：<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/50113f38beb35b89434c28535c12ba1b.png#pic_center" alt="稻妻地图栅格"><br>
图中绿色为起点，红色为终点。</p>
<p>路径规划结果：<br>
<img src="https://i-blog.csdnimg.cn/blog_migrate/8a875e6b8ffc0c48064351488be0d262.png#pic_center" alt="稻妻路径规划"><br>
可以看出，A* 算法可以找到期望路径。</p>
<p>文件所有代码在笔者的资源<a target="_blank" rel="noopener" href="https://download.csdn.net/download/weixin_58399148/43085850">二维A*算法路径规划matlab代码</a>中可以下载得到。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/04/14/Algorithms/Astar%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BF%9D%E5%A7%86%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/04/12/Algorithms/Dijkstra%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"
                            aria-label=": Dijkstra简单介绍"
                        >
                            Dijkstra简单介绍
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-04-12T22:53:09+08:00">
	
		    2023 年 4 月 12 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>不是有个叫迪杰斯特拉(Dijkstra)的算法吗？名字难记不说，加权图的最短路径问题在实际开发中也很少需要自己实现，所以总是很快就忘了。。。</p>
<h2 id="迪杰斯特拉算法是什么"><a href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"></a>迪杰斯特拉算法是什么</h2>
<p>迪杰斯特拉算法是一种用于求解图的最短路径的算法。很多人可能只是听过这个名字。虽然它的原理简单易懂，但初次接触可能有些难以理解，不过只要逐步分析就会发现它其实是一个相当直观的算法。<br>
对于没有权重的迷宫搜索等问题，可以用广度优先搜索(BFS)解决，但如果每条边都有权重，就需要计算所有可能的路径。假设每个顶点只经过一次，且有E条边，那么时间复杂度会是O(E!)，计算量会爆炸式增长。<br>
这样计算起来就很不现实。</p>
<p>而迪杰斯特拉算法正是高效解决这类问题的算法。</p>
<p>需要注意的是，各边的成本必须是非负值（大于等于0）。如果包含负数，则需要使用贝尔曼-福特(Bellman-Ford)等算法。</p>
<h2 id="步骤"><a href="#%E6%AD%A5%E9%AA%A4"></a>步骤</h2>
<p>迪杰斯特拉算法的步骤非常简单：</p>
<ol>
<li>将起点的最短距离设为0</li>
<li>从未访问的点中选择已知最短距离且距离最小的顶点移动</li>
<li>设置该顶点连接的其他顶点的最短距离。如果可以更新更短的距离，则更新。</li>
<li>重复以上步骤，直到所有顶点的最短距离都确定</li>
</ol>
<p>光这么说可能有点抽象，下面我们通过一个具体例子来说明。</p>
<h2 id="示例"><a href="#%E7%A4%BA%E4%BE%8B"></a>示例</h2>
<p>虽然方法很原始，但这是最能表达清楚的方式…<br>
我们来看下面这张图的最短路径：<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F90f90a2f-8991-1bc5-adb4-fb4b053a901f.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b9d055575e737f8a2c459474e25322c7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F90f90a2f-8991-1bc5-adb4-fb4b053a901f.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b9d055575e737f8a2c459474e25322c7" alt="image.png"></a></p>
<p>绿色表示最短路径已确定并已访问的顶点，红色是起点顶点。每个顶点上的数字表示当前的最短路径：<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fae1ddc01-e867-8894-7aee-3940269cfe2e.gif?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=0b8d3bd32321d163185bac4e6ecf4db7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fae1ddc01-e867-8894-7aee-3940269cfe2e.gif?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=0b8d3bd32321d163185bac4e6ecf4db7" alt="dijkstra algo.gif"></a></p>
<p>可以看到，算法从起点开始，每次移动到当前最短路径的顶点，并计算相邻顶点的最短路径。</p>
<h2 id="实现"><a href="#%E5%AE%9E%E7%8E%B0"></a>实现</h2>
<p>接下来我们来实现这个算法。<br>
按照上述步骤直接实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">nodes</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> start = nodes[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 记录已访问的顶点</span></span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">const</span> routesFromStart = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">     <span class="comment">// 记录从起点出发的距离</span></span><br><span class="line"></span><br><span class="line">    routesFromStart.<span class="title function_">set</span>(start, &#123;<span class="attr">distance</span>: <span class="number">0</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> n <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n != start) &#123;</span><br><span class="line">            <span class="comment">// 除起点外所有顶点初始化为无穷大</span></span><br><span class="line">            routesFromStart.<span class="title function_">set</span>(n, &#123;<span class="attr">distance</span>: <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = start</span><br><span class="line">    <span class="keyword">let</span> routes = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">null</span>) &#123;</span><br><span class="line">        visited.<span class="title function_">add</span>(current)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> edge <span class="keyword">of</span> current.<span class="property">edges</span>) &#123;</span><br><span class="line">             <span class="comment">// 计算相邻顶点的最短距离，如果更小则更新</span></span><br><span class="line">            <span class="keyword">if</span>(edge.<span class="property">cost</span> + routesFromStart.<span class="title function_">get</span>(current).<span class="property">distance</span> &lt; routesFromStart.<span class="title function_">get</span>(edge.<span class="property">to</span>).<span class="property">distance</span>) &#123;</span><br><span class="line">                routesFromStart.<span class="title function_">set</span>(edge.<span class="property">to</span>, &#123;<span class="attr">distance</span>: edge.<span class="property">cost</span> + routesFromStart.<span class="title function_">get</span>(current).<span class="property">distance</span>&#125;)</span><br><span class="line">                routes.<span class="title function_">set</span>(current, edge.<span class="property">to</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> cheapestNodeDistance = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span></span><br><span class="line">        current = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 从已计算最短距离的未访问顶点中选择最小的顶点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> city <span class="keyword">of</span> routesFromStart.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.<span class="title function_">has</span>(city) &amp;&amp; cheapestNodeDistance &gt; routesFromStart.<span class="title function_">get</span>(city).<span class="property">distance</span>)&#123;</span><br><span class="line">                cheapestNodeDistance = routesFromStart.<span class="title function_">get</span>(city).<span class="property">distance</span></span><br><span class="line">                current = city</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> routesFromStart.<span class="title function_">get</span>(nodes[nodes.<span class="property">length</span> - <span class="number">1</span>]).<span class="property">distance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设顶点数为V，这段代码在最坏情况下需要遍历所有边，并在内部循环中选择最小顶点，因此时间复杂度是O(V² + E)。空间复杂度需要记录每个顶点，所以是O(V)。</p>
<h2 id="关于使用优先队列的实现"><a href="#%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"></a>关于使用优先队列的实现</h2>
<p>细心的读者可能已经发现，这段代码中选取最小顶点的逻辑可以优化，这就是优先队列(Priority Queue)。<br>
优先队列的插入和取出操作需要O(logN)的时间复杂度，但比线性搜索最小顶点更快。</p>
<p>JavaScript没有内置优先队列，以下是Python实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">nodes</span>):</span><br><span class="line">    start_node = nodes[<span class="number">0</span>]</span><br><span class="line">    routes_from_start = &#123;n: math.inf <span class="keyword">for</span> n <span class="keyword">in</span> nodes&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 起点距离设为0</span></span><br><span class="line">    routes_from_start[start_node] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    minHeap = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加起点</span></span><br><span class="line">    heappush(minHeap, (<span class="number">0</span>, start_node))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直到堆为空</span></span><br><span class="line">    <span class="keyword">while</span> minHeap:</span><br><span class="line">        (cost, current_node) = heappop(minHeap)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查priority key是否重复</span></span><br><span class="line">        <span class="keyword">if</span> cost &gt; routes_from_start[current_node]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> current_node.routes:</span><br><span class="line">            price_info = current_node.routes[node]</span><br><span class="line">            <span class="keyword">if</span> routes_from_start[node] &gt; price_info + routes_from_start[current_node]:</span><br><span class="line">                routes_from_start[node] = price_info + routes_from_start[current_node]</span><br><span class="line">                <span class="comment"># 记录更新最短距离的节点</span></span><br><span class="line">                heappush(minHeap, (price_info + routes_from_start[current_node], node))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> routes_from_start[nodes[-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>优先队列的说明我们以后再讨论。<br>
优化后的算法时间复杂度为O(V + ElogE)，比最初的实现更高效。</p>
<h2 id="记录路径"><a href="#%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84"></a>记录路径</h2>
<p>现在我们已经能求出最短成本，但这是&quot;最短路径&quot;问题，我们自然还想知道具体路径。<br>
改进上面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">nodes</span>):</span><br><span class="line">    start_node = nodes[<span class="number">0</span>]</span><br><span class="line">    routes_from_start = &#123;n: math.inf <span class="keyword">for</span> n <span class="keyword">in</span> nodes&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 起点距离设为0</span></span><br><span class="line">    routes_from_start[start_node] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    minHeap = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加起点</span></span><br><span class="line">    heappush(minHeap, (<span class="number">0</span>, start_node))</span><br><span class="line">    path = collections.defaultdict(Node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直到堆为空</span></span><br><span class="line">    <span class="keyword">while</span> minHeap:</span><br><span class="line">        (cost, current_node) = heappop(minHeap)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查priority key是否重复</span></span><br><span class="line">        <span class="keyword">if</span> cost &gt; routes_from_start[current_node]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> current_node.routes:</span><br><span class="line">            price_info = current_node.routes[node]</span><br><span class="line">            <span class="keyword">if</span> routes_from_start[node] &gt; price_info + routes_from_start[current_node]:</span><br><span class="line">                routes_from_start[node] = price_info + routes_from_start[current_node]</span><br><span class="line">                <span class="comment"># 记录更新最短距离的节点</span></span><br><span class="line">                path[node.<span class="built_in">id</span>] = current_node.<span class="built_in">id</span></span><br><span class="line">                heappush(minHeap, (price_info + routes_from_start[current_node], node))</span><br><span class="line"></span><br><span class="line">    current_node = nodes[-<span class="number">1</span>].<span class="built_in">id</span></span><br><span class="line">    path_array = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从终点回溯记录的最短路径节点</span></span><br><span class="line">    <span class="keyword">while</span> current_node:</span><br><span class="line">        path_array.append(current_node)</span><br><span class="line">        <span class="keyword">if</span> current_node <span class="keyword">not</span> <span class="keyword">in</span> path:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        current_node = path[current_node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> routes_from_start[nodes[-<span class="number">1</span>]], path_array[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>迪杰斯特拉算法会记录更新最短距离的节点，最后回溯即可。时间复杂度会增加最短路径节点数的计算量。</p>
<h2 id="为什么这样能求出最短路径"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E8%83%BD%E6%B1%82%E5%87%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"></a>为什么这样能求出最短路径</h2>
<p>看到这里，很多人可能会想：算法本身很简单，实现也不难，但为什么能保证求出最短距离呢？我们简单验证一下：</p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8623f00e-2046-445a-f386-6341b4bef518.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4286b7e1195710b30d6ffb7ab22967c7"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8623f00e-2046-445a-f386-6341b4bef518.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=4286b7e1195710b30d6ffb7ab22967c7" alt="image.png"></a></p>
<p>假设集合L中的顶点到起点S的最短距离已确定，那么从L连接到的最小顶点也应该是S的最短距离。</p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8eb04095-91e7-85e6-93f1-93cd7f927fa0.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b64897102d0f8dec7ed56385248d0a06"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F8eb04095-91e7-85e6-93f1-93cd7f927fa0.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=b64897102d0f8dec7ed56385248d0a06" alt="image.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fa10dcc01-c558-6f52-3b6f-906cb3433456.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=57a5fb3ec3b55e91b33e0184905063aa"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2Fa10dcc01-c558-6f52-3b6f-906cb3433456.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=57a5fb3ec3b55e91b33e0184905063aa" alt="image.png"></a></p>
<p>在集合T中选取最小顶点i，则d[i] = min(T)。对于任意顶点k，最短距离d[k] ≥ d[i]是确定的，因为d[i]是最小值且各边权重非负。<br>
通过归纳法可以证明这一点。</p>
<p>其实这就是一个递推公式：</p>
<p>d[i] = min(k ⊂ T) + i到L中相邻顶点的最短距离</p>
<p>说到递推公式就想到动态规划(DP)。关于DP可以参考这篇文章：<br>
<a target="_blank" rel="noopener" href="https://qiita.com/drken/items/a5e6fe22863b7992efdb">https://qiita.com/drken/items/a5e6fe22863b7992efdb</a></p>
<p>用DP来看值的更新过程：<br>
<a target="_blank" rel="noopener" href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F800c0d89-06f7-335a-5195-2f47d85cc22c.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=76478692796218d17f0ab00d2f2651b4"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F134294%2F800c0d89-06f7-335a-5195-2f47d85cc22c.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=76478692796218d17f0ab00d2f2651b4" alt="image.png"></a></p>
<p>纵轴表示迭代次数，横轴表示顶点。原来迪杰斯特拉算法是DP的一种啊。</p>
<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93"></a>总结</h2>
<p>通过以上分析，迪杰斯特拉算法一旦理解后其实相当简单。以后在算法问题中遇到类似问题时，希望能快速联想到这个算法。<br>
*顺便说一句，我也想写一篇关于DP的文章</p>
<p>讲解视频可以在这里观看：<br>
<a target="_blank" rel="noopener" href="https://youtu.be/jz8b0q5R1Ss">https://youtu.be/jz8b0q5R1Ss</a></p>
<h2 id="参考"><a href="#%E5%8F%82%E8%80%83"></a>参考</h2>
<p><a target="_blank" rel="noopener" href="http://www.lab2.kuis.kyoto-u.ac.jp/~shuichi/algintro/alg-6s.pdf">http://www.lab2.kuis.kyoto-u.ac.jp/~shuichi/algintro/alg-6s.pdf</a><br>
<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=X1AsMlJdiok">https://www.youtube.com/watch?v=X1AsMlJdiok</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/04/12/Algorithms/Dijkstra%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/30/Teraform/Terraform-%E5%B0%8F%E6%8A%80%E5%B7%A7/"
                            aria-label=": Terraform-小技巧"
                        >
                            Terraform-小技巧
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-30T17:43:45+08:00">
	
		    2023 年 1 月 30 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%88%9B%E5%BB%BA"><strong>1.9.1.1.</strong> 有条件创建</a></li>
</ul>
<p><a href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%88%9B%E5%BB%BA"></a></p>
<h2 id="1-9-1-1-有条件创建"><a href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%88%9B%E5%BB%BA"></a>1.9.1.1. 有条件创建</h2>
<p>Terraform被设计成声明式而非命令式，例如没有常见的 <code>if</code> 条件语句，后来才加上了 <code>count</code> 和 <code>for_each</code> 实现的循环语句(但循环的次数必须是在 <code>plan</code> 阶段就能够确认的，无法根据其他 <code>resource</code> 的输出动态决定)</p>
<p>有时候我们需要根据某种条件来判断是否创建一个资源。虽然我们无法使用if来完成条件判断，但我们还有 <code>count</code> 和 <code>for_each</code> 可以帮助我们完成这个目标。</p>
<p>我们以 UCloud 为例，假如我们正在编写一个旨在被复用的模块，模块的逻辑要创建一台虚拟机，我们的代码可以是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data ucloud_vpcs &quot;default&quot; &#123;</span><br><span class="line">  name_regex = &quot;^Default&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;centos&quot; &#123;</span><br><span class="line">  name_regex = &quot;^CentOS 7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  availability_zone = &quot;cn-bj2-02&quot;</span><br><span class="line">  image_id = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type = &quot;n-basic-2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;uhost_id&quot; &#123;</span><br><span class="line">  value = ucloud_instance.web.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单。但是如果我们想进一步，让模块的调用者决定创建的主机是否要搭配一个弹性公网 IP 该怎么办？</p>
<p>我们可以在上面的代码后面接上这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;allocate_public_ip&quot; &#123;</span><br><span class="line">  description = &quot;Decide whether to allocate a public ip and bind it to the host&quot;</span><br><span class="line">  type = bool</span><br><span class="line">  default = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_eip&quot; &quot;public_ip&quot; &#123;</span><br><span class="line">  count = var.allocate_public_ip ? 1 : 0</span><br><span class="line">  name = &quot;public_ip_for_$&#123;ucloud_instance.web.name&#125;&quot;</span><br><span class="line">  internet_type = &quot;bgp&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_eip_association&quot; &quot;public_ip_binding&quot; &#123;</span><br><span class="line">  count = var.allocate_public_ip ? 1 : 0</span><br><span class="line">  eip_id = ucloud_eip.public_ip[0].id</span><br><span class="line">  resource_id = ucloud_instance.web.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先创建了名为 <code>allocate_public_ip</code> 的输入变量，然后在编写弹性 IP 相关资源代码的时候都声明了 <code>count</code> 参数，值使用了条件表达式，根据 <code>allocate_public_ip</code> 这个输入变量的值决定是 <code>1</code> 还是 <code>0</code>。这实际上实现了按条件创建资源。</p>
<p>需要注意的是，由于我们使用了 <code>count</code>，所以现在弹性 IP 相关的资源实际上是多实例资源类型的。我们在 <code>ucloud_eip_association.public_ip_binding</code> 中引用 <code>ucloud_eip.public</code> 时，还是要加上访问下标。由于 <code>ucloud_eip_association.public_ip_binding</code> 与 <code>ucloud_eip.public</code> 实际上是同生同死，所以在这里他们之间的引用还比较简单；如果是其他没有声明 <code>count</code> 的资源引用它们的话，还要针对 <code>allocate_public_ip</code> 为 <code>false</code> 时 <code>ucloud_eip.public</code> 实际为空做相应处理，比如在 <code>output</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output &quot;public_ip&quot; &#123;</span><br><span class="line">  value = join(&quot;&quot;, ucloud_eip.public_ip[*].public_ip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>join</code> 函数就可以在即使没有创建弹性 IP 时也能返回空字符串。或者我们也可以用条件表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output &quot;public_ip&quot; &#123;</span><br><span class="line">  value = length(ucloud_eip.public_ip[*].public_ip) &gt; 0 ? ucloud_eip.public_ip[0].public_ip : &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC"><strong>1.9.2.1.</strong> 依赖反转</a></li>
</ul>
<p><a href="#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC"></a></p>
<h2 id="1-9-2-1-依赖反转"><a href="#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC"></a>1.9.2.1. 依赖反转</h2>
<p>Terraform 编排的基础设施对象彼此之间可能互相存在依赖关系，有时我们在编写一些旨在重用的模块时，模块内定义的资源可能本身需要依赖其他一些资源，这些资源可能已经存在，也可能有待创建。</p>
<p>举一个例子，假设我们编写了一个模块，定义了在 UCloud 上同一个 VPC 中的两台服务器；第一台服务器部署了一个 Web 应用，它被分配在一个 DMZ 子网里；第二台服务器部署了一个数据库，它被分配在一个内网子网里。现在的问题是，在我们编写模块时，我们并没有关于 VPC 和子网的任何信息，我们甚至连服务器应该部署在哪个可用区都不知道。VPC 和子网可能已经存在，也可以有待创建。</p>
<p>我们可以定义这样的一个模块代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    ucloud = &#123;</span><br><span class="line">      source  = &quot;ucloud/ucloud&quot;</span><br><span class="line">      version = &quot;~&gt;1.22.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;network_config&quot; &#123;</span><br><span class="line">  type = object(&#123;</span><br><span class="line">    vpc_id         = string</span><br><span class="line">    web_app_config = object(&#123;</span><br><span class="line">      az        = string</span><br><span class="line">      subnet_id = string</span><br><span class="line">    &#125;)</span><br><span class="line">    db_config      = object(&#123;</span><br><span class="line">      az        = string</span><br><span class="line">      subnet_id = string</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;web_app&quot; &#123;</span><br><span class="line">  name_regex = &quot;^WebApp&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;mysql&quot; &#123;</span><br><span class="line">  name_regex = &quot;^MySql 5.7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web_app&quot; &#123;</span><br><span class="line">  availability_zone = var.network_config.web_app_config.az</span><br><span class="line">  image_id          = data.ucloud_images.web_app.images[0].id</span><br><span class="line">  instance_type     = &quot;n-basic-2&quot;</span><br><span class="line">  vpc_id            = var.network_config.vpc_id</span><br><span class="line">  subnet_id         = var.network_config.web_app_config.subnet_id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;mysql&quot; &#123;</span><br><span class="line">  availability_zone = var.network_config.db_config.az</span><br><span class="line">  image_id          = data.ucloud_images.mysql.images[0].id</span><br><span class="line">  instance_type     = &quot;n-basic-2&quot;</span><br><span class="line">  vpc_id            = var.network_config.vpc_id</span><br><span class="line">  subnet_id         = var.network_config.db_config.subnet_id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中我们把依赖的网络参数定义为一个复杂类型，一个强类型对象结构。这样的话模块代码就不用再关注网络层究竟是查询而来的还是创建的，模块中只定义了抽象的网络层定义，其具体实现由调用者从外部注入，从而实现了依赖反转。</p>
<p>如果调用者需要创建网络层，那么代码可以是这样的(假设我们把前面编写的模块保存在 <code>./machine</code> 目录下而成为一个内嵌模块)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  cidr_blocks = [</span><br><span class="line">    &quot;192.168.0.0/16&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_subnet&quot; &quot;dmz&quot; &#123;</span><br><span class="line">  cidr_block = &quot;192.168.0.0/24&quot;</span><br><span class="line">  vpc_id     = ucloud_vpc.vpc.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_subnet&quot; &quot;db&quot; &#123;</span><br><span class="line">  cidr_block = &quot;192.168.1.0/24&quot;</span><br><span class="line">  vpc_id     = ucloud_vpc.vpc.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;machine&quot; &#123;</span><br><span class="line">  source         = &quot;./machine&quot;</span><br><span class="line">  network_config = &#123;</span><br><span class="line">    vpc_id         = ucloud_vpc.vpc.id</span><br><span class="line">    web_app_config = &#123;</span><br><span class="line">      az        = &quot;cn-bj2-02&quot;</span><br><span class="line">      subnet_id = ucloud_subnet.dmz.id</span><br><span class="line">    &#125;</span><br><span class="line">    db_config      = &#123;</span><br><span class="line">      az        = &quot;cn-bj2-02&quot;</span><br><span class="line">      subnet_id = ucloud_subnet.db.id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者我们想使用现存的网络来托管服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">data &quot;ucloud_vpcs&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  name_regex = &quot;^AVeryImportantVpc&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_subnets&quot; dmz_subnet &#123;</span><br><span class="line">  vpc_id     = data.ucloud_vpcs.vpc.vpcs[0].id</span><br><span class="line">  name_regex = &quot;^DMZ&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_subnets&quot; &quot;db_subnet&quot; &#123;</span><br><span class="line">  vpc_id     = data.ucloud_vpcs.vpc.vpcs[0].id</span><br><span class="line">  name_regex = &quot;^DataBase&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;machine&quot; &#123;</span><br><span class="line">  source         = &quot;./machine&quot;</span><br><span class="line">  network_config = &#123;</span><br><span class="line">    vpc_id         = data.ucloud_vpcs.vpc.vpcs[0].id</span><br><span class="line">    web_app_config = &#123;</span><br><span class="line">      az        = &quot;cn-bj2-02&quot;</span><br><span class="line">      subnet_id = data.ucloud_subnets.dmz_subnet.subnets[0].id</span><br><span class="line">    &#125;</span><br><span class="line">    db_config      = &#123;</span><br><span class="line">      az        = &quot;cn-bj2-02&quot;</span><br><span class="line">      subnet_id = data.ucloud_subnets.db_subnet.subnets[0].id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于模块代码中对网络层的定义是抽象的，并没有指定必须是 <code>resource</code> 或是 <code>data</code>，所以使得模块的调用者可以自己决定如何构造模块的依赖层，作为参数注入模块。</p>
<ul>
<li><a href="#%E5%A4%9A%E5%8F%AF%E7%94%A8%E5%8C%BA%E5%88%86%E5%B8%83"><strong>1.9.3.1.</strong> 多可用区分布</a></li>
</ul>
<p><a href="#%E5%A4%9A%E5%8F%AF%E7%94%A8%E5%8C%BA%E5%88%86%E5%B8%83"></a></p>
<h2 id="1-9-3-1-多可用区分布"><a href="#%E5%A4%9A%E5%8F%AF%E7%94%A8%E5%8C%BA%E5%88%86%E5%B8%83"></a>1.9.3.1. 多可用区分布</h2>
<p>这是一个相当常见的小技巧。多数公有云为了高可用性，都在单一区域内提供了多可用区的设计。一个可区是一个逻辑上的数据中心，单个可用区可能由于各种自然灾害、网络故障而导致不可用，所以公有云应用部署高可用应用应时刻考虑跨可用区设计。</p>
<p>假如我们想要创建 N 台不同的云主机实例，在 Terraform 0.12 之前的版本中，我们只能用 <code>count</code> 配合模运算来达成这个目的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;az&quot; &#123;</span><br><span class="line">  type    = list(string)</span><br><span class="line">  default = [</span><br><span class="line">    &quot;cn-bj2-03&quot;,</span><br><span class="line">    &quot;cn-bj2-04&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;instance_count&quot; &#123;</span><br><span class="line">  type    = number</span><br><span class="line">  default = 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;centos&quot; &#123;</span><br><span class="line">  name_regex = &quot;^CentOS 7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  count             = var.instance_count</span><br><span class="line">  availability_zone = var.az[count.index % length(var.az)]</span><br><span class="line">  image_id          = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type     = &quot;n-standard-1&quot;</span><br><span class="line">  charge_type       = &quot;dynamic&quot;</span><br><span class="line">  name              = &quot;$&#123;var.az[count.index % length(var.az)]&#125;-$&#123;floor(count.index/length(var.az))&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说就是使用 <code>count</code> 创建多实例资源时，用 <code>var.az[count.index % length(var.az)]</code> 可以循环使用每个可用区，使得机器尽可能均匀分布在各个可用区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply -auto-approve</span><br><span class="line">data.ucloud_images.centos: Refreshing state...</span><br><span class="line">ucloud_instance.web[2]: Creating...</span><br><span class="line">ucloud_instance.web[0]: Creating...</span><br><span class="line">ucloud_instance.web[1]: Creating...</span><br><span class="line">ucloud_instance.web[3]: Creating...</span><br><span class="line">ucloud_instance.web[2]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[0]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[1]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[3]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[2]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[0]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[1]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[3]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[2]: Creation complete after 22s [<span class="built_in">id</span>=uhost-txa2owrp]</span><br><span class="line">ucloud_instance.web[3]: Creation complete after 24s [<span class="built_in">id</span>=uhost-v3qxdbju]</span><br><span class="line">ucloud_instance.web[1]: Creation complete after 26s [<span class="built_in">id</span>=uhost-td3x545p]</span><br><span class="line">ucloud_instance.web[0]: Still creating... [30s elapsed]</span><br><span class="line">ucloud_instance.web[0]: Still creating... [40s elapsed]</span><br><span class="line">ucloud_instance.web[0]: Creation complete after 43s [<span class="built_in">id</span>=uhost-scq1prqj]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 4 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure>
<p>我们可以看一下创建的主机信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">$ terraform show</span><br><span class="line"><span class="comment"># data.ucloud_images.centos:</span></span><br><span class="line">data <span class="string">&quot;ucloud_images&quot;</span> <span class="string">&quot;centos&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">id</span>          = <span class="string">&quot;475496684&quot;</span></span><br><span class="line">    ids         = [</span><br><span class="line">        <span class="string">&quot;uimage-22noyd&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-3p0wg0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-4keil1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-aqvo5l&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-f1chxn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-hq5elw&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-rkn1v2&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    images      = [</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-23T17:39:46+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.0 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.0 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-16T21:05:03+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-f1chxn&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.2 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.2 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-09-09T11:40:31+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot; &quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-aqvo5l&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.4 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.4 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2020-05-07T17:40:42+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">                <span class="string">&quot;CloudInit&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-hq5elw&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.6 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.6 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-16T21:05:05+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-3p0wg0&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.3 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.3 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-16T21:05:02+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-4keil1&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.1 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.1 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-16T21:04:53+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-22noyd&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.5 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.5 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    most_recent = <span class="literal">false</span></span><br><span class="line">    name_regex  = <span class="string">&quot;^CentOS 7&quot;</span></span><br><span class="line">    total_count = 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ucloud_instance.web[1]:</span></span><br><span class="line">resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">    auto_renew        = <span class="literal">true</span></span><br><span class="line">    availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span></span><br><span class="line">    boot_disk_size    = 20</span><br><span class="line">    boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">    charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">    cpu               = 1</span><br><span class="line">    cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span></span><br><span class="line">    create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span></span><br><span class="line">    disk_set          = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">id</span>      = <span class="string">&quot;df06380a-00e1-42df-8c07-eec67d817f97&quot;</span></span><br><span class="line">            is_boot = <span class="literal">true</span></span><br><span class="line">            size    = 20</span><br><span class="line">            <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    expire_time       = <span class="string">&quot;2020-11-29T00:09:06+08:00&quot;</span></span><br><span class="line">    <span class="built_in">id</span>                = <span class="string">&quot;uhost-td3x545p&quot;</span></span><br><span class="line">    image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span></span><br><span class="line">    instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">    ip_set            = [</span><br><span class="line">        &#123;</span><br><span class="line">            internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">            ip            = <span class="string">&quot;10.9.44.37&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    memory            = 4</span><br><span class="line">    name              = <span class="string">&quot;cn-bj2-04-0&quot;</span></span><br><span class="line">    private_ip        = <span class="string">&quot;10.9.44.37&quot;</span></span><br><span class="line">    root_password     = (sensitive value)</span><br><span class="line">    security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">    status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">    subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">    tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">    vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ucloud_instance.web[2]:</span></span><br><span class="line">resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">    auto_renew        = <span class="literal">true</span></span><br><span class="line">    availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">    boot_disk_size    = 20</span><br><span class="line">    boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">    charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">    cpu               = 1</span><br><span class="line">    cpu_platform      = <span class="string">&quot;Intel/IvyBridge&quot;</span></span><br><span class="line">    create_time       = <span class="string">&quot;2020-11-28T23:09:01+08:00&quot;</span></span><br><span class="line">    disk_set          = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">id</span>      = <span class="string">&quot;1d7f07c9-7342-431b-85bb-d3ee0022063d&quot;</span></span><br><span class="line">            is_boot = <span class="literal">true</span></span><br><span class="line">            size    = 20</span><br><span class="line">            <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    expire_time       = <span class="string">&quot;2020-11-29T00:09:02+08:00&quot;</span></span><br><span class="line">    <span class="built_in">id</span>                = <span class="string">&quot;uhost-txa2owrp&quot;</span></span><br><span class="line">    image_id          = <span class="string">&quot;uimage-pxplaj&quot;</span></span><br><span class="line">    instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">    ip_set            = [</span><br><span class="line">        &#123;</span><br><span class="line">            internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">            ip            = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    memory            = 4</span><br><span class="line">    name              = <span class="string">&quot;cn-bj2-03-1&quot;</span></span><br><span class="line">    private_ip        = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">    root_password     = (sensitive value)</span><br><span class="line">    security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">    status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">    subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">    tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">    vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ucloud_instance.web[3]:</span></span><br><span class="line">resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">    auto_renew        = <span class="literal">true</span></span><br><span class="line">    availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span></span><br><span class="line">    boot_disk_size    = 20</span><br><span class="line">    boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">    charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">    cpu               = 1</span><br><span class="line">    cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span></span><br><span class="line">    create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span></span><br><span class="line">    disk_set          = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">id</span>      = <span class="string">&quot;31e2cad6-79a1-4475-a9f5-2c5c95605b18&quot;</span></span><br><span class="line">            is_boot = <span class="literal">true</span></span><br><span class="line">            size    = 20</span><br><span class="line">            <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    expire_time       = <span class="string">&quot;2020-11-29T00:09:04+08:00&quot;</span></span><br><span class="line">    <span class="built_in">id</span>                = <span class="string">&quot;uhost-v3qxdbju&quot;</span></span><br><span class="line">    image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span></span><br><span class="line">    instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">    ip_set            = [</span><br><span class="line">        &#123;</span><br><span class="line">            internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">            ip            = <span class="string">&quot;10.9.85.40&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    memory            = 4</span><br><span class="line">    name              = <span class="string">&quot;cn-bj2-04-1&quot;</span></span><br><span class="line">    private_ip        = <span class="string">&quot;10.9.85.40&quot;</span></span><br><span class="line">    root_password     = (sensitive value)</span><br><span class="line">    security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">    status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">    subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">    tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">    vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ucloud_instance.web[0]:</span></span><br><span class="line">resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">    auto_renew        = <span class="literal">true</span></span><br><span class="line">    availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">    boot_disk_size    = 20</span><br><span class="line">    boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">    charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">    cpu               = 1</span><br><span class="line">    cpu_platform      = <span class="string">&quot;Intel/IvyBridge&quot;</span></span><br><span class="line">    create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span></span><br><span class="line">    disk_set          = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">id</span>      = <span class="string">&quot;da27595d-9645-4883-bf95-87b9076ab7e4&quot;</span></span><br><span class="line">            is_boot = <span class="literal">true</span></span><br><span class="line">            size    = 20</span><br><span class="line">            <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    expire_time       = <span class="string">&quot;2020-11-29T00:09:04+08:00&quot;</span></span><br><span class="line">    <span class="built_in">id</span>                = <span class="string">&quot;uhost-scq1prqj&quot;</span></span><br><span class="line">    image_id          = <span class="string">&quot;uimage-pxplaj&quot;</span></span><br><span class="line">    instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">    ip_set            = [</span><br><span class="line">        &#123;</span><br><span class="line">            internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">            ip            = <span class="string">&quot;10.9.107.152&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    memory            = 4</span><br><span class="line">    name              = <span class="string">&quot;cn-bj2-03-0&quot;</span></span><br><span class="line">    private_ip        = <span class="string">&quot;10.9.107.152&quot;</span></span><br><span class="line">    root_password     = (sensitive value)</span><br><span class="line">    security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">    status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">    subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">    tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">    vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主机的确是均匀地分散在两个可用区了。</p>
<p>但是这样做在调整可用区时会发生大问题，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;az&quot; &#123;</span><br><span class="line">  type = list(string)</span><br><span class="line">  default = [</span><br><span class="line">    &quot;cn-bj2-03&quot;,</span><br><span class="line">#    &quot;cn-bj2-04&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们禁用了 <code>cn-bj2-04</code> 可用区，按道理我们期待的变更计划应该是将两台原本属于 <code>cn-bj2-04</code> 的主机删除，在 <code>cn-bj2-03</code> 可用区新增两台主机。让我们看看会发生什么：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">$ terraform plan</span><br><span class="line">Refreshing Terraform state in-memory prior to plan...</span><br><span class="line">The refreshed state will be used to calculate this plan, but will not be</span><br><span class="line">persisted to <span class="built_in">local</span> or remote state storage.</span><br><span class="line"></span><br><span class="line">data.ucloud_images.centos: Refreshing state... [<span class="built_in">id</span>=475496684]</span><br><span class="line">ucloud_instance.web[0]: Refreshing state... [<span class="built_in">id</span>=uhost-scq1prqj]</span><br><span class="line">ucloud_instance.web[3]: Refreshing state... [<span class="built_in">id</span>=uhost-v3qxdbju]</span><br><span class="line">ucloud_instance.web[2]: Refreshing state... [<span class="built_in">id</span>=uhost-txa2owrp]</span><br><span class="line">ucloud_instance.web[1]: Refreshing state... [<span class="built_in">id</span>=uhost-td3x545p]</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">An execution plan has been generated and is shown below.</span><br><span class="line">Resource actions are indicated with the following symbols:</span><br><span class="line">  ~ update in-place</span><br><span class="line">-/+ destroy and <span class="keyword">then</span> create replacement</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[1] must be replaced</span></span><br><span class="line">-/+ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      ~ auto_renew        = <span class="literal">true</span> -&gt; (known after apply)</span><br><span class="line">      ~ availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03&quot;</span> <span class="comment"># forces replacement</span></span><br><span class="line">      ~ boot_disk_size    = 20 -&gt; (known after apply)</span><br><span class="line">      ~ boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; (known after apply)</span><br><span class="line">        charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      ~ cpu               = 1 -&gt; (known after apply)</span><br><span class="line">      ~ cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      ~ disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;df06380a-00e1-42df-8c07-eec67d817f97&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      ~ expire_time       = <span class="string">&quot;2020-11-29T00:09:06+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ <span class="built_in">id</span>                = <span class="string">&quot;uhost-td3x545p&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">        instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      ~ ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.44.37&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      ~ memory            = 4 -&gt; (known after apply)</span><br><span class="line">      ~ name              = <span class="string">&quot;cn-bj2-04-0&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-1&quot;</span></span><br><span class="line">      ~ private_ip        = <span class="string">&quot;10.9.44.37&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      ~ root_password     = (sensitive value)</span><br><span class="line">      ~ security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ status            = <span class="string">&quot;Running&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; (known after apply)</span><br><span class="line">        tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      ~ vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[2] will be updated in-place</span></span><br><span class="line">  ~ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">        auto_renew        = <span class="literal">true</span></span><br><span class="line">        availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">        boot_disk_size    = 20</span><br><span class="line">        boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">        cpu               = 1</span><br><span class="line">        cpu_platform      = <span class="string">&quot;Intel/IvyBridge&quot;</span></span><br><span class="line">        create_time       = <span class="string">&quot;2020-11-28T23:09:01+08:00&quot;</span></span><br><span class="line">        disk_set          = [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">id</span>      = <span class="string">&quot;1d7f07c9-7342-431b-85bb-d3ee0022063d&quot;</span></span><br><span class="line">                is_boot = <span class="literal">true</span></span><br><span class="line">                size    = 20</span><br><span class="line">                <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">        expire_time       = <span class="string">&quot;2020-11-29T00:09:02+08:00&quot;</span></span><br><span class="line">        <span class="built_in">id</span>                = <span class="string">&quot;uhost-txa2owrp&quot;</span></span><br><span class="line">        image_id          = <span class="string">&quot;uimage-pxplaj&quot;</span></span><br><span class="line">        instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">        ip_set            = [</span><br><span class="line">            &#123;</span><br><span class="line">                internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">                ip            = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">        memory            = 4</span><br><span class="line">      ~ name              = <span class="string">&quot;cn-bj2-03-1&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-2&quot;</span></span><br><span class="line">        private_ip        = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">        root_password     = (sensitive value)</span><br><span class="line">        security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">        status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">        subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">        tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">        vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[3] must be replaced</span></span><br><span class="line">-/+ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      ~ auto_renew        = <span class="literal">true</span> -&gt; (known after apply)</span><br><span class="line">      ~ availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03&quot;</span> <span class="comment"># forces replacement</span></span><br><span class="line">      ~ boot_disk_size    = 20 -&gt; (known after apply)</span><br><span class="line">      ~ boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; (known after apply)</span><br><span class="line">        charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      ~ cpu               = 1 -&gt; (known after apply)</span><br><span class="line">      ~ cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      ~ disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;31e2cad6-79a1-4475-a9f5-2c5c95605b18&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      ~ expire_time       = <span class="string">&quot;2020-11-29T00:09:04+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ <span class="built_in">id</span>                = <span class="string">&quot;uhost-v3qxdbju&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">        instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      ~ ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.85.40&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      ~ memory            = 4 -&gt; (known after apply)</span><br><span class="line">      ~ name              = <span class="string">&quot;cn-bj2-04-1&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-3&quot;</span></span><br><span class="line">      ~ private_ip        = <span class="string">&quot;10.9.85.40&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      ~ root_password     = (sensitive value)</span><br><span class="line">      ~ security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ status            = <span class="string">&quot;Running&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; (known after apply)</span><br><span class="line">        tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      ~ vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 2 to add, 1 to change, 2 to destroy.</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Note: You didn<span class="string">&#x27;t specify an &quot;-out&quot; parameter to save this plan, so Terraform</span></span><br><span class="line"><span class="string">can&#x27;</span>t guarantee that exactly these actions will be performed <span class="keyword">if</span></span><br><span class="line"><span class="string">&quot;terraform apply&quot;</span> is subsequently run.</span><br></pre></td></tr></table></figure>
<p>变更计划与期望略有不同。我们仔细看细节：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ucloud_instance.web[2] will be updated in-place</span></span><br><span class="line">~ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      auto_renew        = <span class="literal">true</span></span><br><span class="line">      availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">      boot_disk_size    = 20</span><br><span class="line">      boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">      charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      cpu               = 1</span><br><span class="line">      cpu_platform      = <span class="string">&quot;Intel/IvyBridge&quot;</span></span><br><span class="line">      create_time       = <span class="string">&quot;2020-11-28T23:09:01+08:00&quot;</span></span><br><span class="line">      disk_set          = [</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">id</span>      = <span class="string">&quot;1d7f07c9-7342-431b-85bb-d3ee0022063d&quot;</span></span><br><span class="line">              is_boot = <span class="literal">true</span></span><br><span class="line">              size    = 20</span><br><span class="line">              <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">      ]</span><br><span class="line">      expire_time       = <span class="string">&quot;2020-11-29T00:09:02+08:00&quot;</span></span><br><span class="line">      <span class="built_in">id</span>                = <span class="string">&quot;uhost-txa2owrp&quot;</span></span><br><span class="line">      image_id          = <span class="string">&quot;uimage-pxplaj&quot;</span></span><br><span class="line">      instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      ip_set            = [</span><br><span class="line">          &#123;</span><br><span class="line">              internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              ip            = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">      ]</span><br><span class="line">      memory            = 4</span><br><span class="line">    ~ name              = <span class="string">&quot;cn-bj2-03-1&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-2&quot;</span></span><br><span class="line">      private_ip        = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">      root_password     = (sensitive value)</span><br><span class="line">      security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">      status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">      subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">      tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>原本名为 <code>cn-bj2-03-1</code> 的主机被更名为 <code>cn-bj2-03-2</code> 了，原本属于 <code>cn-bj2-04</code> 的第一台主机的变更计划是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"># ucloud_instance.web[1] must be replaced</span></span><br><span class="line">-/+ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      ~ auto_renew        = <span class="literal">true</span> -&gt; (known after apply)</span><br><span class="line">      ~ availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03&quot;</span> <span class="comment"># forces replacement</span></span><br><span class="line">      ~ boot_disk_size    = 20 -&gt; (known after apply)</span><br><span class="line">      ~ boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; (known after apply)</span><br><span class="line">        charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      ~ cpu               = 1 -&gt; (known after apply)</span><br><span class="line">      ~ cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      ~ disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;df06380a-00e1-42df-8c07-eec67d817f97&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      ~ expire_time       = <span class="string">&quot;2020-11-29T00:09:06+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ <span class="built_in">id</span>                = <span class="string">&quot;uhost-td3x545p&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">        instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      ~ ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.44.37&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      ~ memory            = 4 -&gt; (known after apply)</span><br><span class="line">      ~ name              = <span class="string">&quot;cn-bj2-04-0&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-1&quot;</span></span><br><span class="line">      ~ private_ip        = <span class="string">&quot;10.9.44.37&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      ~ root_password     = (sensitive value)</span><br><span class="line">      ~ security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ status            = <span class="string">&quot;Running&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; (known after apply)</span><br><span class="line">        tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      ~ vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; (known after apply)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>它的名字从 <code>cn-bj2-04-0</code> 变成了 <code>cn-bj2-03-1</code>。</p>
<p>仔细想想，实际上这是一个比较低效的变更计划。原本属于 <code>cn-bj2-03</code> 的两台主机应该不做任何变更，只需要删除 <code>cn-bj2-04</code> 的主机，再补充两台 <code>cn-bj2-03</code> 的主机即可。这是因为我们使用的是 <code>count</code>，而 <code>count</code> 只看元素在列表中的序号。当我们删除一个可用区时，实际上会引起主机序号的重大变化，导致出现大量低效的变更，这就是我们在讲 <code>count</code> 与 <code>for_each</code> 时强调过的，如果创建的资源实例彼此之间几乎完全一致，那么 <code>count</code> 比较合适。否则，那么使用 <code>for_each</code> 会更加安全。</p>
<p>让我们尝试使用 <code>for_each</code> 改写这段逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;az&quot; &#123;</span><br><span class="line">  type    = list(string)</span><br><span class="line">  default = [</span><br><span class="line">    &quot;cn-bj2-03&quot;,</span><br><span class="line">    &quot;cn-bj2-04&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;instance_count&quot; &#123;</span><br><span class="line">  type    = number</span><br><span class="line">  default = 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  instance_names = [for i in range(var.instance_count):&quot;$&#123;var.az[i%length(var.az)]&#125;-$&#123;floor(i/length(var.az))&#125;&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;centos&quot; &#123;</span><br><span class="line">  name_regex = &quot;^CentOS 7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  for_each          = toset(local.instance_names)</span><br><span class="line">  name              = each.value</span><br><span class="line">  availability_zone = var.az[index(local.instance_names, each.value) % length(var.az)]</span><br><span class="line">  image_id          = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type     = &quot;n-standard-1&quot;</span><br><span class="line">  charge_type       = &quot;dynamic&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了生成主机独一无二的名字，我们首先用 <code>range</code> 函数生成了一个序号集合，比如目标主机数是 <code>4</code>，那么 <code>range(4)</code> 的结果就是 <code>[0, 1, 2, 3]</code>；然后我们通过取模运算使得名字前缀在可用区列表之间循环递增，最后用 <code>floor(i/length(var.az))</code> 计算出当前序号对应在当前可用区是第几台。例如 4 号主机在第二个可用区就是第二台，生成的名字应该就是 <code>cn-bj-04-1</code>。</p>
<p>执行结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply -auto-approve</span><br><span class="line">data.ucloud_images.centos: Refreshing state...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Creating...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Creating...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Creating...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Creating...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Creation complete after 21s [<span class="built_in">id</span>=uhost-fjci1i4o]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Creation complete after 23s [<span class="built_in">id</span>=uhost-bkkhmref]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Creation complete after 26s [<span class="built_in">id</span>=uhost-amosgdaa]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Still creating... [30s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Still creating... [40s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Creation complete after 45s [<span class="built_in">id</span>=uhost-kltudgnf]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 4 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure>
<p>如果我们去掉一个可用区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;az&quot; &#123;</span><br><span class="line">  type = list(string)</span><br><span class="line">  default = [</span><br><span class="line">    &quot;cn-bj2-03&quot;,</span><br><span class="line">#    &quot;cn-bj2-04&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以检查一下执行计划：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">$ terraform plan</span><br><span class="line">Refreshing Terraform state in-memory prior to plan...</span><br><span class="line">The refreshed state will be used to calculate this plan, but will not be</span><br><span class="line">persisted to <span class="built_in">local</span> or remote state storage.</span><br><span class="line"></span><br><span class="line">data.ucloud_images.centos: Refreshing state... [<span class="built_in">id</span>=475496684]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Refreshing state... [<span class="built_in">id</span>=uhost-amosgdaa]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Refreshing state... [<span class="built_in">id</span>=uhost-bkkhmref]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Refreshing state... [<span class="built_in">id</span>=uhost-kltudgnf]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Refreshing state... [<span class="built_in">id</span>=uhost-fjci1i4o]</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">An execution plan has been generated and is shown below.</span><br><span class="line">Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line">  - destroy</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[&quot;cn-bj2-03-2&quot;] will be created</span></span><br><span class="line">  + resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      + auto_renew        = (known after apply)</span><br><span class="line">      + availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">      + boot_disk_size    = (known after apply)</span><br><span class="line">      + boot_disk_type    = (known after apply)</span><br><span class="line">      + charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      + cpu               = (known after apply)</span><br><span class="line">      + cpu_platform      = (known after apply)</span><br><span class="line">      + create_time       = (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      + disk_set          = (known after apply)</span><br><span class="line">      + expire_time       = (known after apply)</span><br><span class="line">      + <span class="built_in">id</span>                = (known after apply)</span><br><span class="line">      + image_id          = <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">      + instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      + ip_set            = (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      + memory            = (known after apply)</span><br><span class="line">      + name              = <span class="string">&quot;cn-bj2-03-2&quot;</span></span><br><span class="line">      + private_ip        = (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      + root_password     = (sensitive value)</span><br><span class="line">      + security_group    = (known after apply)</span><br><span class="line">      + status            = (known after apply)</span><br><span class="line">      + subnet_id         = (known after apply)</span><br><span class="line">      + tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      + vpc_id            = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[&quot;cn-bj2-03-3&quot;] will be created</span></span><br><span class="line">  + resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      + auto_renew        = (known after apply)</span><br><span class="line">      + availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">      + boot_disk_size    = (known after apply)</span><br><span class="line">      + boot_disk_type    = (known after apply)</span><br><span class="line">      + charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      + cpu               = (known after apply)</span><br><span class="line">      + cpu_platform      = (known after apply)</span><br><span class="line">      + create_time       = (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      + disk_set          = (known after apply)</span><br><span class="line">      + expire_time       = (known after apply)</span><br><span class="line">      + <span class="built_in">id</span>                = (known after apply)</span><br><span class="line">      + image_id          = <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">      + instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      + ip_set            = (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      + memory            = (known after apply)</span><br><span class="line">      + name              = <span class="string">&quot;cn-bj2-03-3&quot;</span></span><br><span class="line">      + private_ip        = (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      + root_password     = (sensitive value)</span><br><span class="line">      + security_group    = (known after apply)</span><br><span class="line">      + status            = (known after apply)</span><br><span class="line">      + subnet_id         = (known after apply)</span><br><span class="line">      + tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      + vpc_id            = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[&quot;cn-bj2-04-0&quot;] will be destroyed</span></span><br><span class="line">  - resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      - auto_renew        = <span class="literal">true</span> -&gt; null</span><br><span class="line">      - availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; null</span><br><span class="line">      - boot_disk_size    = 20 -&gt; null</span><br><span class="line">      - boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; null</span><br><span class="line">      - charge_type       = <span class="string">&quot;dynamic&quot;</span> -&gt; null</span><br><span class="line">      - cpu               = 1 -&gt; null</span><br><span class="line">      - cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; null</span><br><span class="line">      - create_time       = <span class="string">&quot;2020-11-28T22:35:53+08:00&quot;</span> -&gt; null</span><br><span class="line">      - disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;b214d840-ffec-4958-a3da-3580846fd2a3&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; null</span><br><span class="line">      - expire_time       = <span class="string">&quot;2020-11-28T23:35:53+08:00&quot;</span> -&gt; null</span><br><span class="line">      - <span class="built_in">id</span>                = <span class="string">&quot;uhost-bkkhmref&quot;</span> -&gt; null</span><br><span class="line">      - image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; null</span><br><span class="line">      - instance_type     = <span class="string">&quot;n-standard-1&quot;</span> -&gt; null</span><br><span class="line">      - ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.48.82&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; null</span><br><span class="line">      - memory            = 4 -&gt; null</span><br><span class="line">      - name              = <span class="string">&quot;cn-bj2-04-0&quot;</span> -&gt; null</span><br><span class="line">      - private_ip        = <span class="string">&quot;10.9.48.82&quot;</span> -&gt; null</span><br><span class="line">      - root_password     = (sensitive value)</span><br><span class="line">      - security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; null</span><br><span class="line">      - status            = <span class="string">&quot;Running&quot;</span> -&gt; null</span><br><span class="line">      - subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; null</span><br><span class="line">      - tag               = <span class="string">&quot;Default&quot;</span> -&gt; null</span><br><span class="line">      - vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[&quot;cn-bj2-04-1&quot;] will be destroyed</span></span><br><span class="line">  - resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      - auto_renew        = <span class="literal">true</span> -&gt; null</span><br><span class="line">      - availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; null</span><br><span class="line">      - boot_disk_size    = 20 -&gt; null</span><br><span class="line">      - boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; null</span><br><span class="line">      - charge_type       = <span class="string">&quot;dynamic&quot;</span> -&gt; null</span><br><span class="line">      - cpu               = 1 -&gt; null</span><br><span class="line">      - cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; null</span><br><span class="line">      - create_time       = <span class="string">&quot;2020-11-28T22:35:53+08:00&quot;</span> -&gt; null</span><br><span class="line">      - disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;6a3f274f-e072-4a46-90f8-edc7dbaa27f7&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; null</span><br><span class="line">      - expire_time       = <span class="string">&quot;2020-11-28T23:35:53+08:00&quot;</span> -&gt; null</span><br><span class="line">      - <span class="built_in">id</span>                = <span class="string">&quot;uhost-fjci1i4o&quot;</span> -&gt; null</span><br><span class="line">      - image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; null</span><br><span class="line">      - instance_type     = <span class="string">&quot;n-standard-1&quot;</span> -&gt; null</span><br><span class="line">      - ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.176.28&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; null</span><br><span class="line">      - memory            = 4 -&gt; null</span><br><span class="line">      - name              = <span class="string">&quot;cn-bj2-04-1&quot;</span> -&gt; null</span><br><span class="line">      - private_ip        = <span class="string">&quot;10.9.176.28&quot;</span> -&gt; null</span><br><span class="line">      - root_password     = (sensitive value)</span><br><span class="line">      - security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; null</span><br><span class="line">      - status            = <span class="string">&quot;Running&quot;</span> -&gt; null</span><br><span class="line">      - subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; null</span><br><span class="line">      - tag               = <span class="string">&quot;Default&quot;</span> -&gt; null</span><br><span class="line">      - vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 2 to add, 0 to change, 2 to destroy.</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Note: You didn<span class="string">&#x27;t specify an &quot;-out&quot; parameter to save this plan, so Terraform</span></span><br><span class="line"><span class="string">can&#x27;</span>t guarantee that exactly these actions will be performed <span class="keyword">if</span></span><br><span class="line"><span class="string">&quot;terraform apply&quot;</span> is subsequently run.</span><br></pre></td></tr></table></figure>
<p>可以看到，原来属于 <code>cn-bj2-03</code> 的两台主机原封不动，删除了属于 <code>cn-bj2-04</code> 的两台主机，并且在 <code>cn-bj2-03</code> 可用区新增两台主机。</p>
<ul>
<li><a href="#provisioner-%E4%B8%8E-userdata"><strong>1.9.4.1.</strong> provisioner 与 user_data</a></li>
</ul>
<p><a href="#provisioner-%E4%B8%8E-userdata"></a></p>
<h2 id="1-9-4-1-provisioner-与-user-data"><a href="#provisioner-%E4%B8%8E-userdata"></a>1.9.4.1. provisioner 与 user_data</h2>
<p>我们在介绍资源时介绍了<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#provisioner-%E5%92%8C-connection">预置器 <code>provisioner</code></a>。同时不少公有云厂商的虚拟机都提供了 cloud-init 功能，可以让我们在虚拟机实例第一次启动时执行一段自定义的脚本来执行一些初始化操作。例如我们在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/1.Terraform%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C/">Terraform 初步体验</a>一章里举的例子，在 UCloud 主机第一次启动时我们通过 <code>user_data</code> 来调用 yum 安装并配置了 ngnix 服务。预置器与 cloud-init 都可以用于初始化虚拟机，那么我们应该用哪一种呢？</p>
<p>首先要指出的是，<code>provisioner</code> 的官方文档里明确指出，由于预置器内部的行为 Terraform 无法感知，无法将它执行的变更纳入到声明式的代码管理中，所以预置器应被作为最后的手段使用，那么也就是说，如果 cloud-init 能够满足我们的要求，那么我们应该优先使用 cloud-init。</p>
<p>但是仍然存在一些 cloud-init 无法满足的场景。例如一个最常见的情况是，比如我们要在 cloud-init 当中格式化卷，后续的所有操作都必须在主机成功格式化并挂载卷之后才能顺利进行下去。但是比如 <code>aws_instance</code>，它的创建是不会等待 <code>user_data</code> 代码执行完成的，只要虚拟机创建成功开始启动，Terraform 就会认为资源创建完成从而继续后续的创建了。</p>
<p>解决这个问题目前来看还是只能依靠预置器。我们以一段 UCloud 云主机代码为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  availability_zone         = &quot;cn-bj2-03&quot;</span><br><span class="line">  image_id                  = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type             = &quot;n-standard-1&quot;</span><br><span class="line">  charge_type               = &quot;dynamic&quot;</span><br><span class="line">  network_interface &#123;</span><br><span class="line">    eip_internet_type = &quot;bgp&quot;</span><br><span class="line">    eip_charge_mode   = &quot;traffic&quot;</span><br><span class="line">    eip_bandwidth     = 1</span><br><span class="line">  &#125;</span><br><span class="line">  delete_eips_with_instance = true</span><br><span class="line">  root_password             = var.root_password</span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123;</span><br><span class="line">    connection &#123;</span><br><span class="line">      type     = &quot;ssh&quot;</span><br><span class="line">      host     = [for ipset in self.ip_set: ipset.ip if ipset.internet_type==&quot;BGP&quot;][0]</span><br><span class="line">      user     = &quot;root&quot;</span><br><span class="line">      password = var.root_password</span><br><span class="line">      timeout  = &quot;1h&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    inline = [</span><br><span class="line">      &quot;sleep 1h&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在资源声明中附加了一个 <code>remote-exec</code> 类型的预置器，它的 <code>host</code> 取值使用了 <code>self.ip_set</code>，<code>self</code> 在当前上下文中指代 <code>provisioner</code> 所属的 <code>ucloud_instance.web</code>，<code>ip_set</code> 是 <code>ucloud_instance</code> 的一个输出属性，内含云主机的内网 IP 以及绑定的弹性公网 IP 信息。我们用一个 <code>for</code> 表达式过滤出弹性公网 IP 地址，然后使用 ssh 连接。预置器执行的脚本代码很简单，休眠一小时。如果我们执行这段代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply -auto-approve</span><br><span class="line">data.ucloud_images.centos: Refreshing state...</span><br><span class="line">ucloud_instance.web: Creating...</span><br><span class="line">ucloud_instance.web: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web: Provisioning with <span class="string">&#x27;remote-exec&#x27;</span>...</span><br><span class="line">ucloud_instance.web (remote-exec): Connecting to remote host via SSH...</span><br><span class="line">ucloud_instance.web (remote-exec):   Host: 106.75.87.148</span><br><span class="line">ucloud_instance.web (remote-exec):   User: root</span><br><span class="line">ucloud_instance.web (remote-exec):   Password: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Private key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Certificate: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   SSH Agent: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Checking Host Key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web: Still creating... [30s elapsed]</span><br><span class="line">ucloud_instance.web (remote-exec): Connecting to remote host via SSH...</span><br><span class="line">ucloud_instance.web (remote-exec):   Host: 106.75.87.148</span><br><span class="line">ucloud_instance.web (remote-exec):   User: root</span><br><span class="line">ucloud_instance.web (remote-exec):   Password: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Private key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Certificate: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   SSH Agent: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Checking Host Key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web: Still creating... [40s elapsed]</span><br><span class="line">ucloud_instance.web (remote-exec): Connecting to remote host via SSH...</span><br><span class="line">ucloud_instance.web (remote-exec):   Host: 106.75.87.148</span><br><span class="line">ucloud_instance.web (remote-exec):   User: root</span><br><span class="line">ucloud_instance.web (remote-exec):   Password: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Private key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Certificate: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   SSH Agent: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Checking Host Key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec): Connected!</span><br><span class="line">ucloud_instance.web: Still creating... [50s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m0s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m10s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m20s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m30s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m40s elapsed]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>不出所料的话，该过程会持续一小时，也就是说，无论预置器脚本中执行的操作耗时多长，<code>ucloud_instance</code> 的创建都会等待它完成，或是触发超时。</p>
<p>在这里我们可以使用这种方法的前提是我们使用的 UCloud 云主机的资源定义允许我们定义资源时声明 <code>network_interface</code> 属性，直接绑定一个公网 IP。如果我们使用的云厂商 Provider 无法让我们在创建主机时绑定公网 IP，而是必须事后绑定弹性 IP 呢？又或者，初始化脚本必须在云主机成功绑定了云盘之后才能成功运行？这种情况下我们还有最后的武器，就是 <code>null_resource</code>。</p>
<p><code>null_resource</code> 可能是 Terraform 体系中最“不 Terraform”的存在，它就是我们用来在 Terraform 这样一个声明式世界里干各种命令式脏活的工具。<code>null_resouce</code> 本身是一个空的 <code>resource</code>，只有一个名为 <code>triggers</code> 的参数以及 <code>id</code> 作为输出属性。</p>
<p>我们看下这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">data &quot;ucloud_images&quot; &quot;centos&quot; &#123;</span><br><span class="line">  name_regex = &quot;^CentOS 7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_eip&quot; &quot;eip&quot; &#123;</span><br><span class="line">  internet_type = &quot;bgp&quot;</span><br><span class="line">  bandwidth     = 1</span><br><span class="line">  charge_mode   = &quot;traffic&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_disk&quot; &quot;data_disk&quot; &#123;</span><br><span class="line">  availability_zone = &quot;cn-bj2-03&quot;</span><br><span class="line">  disk_size         = 10</span><br><span class="line">  charge_type       = &quot;dynamic&quot;</span><br><span class="line">  disk_type         = &quot;data_disk&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  availability_zone = &quot;cn-bj2-03&quot;</span><br><span class="line">  image_id          = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type     = &quot;n-standard-1&quot;</span><br><span class="line">  charge_type       = &quot;dynamic&quot;</span><br><span class="line">  root_password     = var.root_password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_eip_association&quot; &quot;eip_association&quot; &#123;</span><br><span class="line">  eip_id      = ucloud_eip.eip.id</span><br><span class="line">  resource_id = ucloud_instance.web.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_disk_attachment&quot; &quot;data_disk&quot; &#123;</span><br><span class="line">  availability_zone = &quot;cn-bj2-03&quot;</span><br><span class="line">  disk_id           = ucloud_disk.data_disk.id</span><br><span class="line">  instance_id       = ucloud_instance.web.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;null_resource&quot; &quot;web_init&quot; &#123;</span><br><span class="line">  depends_on = [</span><br><span class="line">    ucloud_eip_association.eip_association,</span><br><span class="line">    ucloud_disk_attachment.data_disk</span><br><span class="line">  ]</span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123;</span><br><span class="line">    connection &#123;</span><br><span class="line">      type     = &quot;ssh&quot;</span><br><span class="line">      host     = ucloud_eip.eip.public_ip</span><br><span class="line">      user     = &quot;root&quot;</span><br><span class="line">      password = var.root_password</span><br><span class="line">    &#125;</span><br><span class="line">    inline = [</span><br><span class="line">      &quot;echo hello&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们假设需要远程执行的操纵是必须在云盘挂载成功以后才可以运行的，那么我们可以声明一个 <code>null_resource</code>，把 <code>provisioner</code> 声明放在那里，通过显式声明 <code>depends_on</code> 确保它的执行一定是在云盘挂载结束以后。</p>
<p>另外这个例子里我们运行的脚本非常简单，考虑一种更加复杂一些的场景，我们运行的脚本是通过文件读取的，我们希望在文件内容发生变化时能够重新在服务器上运行该脚本，这时我们可以使用 <code>null_resource</code> 的 <code>triggers</code> 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;null_resource&quot; &quot;web_init&quot; &#123;</span><br><span class="line">  depends_on = [</span><br><span class="line">    ucloud_eip_association.eip_association,</span><br><span class="line">    ucloud_disk_attachment.data_disk</span><br><span class="line">  ]</span><br><span class="line">  triggers = &#123;</span><br><span class="line">    script_hash = filemd5(&quot;$&#123;path.module&#125;/init.sh&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123;</span><br><span class="line">    connection &#123;</span><br><span class="line">      type     = &quot;ssh&quot;</span><br><span class="line">      host     = ucloud_eip.eip.public_ip</span><br><span class="line">      user     = &quot;root&quot;</span><br><span class="line">      password = var.root_password</span><br><span class="line">    &#125;</span><br><span class="line">    script = &quot;$&#123;path.module&#125;/init.sh&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>provisioner</code> 运行的脚本是通过 <code>script</code> 参数传入的脚本文件路径，而我们通过 <code>filemd5</code> 函数把文件内容的哈希值传入了 <code>triggers</code>。<code>triggers</code> 会在值发生改变时触发 <code>null_resource</code> 的重建，这样脚本发生些许变化都会导致重新执行。</p>
<p>官方文档上还给出了对于 <code>triggers</code> 的另一个妙用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;cluster&quot; &#123;</span><br><span class="line">  count = 3</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;null_resource&quot; &quot;cluster&quot; &#123;</span><br><span class="line">  # Changes to any instance of the cluster requires re-provisioning</span><br><span class="line">  triggers = &#123;</span><br><span class="line">    cluster_instance_ids = &quot;$&#123;join(&quot;,&quot;, aws_instance.cluster.*.id)&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # Bootstrap script can run on any instance of the cluster</span><br><span class="line">  # So we just choose the first in this case</span><br><span class="line">  connection &#123;</span><br><span class="line">    host = &quot;$&#123;element(aws_instance.cluster.*.public_ip, 0)&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123;</span><br><span class="line">    # Bootstrap script called with private_ip of each node in the clutser</span><br><span class="line">    inline = [</span><br><span class="line">      &quot;bootstrap-cluster.sh $&#123;join(&quot; &quot;, aws_instance.cluster.*.private_ip)&#125;&quot;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里，我们需要所有 AWS 主机的内网 IP 参与才能够成功初始化集群，可能是类似 Kafka 或是 RabbitMQ 这样的应用，我们需要把集群节点的IP写入配置文件。如何确保未来机器数量发生调整以后，机器上的配置文件始终能够获得完整的集群内网 IP 信息，这里使用 <code>triggers</code> 就可以轻松完成目标。</p>
<p>另外在绝大多数生产环境中，服务器都不允许拥有独立的公网 IP，或是禁止从服务器对外服务的公网 IP 直接连接 ssh。这时一般我们会在集群中配置一台堡垒机，通过堡垒机进行跳转连接。可以访问<a target="_blank" rel="noopener" href="https://www.terraform.io/docs/provisioners/connection.html#connecting-through-a-bastion-host-with-ssh">通过堡垒机使用SSH的官方文档</a>获取详细信息，在此不再赘述。</p>
<h2 id="destroy-provisioner中使用变量"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">destroy-provisioner中使用变量</a></h2>
<ul>
<li>
<p><a href="#destroy-provisioner-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><strong>1.9.5.1.</strong> destroy-provisioner 中使用变量</a></p>
</li>
<li>
<p><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><strong>1.9.5.1.1.</strong> 解决方法</a></p>
</li>
</ul>
<p><a href="#destroy-provisioner-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"></a></p>
<h2 id="1-9-5-1-destroy-provisioner-中使用变量"><a href="#destroy-provisioner-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"></a>1.9.5.1. destroy-provisioner 中使用变量</h2>
<p>我们可以在定义一个 <code>provisioner</code> 块时设置 <code>when</code> 为 <code>destroy</code>，资源在销毁<strong>之前</strong>会首先执行 <code>provisioner</code>，可以帮助我们执行一些析构逻辑。但是如果我们在 Destroy-Provisioner 中引用了变量的话，比如这样的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">&quot;aws_volume_attachment&quot;</span> <span class="string">&quot;attachement_myservice&quot;</span> &#123;</span><br><span class="line">  count         = <span class="string">&quot;$&#123;length(var.network_myservice_subnet_ids)&#125;&quot;</span></span><br><span class="line">  device_name   = <span class="string">&quot;/dev/xvdg&quot;</span></span><br><span class="line">  volume_id     =   <span class="string">&quot;$&#123;element(aws_ebs_volume.ebs_myservice.*.id, count.index)&#125;&quot;</span></span><br><span class="line">  instance_id   =   <span class="string">&quot;$&#123;element(aws_instance.myservice.*.id, count.index)&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">  provisioner <span class="string">&quot;local-exec&quot;</span> &#123;</span><br><span class="line">    command = <span class="string">&quot;aws ec2 stop-instances --instance-ids $&#123;element(aws_instance.myservice.*.id, count.index)&#125; --region $&#123;var.region&#125; &amp;&amp; sleep 30&quot;</span></span><br><span class="line">    when = <span class="string">&quot;destroy&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们会看见这样的报错信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|  Error: Invalid reference from destroy provisioner</span><br><span class="line">│ </span><br><span class="line">│ Destroy-time provisioners and their connection configurations may only reference attributes of the related resource, via &#x27;self&#x27;, &#x27;count.index&#x27;, or &#x27;each.key&#x27;.</span><br><span class="line">│ </span><br><span class="line">│ References to other resources during the destroy phase can cause dependency cycles and interact poorly with create_before_destroy.</span><br></pre></td></tr></table></figure>
<p>从 <code>0.12</code> 开始 Terraform 会对在 Destroy-Time Provisioner 中引用除 <code>self</code>、<code>count.index</code>、<code>each.key</code> 以外的变量做警告，从 <code>0.13</code> 开始则会直接报错。</p>
<h2 id="1-9-5-1-1-解决方法"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"></a>1.9.5.1.1. 解决方法</h2>
<p>目前官方推荐的做法是把需要引用的变量值通过 <code>triggers</code> “捕获”一下再引用，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">&quot;null_resource&quot;</span> <span class="string">&quot;foo&quot;</span> &#123;</span><br><span class="line">  triggers &#123;</span><br><span class="line">    interpreter = <span class="keyword">var</span>.local_exec_interpreter</span><br><span class="line">  &#125;</span><br><span class="line">  provisioner &#123;</span><br><span class="line">    when = destroy</span><br><span class="line"></span><br><span class="line">    interpreter = self.triggers.interpreter</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方法就可以避免这个问题。</p>
<ul>
<li>
<p><a href="#%E5%88%A9%E7%94%A8-nullresource-%E7%9A%84-triggers-%E8%A7%A6%E5%8F%91%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E6%9B%B4%E6%96%B0"><strong>1.9.6.1.</strong> 利用 null_resource 的 triggers 触发其他资源更新</a></p>
</li>
<li>
<p><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><strong>1.9.6.1.1.</strong> 问题描述</a></p>
</li>
<li>
<p><a href="#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"><strong>1.9.6.1.2.</strong> 问题原因</a></p>
</li>
<li>
<p><a href="#%E5%B7%A7%E7%94%A8-nullresource-%E7%9A%84-triggers"><strong>1.9.6.1.3.</strong> 巧用 null_resource 的 triggers</a></p>
</li>
<li>
<p><a href="#%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%AE%9E%E9%AA%8C"><strong>1.9.6.1.4.</strong> 一个小实验</a></p>
</li>
</ul>
<p><a href="#%E5%88%A9%E7%94%A8-nullresource-%E7%9A%84-triggers-%E8%A7%A6%E5%8F%91%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E6%9B%B4%E6%96%B0"></a></p>
<h2 id="1-9-6-1-利用-null-resource-的-triggers-触发其他资源更新"><a href="#%E5%88%A9%E7%94%A8-nullresource-%E7%9A%84-triggers-%E8%A7%A6%E5%8F%91%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E6%9B%B4%E6%96%B0"></a>1.9.6.1. 利用 null_resource 的 triggers 触发其他资源更新</h2>
<p>社区有人提了一个 Terraform 问题，他写了这样一段 Terraform 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_key_vault_secret&quot; &quot;service_bus_connection_string&quot; &#123;</span><br><span class="line">  name = &quot;service-bus-connection-string&quot;</span><br><span class="line"></span><br><span class="line">  value        = azurerm_servicebus_topic_authorization_rule.mysb.primary_connection_string</span><br><span class="line">  key_vault_id = azurerm_key_vault.main.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;azurerm_function_app&quot; &quot;main&quot; &#123;</span><br><span class="line">  name                = &quot;myfn&quot;</span><br><span class="line">  location            = azurerm_resource_group.main.location</span><br><span class="line">  resource_group_name = azurerm_resource_group.main.name</span><br><span class="line"></span><br><span class="line">  app_service_plan_id = azurerm_app_service_plan.main.id</span><br><span class="line"></span><br><span class="line">  enable_builtin_logging = true</span><br><span class="line">  https_only             = true</span><br><span class="line">  os_type                = &quot;linux&quot;</span><br><span class="line"></span><br><span class="line">  storage_account_name       = azurerm_storage_account.main.name</span><br><span class="line">  storage_account_access_key = azurerm_storage_account.main.primary_access_key</span><br><span class="line"></span><br><span class="line">  version = &quot;~3&quot;</span><br><span class="line"></span><br><span class="line">  app_settings = &#123;</span><br><span class="line">    AzureWebJobsServiceBus      = &quot;@Microsoft.KeyVault(SecretUri=$&#123;azurerm_key_vault_secret.service_bus_connection_string.id&#125;)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意思大概是他把一段含有机密信息的连接字符串保存在 Azure KeyVault 服务中，然后创建了一个 Azure Faas 函数，通过 KeyVault 机密引用地址传递该机密。</p>
<h2 id="1-9-6-1-1-问题描述"><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"></a>1.9.6.1.1. 问题描述</h2>
<p>这位老兄发现，如果他修改了机密的内容，也就是 <code>azurerm_key_vault_secret</code> 声明里的 <code>value = azurerm_servicebus_topic_authorization_rule.mysb.primary_connection_string</code> 这一段的值的时候，KeyVault 保存的机密内容的确会正确更新，但 Azure Function 读取到的还是旧的机密引用地址，也就是这段代码中得到的 KeyVault 机密引用地址没有更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app_settings = &#123;</span><br><span class="line">  AzureWebJobsServiceBus      = &quot;@Microsoft.KeyVault(SecretUri=$&#123;azurerm_key_vault_secret.service_bus_connection_string.id&#125;)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更加奇怪的是，这之后他什么都没有做，只是重新再执行一次 <code>terraform apply</code>，该引用地址又被正确更新了？！</p>
<h2 id="1-9-6-1-2-问题原因"><a href="#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"></a>1.9.6.1.2. 问题原因</h2>
<p>因为 KeyVault Secret 被设计成是不可变的，所以更新 <code>azurerm_key_vault_secret</code> 的 <code>value</code> 会导致资源被重新创建。Terraform 官网上的相关文档中对该参数的定义如下：</p>
<blockquote>
<p><code>value</code> - (Required) Specifies the value of the Key Vault Secret.</p>
</blockquote>
<p>在 Terraform 中 ，一个参数如果被标记为 <code>Required</code>，那么它不但是必填项，同时类似数据库记录的主键的概念，主键不同的记录被认定是两条不同的记录，修改记录的主键值可以看作是删除重建之。Terraform 资源的 <code>Required</code> 参数如果发生变化会触发重新创建资源，这就导致了修改 <code>value</code> 后，该 <code>azurerm_key_vault_secret</code> 的 <code>id</code> 也会发生变化。</p>
<p>那么为什么在 <code>azurerm_key_vault_secret</code> 被重新创建之后，我们会发现 <code>azurerm_function_app</code> 中引用的 <code>id</code> 没有变化呢？</p>
<p>Terraform 的工作流含有 Plan 和 Apply 两个主要阶段，首先会分析 Terraform 代码，调用 <code>terraform refresh</code>（可以用参数跳过该步骤）读取资源在云端目前的最新状态，再加上 State 文件中记录的状态，三个状态对比出一个执行计划，使得最终产生的云端状态能够符合当前代码描述的状态。</p>
<p>就这个场景而言，Terraform 能够意识到 <code>azurerm_key_vault_secret</code> 的参数发生了变化，这会导致某种程度的更新，但它无法意识到这个更新会导致 <code>azurerm_key_vault_secret</code> 的 <code>id</code> 发生变化，进而导致 <code>azurerm_function_app</code> 也必须进行更新，所以就发生了他第一次执行 <code>terraform apply</code> 后看到的情况。</p>
<p>当他第二次执行 <code>terraform apply</code> 时，Terraform 记录的 State 文件里，<code>azurerm_key_vault_secret</code> 的 <code>id</code>和<code>azurerm_function_app</code> 里使用的 <code>id</code> 已经对不上了，这时 Terraform 会再生成一个更新 <code>azurerm_function_app</code> 的 Plan，执行后一切恢复正常。</p>
<p>有没有办法让 <code>azurerm_function_app</code> 能在第一次生成 Plan 时就感知到这个变更？</p>
<h2 id="1-9-6-1-3-巧用-null-resource-的-triggers"><a href="#%E5%B7%A7%E7%94%A8-nullresource-%E7%9A%84-triggers"></a>1.9.6.1.3. 巧用 null_resource 的 triggers</h2>
<p>HashiCorp 提供了一个非常常用的内建 Provider —— <code>null</code>。其中最知名的资源就是 <code>null_resource</code> 了，一般它都是和 <code>provisioner</code> 搭配出现，可以用来在某些资源创建完成后执行一些自定义脚本等等。但是它还有一个很有用的参数：</p>
<blockquote>
<p>The <code>triggers</code> argument allows specifying an arbitrary set of values that, when changed, will cause the resource to be replaced.</p>
</blockquote>
<p><code>triggers</code> 参数可以用来指向一些值，只要这些值的内容发生了变动，会导致 <code>null_resource</code> 资源被重新创建，从而生成一个新的 <code>id</code>。</p>
<h2 id="1-9-6-1-4-一个小实验"><a href="#%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%AE%9E%E9%AA%8C"></a>1.9.6.1.4. 一个小实验</h2>
<p>我们尝试构建一个简单的实验环境来验证一下，首先是这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_key_vault_secret&quot; &quot;example&quot; &#123;</span><br><span class="line">  name         = &quot;secret-sauce&quot;</span><br><span class="line">  value        = &quot;szechuan&quot;</span><br><span class="line">  key_vault_id = azurerm_key_vault.example.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;local_file&quot; &quot;output&quot; &#123;</span><br><span class="line">  filename = &quot;$&#123;path.module&#125;/output.txt&quot;</span><br><span class="line">  content = azurerm_key_vault_secret.example.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个 <code>azurerm_key_vault_secret</code>，然后把它的 <code>id</code> 输出到一个文件里。随后我们复制一下该文件，比如叫 <code>output.bak</code> 好了。随后我们修改 <code>azurerm_key_vault_secret</code> 的 <code>value</code> 到一个新的值，执行 <code>terraform apply</code> 以后，我们会发现 <code>output.txt</code> 与 <code>output.bak</code> 的内容完全一样，说明 <code>value</code> 的更新并没有触发 <code>local_file</code> 的更新。</p>
<p>随后我们把代码改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_key_vault_secret&quot; &quot;example&quot; &#123;</span><br><span class="line">  name         = &quot;secret-sauce&quot;</span><br><span class="line">  value        = &quot;szechuan2&quot;</span><br><span class="line">  key_vault_id = azurerm_key_vault.example.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;null_resource&quot; &quot;example&quot; &#123;</span><br><span class="line">  triggers = &#123;</span><br><span class="line">    trigger = azurerm_key_vault_secret.example.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;local_file&quot; &quot;output&quot; &#123;</span><br><span class="line">  filename = &quot;$&#123;path.module&#125;/output.txt&quot;</span><br><span class="line">  content = null_resource.example.id == null_resource.example.id ? azurerm_key_vault_secret.example.id : &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在代码中插入了一个 <code>null_resource</code>，并设置 <code>triggers</code> 的内容，盯住 <code>azurerm_key_vault_secret.example.value</code>。在 <code>value</code> 发生变化时，<code>null_resource</code> 的 <code>id</code> 也会发生变化。</p>
<p>然后我们在 <code>local_file</code> 的代码中，<code>content</code> 的赋值改成了这样一个三目表达式：<code>null_resource.example.id == null_resource.example.id ? azurerm_key_vault_secret.example.id : &quot;&quot;</code>。这个表达式里实际上 <code>null_resource.example.id</code> 是不起作用的，自己等于自己的永真条件会导致仍然使用 <code>azurerm_key_vault_secret.example.id</code> 作为值，但是由于掺入了 <code>null_resource.example.id</code>，使得 Terraform 在第一次计算 Plan 时就感知到 <code>local_file</code> 的内容发生了变化，从而使得我们可以一次 <code>terraform apply</code> 搞定。</p>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8-nullresource-%E6%90%AD%E9%85%8D-replacetriggeredby-%E6%9B%B4%E6%96%B0%E6%97%A0%E6%B3%95%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9%E7%9A%84%E5%B1%9E%E6%80%A7"><strong>1.9.7.1.</strong> 利用 null_resource 搭配 replace_triggered_by 更新无法从服务端读取内容的属性</a></li>
</ul>
<p><a href="#%E5%88%A9%E7%94%A8-nullresource-%E6%90%AD%E9%85%8D-replacetriggeredby-%E6%9B%B4%E6%96%B0%E6%97%A0%E6%B3%95%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9%E7%9A%84%E5%B1%9E%E6%80%A7"></a></p>
<h2 id="1-9-7-1-利用-null-resource-搭配-replace-triggered-by-更新无法从服务端读取内容的属性"><a href="#%E5%88%A9%E7%94%A8-nullresource-%E6%90%AD%E9%85%8D-replacetriggeredby-%E6%9B%B4%E6%96%B0%E6%97%A0%E6%B3%95%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9%E7%9A%84%E5%B1%9E%E6%80%A7"></a>1.9.7.1. 利用 null_resource 搭配 replace_triggered_by 更新无法从服务端读取内容的属性</h2>
<p>曾经处理的一个提问，有人写了这样一段 Terraform 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_container_group&quot; &quot;this&quot; &#123;</span><br><span class="line">  name                = var.name</span><br><span class="line">  location            = var.location</span><br><span class="line">  resource_group_name = var.resource_group_name</span><br><span class="line">  ip_address_type     = &quot;Private&quot;</span><br><span class="line">  network_profile_id  = azurerm_network_profile.this.id</span><br><span class="line">  os_type             = &quot;Linux&quot;</span><br><span class="line"></span><br><span class="line">  container &#123;</span><br><span class="line">    name   = &quot;someName&quot;</span><br><span class="line">    image  = &quot;someImage&quot;</span><br><span class="line">    cpu    = &quot;0.5&quot;</span><br><span class="line">    memory = &quot;0.5&quot;</span><br><span class="line"></span><br><span class="line">    commands = [&quot;some&quot;, &quot;commands&quot;]</span><br><span class="line"></span><br><span class="line">    ports &#123;</span><br><span class="line">      port     = 53</span><br><span class="line">      protocol = &quot;UDP&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    volume &#123;</span><br><span class="line">      mount_path = &quot;/app/conf&quot;</span><br><span class="line">      name       = &quot;someName&quot;</span><br><span class="line">      read_only  = true</span><br><span class="line">      secret = &#123;</span><br><span class="line">        Corefile = base64encode(someContent)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tags = var.tags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果每次执行 <code>apply</code> 操作时，都会发现 Terraform 试图重建这个容器：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># module.dns_forwarder.azurerm_container_group.this must be replaced</span><br><span class="line">-/+ resource &quot;azurerm_container_group&quot; &quot;this&quot; &#123;</span><br><span class="line">      ~ exposed_port        = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - port     = 53</span><br><span class="line">              - protocol = &quot;UDP&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      + fqdn                = (known after apply)</span><br><span class="line">      ~ id                  = &quot;/subscriptions/&lt;mySubId&gt;/resourceGroups/&lt;myRgName&gt;/providers/Microsoft.ContainerInstance/containerGroups/&lt;myContainerGroupName&gt;&quot; -&gt; (known after apply)</span><br><span class="line">      ~ ip_address          = &quot;someIp&quot; -&gt; (known after apply)</span><br><span class="line">        name                = &quot;someName&quot;</span><br><span class="line">      - tags                = &#123;&#125; -&gt; null</span><br><span class="line">        # (6 unchanged attributes hidden)</span><br><span class="line"></span><br><span class="line">      ~ container &#123;</span><br><span class="line">          - environment_variables        = &#123;&#125; -&gt; null</span><br><span class="line">            name                         = &quot;someName&quot;</span><br><span class="line">          - secure_environment_variables = (sensitive value)</span><br><span class="line">            # (4 unchanged attributes hidden)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          ~ volume &#123;</span><br><span class="line">                name       = &quot;someName&quot;</span><br><span class="line">              ~ secret     = (sensitive value) # forces replacement</span><br><span class="line">                # (3 unchanged attributes hidden)</span><br><span class="line">            &#125;</span><br><span class="line">            # (1 unchanged block hidden)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个问题的原因是 API 在读取容器信息时不会返回 <code>volume</code> 的 <code>secret</code> 数据，这其实是一个还挺合理的设定，机密数据的确不应该可以直接从 API 返回，但这就导致 Terraform 每次制定变更计划时都会试图重新设置这个值(因为会理解成服务端这个值被修改成了空)，而容器是不可变的，要修改容器的任何配置都会导致容器被重建。</p>
<p>有没有办法能够避免这种问题？经验告诉我们，可以使用 <code>ignore_changes</code> 让 Terraform 忽略这个属性的变更来避免重建，但如果 <code>secret</code> 真的变了怎么办？</p>
<p>我们可以这样干，第一，在 <code>azurerm_container_group</code> 添加这样一段 <code>lifecycle</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lifecycle &#123;</span><br><span class="line">    ignore_changes       = [container[0].volume[0].secret]</span><br><span class="line">    replace_triggered_by = [null_resource.secret_trigger.id]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会忽略 <code>secret</code> 的变化，但我们同时声明了一个 <code>replace_triggered_by</code>，在 <code>null_resource.secret_trigger.id</code> 的值发生变化时可以删除重建 <code>azurerm_container_group</code> 实例。</p>
<p>其次，我们把 <code>secret</code> 的内容提取到一个 <code>local</code> 里，这时 <code>azurerm_container_group</code> 的 <code>volume</code> 看起来大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">volume &#123;</span><br><span class="line">    mount_path = &quot;/app/conf&quot;</span><br><span class="line">    name       = &quot;somename&quot;</span><br><span class="line">    read_only  = true</span><br><span class="line">    secret     = &#123;</span><br><span class="line">      Corefile = local.secret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>local.secret</code> 存放着使用的机密数据。这时我们再定义一个 <code>null_resource</code> 充当触发器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  secret = base64encode(&quot;abcdefg&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;null_resource&quot; &quot;secret_trigger&quot; &#123;</span><br><span class="line">  triggers = &#123;</span><br><span class="line">    trigger = local.secret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在机密数据真的发生变化的时候，<code>triggers</code> 会触发 <code>null_resource</code> 的重建，导致 <code>null_resource.secret_trigger.id</code> 发生变化，进而触发 <code>azurerm_container_group</code> 的重建。</p>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E8%BE%93%E5%87%BA%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E"><strong>1.9.8.1.</strong> 创建资源的条件依赖另一个资源的输出时怎么办</a></li>
</ul>
<p><a href="#%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E8%BE%93%E5%87%BA%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E"></a></p>
<h2 id="1-9-8-1-创建资源的条件依赖另一个资源的输出时怎么办"><a href="#%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E8%BE%93%E5%87%BA%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E"></a>1.9.8.1. 创建资源的条件依赖另一个资源的输出时怎么办</h2>
<p>我们在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/8.%E6%8A%80%E5%B7%A7/1.%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%88%9B%E5%BB%BA">有条件创建</a>当中介绍了如何可以通过判断用户的输入参数来决定是否要创建某个资源，让我们来看一下这样一个 Module 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;vpc_id&quot; &#123;</span><br><span class="line">  type    = string</span><br><span class="line">  default = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  count       = var.vpc_id == null ? 1 : 0</span><br><span class="line">  cidr_blocks = [&quot;10.0.0.0/16&quot;]</span><br><span class="line">  name        = &quot;vpc&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_subnet&quot; &quot;subnet&quot; &#123;</span><br><span class="line">  cidr_block = &quot;10.0.0.0/24&quot;</span><br><span class="line">  vpc_id     = var.vpc_id == null ? ucloud_vpc.vpc[0].id : var.vpc_id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想在 Module 中创建一个 <code>ucloud_subnet</code>，用户可以输入一个 <code>vpc_id</code> 配置给它，也可以不输入，这时 Module 会创建一个 <code>ucloud_vpc</code> 来用。</p>
<p>假如我们使用这个模块，不传入 <code>vpc_id</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module vpc &#123;</span><br><span class="line">  source = &quot;./vpc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码生成的 Plan 内容如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  # module.vpc.ucloud_subnet.subnet will be created</span><br><span class="line">  + resource &quot;ucloud_subnet&quot; &quot;subnet&quot; &#123;</span><br><span class="line">      + cidr_block  = &quot;10.0.0.0/24&quot;</span><br><span class="line">      + create_time = (known after apply)</span><br><span class="line">      + id          = (known after apply)</span><br><span class="line">      + name        = (known after apply)</span><br><span class="line">      + remark      = (known after apply)</span><br><span class="line">      + tag         = &quot;Default&quot;</span><br><span class="line">      + vpc_id      = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  # module.vpc.ucloud_vpc.vpc[0] will be created</span><br><span class="line">  + resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">      + cidr_blocks  = [</span><br><span class="line">          + &quot;10.0.0.0/16&quot;,</span><br><span class="line">        ]</span><br><span class="line">      + create_time  = (known after apply)</span><br><span class="line">      + id           = (known after apply)</span><br><span class="line">      + name         = &quot;vpc&quot;</span><br><span class="line">      + network_info = (known after apply)</span><br><span class="line">      + remark       = (known after apply)</span><br><span class="line">      + tag          = &quot;Default&quot;</span><br><span class="line">      + update_time  = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 2 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure>
<p>完全符合预期。假如我们希望由模块的调用者来创建 Vpc 的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  cidr_blocks = [&quot;10.0.0.0/16&quot;]</span><br><span class="line">  name        = &quot;vpc&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module vpc &#123;</span><br><span class="line">  source = &quot;./vpc&quot;</span><br><span class="line"></span><br><span class="line">  vpc_id = ucloud_vpc.vpc.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们执行 <code>terraform plan</code> 的话，会得到这样的结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">╷</span><br><span class="line">│ Error: Invalid count argument</span><br><span class="line">│ </span><br><span class="line">│   on vpc/main.tf line 16, in resource &quot;ucloud_vpc&quot; &quot;vpc&quot;:</span><br><span class="line">│   16:   count       = var.vpc_id == null ? 1 : 0</span><br><span class="line">│ </span><br><span class="line">│ The &quot;count&quot; value depends on resource attributes that cannot be determined until apply, so Terraform cannot predict how many instances will be created. To work around this,</span><br><span class="line">│ use the -target argument to first apply only the resources that the count depends on.</span><br><span class="line">╵</span><br></pre></td></tr></table></figure>
<p>Terraform 试图向我们抱怨，我们在 <code>count</code> 参数的表达式里使用了一个必须在 <code>apply</code> 阶段才能知道的值，所以它无法在 <code>plan</code> 阶段就计算出 <code>count</code> 的值。它建议我们先用 <code>terraform apply</code> 命令搭配 <code>-target</code> 参数把 Vpc 先创建出来，消除后续计算 Plan 时尚不知晓的值来解决这个问题。</p>
<p>这当然是一种很麻烦的方法，所以我们在设计 Module 时就要考虑到这种问题。有一种很简单的方法可以解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;vpc&quot; &#123;</span><br><span class="line">  type    = object(</span><br><span class="line">    &#123;</span><br><span class="line">      id = string</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  default = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  count       = var.vpc == null ? 1 : 0</span><br><span class="line">  cidr_blocks = [&quot;10.0.0.0/16&quot;]</span><br><span class="line">  name        = &quot;vpc&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_subnet&quot; &quot;subnet&quot; &#123;</span><br><span class="line">  cidr_block = &quot;10.0.0.0/24&quot;</span><br><span class="line">  vpc_id     = var.vpc == null ? ucloud_vpc.vpc[0].id : var.vpc.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把用来判断创建条件的输入参数类型改成 <code>object</code>，调用 Module 的代码就变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  # ucloud_vpc.vpc will be created</span><br><span class="line">  + resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">      + cidr_blocks  = [</span><br><span class="line">          + &quot;10.0.0.0/16&quot;,</span><br><span class="line">        ]</span><br><span class="line">      + create_time  = (known after apply)</span><br><span class="line">      + id           = (known after apply)</span><br><span class="line">      + name         = &quot;vpc&quot;</span><br><span class="line">      + network_info = (known after apply)</span><br><span class="line">      + remark       = (known after apply)</span><br><span class="line">      + tag          = &quot;Default&quot;</span><br><span class="line">      + update_time  = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  # module.vpc.ucloud_subnet.subnet will be created</span><br><span class="line">  + resource &quot;ucloud_subnet&quot; &quot;subnet&quot; &#123;</span><br><span class="line">      + cidr_block  = &quot;10.0.0.0/24&quot;</span><br><span class="line">      + create_time = (known after apply)</span><br><span class="line">      + id          = (known after apply)</span><br><span class="line">      + name        = (known after apply)</span><br><span class="line">      + remark      = (known after apply)</span><br><span class="line">      + tag         = &quot;Default&quot;</span><br><span class="line">      + vpc_id      = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 2 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure>
<p>成功计算出 Plan。请注意虽然这个 Plan 仍然是创建两个资源，但 <code>ucloud_vpc</code> 资源并不是 Module 创建的。</p>
<p>这个方法的原理就是虽然 <code>var.vpc.id</code> 仍然是一个只有在 <code>apply</code> 阶段才能知道的值，但 <code>var.vpc</code> 本身是一个在 <code>plan</code> 阶段就可以知道的值，直接可以判读它是否为 <code>null</code>，所以该方法可以绕过这个限制。</p>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8-createbeforedestroy-%E8%B0%83%E6%95%B4%E8%B5%84%E6%BA%90-update-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><strong>1.9.9.1.</strong> 利用 create_before_destroy 调整资源 Update 的执行顺序</a></li>
</ul>
<p><a href="#%E5%88%A9%E7%94%A8-createbeforedestroy-%E8%B0%83%E6%95%B4%E8%B5%84%E6%BA%90-update-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"></a></p>
<h2 id="1-9-9-1-利用-create-before-destroy-调整资源-Update-的执行顺序"><a href="#%E5%88%A9%E7%94%A8-createbeforedestroy-%E8%B0%83%E6%95%B4%E8%B5%84%E6%BA%90-update-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"></a>1.9.9.1. 利用 create_before_destroy 调整资源 Update 的执行顺序</h2>
<p>最近处理了一个问题，有人写了这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;azurerm&quot; &#123;</span><br><span class="line">  features &#123;</span><br><span class="line">    resource_group &#123;</span><br><span class="line">      prevent_deletion_if_contains_resources = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;azurerm_resource_group&quot; &quot;rg&quot; &#123;</span><br><span class="line">  location = &quot;eastus&quot;</span><br><span class="line">  name     = &quot;example&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  environments = toset([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;azurerm_public_ip&quot; &quot;lb&quot; &#123;</span><br><span class="line">  for_each = local.environments</span><br><span class="line"></span><br><span class="line">  name                = &quot;frontend-lb-$&#123;each.key&#125;&quot;</span><br><span class="line">  location            = azurerm_resource_group.rg.location</span><br><span class="line">  resource_group_name = azurerm_resource_group.rg.name</span><br><span class="line">  allocation_method   = &quot;Static&quot;</span><br><span class="line">  ip_version          = &quot;IPv4&quot;</span><br><span class="line">  sku                 = &quot;Standard&quot;</span><br><span class="line">  zones               = [1, 2, 3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;azurerm_lb&quot; &quot;this&quot; &#123;</span><br><span class="line">  name                = &quot;azurelb&quot;</span><br><span class="line">  location            = azurerm_resource_group.rg.location</span><br><span class="line">  resource_group_name = azurerm_resource_group.rg.name</span><br><span class="line">  sku                 = &quot;Standard&quot;</span><br><span class="line"></span><br><span class="line">  dynamic &quot;frontend_ip_configuration&quot; &#123;</span><br><span class="line">    for_each = local.environments</span><br><span class="line">    content &#123;</span><br><span class="line">      name                 = frontend_ip_configuration.key</span><br><span class="line">      public_ip_address_id = azurerm_public_ip.lb[frontend_ip_configuration.key].id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当他从 <code>local.environments</code> 中删除一个元素，然后执行 <code>terraform apply</code> 时，他遇到了下面的问题：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">│ Error: deleting Public Ip Address: (Name &quot;azurelb&quot; / Resource Group &quot;example&quot;): network.PublicIPAddressesClient#Delete: Failure sending request: StatusCode=400 -- Original Error: Code=&quot;PublicIPAddressCannotBeDeleted&quot; Message=&quot;Public IP address /subscriptions/subscription-id/resourceGroups/resource-group/providers/Microsoft.Network/publicIPAddresses/one can not be deleted since it is still allocated to resource /subscriptions/subscription-id/resourceGroups/resource-group/providers/Microsoft.Network/loadBalancers/azurelb/frontendIPConfigurations/one. In order to delete the public IP, disassociate/detach the Public IP address from the resource.  To learn how to do this, see aka.ms/deletepublicip.&quot; Details=[]</span><br></pre></td></tr></table></figure>
<p>这其实是一个还挺常见的问题，<code>azurerm_lb.this</code> 依赖于 <code>azurerm_public_ip.lb[index]</code>，正确的变更顺序应该是先更新 <code>azurerm_lb.this</code>，再删除 <code>azurerm_public_ip.lb</code> 的成员，但是 Terraform 默认的执行顺序会首先尝试执行删除操作，这时因为 ip 仍然被 LoadBalancer 使用着，所以会引发一个错误。</p>
<p>解决方法是给 <code>azurerm_public.lb</code> 添加一个 <code>create_before_destroy</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_public_ip&quot; &quot;lb&quot; &#123;</span><br><span class="line">  for_each = local.environments</span><br><span class="line"></span><br><span class="line">  name                = &quot;frontend-lb-$&#123;each.key&#125;&quot;</span><br><span class="line">  location            = azurerm_resource_group.rg.location</span><br><span class="line">  resource_group_name = azurerm_resource_group.rg.name</span><br><span class="line">  allocation_method   = &quot;Static&quot;</span><br><span class="line">  ip_version          = &quot;IPv4&quot;</span><br><span class="line">  sku                 = &quot;Standard&quot;</span><br><span class="line">  zones               = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    create_before_destroy = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create_before_destroy</code> 名字里虽然看起来是与 Create 有关，实际上它也会将 Update 与 Create 放在一起调整，声明该参数后实际上是将 <code>azurerm_public_ip.lb</code> 的 Delete 推迟到执行 Update 之后再执行了，该问题得解。</p>
<ul>
<li>
<p><a href="#terraform-%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96"><strong>1.9.10.1.</strong> Terraform 与自动化</a></p>
</li>
<li>
<p><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84-terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E4%BD%9C%E6%B5%81"><strong>1.9.10.1.1.</strong> 自动化的 Terraform 命令行工作流</a></p>
</li>
<li>
<p><a href="#%E6%8E%A7%E5%88%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%AD%E7%9A%84-terraform-%E8%BE%93%E5%87%BA"><strong>1.9.10.1.2.</strong> 控制自动化中的 Terraform 输出</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C-plan-%E5%92%8C-apply"><strong>1.9.10.1.3.</strong> 在不同的机器上运行 plan 和 apply</a></p>
</li>
<li>
<p><a href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%A1%E6%89%B9%E8%AE%A1%E5%88%92"><strong>1.9.10.1.4.</strong> 交互式审批计划</a></p>
</li>
<li>
<p><a href="#%E8%87%AA%E5%8A%A8%E6%89%B9%E5%87%86%E8%AE%A1%E5%88%92"><strong>1.9.10.1.5.</strong> 自动批准计划</a></p>
</li>
<li>
<p><a href="#%E7%94%A8-terraform-plan-%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95-pull-requests"><strong>1.9.10.1.6.</strong> 用 terraform plan 命令测试 Pull Requests</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2"><strong>1.9.10.1.7.</strong> 多环境部署</a></p>
</li>
<li>
<p><a href="#%E9%A2%84%E5%85%88%E5%AE%89%E8%A3%85%E7%9A%84%E6%8F%92%E4%BB%B6"><strong>1.9.10.1.8.</strong> 预先安装的插件</a></p>
</li>
</ul>
<p><a href="#terraform-%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96"></a></p>
<h2 id="1-9-10-1-Terraform-与自动化"><a href="#terraform-%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96"></a>1.9.10.1. Terraform 与自动化</h2>
<p>如果团队使用 Terraform 作为变更管理和部署管道的核心工具，可能需要以某种自动化方式编排 Terraform 的运行，以确保运行之间的一致性，并提供其他有趣的功能，例如与版本控制系统钩子的集成。</p>
<p>Terraform 的自动化可以有多种形式，并且程度不同。一些团队继续在本地运行 Terraform，但使用脚本代码来准备一致的工作目录来运行 Terraform，而另一些团队则完全在 Jenkins 等 CI 工具中运行 Terraform。</p>
<p>本篇涵盖了实现此类自动化时应考虑的一些事项，既确保 Terraform 的安全运行，又适应 Terraform 工作流程中当前需要仔细注意的一些限制。它假设 Terraform 将在非交互式环境中运行，无法在终端提示输入。对于脚本代码来说不一定如此，但在 CI 工具中运行时通常如此。</p>
<h2 id="1-9-10-1-1-自动化的-Terraform-命令行工作流"><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84-terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E4%BD%9C%E6%B5%81"></a>1.9.10.1.1. 自动化的 Terraform 命令行工作流</h2>
<p>在自动化流程中运行 Terraform 时，重点通常是核心的 <code>plan</code>/<code>apply</code> 循环。那么，使用 Terraform 命令行的流程大体如下：</p>
<ol>
<li>初始化 Terraform 工作目录。</li>
<li>针对当前代码，为产生变化的资源计算变更计划</li>
<li>让操作员审查计划，以确保其可接受</li>
<li>应用计划描述的更改。</li>
</ol>
<p>步骤 1、2 和 4 可以使用熟悉的 Terraform 命令以及一些附加选项来执行：</p>
<ul>
<li><code>terraform init -input=false</code> 初始化工作目录。</li>
<li><code>terraform plan -out=tfplan -input=false</code> 创建计划文件并将其保存到名为 <code>tfplan</code> 的本地文件。</li>
<li><code>terraform apply -input=false tfplan</code> 执行存储在文件 <code>tfplan</code> 中的计划。</li>
</ul>
<p><code>-input=false</code> 参数命令 Terraform 不应尝试提示输入，而是要求配置文件或命令行提供所有必要的值。因此，可能需要在 <code>terraform plan</code> 上使用 <code>-var</code> 和 <code>-var-file</code> 参数来指定所有传统上在交互式使用下手动输入的变量值。</p>
<p>强烈建议使用支持远程状态的 Backend，因为 Terraform 可以自动将持久保存状态，后续运行可以在找回并更新状态。选择支持状态锁定的 Backend 还将提供针对 Terraform 并发运行的竞争安全保障。</p>
<h2 id="1-9-10-1-2-控制自动化中的-Terraform-输出"><a href="#%E6%8E%A7%E5%88%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%AD%E7%9A%84-terraform-%E8%BE%93%E5%87%BA"></a>1.9.10.1.2. 控制自动化中的 Terraform 输出</h2>
<p>默认情况下，一些 Terraform 命令会提示用户下一步可能执行的步骤，通常包括具体的下一步要运行的命令。</p>
<p>自动化工具通常会封装正在运行的命令的具体细节，只提供抽象的步骤，这时 Terraform 输出的此类消息反而令人困惑，且无法操作，如果它们无意中鼓励用户完全绕过自动化工具，则可能还是有害的。</p>
<p>当环境变量 <code>TF_IN_AUTOMATION</code> 设置为任何非空值时，Terraform 会对其输出进行一些细微调整，不再强调要运行的特定命令。所做的具体更改会随着时间的推移而变化，但一般来说，Terraform 发现该变量时，会认为存在某种包装了 Terraform 的应用程序，它们会帮助用户进行下一步。</p>
<p>为了降低复杂性，该功能主要针对 Terraform 主要的工作流程命令实现。无论该变量为何值如何，其他辅助命令仍可能会产生命令行建议。</p>
<h2 id="1-9-10-1-3-在不同的机器上运行-plan-和-apply"><a href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C-plan-%E5%92%8C-apply"></a>1.9.10.1.3. 在不同的机器上运行 plan 和 apply</h2>
<p>在 CI 工具中运行时，可能很难或无法确保 <code>plan</code> 和 <code>apply</code> 命令在同一台计算机上的同一目录中运行，并且所有的文件都保持相同。</p>
<p>在不同的机器上运行 <code>plan</code> 和 <code>apply</code> 需要一些额外的步骤来确保正确的行为。稳健的策略如下：</p>
<ul>
<li><code>plan</code> 完成后，保存整个工作目录，包括 <code>init</code> 期间创建的 <code>.terraform</code> 子目录，并将其保存在 <code>apply</code> 阶段可以访问得到的位置。常见的选择是作为所选 CI 工具中的“Build Artifact”。</li>
<li>在运行 <code>apply</code> 之前，获取上一步中创建的存档并将其解压到相同的绝对路径。这会重新创建 <code>plan</code> 后出现的所有内容，避免在 <code>plan</code> 步骤期间创建本地文件的奇怪问题。</li>
</ul>
<p>Terraform 目前为此类自动化系统设置了一些必须满足的前提条件：</p>
<ul>
<li>保存的计划文件可以包含子模块的绝对路径以及代码中引用的其他数据文件。因此，必须确保在相同的绝对路径中还原保存的工作目录。这通常是通过在某种隔离中运行 Terraform 来实现的，例如可以控制文件系统布局的 Docker 容器。</li>
<li>Terraform 假设该计划将在与其创建时相同的操作系统和 CPU 架构上 Apply。例如，这意味着无法在 Windows 计算机上创建计划，然后将其应用到 Linux 服务器上。</li>
<li>Terraform 期望用于生成计划的 Provider 程序插件在应用计划时可用且相同，以确保正确执行计划。如果在创建和应用计划之间升级 Terraform 或任何插件，将会产生错误。</li>
<li>Terraform 无法自动检测用于创建计划的凭据是否授予对用于应用该计划的相同资源的访问权限。如果对每个凭据使用不同的凭据（例如，使用只读凭据生成计划），那么确保两套凭据在它们所属的相应服务的帐户中保持一致非常重要。</li>
</ul>
<p><strong>警告</strong>：计划文件包含代码的完整副本、计划所要应用的状态数据以及传递给 <code>terraform plan</code> 的所有变量。如果其中包含任意敏感数据，则包含计划文件的存档工作目录应受到相应保护。对于 Provider 使用的身份验证凭据，建议尽可能使用环境变量，因为这些变量不会被包含在计划中或由 Terraform 以任何其他方式保存到磁盘。</p>
<h2 id="1-9-10-1-4-交互式审批计划"><a href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%A1%E6%89%B9%E8%AE%A1%E5%88%92"></a>1.9.10.1.4. 交互式审批计划</h2>
<p>自动化 Terraform 工作流程的另一个挑战是需要在计划和应用之间进行交互式审批步骤。为了稳健地实现这一点，重要的是要确保一次只能有一个计划未完成，或者两个步骤相互连接，以便批准计划将足够的信息传递到应用步骤，以确保应用正确的计划，与后来也存在的一些计划相反。</p>
<p>不同的 CI 工具以不同的方式解决这个问题，但通常这是通过构建管道功能实现的，其中可以按顺序应用不同的步骤，后面的步骤可以访问前面步骤生成的数据。</p>
<p>推荐的方法是一次只允许一个计划处于未应用状态。应用计划时，针对同一状态生成的任何其他现有计划都会失效，因为现在必须相对于新状态重新计算它们。通过强制计划按顺序获得批准（或驳回），可以避免这种情况。</p>
<h2 id="1-9-10-1-5-自动批准计划"><a href="#%E8%87%AA%E5%8A%A8%E6%89%B9%E5%87%86%E8%AE%A1%E5%88%92"></a>1.9.10.1.5. 自动批准计划</h2>
<p>虽然强烈建议对生产环境应用计划前要进行人工审查，但有时在预生产或开发环境中部署时需要采取更自动化的方法。</p>
<p>如果不需要手动批准，可以使用更简单的命令序列：</p>
<ul>
<li><code>terraform init -input=false</code></li>
<li><code>terraform apply -input=false -auto-approve</code></li>
</ul>
<p><code>apply</code> 命令的这个变体隐式地创建一个新计划，然后立即应用它。 <code>-auto-approve</code> 选项告诉 Terraform 在应用计划之前不需要对计划进行交互式批准。</p>
<p><strong>警告</strong>：当 Terraform 有权对基础设施进行破坏性更改时，始终建议对计划进行人工审查，除非在发生意外更改时可以容忍停机。仅对非关键基础设施使用自动批准。</p>
<h2 id="1-9-10-1-6-用-terraform-plan-命令测试-Pull-Requests"><a href="#%E7%94%A8-terraform-plan-%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95-pull-requests"></a>1.9.10.1.6. 用 terraform plan 命令测试 Pull Requests</h2>
<p><code>terraform plan</code> 可以用来对 Terraform 配置的有效性进行某些有限的验证，而不影响实际的基础设施。尽管 <code>plan</code> 命令会更新状态以匹配实际资源，从而确保准确的计划，但更新后的状态文件并不会持久保存，因此可以安全地使用该命令来生成仅为了帮助代码审查而创建的“一次性”计划。</p>
<p>实现此类工作流程时，可以在相关代码审查工具（例如，Github Pull Request）中使用钩子，为每个正在审查的新提交触发 CI 工具。在这种情况下，Terraform 可以按如下方式运行：</p>
<ul>
<li><code>terraform plan -input=false</code></li>
</ul>
<p>与在“主”工作流程中一样，可能需要根据需要设置 <code>-var</code> 或 <code>-var-file</code>。在这种情况下不使用 <code>-out</code> 选项，因为为代码审查目的而生成的计划永远不会被应用。相反，一旦合并更改，就可以从主版本控制分支创建并应用新计划。</p>
<p><strong>警告</strong>：请注意，通过输入变量或环境变量将敏感秘密数据传递给 Terraform 将使任何可以提交 PR 的人都可以看到，因此在开源项目或任何私人项目上必须谨慎使用此流程部分，或所有贡献者不应能够直接访问凭据等。</p>
<h2 id="1-9-10-1-7-多环境部署"><a href="#%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2"></a>1.9.10.1.7. 多环境部署</h2>
<p>Terraform 的自动化通常会被用来创建数个相同的配置，比如为预发布、测试或多租户基础设施等场景生成平行的环境。这种情况下的自动化可以帮助确保为每个环境使用正确的设置，并且在每次操作之前正确配置工作目录。</p>
<p>多环境编排最有趣的两个命令是 <code>terraform init</code> 和 <code>terraform workspace</code>。前者可以与其他参数一起使用，以针对环境之间的差异定制 Backend 配置，而后者可用于在单个 Backend 中存储的相同配置的多个状态之间安全切换。</p>
<p>如果可能，建议对所有环境使用单一后端配置，并使用 <code>terraform workspace</code> 命令在工作空间之间切换：</p>
<ul>
<li><code>terraform init -input=false</code></li>
<li><code>terraform workspace select QA</code></li>
</ul>
<p>在此使用模型中，Backend 存储中使用固定的命名方案，以允许多个状态共存，而无需任何进一步的配置。</p>
<p>或者，自动化工具可以将环境变量 <code>TF_WORKSPACE</code> 设置为现有工作空间名称，这将覆盖使用 <code>terraform workspace select</code> 命令所做的任何选择。建议仅在非交互式使用中使用此环境变量，因为在本地 shell 环境中，很容易忘记设置该变量并将变更应用到错误的状态。</p>
<p>在一些更复杂的情况下，不可能跨环境共享相同的 Backend 配置。例如，环境可能运行在完全独立的不同帐户的服务里，因此需要对 Backend 本身使用不同的凭据或端点。在这种情况下，可以通过 <code>terraform init</code> 的 <code>-backend-config</code> 选项覆盖后端配置设置。</p>
<h2 id="1-9-10-1-8-预先安装的插件"><a href="#%E9%A2%84%E5%85%88%E5%AE%89%E8%A3%85%E7%9A%84%E6%8F%92%E4%BB%B6"></a>1.9.10.1.8. 预先安装的插件</h2>
<p>在默认使用情况下，<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/12.init.html"><code>terraform init</code></a> 会自动下载并安装代码中使用的所有 Provider 程序的插件，并将它们放置在 <code>.terraform</code> 目录的子目录中。这为简单的情况提供了更简单的工作流程，并允许每段代码可以使用不同版本的插件。</p>
<p>在自动化环境中，可能需要禁用此行为，而是提供一组已安装在运行 Terraform 的系统上的固定插件。这样就避免了每次执行时重新下载插件的开销，并允许系统管理员控制可以使用哪些插件。</p>
<p>要使用此机制，请在系统上的某个位置创建一个 Terraform 运行时会将插件可执行文件放入其中的目录。已发布的插件文件可在 <a target="_blank" rel="noopener" href="https://releases.hashicorp.com/">releases.hashicorp.com</a> 上下载。请务必下载适合目标操作系统和体系结构的文件。</p>
<p>提取必要的插件后，新插件目录的内容将如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lah /usr/lib/custom-terraform-plugins</span></span><br><span class="line">-rwxrwxr-x 1 user user  84M Jun 13 15:13 terraform-provider-aws-v1.0.0-x3</span><br><span class="line">-rwxrwxr-x 1 user user  84M Jun 13 15:15 terraform-provider-rundeck-v2.3.0-x3</span><br><span class="line">-rwxrwxr-x 1 user user  84M Jun 13 15:15 terraform-provider-mysql-v1.2.0-x3</span><br></pre></td></tr></table></figure>
<p>文件名末尾的版本信息很重要，它使得 Terraform 可以推断每个插件的版本号。可以安装同一 Provider 程序插件的多个版本，Terraform 将使用与 Terraform 代码中的 Provider 程序版本约束相匹配的最新版本。</p>
<p>填充此目录后，可以使用 <code>terraform init</code> 的 <code>-plugin-dir</code> 选项跳过常规的自动下载和插件发现行为：</p>
<ul>
<li><code>terraform init -input=false -plugin-dir=/usr/lib/custom-terraform-plugins</code></li>
</ul>
<p>使用该组参数时，只有给定目录中的插件可以被使用。这使系统管理员可以对执行环境进行强力控制，但另一方面，它会阻止使用尚未安装到本地插件目录中的较新插件版本。哪种方法更合适将取决于每个组织内的特定情况。</p>
<p>还可以通过创建 <code>terraform.d/plugins/OS_ARCH</code> 目录与配置一起提前安装插件，在自动下载其他插件之前将搜索该目录。 <code>-get-plugins=false</code> 参数可禁止 Terraform 自动下载其他插件。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/30/Teraform/Terraform-%E5%B0%8F%E6%8A%80%E5%B7%A7/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../5/"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../7/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 6 頁 共 24 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 234 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
