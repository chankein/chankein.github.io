
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>所有文章 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://keinchan.com/archives/page/2/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../#about"
            >
        
        
            <img class="header-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/20/cheat-sheet/vim-cheat-sheet/"
                            aria-label=": vim cheat sheet"
                        >
                            vim cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:41:16+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/vim/">vim</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="python">python:</h3>


	<div class="row">
    <embed src="/assets/pdf/vim-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>



                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/20/cheat-sheet/vim-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/20/cheat-sheet/ansible-cheat-sheet/"
                            aria-label=": ansible cheat sheet"
                        >
                            ansible cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T23:10:52+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/ansible/">ansible</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="ansible-command">ansible command:</h3>


	<div class="row">
    <embed src="/assets/pdf/ansible-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h3 id="playbook">playbook:</h3>


	<div class="row">
    <embed src="/assets/pdf/ansible-playbook.pdf" width="100%" height="550" type="application/pdf">
	</div>



                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/20/cheat-sheet/ansible-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/20/cheat-sheet/curl-cheat-sheet/"
                            aria-label=": curl cheat sheet"
                        >
                            curl cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T19:47:54+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/curl/">curl</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="curl-command">curl command:</h3>


	<div class="row">
    <embed src="/assets/pdf/curl-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>




                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/20/cheat-sheet/curl-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/20/cheat-sheet/docker-cheat-sheet/"
                            aria-label=": docker cheat sheet"
                        >
                            docker cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-20T19:36:58+08:00">
	
		    2025 年 5 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/docker/">docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="docker">docker:</h3>
<p><img src="/assets/images/docker-cheat-sheet.webp" alt="image"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/20/cheat-sheet/docker-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/15/cheat-sheet/Linux-cheat-sheet/"
                            aria-label=": Linux cheat sheet"
                        >
                            Linux cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-15T21:37:03+08:00">
	
		    2025 年 5 月 15 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E5%90%8E%E7%AB%AF/">后端</a>, <a class="category-link" href="../../../categories/%E5%90%8E%E7%AB%AF/linux/">linux</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="linux">linux:</h3>
<p><img src="/assets/images/Linux-Commands_Cheat-Sheet.png" alt="image"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/15/cheat-sheet/Linux-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2025/05/14/git/git-cheat-sheet/"
                            aria-label=": git cheat sheet"
                        >
                            git cheat sheet
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2025-05-14T08:57:44+08:00">
	
		    2025 年 5 月 14 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/git/">git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="/assets/images/gitcheatsheet.png" alt="image"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2025/05/14/git/git-cheat-sheet/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2024/08/17/react/React-%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%B5%81-%E7%BB%84%E4%BB%B6%E9%97%B4%E6%B2%9F%E9%80%9A/"
                            aria-label=": React 组件数据流 &amp;&amp; 组件间沟通"
                        >
                            React 组件数据流 &amp;&amp; 组件间沟通
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2024-08-17T18:50:09+08:00">
	
		    2024 年 8 月 17 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>使用React我们首先要知道如何传递数据，组件如何沟通，才能展示我们想要的数据。下面的列子都是使用ES6语法，不懂的同学需要先学习ES6语法。</p>
<h2 id="数据流">数据流</h2>
<p>React是单向数据流，从父节点传递到子节点（通过<code>props</code>）。如果顶层的某个<code>props</code>改变了，React会重渲染所有的子节点（未做性能优化）。严格意义上React只提供，也强烈建议使用这种数据交流方式。</p>
<h3 id="Props">Props</h3>
<p><code>props</code>是property的缩写，可以理解为HTML标签的attribute。请把<code>props</code>当做只读的（不可以使用<code>this.props</code>直接修改props），<code>props</code>是用于整个组件树中传递数据和配置。在当前组件访问<code>props</code>，使用<code>this.props</code>。在什么情况下可以使用<code>props</code>，请看<a href="https://keinchan.com/2024/08/16/react/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">组件生命周期</a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&#123;this.props.title&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="title class_">Component</span> title=<span class="string">&quot;test&quot;</span>/&gt;<span class="comment">//调用title就传进去了</span></span><br></pre></td></tr></table></figure>
<h3 id="PropTypes">PropTypes</h3>
<p><code>PropsTypes</code>是React中用来定义<code>props</code>的类型，不符合定义好的类型会报错。建议可复用组件要使用prop验证！接着上面的列子设置<code>PropsTypes</code>如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property">PropsType</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.PropTypes</code> 提供很多验证器 (validator) 来验证传入数据的有效性。官方定义的验证器如下，不是使用ES6语法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="attr">propTypes</span>: &#123;</span><br><span class="line">    <span class="comment">// 可以声明 prop 为指定的 JS 基本类型。默认</span></span><br><span class="line">    <span class="comment">// 情况下，这些 prop 都是可传可不传的。</span></span><br><span class="line">    <span class="attr">optionalArray</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">array</span>,</span><br><span class="line">    <span class="attr">optionalBool</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">bool</span>,</span><br><span class="line">    <span class="attr">optionalFunc</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">func</span>,</span><br><span class="line">    <span class="attr">optionalNumber</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line">    <span class="attr">optionalObject</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">object</span>,</span><br><span class="line">    <span class="attr">optionalString</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">    <span class="attr">optionalSymbol</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">symbol</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有可以被渲染的对象：数字，</span></span><br><span class="line">    <span class="comment">// 字符串，DOM 元素或包含这些类型的数组(or fragment) 。</span></span><br><span class="line">    <span class="attr">optionalNode</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">node</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// React 元素</span></span><br><span class="line">    <span class="attr">optionalElement</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">element</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你同样可以断言一个 prop 是一个类的实例。</span></span><br><span class="line">    <span class="comment">// 用 JS 的 instanceof 操作符声明 prop 为类的实例。</span></span><br><span class="line">    <span class="attr">optionalMessage</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">instanceOf</span>(<span class="title class_">Message</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你可以用 enum 的方式</span></span><br><span class="line">    <span class="comment">// 确保你的 prop 被限定为指定值。</span></span><br><span class="line">    <span class="attr">optionalEnum</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">oneOf</span>([<span class="string">&#x27;News&#x27;</span>, <span class="string">&#x27;Photos&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定的多个对象类型中的一个</span></span><br><span class="line">    <span class="attr">optionalUnion</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">oneOfType</span>([</span><br><span class="line">      <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">      <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line">      <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">instanceOf</span>(<span class="title class_">Message</span>)</span><br><span class="line">    ]),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定类型组成的数组</span></span><br><span class="line">    <span class="attr">optionalArrayOf</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">arrayOf</span>(<span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">number</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定类型的属性构成的对象</span></span><br><span class="line">    <span class="attr">optionalObjectOf</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">objectOf</span>(<span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">number</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特定形状参数的对象</span></span><br><span class="line">    <span class="attr">optionalObjectWithShape</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">shape</span>(&#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">      <span class="attr">fontSize</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">number</span></span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你可以在任意东西后面加上 `isRequired`</span></span><br><span class="line">    <span class="comment">// 来确保 如果 prop 没有提供 就会显示一个警告。</span></span><br><span class="line">    <span class="attr">requiredFunc</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可空的任意类型</span></span><br><span class="line">    <span class="attr">requiredAny</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">any</span>.<span class="property">isRequired</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你可以自定义一个验证器。如果验证失败需要返回一个 Error 对象。</span></span><br><span class="line">    <span class="comment">// 不要直接使用 `console.warn` 或抛异常，</span></span><br><span class="line">    <span class="comment">// 因为这在 `oneOfType` 里不起作用。</span></span><br><span class="line">    <span class="attr">customProp</span>: <span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.<span class="title function_">test</span>(props[propName])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Validation failed!&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="defaultProps">defaultProps</h3>
<p>如何设置组件默认的<code>props</code>？</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//React提供的crateClass创建方式</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Component</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="title function_">getDefaultProps</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">//这里设置defaultProps</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property">defaultProps</span> = &#123;&#125;</span><br><span class="line"><span class="comment">//ES7 stage-0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="state">state</h3>
<p>每个组件都有属于自己的<code>state</code>，<code>state</code>和<code>props</code>的区别在于前者之只存在于组件内部，只能从当前组件调用<code>this.setState</code>修改state值（不可以直接修改<code>this.state</code>）。一般我们更新子组件都是通过改变<code>state</code>值，更新新子组件的<code>props</code>值从而达到更新。</p>
<p>那如何设置默认state?</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//React提供的crateClass创建方式</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Component</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="title function_">getInitialState</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">//这里设置初始state值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//ES6 &amp;&amp; ES7</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;<span class="comment">//在ES6中的构造函数中初始化，可以之直接赋值，在其他方法中，只能使用this.setState</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="props和state使用方式">props和state使用方式</h3>
<p>尽可能使用<code>props</code>当做数据源，<code>state</code>用来存放状态值（简单的数据），如复选框、下拉菜单等。</p>
<h2 id="组件沟通">组件沟通</h2>
<p>组件沟通因为React的单向数据流方式会有所限制，下面述说组件之间的沟通方式。</p>
<h3 id="父子组件沟通">父子组件沟通</h3>
<p>这种方式是最常见的，也是最简单的。</p>
<ul>
<li>父组件更新组件状态</li>
</ul>
<p>父组件更新子组件状态，通过传递<code>props</code>，就可以了。</p>
<ul>
<li>子组件更新父组件状态</li>
</ul>
<p>这种情况需要父组件传递回调函数给子组件，子组件调用触发即可。</p>
<p>代码示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.text&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.refreshParent&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            更新父组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">refreshChild</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">childText</span>: <span class="string">&quot;父组件沟通子组件成功&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">refreshParent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">parentText</span>: <span class="string">&quot;子组件沟通父组件成功&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父子组件沟通<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.refreshChild()&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            更新子组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">text</span>=<span class="string">&#123;this.state.childText</span> || &quot;<span class="attr">子组件未更新</span>&quot;&#125; </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">refreshParent</span>=<span class="string">&#123;this.refreshParent.bind(this)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.parentText || &quot;父组件未更新&quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>codepen例子<a target="_blank" rel="noopener" href="https://codepen.io/nange/pen/KgwRJk">React组件之父子组件沟通</a> 。</p>
<h3 id="兄弟组件沟通">兄弟组件沟通</h3>
<p>当两个组件有相同的父组件时，就称为兄弟组件（堂兄也算的）。按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的<code>props</code>。</p>
<h4 id="方式一">方式一</h4>
<p>通过<code>props</code>传递父组件回调函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brother1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.refresh&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            更新兄弟组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brother2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         &#123;this.props.text || &quot;兄弟组件未更新&quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">refresh</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&quot;兄弟组件沟通成功&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>兄弟组件沟通<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Brother1</span> <span class="attr">refresh</span>=<span class="string">&#123;this.refresh()&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Brother2</span> <span class="attr">text</span>=<span class="string">&#123;this.state.text&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>codepen例子：<a target="_blank" rel="noopener" href="https://codepen.io/nange/pen/xEbJVg">React组件之兄弟组件沟通</a>。</p>
<h4 id="方式二">方式二</h4>
<p>但是如果组件层次太深（如下图），上面的兄弟组件沟通方式就效率低了（不建议组件层次太深）。</p>
<p><img src="http://cdn.alloyteam.com/wp-content/uploads/2016/01/share-parent-components-278x300.png" alt=""></p>
<p>React提供了一种上下文方式（挺方便的），可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brother1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.context.refresh&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            更新兄弟组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Brother1</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line">  <span class="attr">refresh</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brother2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         &#123;this.context.text || &quot;兄弟组件未更新&quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Brother2</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">getChildContext</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">refresh</span>: <span class="variable language_">this</span>.<span class="title function_">refresh</span>(),</span><br><span class="line">          <span class="attr">text</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">text</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">refresh</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&quot;兄弟组件沟通成功&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>兄弟组件沟通<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Brother1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Brother2</span> <span class="attr">text</span>=<span class="string">&#123;this.state.text&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property">childContextTypes</span> = &#123;</span><br><span class="line">  <span class="attr">refresh</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">any</span>,</span><br><span class="line">  <span class="attr">text</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">any</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>codepen例子：<a target="_blank" rel="noopener" href="https://codepen.io/nange/pen/VKYBAX">React组件之兄弟组件沟通2</a></p>
<h3 id="全局事件">全局事件</h3>
<blockquote>
<p>For communication between two components that don’t have a parent-child relationship, you can set up your own global event system. Subscribe to events in <code>componentDidMount()</code>, unsubscribe in <code>componentWillUnmount()</code>, and call <code>setState()</code> when you receive an event.Flux pattern is one of the possible ways to arrange this.</p>
</blockquote>
<p>官网中提到可以使用全局事件来进行组件间的通信，官网推荐Flux（Facebook官方出的），还有Relay、Redux、trandux等第三方类库。这些框架思想都一致，都是统一管理组件state变化情况，达到<strong>数据可控</strong>目的。本人使用了Redux，建议要会其中一种。对于EventEmitter或PostalJS这类的第三方库是不建议使用的，这类全局事件框架并没有统一管理组件数据变化，用多了会导致数据流不可控。</p>
<p>这里就不细说，请选择其中一种类库，深入学习下。</p>
<h2 id="总结">总结</h2>
<p>简单的组件交流我们可以使用上面非全局事件的简单方式，但是当项目复杂，组件间层次越来越深，上面的交流方式就不太合适（当然还是要用到的，简单的交流）。强烈建议使用Flux、Relay、Redux、trandux等类库其中一种，这些类库不只适合React，像Angular等都可以使用。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2024/08/17/react/React-%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%B5%81-%E7%BB%84%E4%BB%B6%E9%97%B4%E6%B2%9F%E9%80%9A/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2024/08/16/react/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
                            aria-label=": React组件生命周期"
                        >
                            React组件生命周期
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2024-08-16T22:30:15+08:00">
	
		    2024 年 8 月 16 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>此文章适合 React@17 之前的版本，React@16.3.0，添加了一些新的生命周期函数，同时准备废弃一些会造成困扰的生命周期函数。所有如果在React@17 发布之前，这篇文章还是适用的。<br>
新的生命周期请看官网 blog 文章 <a target="_blank" rel="noopener" href="https://legacy.reactjs.org/blog/2018/03/29/react-v-16-3.html">React v16.3.0: New lifecycles and context API</a>。</p>
<h3 id="前言">前言</h3>
<p>组件会随着组件的 <code>props</code> 和 <code>state</code> 改变而发生变化，它的 DOM 也会有相应的变化。</p>
<blockquote>
<p>一个组件就是一个状态机：对于特定的输入，它总会返回一致的输出。</p>
</blockquote>
<p>React组件提供了<code>生命周期</code>的<code>钩子函数</code>去响应组件不同时刻的状态，组件的<code>生命周期</code>如下：</p>
<ul>
<li>实例化</li>
<li>存在期</li>
<li>销毁期</li>
</ul>
<p><code>钩子函数</code>是我们重点关注的地方，下面来详细了解下<code>生命周期</code>下的<code>钩子函数</code>调用顺序和作用。每个<code>生命周期</code>阶段调用的<code>钩子函数</code>会略有不同。下面的图片或许对你有帮助。</p>
<p><img src="/assets/images/react-hook.webp" alt="图片描述" title="图片描述"></p>
<p>可以查看 CodePen 在线 Demo <a target="_blank" rel="noopener" href="https://codepen.io/nange/pen/RGwPXB">React 生命周期</a></p>
<h3 id="实例化">实例化</h3>
<p>首次调用组件时，有以下方法会被调用（注意顺序，从上到下先后执行）：</p>
<ul>
<li>
<p><code>getDefaultProps</code></p>
<p>这个方法是用来设置组件默认的 <code>props</code>，组件<code>生命周期</code>只会调用一次。但是只适合 <code>React.createClass</code> 直接创建的组件，使用 ES6/ES7 创建的这个方法不可使用， ES6/ES7 可以使用下面方式：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es7</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者也可以在外面定义es6</span></span><br><span class="line"><span class="comment">// Compnent.defaultProps</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>getInitialState</code></p>
<p>设置state初始值，在这个方法中你已经可以访问到 <code>this.props</code>。 <code>getInitialState</code> 只适合 <code>React.createClass</code> 使用。使用 ES6 初始化state方法如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">render</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者这样</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">      <span class="attr">render</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>componentWillMount</code></p>
<p>改方法会在组件首次渲染之前调用，这个是在 render 方法调用前可修改 state 的最后一次机会。这个方法很少用到。</p>
</li>
<li>
<p><code>render</code></p>
<p>这个方法以后大家都应该会很熟悉，JSX 通过这里，解析成对应的<code>虚拟 DOM</code>，渲染成最终效果。格式大致如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li>
<p><code>componentDidMount</code></p>
<p>这个方法在首次真实的 DOM 渲染后调用（仅此一次）当我们需要访问真实的 DOM 时，这个方法就经常用到。如何访问真实的 DOM 这里就不想说了。当我们需要请求外部接口数据，一般都在这里处理。</p>
</li>
</ul>
<h3 id="存在期">存在期</h3>
<p>实例化后，当<code>props</code>或者<code>state</code>发生变化时，下面方法依次被调用：</p>
<ul>
<li>
<p>componentWillReceiveProps</p>
<p>没当我们通过父组件更新子组件 props 时（这个也是唯一途径），这个方法就会被调用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>shouldComponentUpdate</p>
<p>字面意思，是否应该更新组件，默认返回 true。当返回 false 时，后期函数就不会调用，组件不会在次渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps,nextState)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>componentWillUpdate</p>
<p>字面意思组件将会更新，<code>props</code> 和 <code>state</code> 改变后必调用。</p>
</li>
<li>
<p>render</p>
<p>跟实例化时的render一样，不多说</p>
</li>
<li>
<p>componentDidUpdate</p>
<p>这个方法在更新真实的 DOM 成功后调用，当我们需要访问真实的 DOM 时，这个方法就也经常用到。</p>
</li>
</ul>
<h3 id="销毁期">销毁期</h3>
<p>销毁阶段，只有一个函数被调用：</p>
<ul>
<li>
<p>componentWillUnmount</p>
<p>没当组件使用完成，这个组件就必须从DOM中销毁，此时该方法就会被调用。当我们在组件中使用了 setInterval，那我们就需要在这个方法中调用 clearInterval。如果手动使用了 addEventListener 绑定了事件，也需要解绑事件。</p>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2024/08/16/react/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2024/08/15/react/React%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"
                            aria-label=": React入门教程"
                        >
                            React入门教程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2024-08-15T00:11:14+08:00">
	
		    2024 年 8 月 15 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/React/">React</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="react-JSX">react - JSX</h2>
<h3 id="React-背景介绍">React 背景介绍</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/03/react.html">React 入门实例教程</a></li>
</ul>
<p>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 <a target="_blank" rel="noopener" href="https://www.instagram.com/">Instagram</a> 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。</p>
<h3 id="什么是React">什么是React</h3>
<ul>
<li>
<p>A JAVASCRIPT LIBRARY FOR BUILDING USER INTERFACES</p>
<ul>
<li>用来构建UI的 JavaScript库</li>
<li>React 不是一个 MVC 框架，仅仅是视图（V）层的库</li>
</ul>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://legacy.reactjs.org/">React 官网</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://doc.react-china.org/">React 中文文档</a></p>
</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>1 使用 JSX语法 创建组件，实现组件化开发，<strong>为函数式的 UI 编程方式打开了大门</strong></li>
<li>2 性能高的让人称赞：通过 <code>diff算法</code> 和 <code>虚拟DOM</code> 实现视图的高效更新</li>
<li>3 HTML仅仅是个开始</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; JSX --TO--&gt; EveryThing</span><br><span class="line"></span><br><span class="line">- JSX --&gt; HTML</span><br><span class="line">- JSX --&gt; native ios或android中的组件（XML）</span><br><span class="line">- JSX --&gt; VR</span><br><span class="line">- JSX --&gt; 物联网</span><br></pre></td></tr></table></figure>
<h3 id="为什么要用React">为什么要用React</h3>
<ul>
<li>1 使用<code>组件化</code>开发方式，符合现代Web开发的趋势</li>
<li>2 技术成熟，社区完善，配件齐全，适用于大型Web项目（生态系统健全）</li>
<li>3 由Facebook专门的团队维护，技术支持可靠</li>
<li>4 ReactNative - Learn once, write anywhere: Build mobile apps with React</li>
<li>5 使用方式简单，性能非常高，支持服务端渲染</li>
<li>6 React非常火，从技术角度，可以满足好奇心，提高技术水平；从职业角度，有利于求职和晋升，有利于参与潜力大的项目</li>
</ul>
<h3 id="React中的核心概念">React中的核心概念</h3>
<ul>
<li>1 虚拟DOM（Virtual DOM）</li>
<li>2 Diff算法（虚拟DOM的加速器，提升React性能的法宝）</li>
</ul>
<h3 id="虚拟DOM（Vitural-DOM）">虚拟DOM（Vitural DOM）</h3>
<blockquote>
<p>React将DOM抽象为虚拟DOM，虚拟DOM其实就是用一个对象来描述DOM，通过对比前后两个对象的差异，最终只把变化的部分重新渲染，提高渲染的效率</p>
<p>为什么用虚拟dom，当dom反生更改时需要遍历 而原生dom可遍历属性多大231个 且大部分与渲染无关 更新页面代价太大</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/livoras/blog/issues/13">如何实现一个 Virtual DOM 算法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31809713">理解 Virtual DOM</a></li>
</ul>
<h4 id="VituralDOM的处理方式">VituralDOM的处理方式</h4>
<ul>
<li>1 用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>2 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>3 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了</li>
</ul>
<h3 id="Diff算法">Diff算法</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://legacy.reactjs.org/docs/reconciliation.html">Reconciliation diff</a></li>
<li><a target="_blank" rel="noopener" href="https://doc.react-china.org/docs/reconciliation.html">diff算法 - 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20346379">不可思议的 react diff</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/zmmbreeze/blog/issues/9">React diff 算法</a></li>
</ul>
<blockquote>
<p>当你使用React的时候，在某个时间点 render() 函数创建了一棵React元素树，<br>
在下一个state或者props更新的时候，render() 函数将创建一棵新的React元素树，<br>
React将对比这两棵树的不同之处，计算出如何高效的更新UI（只更新变化的地方）</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 了解：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有一些解决将一棵树转换为另一棵树的最小操作数算法问题的通用方案。然而，树中元素个数为n，最先进的算法 的时间复杂度为O(n3) 。</span></span><br><span class="line"><span class="comment">如果直接使用这个算法，在React中展示1000个元素则需要进行10亿次的比较。这操作太过昂贵，相反，React基于两点假设，实现了一个O(n)算法，提升性能： --&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>React中有两种假定：</p>
<ul>
<li>1 <strong>两个不同类型的元素会产生不同的树(根元素不同结构树一定不同)</strong></li>
<li>2 <strong>开发者可以通过key属性指定不同树中没有发生改变的子元素</strong></li>
</ul>
</li>
</ul>
<h4 id="Diff算法的说明-1">Diff算法的说明 - 1</h4>
<ul>
<li>如果两棵树的根元素类型不同，React会销毁旧树，创建新树</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧树</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新树</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">执行过程：destory <span class="title class_">Counter</span> -&gt; insert <span class="title class_">Counter</span></span><br></pre></td></tr></table></figure>
<h4 id="Diff算法的说明-2">Diff算法的说明 - 2</h4>
<ul>
<li>对于类型相同的React DOM 元素，React会对比两者的属性是否相同，只更新不同的属性</li>
<li>当处理完这个DOM节点，React就会递归处理子节点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;div className=<span class="string">&quot;before&quot;</span> title=<span class="string">&quot;stuff&quot;</span> /&gt;</span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;after&quot;</span> <span class="attr">title</span>=<span class="string">&quot;stuff&quot;</span> /&gt;</span></span></span><br><span class="line">只更新：className 属性</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">fontWeight</span>: <span class="string">&#x27;bold&#x27;</span>&#125;&#125; /&gt;</span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> &#x27;<span class="attr">green</span>&#x27;, <span class="attr">fontWeight:</span> &#x27;<span class="attr">bold</span>&#x27;&#125;&#125; /&gt;</span></span></span><br><span class="line">只更新：color属性</span><br></pre></td></tr></table></figure>
<h4 id="Diff算法的说明-3">Diff算法的说明 - 3</h4>
<ul>
<li>1 当在子节点的后面添加一个节点，这时候两棵树的转化工作执行的很好</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">执行过程：</span><br><span class="line"><span class="title class_">React</span>会匹配新旧两个&lt;li&gt;first&lt;<span class="regexp">/li&gt;，匹配两个&lt;li&gt;second&lt;/</span>li&gt;，然后添加 &lt;li&gt;third&lt;/li&gt; tree</span><br></pre></td></tr></table></figure>
<ul>
<li>2 但是如果你在开始位置插入一个元素，那么问题就来了：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">在没有key属性时执行过程：</span><br><span class="line"><span class="title class_">React</span>将改变每一个子删除重新创建，而非保持 &lt;li&gt;<span class="title class_">Duke</span>&lt;<span class="regexp">/li&gt; 和 &lt;li&gt;Villanova&lt;/</span>li&gt; 不变</span><br></pre></td></tr></table></figure>
<h4 id="key-属性">key 属性</h4>
<blockquote>
<p>为了解决以上问题，React提供了一个 key 属性。当子节点带有key属性，React会通过key来匹配原始树和后来的树。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2015&quot;</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2016&quot;</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2014&quot;</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2015&quot;</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2016&quot;</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">执行过程：</span><br><span class="line">现在 <span class="title class_">React</span> 知道带有key <span class="string">&#x27;2014&#x27;</span> 的元素是新的，对于 <span class="string">&#x27;2015&#x27;</span> 和 <span class="string">&#x27;2016&#x27;</span> 仅仅移动位置即可 </span><br></pre></td></tr></table></figure>
<ul>
<li>说明：key属性在React内部使用，但不会传递给你的组件</li>
<li>推荐：在遍历数据时，推荐在组件中使用 key 属性：<code>&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</code></li>
<li>注意：<strong>key只需要保持与他的兄弟节点唯一即可，不需要全局唯一</strong></li>
<li>注意：<strong>尽可能的减少数组index作为key，数组中插入元素的等操作时，会使得效率底下</strong></li>
</ul>
<h3 id="React的基本使用">React的基本使用</h3>
<ul>
<li>安装：<code>npm i -S react react-dom</code></li>
<li><code>react</code>：react 是React库的入口点</li>
<li><code>react-dom</code>：提供了针对DOM的方法，比如：把创建的虚拟DOM，渲染到页面上</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 react</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 虚拟DOM</span></span><br><span class="line"><span class="comment">// 参数1：元素名称  参数2：元素属性对象(null表示无)  参数3：当前元素的子元素string||createElement() 的返回值</span></span><br><span class="line"><span class="keyword">const</span> divVD = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">&#125;, <span class="string">&#x27;Hello React！！！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 渲染</span></span><br><span class="line"><span class="comment">// 参数1：虚拟dom对象  参数2：dom对象表示渲染到哪个元素内 参数3：回调函数</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(divVD, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="createElement-的问题">createElement()的问题</h4>
<ul>
<li>说明：<code>createElement()</code>方式，代码编写不友好，太复杂</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dv = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">&quot;shopping-list&quot;</span> &#125;,</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Shopping List for &quot;</span></span><br><span class="line">  ),</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&quot;ul&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">      <span class="string">&quot;li&quot;</span>,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&quot;Instagram&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">      <span class="string">&quot;li&quot;</span>,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&quot;WhatsApp&quot;</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 渲染</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(dv, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="JSX-的基本使用">JSX 的基本使用</h4>
<ul>
<li>注意：JSX语法，最终会被编译为 createElement() 方法</li>
<li>推荐：<strong>使用 JSX 的方式创建组件</strong></li>
<li>JSX - JavaScript XML</li>
<li>安装：<code>npm i -D babel-preset-react</code> （依赖与：babel-core/babel-loader）</li>
</ul>
<blockquote>
<p>注意：JSX的语法需要通过 babel-preset-react 编译后，才能被解析执行</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 在 .babelrc 开启babel对 JSX 的转换 */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;env&quot;</span>, <span class="string">&quot;react&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 webpack.config.js */</span></span><br><span class="line"><span class="attr">module</span>: [</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,</span><br><span class="line">  ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3 在 js 文件中 使用 JSX */</span></span><br><span class="line"><span class="keyword">const</span> dv = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;标题&quot;</span> <span class="attr">className</span>=<span class="string">&quot;cls container&quot;</span>&gt;</span>Hello JSX!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 渲染 JSX 到页面中 */</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(dv, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="JSX的注意点">JSX的注意点</h3>
<ul>
<li>
<p>注意 1: 如果在 JSX 中给元素添加类, 需要使用 <code>className</code> 代替 class</p>
<ul>
<li>类似：label 的 for属性，使用<code>htmlFor</code>代替</li>
</ul>
</li>
<li>
<p>注意 2：在 JSX 中可以直接使用 JS代码，直接在 JSX 中通过 {} 中间写 JS代码即可</p>
</li>
<li>
<p>注意 3：在 JSX 中<strong>只能使用表达式</strong>，但是不能出现 语句！！！</p>
</li>
<li>
<p>注意 4：在 JSX 中注释语法：<code>&#123;/* 中间是注释的内容 */&#125;</code></p>
</li>
</ul>
<h3 id="React组件">React组件</h3>
<blockquote>
<p>React 组件可以让你把UI分割为独立、可复用的片段，并将每一片段视为相互独立的部分。</p>
</blockquote>
<ul>
<li>组件是由一个个的HTML元素组成的</li>
<li>概念上来讲, 组件就像JS中的函数。它们接受用户输入（<code>props</code>），并且<strong>返回</strong>一个React对象，用来描述展示在页面中的内容</li>
</ul>
<h4 id="React创建组件的两种方式">React创建组件的两种方式</h4>
<ul>
<li>1 通过 JS函数 创建（无状态组件）</li>
<li>2 通过 class 创建（有状态组件）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数式组件 和 class 组件的使用场景说明：</span><br><span class="line">1 如果一个组件仅仅是为了展示数据，那么此时就可以使用 函数组件</span><br><span class="line">2 如果一个组件中有一定业务逻辑，需要操作数据，那么就需要使用 class 创建组件，因为，此时需要使用 state</span><br></pre></td></tr></table></figure>
<h5 id="JavaScript函数创建">JavaScript函数创建</h5>
<ul>
<li>注意：1 函数名称必须为大写字母开头，React通过这个特点来判断是不是一个组件</li>
<li>注意：2 函数必须有返回值，返回值可以是：JSX对象或<code>null</code></li>
<li>注意：3 返回的JSX，必须有<em>一个</em>根元素</li>
<li>注意：4 组件的返回值使用<code>()</code>包裹，避免换行问题</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 此处注释的写法 </span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;shopping-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 此处 注释的写法 必须要&#123;&#125;包裹 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shopping List for &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Instagram<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>WhatsApp<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;jack&quot;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="class创建">class创建</h5>
<blockquote>
<p>在es6中class仅仅是一个语法糖，不是真正的类，本质上还是构造函数+原型 实现继承</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6中class关键字的简单使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// - **ES6中的所有的代码都是运行在严格模式中的**</span></span><br><span class="line"><span class="comment">// - 1 它是用来定义类的，是ES6中实现面向对象编程的新方式</span></span><br><span class="line"><span class="comment">// - 2 使用`static`关键字定义静态属性</span></span><br><span class="line"><span class="comment">// - 3 使用`constructor`构造函数，创建实例属性</span></span><br><span class="line"><span class="comment">// - [参考](http://es6.ruanyifeng.com/#docs/class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 实例的构造函数 constructor</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age</span>)&#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在class中定义方法 此处为实例方法 通过实例打点调用</span></span><br><span class="line">  <span class="title function_">sayHello</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;大家好，我今年&#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&#x27;了&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法 通过构造函数打点调用 Person.doudou()</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">doudou</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是小明，我新get了一个技能，会暖床&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加静态属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">staticName</span> = <span class="string">&#x27;静态属性&#x27;</span></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">19</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 实现继承的方式</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">American</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 必须调用super(), super表示父类的构造函数</span></span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">skin</span> = <span class="string">&#x27;white&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eyeColor</span> = <span class="string">&#x27;white&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建react对象</span></span><br><span class="line"><span class="comment">// 注意：基于 `ES6` 中的class，需要配合 `babel` 将代码转化为浏览器识别的ES5语法</span></span><br><span class="line"><span class="comment">// 安装：`npm i -D babel-preset-env`</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//  react对象继承字React.Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123; </span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// class创建的组件中 必须有rander方法 且显示return一个react对象或者null</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;shopping-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shopping List for &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>Instagram<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>WhatsApp<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给组件传递数据-父子组件传递数据">给组件传递数据 - 父子组件传递数据</h3>
<ul>
<li>组件中有一个 <code>只读的对象</code> 叫做 <code>props</code>，无法给props添加属性</li>
<li>获取方式：函数参数 <code>props</code></li>
<li>作用：将传递给组件的属性转化为 <code>props</code> 对象中的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="comment">// props ---&gt; &#123; username: &#x27;zs&#x27;, age: 20 &#125;</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Welcome React<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>姓名：&#123;props.username&#125;----年龄是：&#123;props.age&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 Hello组件 传递 props：username 和 age(如果你想要传递numb类型是数据 就需要向下面这样)</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">reander</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">username</span>=<span class="string">&quot;zs&quot;</span> <span class="attr">age</span>=<span class="string">&#123;20&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span>, ......)</span><br></pre></td></tr></table></figure>
<h3 id="封装组件到独立的文件中">封装组件到独立的文件中</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Hello2.js组件文件</span></span><br><span class="line"><span class="comment">// 1. 引入React模块</span></span><br><span class="line"><span class="comment">// 由于 JSX 编译后会调用 React.createElement 方法，所以在你的 JSX 代码中必须首先拿到React。</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用function构造函数创建组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Hello2</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是Hello2组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是大大的H1标签，我大，我骄傲！！！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h6</span>&gt;</span>这是小小的h6标签，我小，我傲娇！！！<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 导出组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Hello2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js中   使用组件：</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Hello2</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Hello2&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="props和state">props和state</h3>
<h4 id="props">props</h4>
<ul>
<li>
<p>作用：<strong>给组件传递数据，一般用在父子组件之间</strong></p>
</li>
<li>
<p>说明：React把传递给组件的属性转化为一个对象并交给 <code>props</code></p>
</li>
<li>
<p>特点：<code>props</code>是只读的，无法给<code>props</code>添加或修改属性</p>
</li>
<li>
<p><code>props.children</code>：获取组件的内容，比如：</p>
<ul>
<li><code>&lt;Hello&gt;组件内容&lt;/Hello&gt;</code> 中的 <code>组件内容</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// props 是一个包含数据的对象参数，不要试图修改 props 参数</span></span><br><span class="line"><span class="comment">// 返回值：react元素</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回的 react元素中必须只有一个根元素</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="state">state</h4>
<blockquote>
<p>状态即数据</p>
</blockquote>
<ul>
<li>
<p>作用：用来给组件提供<code>组件内部</code>使用的数据</p>
</li>
<li>
<p>注意：只有通过<code>class</code>创建的组件才具有状态</p>
</li>
<li>
<p>注意：<strong>状态是私有的，完全由组件来控制</strong></p>
</li>
<li>
<p>注意：不要在 <code>state</code> 中添加 <code>render()</code> 方法中不需要的数据，会影响渲染性能！</p>
<ul>
<li>可以将组件内部使用但是不渲染在视图中的内容，直接添加给 this</li>
</ul>
</li>
<li>
<p>注意：不要在 <code>render()</code> 方法中调用 setState() 方法来修改<code>state</code>的值</p>
<ul>
<li>但是可以通过 <code>this.state.name = 'rose'</code> 方式设置state（不推荐!!!）</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// es6继承必须用super调用父类的constructor</span></span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>性别：&#123; this.state.gender &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSX语法转化过程">JSX语法转化过程</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、JSX</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;greeting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello, world!</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、JSX -&gt; createElement</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// React elements: 使用对象的形式描述页面结构</span></span><br><span class="line"><span class="comment">// Note: 这是简化后的对象结构</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: [<span class="string">&#x27;Hello, world&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="评论列表案例">评论列表案例</h3>
<ul>
<li>巩固有状态组件和无状态组件的使用</li>
<li>两个组件：<code>&lt;CommentList&gt;&lt;/CommentList&gt;</code> 和 <code>&lt;Comment&gt;&lt;/Comment&gt;</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;哈哈，沙发&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&#x27;张三2&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;哈哈，板凳&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&#x27;张三3&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;哈哈，凉席&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&#x27;张三4&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;哈哈，砖头&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&#x27;张三5&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;哈哈，楼下山炮&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性扩展</span></span><br><span class="line">&lt;<span class="title class_">Comment</span> &#123;...item&#125; key=&#123;i&#125;&gt;&lt;/<span class="title class_">Comment</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="style样式">style样式</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 直接写行内样式：</span></span><br><span class="line">&lt;li style=&#123;&#123;<span class="attr">border</span>:<span class="string">&#x27;1px solid red&#x27;</span>, <span class="attr">fontSize</span>:<span class="string">&#x27;12px&#x27;</span>&#125;&#125;&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 抽离为对象形式</span></span><br><span class="line"><span class="keyword">var</span> styleH3 = &#123;<span class="attr">color</span>:<span class="string">&#x27;blue&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> styleObj = &#123;</span><br><span class="line">  <span class="attr">liStyle</span>:&#123;<span class="attr">border</span>:<span class="string">&#x27;1px solid red&#x27;</span>, <span class="attr">fontSize</span>:<span class="string">&#x27;12px&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">h3Style</span>:&#123;<span class="attr">color</span>:<span class="string">&#x27;green&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;li style=&#123;styleObj.<span class="property">liStyle</span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&#123;styleObj.h3Style&#125;</span>&gt;</span>评论内容：&#123;props.content&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用样式表定义样式：</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../css/comment.css&#x27;</span></span><br><span class="line">&lt;p className=<span class="string">&quot;pUser&quot;</span>&gt;评论人：&#123;props.<span class="property">user</span>&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="相关文章">相关文章</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tim100/p/6050514.html">React数据流和组件间的沟通总结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/29504639?sort=created">怎么更好的理解虚拟DOM?</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yczz/article/details/49886061">React 源码剖析系列 － 不可思议的 react diff</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/react-dom-diff/?from=timeline&amp;isappinstalled=0">深入浅出React（四）：虚拟DOM Diff算法解析</a></li>
</ul>
<h3 id="组件的生命周期">组件的生命周期</h3>
<ul>
<li>简单说：<strong>一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期</strong></li>
</ul>
<p>组件生命周期函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，那么这些事件，统称为组件的生命周期函数！</p>
<ul>
<li>通过这个函数，能够让开发人员的代码，参与到组件的生命周期中。也就是说，通过钩子函数，就可以控制组件的行为</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20312691?refer=purerender">React 生命周期的管理艺术</a></li>
</ul>
<h4 id="组件生命周期函数总览">组件生命周期函数总览</h4>
<ul>
<li>组件的生命周期包含三个阶段：创建阶段（Mounting）、运行和交互阶段（Updating）、卸载阶段（Unmounting）</li>
<li>Mounting：</li>
</ul>
<blockquote>
<p>constructor()<br>
componentWillMount()<br>
render()<br>
componentDidMount()</p>
</blockquote>
<ul>
<li>Updating</li>
</ul>
<blockquote>
<p>componentWillReceiveProps()<br>
shouldComponentUpdate()<br>
componentWillUpdate()<br>
render()<br>
componentDidUpdate()</p>
</blockquote>
<ul>
<li>Unmounting</li>
</ul>
<blockquote>
<p>componentWillUnmount()</p>
</blockquote>
<h4 id="组件生命周期-创建阶段-Mounting">组件生命周期 - 创建阶段(Mounting)</h4>
<ul>
<li>特点：该阶段的函数只执行一次</li>
</ul>
<h5 id="constructor">constructor()</h5>
<ul>
<li>作用：1 获取props 2 初始化state</li>
<li>说明：通过 <code>constructor()</code> 的参数<code>props</code>获取</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取 props</span></span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="comment">// 初始化 state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: props.<span class="property">initCount</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 props</span></span><br><span class="line"><span class="comment">// 语法：通过静态属性 defaultProps 来初始化props</span></span><br><span class="line"><span class="title class_">Greeting</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">  <span class="attr">initCount</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="componentWillMount">componentWillMount()</h5>
<ul>
<li>说明：组件被挂载到页面之前调用，其在render()之前被调用，因此在这方法里<code>同步</code>地设置状态将不会触发重渲染</li>
<li>注意：无法获取页面中的DOM对象</li>
<li>注意：可以调用 <code>setState()</code> 方法来改变状态值</li>
<li>用途：发送ajax请求获取数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)) <span class="comment">// null</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="render">render()</h5>
<ul>
<li>
<p>作用：渲染组件到页面中，无法获取页面中的DOM对象</p>
</li>
<li>
<p>注意：<strong>不要在render方法中调用 <code>setState()</code> 方法，否则会递归渲染</strong></p>
<ul>
<li>原因说明：状态改变会重新调用<code>render()</code>，<code>render()</code>又重新改变状态</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleAdd&#125;</span>&gt;</span>打豆豆一次<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;</span></span><br><span class="line"><span class="language-xml">        this.state.count === 4</span></span><br><span class="line"><span class="language-xml">        ? null</span></span><br><span class="line"><span class="language-xml">        : <span class="tag">&lt;<span class="name">CounterChild</span> <span class="attr">initCount</span>=<span class="string">&#123;this.state.count&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CounterChild</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="componentDidMount">componentDidMount()</h5>
<ul>
<li>1 组件已经挂载到页面中</li>
<li>2 可以进行DOM操作，比如：获取到组件内部的DOM对象</li>
<li>3 可以<strong>发送请求</strong>获取数据</li>
<li>4 可以通过 <code>setState()</code> 修改状态的值</li>
<li>注意：在这里修改状态会重新渲染</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 此时，就可以获取到组件内部的DOM对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;componentDidMount&#x27;</span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组件生命周期-运行阶段（Updating）">组件生命周期 - 运行阶段（Updating）</h4>
<ul>
<li>特点：该阶段的函数执行多次</li>
<li>说明：每当组件的<code>props</code>或者<code>state</code>改变的时候，都会触发运行阶段的函数</li>
</ul>
<h5 id="componentWillReceiveProps">componentWillReceiveProps()</h5>
<ul>
<li>说明：组件接受到新的<code>props</code>前触发这个方法</li>
<li>参数：当前组件<code>props</code>值</li>
<li>可以通过 <code>this.props</code> 获取到上一次的值</li>
<li>使用：若你需要响应属性的改变，可以通过对比<code>this.props</code>和<code>nextProps</code>并在该方法中使用<code>this.setState()</code>处理状态改变</li>
<li>注意：修改<code>state</code>不会触发该方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;componentWillReceiveProps&#x27;</span>, nextProps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="shouldComponentUpdate">shouldComponentUpdate()</h5>
<ul>
<li>作用：根据这个方法的返回值决定是否重新渲染组件，返回<code>true</code>重新渲染，否则不渲染</li>
<li>优势：通过某个条件渲染组件，降低组件渲染频率，提升组件性能</li>
<li>说明：如果返回值为<code>false</code>，那么，后续<code>render()</code>方法不会被调用</li>
<li>注意：<strong>这个方法必须返回布尔值！！！</strong></li>
<li>场景：根据随机数决定是否渲染组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// - 参数：</span></span><br><span class="line"><span class="comment">//   - 第一个参数：最新属性对象</span></span><br><span class="line"><span class="comment">//   - 第二个参数：最新状态对象</span></span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;shouldComponentUpdate&#x27;</span>, nextProps, nextState)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextState.<span class="property">count</span> % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="componentWillUpdate">componentWillUpdate()</h5>
<ul>
<li>作用：组件将要更新</li>
<li>参数：最新的属性和状态对象</li>
<li>注意：不能修改状态 否则会循环渲染</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;componentWillUpdate&#x27;</span>, nextProps, nextState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="render-渲染">render() 渲染</h5>
<ul>
<li>作用：重新渲染组件，与<code>Mounting</code>阶段的<code>render</code>是同一个函数</li>
<li>注意：这个函数能够执行多次，只要组件的属性或状态改变了，这个方法就会重新执行</li>
</ul>
<h5 id="componentDidUpdate">componentDidUpdate()</h5>
<ul>
<li>作用：组件已经被更新</li>
<li>参数：旧的属性和状态对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;componentDidUpdate&#x27;</span>, prevProps, prevState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组件生命周期-卸载阶段（Unmounting）">组件生命周期 - 卸载阶段（Unmounting）</h4>
<ul>
<li>组件销毁阶段：组件卸载期间，函数比较单一，只有一个函数，这个函数也有一个显著的特点：组件一辈子只能执行依次！</li>
<li>使用说明：只要组件不再被渲染到页面中，那么这个方法就会被调用（ 渲染到页面中 -&gt; 不再渲染到页面中 ）</li>
</ul>
<h5 id="componentWillUnmount">componentWillUnmount()</h5>
<ul>
<li>
<p>作用：在卸载组件的时候，执行清理工作，比如</p>
<ul>
<li>1 清除定时器</li>
<li>2 清除<code>componentDidMount</code>创建的DOM对象</li>
</ul>
</li>
</ul>
<hr>
<h3 id="React-createClass（不推荐）">React - createClass（不推荐）</h3>
<ul>
<li><strong><code>React.createClass(&#123;&#125;)</code> 方式，创建有状态组件，该方式已经被废弃！！！</strong></li>
<li>通过导入 <code>require('create-react-class')</code>，可以在不适用ES6的情况下，创建有状态组件</li>
<li>getDefaultProps() 和 getInitialState() 方法：是 <code>createReactClass()</code> 方式创建组件中的两个函数</li>
<li><a target="_blank" rel="noopener" href="https://legacy.reactjs.org/docs/react-without-es6.html#declaring-default-props">React without ES6</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createReactClass = <span class="built_in">require</span>(<span class="string">&#x27;create-react-class&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Greeting</span> = <span class="title function_">createReactClass</span>(&#123;</span><br><span class="line">  <span class="comment">// 初始化 props</span></span><br><span class="line">  <span class="attr">getDefaultProps</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getDefaultProps&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Basic counter!!!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 state</span></span><br><span class="line">  <span class="attr">getInitialState</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getInitialState&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">render</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;button&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;+&#x27;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleIncrement&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">handleIncrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> newCount = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>: newCount&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">propTypes</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">Greeting</span>),</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="state和setState">state和setState</h3>
<ul>
<li>注意：使用 <code>setState()</code> 方法修改状态，状态改变后，React会重新渲染组件</li>
<li>注意：不要直接修改state属性的值，这样不会重新渲染组件！！！</li>
<li>使用：1 初始化state 2 setState修改state</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改state（不推荐使用）</span></span><br><span class="line"><span class="comment">// https://facebook.github.io/react/docs/state-and-lifecycle.html#do-not-modify-state-directly</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">test</span> = <span class="string">&#x27;这样方式，不会重新渲染组件&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确姿势！！！</span></span><br><span class="line">  <span class="comment">// -------------- 初始化 state --------------</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">    <span class="attr">count</span>: props.<span class="property">initCount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// -------------- 修改 state 的值 --------------</span></span><br><span class="line">  <span class="comment">// 方式一：</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">  &#125;, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 由于 setState() 是异步操作，所以，如果想立即获取修改后的state</span></span><br><span class="line">    <span class="comment">// 需要在回调函数中获取</span></span><br><span class="line">    <span class="comment">// https://doc.react-china.org/docs/react-component.html#setstate</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方式二：</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="keyword">function</span>(<span class="params">prevState, props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">counter</span>: prevState.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者 - 注意： =&gt; 后面需要带有小括号，因为返回的是一个对象</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">counter</span>: prevState.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件绑定事件">组件绑定事件</h3>
<ul>
<li>
<p>1 通过React事件机制 <code>onClick</code> 绑定</p>
</li>
<li>
<p>2 JS原生方式绑定（通过 <code>ref</code> 获取元素）</p>
<ul>
<li>注意：<code>ref</code> 是React提供的一个特殊属性</li>
<li><code>ref</code>的使用说明</li>
</ul>
</li>
</ul>
<h4 id="React中的事件机制-推荐">React中的事件机制 - 推荐</h4>
<ul>
<li>注意：事件名称采用驼峰命名法</li>
<li>例如：<code>onClick</code> 用来绑定单击事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;触发单击事件&quot;</span></span><br><span class="line">  onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleCountAdd</span>&#125;</span><br><span class="line">  onMouseEnter=&#123;<span class="variable language_">this</span>.<span class="property">handleMouseEnter</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="JS原生方式-知道即可">JS原生方式 - 知道即可</h4>
<ul>
<li>说明：给元素添加 <code>ref</code> 属性，然后，获取元素绑定事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="comment">// 将当前DOM的引用赋值给 this.txtInput 属性</span></span><br><span class="line">&lt;input ref=&#123; <span class="function"><span class="params">input</span> =&gt;</span> <span class="variable language_">this</span>.<span class="property">txtInput</span> = input &#125; type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;我是豆豆&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 通过 this.txtInput 属性获取元素绑定事件</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">txtInput</span>.<span class="title function_">addEventListener</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件绑定中的this">事件绑定中的this</h3>
<ul>
<li>1 通过 <code>bind</code> 绑定</li>
<li>2 通过 <code>箭头函数</code> 绑定</li>
</ul>
<h4 id="通过bind绑定">通过bind绑定</h4>
<ul>
<li>原理：<code>bind</code>能够调用函数，改变函数内部this的指向，并返回一个新函数</li>
<li>说明：<code>bind</code>第一个参数为返回函数中this的指向，后面的参数为传给返回函数的参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义方法：</span></span><br><span class="line"><span class="title function_">handleBtnClick</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;点击事件修改state的值&#x27;</span> + arg1 + arg2</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        // <span class="attr">无参数</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        // <span class="attr">this.handleBtnClick.bind</span>(<span class="attr">this</span>)</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        // <span class="attr">有参数</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">this.handleBtnClick.bind</span>(<span class="attr">this</span>, &#x27;<span class="attr">abc</span>&#x27;, [<span class="attr">1</span>, <span class="attr">2</span>])</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &#125;&gt;</span>事件中this的处理<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在构造函数中使用<code>bind</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>()</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">handleBtnClick</span> = <span class="variable language_">this</span>.<span class="property">handleBtnClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render() 方法中：</span></span><br><span class="line">&lt;button onClick=&#123; <span class="variable language_">this</span>.<span class="property">handleBtnClick</span> &#125;&gt;事件中<span class="variable language_">this</span>的处理&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h4 id="通过箭头函数绑定">通过箭头函数绑定</h4>
<ul>
<li>原理：<code>箭头函数</code>中的this由所处的环境决定，自身不绑定this</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;在构造函数中绑定this并传参&quot;</span> onClick=&#123;</span><br><span class="line">  <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="title function_">handleBtnClick</span>(<span class="string">&#x27;参数1&#x27;</span>, <span class="string">&#x27;参数2&#x27;</span>) &#125;</span><br><span class="line">&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleBtnClick</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;在构造函数中绑定this并传参&#x27;</span> + arg1 + arg2</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="受控组件">受控组件</h3>
<ul>
<li>表单和受控组件</li>
<li>非受控组件</li>
</ul>
<blockquote>
<p>在HTML当中，像<code>input</code>,<code>textarea</code>和<code>select</code>这类表单元素会维持自身状态，并根据用户输入进行更新。<br>
在React中，可变的状态通常保存在组件的<code>state</code>中，并且只能用 <code>setState()</code> 方法进行更新.<br>
React根据初始状态渲染表单组件，接受用户后续输入，改变表单组件内部的状态。<br>
因此，将那些值由React控制的表单元素称为：受控组件。</p>
</blockquote>
<ul>
<li>
<p>受控组件的特点：</p>
<ul>
<li>1 表单元素</li>
<li>2 由React通过JSX渲染出来</li>
<li>3 由React控制值的改变，也就是说想要改变元素的值，只能通过React提供的方法来修改</li>
</ul>
</li>
<li>
<p>注意：<strong>只能通过setState来设置受控组件的值</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟实现文本框数据的双向绑定</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>&#125; onChange=&#123;<span class="variable language_">this</span>.<span class="property">handleTextChange</span>&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当文本框内容改变的时候，触发这个事件，重新给state赋值</span></span><br><span class="line">handleTextChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">msg</span>: event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="评论列表案例-2">评论列表案例</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;沙发！！！&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;小红&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;小明，居然是你&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&#x27;小刚&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;小明，放学你别走！！！&#x27;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="props校验">props校验</h3>
<ul>
<li>作用：通过类型检查，提高程序的稳定性</li>
<li>命令：<code>npm i -S prop-types</code></li>
<li>使用：给类提供一个静态属性 <code>propTypes</code>（对象），来约束<code>props</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...以下代码是类的静态属性：</span></span><br><span class="line"><span class="comment">// propTypes 静态属性的名称是固定的！！！</span></span><br><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">  <span class="attr">initCount</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>, <span class="comment">// 规定属性的类型</span></span><br><span class="line">  <span class="attr">initAge</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequired</span> <span class="comment">// 规定属性的类型，且规定为必传字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="React-单向数据流">React 单向数据流</h3>
<ul>
<li><strong>React 中采用单项数据流</strong></li>
<li>数据流动方向：自上而下，也就是只能由父组件传递到子组件</li>
<li>数据都是由父组件提供的，子组件想要使用数据，都是从父组件中获取的</li>
<li>如果多个组件都要使用某个数据，最好将这部分共享的状态提升至他们最近的父组件当中进行管理</li>
<li>单向数据流</li>
<li>状态提升</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">react中的单向数据流动：</span><br><span class="line">1 数据应该是从上往下流动的，也就是由父组件将数据传递给子组件</span><br><span class="line">2 数据应该是由父组件提供，子组件要使用数据的时候，直接从子组件中获取</span><br><span class="line"></span><br><span class="line">在我们的评论列表案例中：数据是由CommentList组件（父组件）提供的</span><br><span class="line">子组件 CommentItem 负责渲染评论列表，数据是由 父组件提供的</span><br><span class="line">子组件 CommentForm 负责获取用户输入的评论内容，最终也是把用户名和评论内容传递给了父组件，由父组件负责处理这些数据（ 把数据交给 CommentItem 由这个组件负责渲染 ）</span><br></pre></td></tr></table></figure>
<h4 id="组件通讯">组件通讯</h4>
<ul>
<li>父 -&gt; 子：<code>props</code></li>
<li>子 -&gt; 父：父组件通过props传递回调函数给子组件，子组件调用函数将数据作为参数传递给父组件</li>
<li>兄弟组件：因为React是单向数据流，因此需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的props</li>
<li>React中的状态管理： flux（提出状态管理的思想） -&gt; Redux -&gt; mobx</li>
<li>Vue中的状态管理： Vuex</li>
<li>简单来说，就是统一管理了项目中所有的数据，让数据变的可控</li>
<li><a href="https://keinchan.com/2024/08/17/react/React-%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%B5%81-%E7%BB%84%E4%BB%B6%E9%97%B4%E6%B2%9F%E9%80%9A/">组件通讯</a></li>
</ul>
<h4 id="Context特性">Context特性</h4>
<ul>
<li>
<p>注意：<strong>如果不熟悉React中的数据流，不推荐使用这个属性</strong></p>
<ul>
<li>这是一个实验性的API，在未来的React版本中可能会被更改</li>
</ul>
</li>
<li>
<p>作用：跨级传递数据（爷爷给孙子传递数据），避免向下每层手动地传递<code>props</code></p>
</li>
<li>
<p>说明：需要配合<code>PropTypes</code>类型限制来使用</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grandfather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 类型限制（必须），静态属性名称固定</span></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传递给孙子组件的数据</span></span><br><span class="line">  <span class="title function_">getChildContext</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span>&gt;</span><span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 类型限制，静态属性名字固定</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 从上下文对象中获取爷爷组件传递过来的数据</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">this.context.color</span> &#125;&#125;&gt;</span>爷爷告诉文字是红色的<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="react-router">react-router</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://reacttraining.com/react-router">react router 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/remix-run/react-router">react router github</a></li>
<li>安装：<code>npm i -S react-router-dom</code></li>
</ul>
<h4 id="基本概念说明">基本概念说明</h4>
<ul>
<li><code>Router</code>组件本身只是一个容器，真正的路由要通过<code>Route组件</code>定义</li>
</ul>
<h4 id="使用步骤">使用步骤</h4>
<ul>
<li>
<p>1 导入路由组件</p>
</li>
<li>
<p>2 使用 <code>&lt;Router&gt;&lt;/Router&gt;</code> 作为根容器，包裹整个应用（JSX）</p>
<ul>
<li>在整个应用程序中，只需要使用一次</li>
</ul>
</li>
<li>
<p>3 使用 <code>&lt;Link to=&quot;/movie&quot;&gt;&lt;/Link&gt;</code> 作为链接地址，并指定<code>to</code>属性</p>
</li>
<li>
<p>4 使用 <code>&lt;Route path=&quot;/&quot; compoent=&#123;Movie&#125;&gt;&lt;/Route&gt;</code> 展示路由内容</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 导入组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">HashRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>,</span><br><span class="line">  <span class="title class_">Link</span>, <span class="title class_">Route</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 使用 &lt;Router&gt;</span></span><br><span class="line">&lt;<span class="title class_">Router</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 设置 Link</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/movie&quot;</span>&gt;</span>电影<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 设置 Route</span></span><br><span class="line">    <span class="comment">// exact 表示：绝对匹配（完全匹配，只匹配：/）</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;HomeContainer&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/movie&quot;</span> <span class="attr">component</span>=<span class="string">&#123;MovieContainer&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AboutContainer&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/<span class="title class_">Router</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="注意点">注意点</h4>
<ul>
<li><code>&lt;Router&gt;&lt;/Router&gt;</code>：作为整个组件的根元素，是路由容器，只能有一个唯一的子元素</li>
<li><code>&lt;Link&gt;&lt;/Link&gt;</code>：类似于vue中的<code>&lt;router-link&gt;&lt;/router-link&gt;</code>标签，<code>to</code> 属性指定路由地址</li>
<li><code>&lt;Route&gt;&lt;/Route&gt;</code>：类似于vue中的<code>&lt;router-view&gt;&lt;/router-view&gt;</code>，指定路由内容（组件）展示位置</li>
</ul>
<h4 id="路由参数">路由参数</h4>
<ul>
<li>配置：通过<code>Route</code>中的path属性来配置路由参数</li>
<li>获取：<code>this.props.match.params</code> 获取</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置路由参数</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/movie/:movieType&quot;</span>&gt;&lt;/<span class="title class_">Route</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路由参数</span></span><br><span class="line"><span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">match</span>.<span class="property">params</span>.<span class="property">movieType</span></span><br></pre></td></tr></table></figure>
<h4 id="路由跳转">路由跳转</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://reacttraining.com/react-router/web/api/history">react router - history</a></li>
<li><code>history.push()</code> 方法用于在JS中实现页面跳转</li>
<li><code>history.go(-1)</code> 用来实现页面的前进（1）和后退(-1)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="string">&#x27;/movie/movieDetail/&#x27;</span> + movieId)</span><br></pre></td></tr></table></figure>
<h3 id="fetch">fetch</h3>
<ul>
<li>作用：Fetch 是一个现代的概念, 等同于 XMLHttpRequest。它提供了许多与XMLHttpRequest相同的功能，但被设计成更具可扩展性和高效性。</li>
<li><code>fetch()</code> 方法返回一个<code>Promise</code>对象</li>
</ul>
<h4 id="fetch-基本使用">fetch 基本使用</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response">fetch Response</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ccf99a12faf1">fetch 介绍</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  通过fetch请求回来的数据，是一个Promise对象.</span></span><br><span class="line"><span class="comment">  调用then()方法，通过参数response，获取到响应对象</span></span><br><span class="line"><span class="comment">  调用 response.json() 方法，解析服务器响应数据</span></span><br><span class="line"><span class="comment">  再次调用then()方法，通过参数data，就获取到数据了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/movie/&#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">movieType</span>)</span><br><span class="line">  <span class="comment">// response.json() 读取response对象，并返回一个被解析为JSON格式的promise对象</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  <span class="comment">// 通过 data 获取到数据</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">movieList</span>: data.<span class="property">subjects</span>,</span><br><span class="line">      <span class="attr">loaing</span>: <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="跨域获取数据的三种常用方式">跨域获取数据的三种常用方式</h3>
<ul>
<li>1 JSONP</li>
<li>2 代理</li>
<li>3 CORS</li>
</ul>
<h4 id="JSONP">JSONP</h4>
<ul>
<li>安装：<code>npm i -S fetch-jsonp</code></li>
<li>利用<code>JSONP</code>实现跨域获取数据，只能获取GET请求</li>
<li><code>fetch-jsonp</code></li>
<li><a href="hhttps://github.com/camsong/fetch-jsonp">fetch-jsonp</a></li>
<li>限制：1 只能发送GET请求 2 需要服务端支持JSONP请求</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* movielist.js */</span></span><br><span class="line"><span class="title function_">fetchJsonp</span>(<span class="string">&#x27;https://api.douban.com/v2/movie/in_theaters&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">rep</span> =&gt;</span> rep.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(data) &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="代理">代理</h4>
<ul>
<li><code>webpack-dev-server</code> 代理配置如下：</li>
<li>问题：webpack-dev-server 是开发期间使用的工具，项目上线了就不再使用 webpack-dev-server</li>
<li>解决：项目上线后的代码，也是会部署到一个服务器中，这个服务器配置了代理功能即可（要求两个服务器中配置的代理规则相同）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack-dev-server的配置</span></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="comment">// https://webpack.js.org/configuration/dev-server/#devserver-proxy</span></span><br><span class="line">  <span class="comment">// https://github.com/chimurai/http-proxy-middleware#http-proxy-options</span></span><br><span class="line">  <span class="comment">// http://www.jianshu.com/p/3bdff821f859</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用：/api/movie/in_theaters</span></span><br><span class="line">    <span class="comment">// 访问 ‘/api/movie/in_theaters’ ==&gt; &#x27;https://api.douban.com/v2/movie/in_theaters&#x27;</span></span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">      <span class="comment">// 代理的目标服务器地址</span></span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;https://api.douban.com/v2&#x27;</span>,</span><br><span class="line">      <span class="comment">// https请求需要该设置</span></span><br><span class="line">      <span class="attr">secure</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">// 必须设置该项</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// &#x27;/api/movie/in_theaters&#x27; 路径重写为：&#x27;/movie/in_theaters&#x27;</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;<span class="string">&quot;^/api&quot;</span> : <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* movielist.js */</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/movie/in_theaters&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 将服务器返回的数据转化为 json 格式</span></span><br><span class="line">    <span class="keyword">return</span> data.<span class="title function_">json</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">rep</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取上面格式化后的数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rep);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="CORS-服务器端配合">CORS - 服务器端配合</h4>
<ul>
<li>示例：NodeJS设置跨域</li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 - 阮一峰</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Express的中间件来处理所有请求</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 设置请求头为允许跨域</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置服务器支持的所有头信息字段</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type,Content-Length, Authorization,Accept,X-Requested-With&#x27;</span>);</span><br><span class="line">  <span class="comment">// 设置服务器支持的所有跨域请求的方法</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;POST,GET&#x27;</span>);</span><br><span class="line">  <span class="comment">// next()方法表示进入下一个路由</span></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="redux">redux</h3>
<ul>
<li>状态管理工具，用来管理应用中的数据</li>
</ul>
<h4 id="核心">核心</h4>
<ul>
<li>
<p>Action：行为的抽象，视图中的每个用户交互都是一个action</p>
<ul>
<li>比如：点击按钮</li>
</ul>
</li>
<li>
<p>Reducer：行为响应的抽象，也就是：根据action行为，执行相应的逻辑操作，更新state</p>
<ul>
<li>比如：点击按钮后，添加任务，那么，添加任务这个逻辑放到 Reducer 中</li>
<li>1 创建State</li>
</ul>
</li>
<li>
<p>Store：</p>
<ul>
<li>1 <strong>Redux应用只能有一个store</strong></li>
<li>2 <code>getState()</code>：获取state</li>
<li>3 <code>dispatch(action)</code>：更新state</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* action */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 redux 中，action 就是一个对象</span></span><br><span class="line"><span class="comment">// action 必须提供一个：type属性，表示当前动作的标识</span></span><br><span class="line"><span class="comment">// 其他的参数：表示这个动作需要用到的一些数据</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;要添加的任务名称&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个动作表示要切换任务状态</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;TOGGLE_TODO&#x27;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reducer */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数：表示状态（数据），我们需要给初始状态设置默认值</span></span><br><span class="line"><span class="comment">// 第二个参数：表示 action 行为</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todo</span>(<span class="params">state = [], action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">      state.<span class="title function_">push</span>(&#123; <span class="attr">id</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>(), <span class="attr">name</span>: action.<span class="property">name</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;TOGGLE_TODO&#x27;</span>:</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; state.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state[i].<span class="property">id</span> === action.<span class="property">id</span>) &#123;</span><br><span class="line">          state[i].<span class="property">completed</span> = !state[i].<span class="property">completed</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要执行 ADD_TODO 这个动作：</span></span><br><span class="line"><span class="title function_">dispatch</span>( &#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;要添加的任务名称&#x27;</span> &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部会调用 reducer</span></span><br><span class="line"><span class="title function_">todo</span>(<span class="literal">undefined</span>, &#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;要添加的任务名称&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2024/08/15/react/React%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2024/01/18/JavaScript/JavaScript-Node-js/"
                            aria-label=": JavaScript-Node.js"
                        >
                            JavaScript-Node.js
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2024-01-18T22:16:57+08:00">
	
		    2024 年 1 月 18 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>, <a class="category-link" href="../../../categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>从本章开始，我们就正式开启JavaScript的后端开发之旅。</p>
<p>Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。</p>
<p>众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。</p>
<p>后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。</p>
<p>没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可改进之处，然后解散了IE6开发团队！而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍。</p>
<p>先是Mozilla借助已壮烈牺牲的Netscape遗产在2002年推出了<a target="_blank" rel="noopener" href="https://www.mozilla.org/firefox/">Firefox</a>浏览器，紧接着Apple于2003年在开源的KHTML浏览器的基础上推出了WebKit内核的<a target="_blank" rel="noopener" href="https://www.apple.com/safari/">Safari</a>浏览器，不过仅限于Mac平台。</p>
<p>随后，Google也开始创建自家的浏览器。他们也看中了WebKit内核，于是基于WebKit内核推出了<a target="_blank" rel="noopener" href="https://www.google.com/chrome/">Chrome</a>浏览器。</p>
<p>Chrome浏览器是跨Windows和Mac平台的，并且，Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。</p>
<p>现代浏览器大战让微软的IE浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队！回过头再追赶却发现，支持HTML5的WebKit已经成为手机端的标准了，IE浏览器从此与主流移动端设备绝缘。</p>
<p>浏览器大战和Node有何关系？</p>
<p>话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。</p>
<p>因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。</p>
<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为<a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js</a>。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。</p>
<p>在Node上运行的JavaScript相比其他后端开发语言有何优势？</p>
<p>最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。</p>
<p>其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。</p>
<p>由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。</p>
<h3 id="安装Node-js">安装Node.js</h3>
<p>目前Node.js的最新版本是22.3.0，LTS版本是20.14.0，追求稳定性如服务器上长期运行的Node环境可以选择LTS版本，本地开发和测试可以选择最新版本。</p>
<p>要安装Node.js，首先，从<a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js官网</a>下载对应平台的安装程序，初学者建议选择Prebuilt Installer，选择版本，再选操作系统，最后选CPU类型后点Download下载：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/install/install-node.png" alt="download"></p>
<p>有经验的开发者可以选择Package Manager，它允许本地安装多个不同版本的Node并切换至不同版本。</p>
<p>在Windows上安装时务必选择全部组件，包括勾选<code>Add to Path</code>。</p>
<p>安装完成后，在Windows环境下，请打开命令提示符，然后输入<code>node -v</code>，如果安装正常，你应该看到<code>v22.3.0</code>这样的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\IEUser&gt; node -v</span><br><span class="line">v22.3.0</span><br></pre></td></tr></table></figure>
<p>继续在命令提示符输入<code>node</code>，此刻你将进入Node.js的交互环境。在交互环境下，你可以输入任意JavaScript语句，例如<code>100+200</code>，回车后将得到输出结果。</p>
<p>要退出Node.js环境，连按两次Ctrl+C。</p>
<h3 id="npm">npm</h3>
<p>在正式开始Node.js学习之前，我们先认识一下npm。</p>
<p>npm是什么东东？npm其实是Node.js的包管理工具（package manager）。</p>
<p>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
<p>讲了这么多，npm究竟在哪？</p>
<p>其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入<code>npm -v</code>，应该看到类似的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;npm -v</span><br><span class="line">10.8.0</span><br></pre></td></tr></table></figure>
<p>如果直接输入<code>npm</code>，你会看到类似下面的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; npm</span><br><span class="line"></span><br><span class="line">Usage: npm &lt;command&gt;</span><br><span class="line"></span><br><span class="line">where &lt;command&gt; is one of:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>上面的一大堆文字告诉你，<code>npm</code>需要跟上命令。现在我们不用关心这些命令，后面会一一讲到。目前，你只需要确保npm正确安装了，能运行就行。</p>
<h3 id="小结">小结</h3>
<p>请在本机安装Node.js环境，并确保<code>node</code>和<code>npm</code>能正常运行。</p>
<p>在前面的所有章节中，我们编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的JavaScript代码将<em>不能</em>在浏览器环境中执行了，而是在Node环境中执行，因此，JavaScript代码将直接在你的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写JavaScript代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>
<p>那么问题来了：文本编辑器到底哪家强？</p>
<p>首先，请注意，<strong>绝对不能用Word和写字板</strong>。Word和写字板保存的不是纯文本文件。如果我们要用记事本来编写JavaScript代码，要务必注意，记事本以UTF-8格式保存文件时，会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果经常会导致程序运行出现莫名其妙的错误。</p>
<p>所以，用记事本写代码时请注意，保存文件时使用ANSI编码，并且暂时不要输入中文。</p>
<p>如果你的电脑上已经安装了<a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a>，也可以用来编写JavaScript代码，注意用UTF-8格式保存。</p>
<p>输入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world.&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>第一行总是写上<code>'use strict';</code>是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。</p>
<p>然后，选择一个目录，例如<code>C:\Workspace</code>，把文件保存为<code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到<code>hello.js</code>所在目录，然后输入以下命令运行这个程序了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node hello.js</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>
<p>也可以保存为别的名字，比如<code>first.js</code>，但是必须要以<code>.js</code>结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有<code>hello.js</code>这个文件，运行<code>node hello.js</code>就会报错：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node hello.js</span><br><span class="line">node:internal/modules/cjs/loader:1227</span><br><span class="line">    throw err;</span><br><span class="line">          ^</span><br><span class="line">Error: Cannot find module &#x27;C:\Workspace\hello.js&#x27;</span><br><span class="line">    at Module._resolveFilename</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>报错的意思就是，没有找到<code>hello.js</code>这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>
<h3 id="命令行模式和Node交互模式">命令行模式和Node交互模式</h3>
<p>请注意区分命令行模式和Node交互模式。</p>
<p>看到类似<code>PS C:\&gt;</code>是在Windows提供的命令行模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt; node hello.js                   │</span><br><span class="line">│Hello, world.                                            │</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt;                                 │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>在命令行模式下，可以执行<code>node</code>进入Node交互式环境，也可以执行<code>node hello.js</code>运行一个<code>.js</code>文件。</p>
<p>看到<code>&gt;</code>是在Node交互式环境下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│Windows PowerShell                                 - □ x │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│Windows PowerShell                                       │</span><br><span class="line">│Copyright (C) Microsoft Corporation. All rights reserved.│</span><br><span class="line">│                                                         │</span><br><span class="line">│PS C:\Users\liaoxuefeng&gt; node                            │</span><br><span class="line">│Welcome to Node.js v22.x.x.                              │</span><br><span class="line">│&gt;                                                        │</span><br><span class="line">│                                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。</p>
<p>此外，在命令行模式运行<code>.js</code>文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。</p>
<p>例如，在Node交互式环境下，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 100 + 200 + 300;</span><br><span class="line">600</span><br></pre></td></tr></table></figure>
<p>直接可以看到结果<code>600</code>。</p>
<p>但是，写一个<code>calc.js</code>的文件，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> + <span class="number">200</span> + <span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<p>然后在命令行模式下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node calc.js</span><br></pre></td></tr></table></figure>
<p>发现什么输出都没有。</p>
<p>这是正常的。想要输出结果，必须自己用<code>console.log()</code>打印出来。把<code>calc.js</code>改造一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100</span> + <span class="number">200</span> + <span class="number">300</span>);</span><br></pre></td></tr></table></figure>
<p>再执行，就可以看到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; node calc.js</span><br><span class="line">600</span><br></pre></td></tr></table></figure>
<h3 id="小结-2">小结</h3>
<p>用文本编辑器写JavaScript程序，然后保存为后缀为<code>.js</code>的文件，就可以用node直接运行这个程序了。</p>
<p>Node的交互模式和直接运行<code>.js</code>文件有什么区别呢？</p>
<p>直接输入<code>node</code>进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行<code>node hello.js</code>文件相当于启动了Node解释器，然后一次性把<code>hello.js</code>文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</p>
<p>在编写JavaScript代码的时候，完全可以一边在文本编辑器里写代码，一边开一个Node交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27’的超大显示器！</p>
<h3 id="参考源码">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/first-node-app/hello.js">hello.js</a></p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/first-node-app/calc.js">calc.js</a></p>
<p>使用文本编辑器来开发Node程序，最大的缺点是效率太低，运行Node程序还需要在命令行单独敲命令。如果还需要调试程序，就更加麻烦了。</p>
<p>所以我们需要一个IDE集成开发环境，让我们能在一个环境里编码、运行、调试，这样就可以大大提升开发效率。</p>
<p>Java的集成开发环境有Eclipse，Intellij idea等，C#的集成开发环境有Visual Studio，那么问题又来了：Node.js的集成开发环境到底哪家强？</p>
<p>考察Node.js的集成开发环境，重点放在启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>
<p>综合考察后，我们隆重向大家推荐Node.js集成开发环境：</p>
<h2 id="Visual-Studio-Code">Visual Studio Code</h2>
<p>Visual Studio Code由微软出品，但它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。</p>
<h3 id="安装Visual-Studio-Code">安装Visual Studio Code</h3>
<p>可以从Visual Studio Code的<a target="_blank" rel="noopener" href="http://code.visualstudio.com/">官方网站</a>下载并安装最新的版本。</p>
<p>安装过程中，请务必钩上以下选项“将“通过Code打开”操作添加到Windows资源管理器目录上下文菜单”：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/install-vscode.png" alt="install-vsc"></p>
<p>这将大大提升将来的操作快捷度。</p>
<h3 id="运行和调试JavaScript">运行和调试JavaScript</h3>
<p>在VS Code中，我们可以非常方便地运行JavaScript文件。</p>
<p>VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。</p>
<p>假设我们在<code>C:\Work\</code>目录下创建了一个<code>hello</code>目录作为工程目录，并编写了一个<code>hello.js</code>文件，则该工程目录的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello/        &lt;-- workspace dir</span><br><span class="line">└── hello.js  &lt;-- JavaScript file</span><br></pre></td></tr></table></figure>
<p>启动VS Code，选择菜单File - Open Folder…，选择<code>hello</code>目录，就可以直接编辑<code>hello.js</code>文件：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-edit.png" alt="vscode-edit"></p>
<h3 id="运行JS代码">运行JS代码</h3>
<p>确保当前编辑器正在编辑<code>hello.js</code>文件，然后在VS Code中选择左侧调试按钮，直接点击<code>Run And Debug</code>按钮，如果弹出环境选项则选择<code>Node</code>，在右下侧<code>DEBUG CONSOLE</code>可直接看到运行结果。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-run.png" alt="vscode-run"></p>
<p>如果右下侧面板没有显示，左上角有几个按钮可以切换视图。</p>
<h3 id="调试JS代码">调试JS代码</h3>
<p>在VS Code中，可以通过断点调试方便进行JavaScript的开发和测试。我们先在<code>hello.js</code>的编辑器中打一个断点（鼠标点击行号左侧出现小红点即为断点），然后点击<code>Run And Debug</code>按钮，此时进入调试模式，会自动停在断点处，左侧窗口可查看变量，顶部按钮可选择单步执行或继续执行到下一个断点，也可以随时结束程序：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/vscode-debug.png" alt="vscode-debug"></p>
<p>总的来说，使用VS Code，开发和调试JavaScript代码十分方便。</p>
<h3 id="参考源码-2">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/dev-env/hello.js">hello.js</a></p>
<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。</p>
<p>使用模块有什么好处？</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>
<p>在上一节，我们编写了一个<code>hello.js</code>文件，这个<code>hello.js</code>文件就是一个模块，模块的名字就是文件名（去掉<code>.js</code>后缀），所以<code>hello.js</code>文件就是名为<code>hello</code>的模块。</p>
<p>我们把<code>hello.js</code>改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s + <span class="string">&#x27;, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br></pre></td></tr></table></figure>
<p>函数<code>greet()</code>是我们在<code>hello</code>模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数<code>greet</code>作为模块的输出暴露出去，这样其他模块就可以使用<code>greet</code>函数了。</p>
<p>问题是其他模块怎么使用<code>hello</code>模块的这个<code>greet</code>函数呢？我们再编写一个<code>main.js</code>文件，调用<code>hello</code>模块的<code>greet</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入hello模块:</span></span><br><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(s); <span class="comment">// Hello, Michael!</span></span><br></pre></td></tr></table></figure>
<p>注意到引入<code>hello</code>模块用Node提供的<code>require</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>引入的模块作为变量保存在<code>greet</code>变量中，那<code>greet</code>变量到底是什么东西？其实变量<code>greet</code>就是在<code>hello.js</code>中我们用<code>module.exports = greet;</code>输出的<code>greet</code>函数。所以，<code>main.js</code>就成功地引用了<code>hello.js</code>模块中定义的<code>greet()</code>函数，接下来就可以直接使用它了。</p>
<p>在使用<code>require()</code>引入模块的时候，请注意模块的相对路径。因为<code>main.js</code>和<code>hello.js</code>位于同一个目录，所以我们用了当前目录<code>.</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>); <span class="comment">// 不要忘了写相对目录!</span></span><br></pre></td></tr></table></figure>
<p>如果只写模块名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>则Node会依次在内置模块、全局模块和当前模块下查找<code>hello.js</code>，你很可能会得到一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">js</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">          ^</span><br><span class="line"><span class="title class_">Error</span>: <span class="title class_">Cannot</span> find <span class="variable language_">module</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    at <span class="title class_">Module</span>.<span class="property">_resolveFilename</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>遇到这个错误，你要检查：</p>
<ul>
<li>模块名是否写对了；</li>
<li>模块文件是否存在；</li>
<li>相对路径是否写对了。</li>
</ul>
<h3 id="CommonJS规范">CommonJS规范</h3>
<p>这种模块加载机制被称为CommonJS规范。在这个规范下，每个<code>.js</code>文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code>和<code>main.js</code>都申明了全局变量<code>var s = 'xxx'</code>，但互不影响。</p>
<p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require('module_name');</code>就拿到了引用模块的变量。</p>
<h3 id="结论">结论</h3>
<p>要在模块中对外输出变量，用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = variable;</span><br></pre></td></tr></table></figure>
<p>输出的变量可以是任意对象、函数、数组等等。</p>
<p>要引入其他模块输出的对象，用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;other_module&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>引入的对象具体是什么，取决于引入模块输出的对象。</p>
<h3 id="深入了解模块原理">深入了解模块原理</h3>
<p>如果你想详细地了解CommonJS的模块实现原理，请继续往下阅读。如果不想了解，请直接跳到最后做练习。</p>
<p>当我们编写JavaScript代码时，我们可以申明全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;global&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在浏览器中，大量使用全局变量可不好。如果你在<code>a.js</code>中使用了全局变量<code>s</code>，那么，在<code>b.js</code>中也使用全局变量<code>s</code>，将造成冲突，<code>b.js</code>中对<code>s</code>赋值会改变<code>a.js</code>的运行逻辑。</p>
<p>也就是说，在ESM标准之前，JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>
<p>那Node.js是如何实现这一点的？</p>
<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>
<p>请注意我们编写的<code>hello.js</code>代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s + <span class="string">&#x27; &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>Node.js加载了<code>hello.js</code>后，它可以把代码包装一下，变成这样执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 读取的hello.js代码:</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s + <span class="string">&#x27; &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="comment">// hello.js代码结束</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这样一来，原来的全局变量<code>s</code>现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量<code>s</code>也互不干扰。</p>
<p>所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>但是，模块的输出<code>module.exports</code>怎么实现？</p>
<p>这个也很容易实现，Node可以先准备一个对象<code>module</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备module对象:</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> load = <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 读取的hello.js代码:</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br><span class="line">    <span class="comment">// hello.js代码结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> exported = <span class="title function_">load</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="comment">// 保存module:</span></span><br><span class="line"><span class="title function_">save</span>(<span class="variable language_">module</span>, exported);</span><br></pre></td></tr></table></figure>
<p>可见，变量<code>module</code>是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在<code>hello.js</code>中可以直接使用变量<code>module</code>原因就在于它实际上是函数的一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br></pre></td></tr></table></figure>
<p>通过把参数<code>module</code>传递给<code>load()</code>函数，<code>hello.js</code>就顺利地把一个变量传递给了Node执行环境，Node会把<code>module</code>变量保存到某个地方。</p>
<p>由于Node保存了所有导入的<code>module</code>，当我们用<code>require()</code>获取module时，Node找到对应的<code>module</code>，把这个<code>module</code>的<code>exports</code>变量返回，这样，另一个模块就顺利拿到了模块的输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="built_in">require</span>(<span class="string">&#x27;./hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以上是Node实现JavaScript模块的一个简单的原理介绍。</p>
<h3 id="module-exports-vs-exports">module.exports vs exports</h3>
<p>很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：</p>
<p>方法一：对module.exports赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">hello</span>: hello,</span><br><span class="line">    <span class="attr">greet</span>: greet</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：直接使用exports：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">hello</span> = hello;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">greet</span> = greet;</span><br></pre></td></tr></table></figure>
<p>但是你不可以直接对<code>exports</code>赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码可以执行，但是模块并没有输出任何变量:</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">    <span class="attr">hello</span>: hello,</span><br><span class="line">    <span class="attr">greet</span>: greet</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：</p>
<p>首先，Node会把整个待加载的<code>hello.js</code>文件放入一个包装函数<code>load</code>中执行。在执行这个<code>load()</code>函数前，Node准备好了module变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>load()</code>函数最终返回<code>module.exports</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> load = <span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">// hello.js的文件内容</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// load函数返回:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> exported = <span class="title function_">load</span>(<span class="variable language_">module</span>.<span class="property">exports</span>, <span class="variable language_">module</span>);</span><br></pre></td></tr></table></figure>
<p>也就是说，默认情况下，Node准备的<code>exports</code>变量和<code>module.exports</code>变量实际上是同一个变量，并且初始化为空对象<code>&#123;&#125;</code>，于是，我们可以写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bar</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>也可以写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">foo</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">bar</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>换句话说，Node默认给你准备了一个空对象<code>&#123;&#125;</code>，这样你可以直接往里面加东西。</p>
<p>但是，如果我们要输出的是一个函数或数组，那么，只能给<code>module.exports</code>赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>给<code>exports</code>赋值是无效的，因为赋值后，<code>module.exports</code>仍然是空对象<code>&#123;&#125;</code>。</p>
<h3 id="结论-2">结论</h3>
<p>如果要输出一个键值对象<code>&#123;&#125;</code>，可以利用<code>exports</code>这个已存在的空对象<code>&#123;&#125;</code>，并继续在上面添加新的键值；</p>
<p>如果要输出一个函数或数组，必须直接对<code>module.exports</code>对象赋值。</p>
<p>所以我们可以得出结论：直接对<code>module.exports</code>赋值，可以应对任何情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>最终，我们<em>强烈建议</em>使用<code>module.exports = xxx</code>的方式来输出模块变量，这样，你只需要记忆一种方法。</p>
<h3 id="练习">练习</h3>
<p>编写<code>hello.js</code>，输出一个或多个函数；</p>
<p>编写<code>main.js</code>，引入<code>hello</code>模块，调用其函数。</p>
<h3 id="参考源码-3">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/module/hello.zip">module</a></p>
<p>虽然Node.js从诞生起就支持模块，但JavaScript语言本身长期以来却一直没有模块功能，只能由CommonJS或其他AMD等模块系统来“模拟”。</p>
<p>随着ES 6标准的推出，JavaScript语言本身终于也迎来了原生内置的模块支持，称为ECMAScript Modules（简称ESM），不仅可以直接在浏览器中使用模块，也可以在Node.js中使用ESM模块。</p>
<p>不使用ESM模块时，我们用<code>module.exports</code>导出可供外部使用的JS对象，例如，以下模块导出了两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params">prompt, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prompt&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(s, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(<span class="string">&#x27;Hi&#x27;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">greet</span>: greet,</span><br><span class="line">    <span class="attr">hi</span>: hi</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要把上述代码改为ESM模块，我们用<code>export</code>标识需要导出的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out是模块内部函数，模块外部不可见:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params">prompt, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prompt&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// greet是导出函数，可被外部调用:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(s, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi是导出函数，可被外部调用:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">hi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title function_">out</span>(<span class="string">&#x27;Hi&#x27;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并将其保存为<code>hello.mjs</code>文件，注意扩展名不是<code>.js</code>，而是<code>.mjs</code>。</p>
<p>可以再编写一个<code>main.mjs</code>文件来调用<code>hello</code>模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; greet, hi &#125; <span class="keyword">from</span> <span class="string">&#x27;./hello.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"><span class="title function_">greet</span>(name);</span><br><span class="line"><span class="title function_">hi</span>(name);</span><br></pre></td></tr></table></figure>
<p>可见，ESM模块用<code>export</code>关键字导出一个JS对象，用<code>import</code>关键字导入一个模块的导出对象。</p>
<p>如果要实现类似如下代码的单个函数导出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = greet;</span><br></pre></td></tr></table></figure>
<p>则可以用<code>export default</code>导出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的，导入代码修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> greet <span class="keyword">from</span> <span class="string">&#x27;./hello.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>细心的同学还注意到ESM模块文件第一行并没有<code>'use strict'</code>，这是因为ESM模块默认启用严格模式，因此无需再手动声明<code>'use strict'</code>。</p>
<h3 id="浏览器加载ESM">浏览器加载ESM</h3>
<p>对于浏览器来说，也可以直接使用ESM模块。当我们加载一个ESM模块时，需要用<code>type=&quot;module&quot;</code>来表示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">greet</span>(<span class="string">&#x27;Bob&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者直接使用<code>import</code>加载一个模块：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">import</span> &#123; greet &#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">greet</span>(<span class="string">&#x27;Bob&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="练习-2">练习</h3>
<p>在Node环境中使用ESM模块：</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/esm/esm.zip">下载练习</a></p>
<h3 id="小结-3">小结</h3>
<p>使用JavaScript内置的原生模块时，用关键字<code>export</code>和<code>import</code>来实现导出与导入；</p>
<p>ESM模块默认启用strict模式，无需声明<code>'use strict'</code>。</p>
<p>因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。</p>
<h3 id="global">global</h3>
<p>在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫<code>window</code>对象。而在Node.js环境中，也有唯一的全局对象，但不叫<code>window</code>，而叫<code>global</code>，这个对象的属性和方法也和浏览器环境的<code>window</code>不同。进入Node.js交互环境，可以直接输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; global.console</span><br><span class="line">Object [console] &#123;</span><br><span class="line">  log: [Function: log],</span><br><span class="line">  warn: [Function: warn],</span><br><span class="line">  dir: [Function: dir],</span><br><span class="line">  time: [Function: time],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="process">process</h3>
<p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。通过<code>process</code>对象可以拿到许多有用信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; process === global.process;</span><br><span class="line">true</span><br><span class="line">&gt; process.version;</span><br><span class="line">&#x27;v22.3.0&#x27;</span><br><span class="line">&gt; process.platform;</span><br><span class="line">&#x27;darwin&#x27;</span><br><span class="line">&gt; process.arch;</span><br><span class="line">&#x27;x64&#x27;</span><br><span class="line">&gt; process.cwd(); //返回当前工作目录</span><br><span class="line">&#x27;/Users/michael&#x27;</span><br><span class="line">&gt; process.chdir(&#x27;/private/tmp&#x27;); // 切换当前工作目录</span><br><span class="line">undefined</span><br><span class="line">&gt; process.cwd();</span><br><span class="line">&#x27;/private/tmp&#x27;</span><br></pre></td></tr></table></figure>
<p>JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。</p>
<p>如果我们想要在下一次事件响应中执行代码，可以调用<code>process.nextTick()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="comment">// process.nextTick()将在下一轮事件循环中调用:</span></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick callback!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick was set!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>用Node执行上面的代码<code>node test.js</code>，你会看到，打印输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nextTick was set!</span><br><span class="line">nextTick callback!</span><br></pre></td></tr></table></figure>
<p>这说明传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>
<p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序即将退出时的回调函数:</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="keyword">function</span> (<span class="params">code</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;about to exit with code: &#x27;</span> + code);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="判断JavaScript执行环境">判断JavaScript执行环境</h3>
<p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">typeof</span>(<span class="variable language_">window</span>) === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;node.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;browser&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="导入Node模块">导入Node模块</h3>
<p>Node内置了许多模块，可以从Node.js的<a target="_blank" rel="noopener" href="https://nodejs.org/api/">在线文档</a>查询所有模块信息。</p>
<p>以<code>crypto</code>模块的<code>randomInt()</code>函数为例，导入模块有两种方法：</p>
<p>方法一：使用传统的<code>require()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; randomInt &#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">randomInt</span>(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 0~100之间的随机数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br></pre></td></tr></table></figure>
<p>方法二：使用<code>import</code>关键字导入ESM模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; randomInt &#125; <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">randomInt</span>(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 0~100之间的随机数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br></pre></td></tr></table></figure>
<p>后面，我们将介绍Node.js的常用内置模块。</p>
<p>Node.js内置的<code>fs</code>模块就是文件系统模块，负责读写文件。</p>
<p>和所有其它JavaScript模块不同的是，<code>fs</code>模块同时提供了异步和同步的方法。</p>
<p>回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的<code>getJSON()</code>操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(<span class="string">&#x27;http://example.com/ajax&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;IO结果返回后执行...&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不等待IO结果直接执行后续代码...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>而同步的IO操作则需要等待函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据网络耗时，函数将执行几十毫秒~几秒不等:</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="title function_">getJSONSync</span>(<span class="string">&#x27;http://example.com/ajax&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。</p>
<h3 id="异步读文件">异步读文件</h3>
<p>按照JavaScript的标准，异步读取一个文本文件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-text-file-async.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BEGIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;END&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>请注意，<code>sample.txt</code>文件必须在当前目录下，且文件编码为<code>utf-8</code>。</p>
<p>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。</p>
<p>由于<code>err</code>是否为<code>null</code>就是判断是否出错的标志，所以通常的判断逻辑总是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 出错了</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码，可以看到打印的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; BEGIN &gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; END &gt;&gt;&gt;</span><br><span class="line">Sample file content...</span><br></pre></td></tr></table></figure>
<p>因为异步读取，所以，先打印<code>END</code>后，才会执行回调函数，打印文件内容。</p>
<p>如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？</p>
<p>下面的例子演示了如何读取一个图片文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;sample.png&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>); <span class="comment">// true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// Buffer(12451) [137, 80, 78, 71, 13, ...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。</p>
<p><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffer -&gt; String</span></span><br><span class="line"><span class="keyword">let</span> text = data.<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br></pre></td></tr></table></figure>
<p>或者把一个String转换成<code>Buffer</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; Buffer</span></span><br><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(text, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);</span><br></pre></td></tr></table></figure>
<h3 id="同步读文件">同步读文件</h3>
<p>除了标准的异步读取模式外，<code>fs</code>也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</p>
<p>用<code>fs</code>模块同步读取一个文本文件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-text-file-sync.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BEGIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="title function_">readFileSync</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;END&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>可见，原异步调用的回调函数的<code>data</code>被函数直接返回，函数名需要改为<code>readFileSync</code>，其它参数不变。</p>
<p>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误。</p>
<h3 id="写文件">写文件</h3>
<p>将数据写入文件是通过<code>fs.writeFile()</code>实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write-file-async.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; writeFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">&#x27;Hello, Node.js&#x27;</span>;</span><br><span class="line"><span class="title function_">writeFile</span>(<span class="string">&#x27;output.txt&#x27;</span>, data, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>writeFile()</code>的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是<code>Buffer</code>，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个<code>err</code>参数。</p>
<p>和<code>readFile()</code>类似，<code>writeFile()</code>也有一个同步方法，叫<code>writeFileSync()</code>。</p>
<h3 id="stat">stat</h3>
<p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-stat-async.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">stat</span>(<span class="string">&#x27;sample.png&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, st</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是否是文件:</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isFile: &#x27;</span> + st.<span class="title function_">isFile</span>());</span><br><span class="line">        <span class="comment">// 是否是目录:</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isDirectory: &#x27;</span> + st.<span class="title function_">isDirectory</span>());</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">            <span class="comment">// 文件大小:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;size: &#x27;</span> + st.<span class="property">size</span>);</span><br><span class="line">            <span class="comment">// 创建时间, Date对象:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;birth time: &#x27;</span> + st.<span class="property">birthtime</span>);</span><br><span class="line">            <span class="comment">// 修改时间, Date对象:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;modified time: &#x27;</span> + st.<span class="property">mtime</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isFile: true</span><br><span class="line">isDirectory: false</span><br><span class="line">size: 12451</span><br><span class="line">birth time: Mon Jun 17 2024 19:37:24 GMT+0800 (China Standard Time)</span><br><span class="line">modified time: Mon Jun 17 2024 19:37:24 GMT+0800 (China Standard Time)</span><br></pre></td></tr></table></figure>
<p><code>stat()</code>也有一个对应的同步函数<code>statSync()</code>，请试着改写上述异步代码为同步代码。</p>
<h3 id="使用Promise">使用Promise</h3>
<p>我们在介绍JavaScript的<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/browser/promise/index.html">Promise</a>时，讲到通过<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/browser/async/index.html">async</a>函数实现异步逻辑，代码更简单。</p>
<p>类似的，Node还提供Promise版本的fs，可以用如下代码在async函数中读取文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async-read.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readTextFile</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">readFile</span>(path, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readTextFile</span>(<span class="string">&#x27;sample.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">s</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(s));</span><br></pre></td></tr></table></figure>
<p>在async函数中，用await调用<code>fs/promises</code>与同步方法类似，但代码却是异步执行的。</p>
<h3 id="异步还是同步">异步还是同步</h3>
<p>在<code>fs</code>模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？</p>
<p>由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，<em>必须使用异步代码</em>，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。</p>
<p>服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。</p>
<p>如果代码中编写了大量的async函数，那么通过await异步调用<code>fs/promises</code>模块更加方便。</p>
<h3 id="参考源码-4">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/fs/fs.zip">fs</a></p>
<p><code>stream</code>是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。</p>
<p>什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>
<p>如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/stream/std.png" alt="stream"></p>
<p>有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。</p>
<p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>
<p>下面是一个从文件流读取文本内容的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createReadStream &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开流:</span></span><br><span class="line"><span class="keyword">let</span> rs = <span class="title function_">createReadStream</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取到数据:</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---- chunk ----&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束读取:</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---- end ----&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错:</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要注意，<code>data</code>事件可能会有多次，每次传递的<code>chunk</code>是流的一部分数据。</p>
<p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createWriteStream &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ws = <span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;使用Stream写入文本数据...\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;继续写入...\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;DONE.\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">end</span>(); <span class="comment">// 结束写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入二进制数据:</span></span><br><span class="line"><span class="keyword">let</span> b64array = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ws2 = <span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.png&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b64 <span class="keyword">of</span> b64array) &#123;</span><br><span class="line">    <span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(b64, <span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line">    ws2.<span class="title function_">write</span>(buf); <span class="comment">// 写入Buffer对象</span></span><br><span class="line">&#125;</span><br><span class="line">ws2.<span class="title function_">end</span>(); <span class="comment">// 结束写入</span></span><br></pre></td></tr></table></figure>
<p>所有可以读取数据的流都继承自<code>stream.Readable</code>，所有可以写入的流都继承自<code>stream.Writable</code>。</p>
<h3 id="pipe">pipe</h3>
<p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。</p>
<p>在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.<span class="title function_">pipe</span>(ws);</span><br></pre></td></tr></table></figure>
<p>除了直接使用<code>pipe()</code>方法，Node还提供了<code>pipeline</code>功能，它可以将一个流输出到另一个流。以下是一个复制文件的程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createReadStream, createWriteStream &#125; <span class="keyword">from</span> <span class="string">&quot;node:fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; pipeline &#125; <span class="keyword">from</span> <span class="string">&#x27;node:stream/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">src, dest</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rs = <span class="title function_">createReadStream</span>(src);</span><br><span class="line">    <span class="keyword">let</span> ws = <span class="title function_">createWriteStream</span>(dest);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">pipeline</span>(rs, ws);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">copy</span>(<span class="string">&#x27;sample.txt&#x27;</span>, <span class="string">&#x27;output.txt&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;copied.&#x27;</span>))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br></pre></td></tr></table></figure>
<p>使用<code>pipeline</code>的好处是，它可以添加若干个转换器，即输入流经过若干转换后，再进入输出流。如果我们添加的转换器实现了gzip功能，那么实际上就可以把输入流自动压缩后进入输出流。</p>
<h3 id="参考源码-5">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/stream/stream.zip">stream</a></p>
<p>Node.js开发的目的就是为了用JavaScript编写Web服务器程序。因为JavaScript实际上已经统治了浏览器端的脚本，其优势就是有世界上数量最多的前端开发人员。如果已经掌握了JavaScript前端开发，再学习一下如何将JavaScript应用在后端开发，就是名副其实的<em>全栈</em>了。</p>
<h3 id="HTTP协议">HTTP协议</h3>
<p>要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。如果你对HTTP协议不太熟悉，先看一看<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/web/http/index.html">HTTP协议简介</a>。</p>
<h3 id="HTTP服务器">HTTP服务器</h3>
<p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的<code>http</code>模块完成了。应用程序并不直接和HTTP协议打交道，而是操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>
<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；</p>
<p><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>
<p>用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;node:http&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调函数接收request和response对象,</span></span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">method</span> + <span class="string">&#x27;: &#x27;</span> + request.<span class="property">url</span>);</span><br><span class="line">    <span class="comment">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;Hello world!&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错时返回400:</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientError&#x27;</span>, <span class="function">(<span class="params">err, socket</span>) =&gt;</span> &#123;</span><br><span class="line">  socket.<span class="title function_">end</span>(<span class="string">&#x27;HTTP/1.1 400 Bad Request\r\n\r\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>在命令提示符下运行该程序，可以看到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node simple-server.mjs </span><br><span class="line">Server is running at http://127.0.0.1:8080/</span><br></pre></td></tr></table></figure>
<p>不要关闭命令提示符，直接打开浏览器输入<code>http://localhost:8080</code>，即可看到服务器响应的内容：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/http-page.png" alt="http-page"></p>
<p>同时，在命令提示符窗口，可以看到程序打印的请求信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET: /</span><br><span class="line">GET: /favicon.ico</span><br></pre></td></tr></table></figure>
<p>这就是我们编写的第一个HTTP服务器程序！</p>
<h3 id="文件服务器">文件服务器</h3>
<p>让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>
<p>观察打印的<code>request.url</code>，它实际上是浏览器请求的路径和参数，如：</p>
<ul>
<li><code>/</code></li>
<li><code>/index.html</code></li>
<li><code>/hello?name=bob</code></li>
</ul>
<p>解析出path部分可以直接用URL对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;http://localost&#x27;</span> + <span class="string">&#x27;/index.html?v=1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> pathname = url.<span class="property">pathname</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathname); <span class="comment">// index.html</span></span><br></pre></td></tr></table></figure>
<p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;node:path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析当前目录:</span></span><br><span class="line"><span class="keyword">let</span> workDir = path.<span class="title function_">resolve</span>(<span class="string">&#x27;.&#x27;</span>); <span class="comment">// &#x27;/Users/michael&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合完整的文件路径:当前目录+&#x27;pub&#x27;+&#x27;index.html&#x27;:</span></span><br><span class="line"><span class="keyword">let</span> filePath = path.<span class="title function_">join</span>(workDir, <span class="string">&#x27;pub&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;/Users/michael/pub/index.html&#x27;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>path</code>模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于<code>C:\Users\michael\static\index.html</code>，这样，我们就不关心怎么拼接路径了。</p>
<p>最后，我们实现一个文件服务器<code>simple-file-server.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块:</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;node:http&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;node:path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createReadStream &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; stat &#125; <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定www根目录为当前目录:</span></span><br><span class="line"><span class="keyword">const</span> wwwRoot = path.<span class="title function_">resolve</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set www root: <span class="subst">$&#123;wwwRoot&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据扩展名确定MIME类型:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">guessMime</span>(<span class="params">pathname</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http file server，并传入回调函数:</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">method</span> + <span class="string">&#x27;: &#x27;</span> + request.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">method</span> !== <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">        response.<span class="title function_">writeHead</span>(<span class="number">400</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解析path: </span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">`http://localhost<span class="subst">$&#123;request.url&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> pathname = url.<span class="property">pathname</span>;</span><br><span class="line">        <span class="keyword">let</span> filepath = path.<span class="title function_">join</span>(wwwRoot, pathname);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 必要的安全检查</span></span><br><span class="line">        <span class="comment">// 检查文件状态:</span></span><br><span class="line">        <span class="title function_">stat</span>(filepath).<span class="title function_">then</span>(<span class="function"><span class="params">st</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;200 OK&#x27;</span>);</span><br><span class="line">                <span class="comment">// 发送200响应:</span></span><br><span class="line">                response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="title function_">guessMime</span>(pathname) &#125;);</span><br><span class="line">                <span class="comment">// 将文件流导向response:</span></span><br><span class="line">                <span class="title function_">createReadStream</span>(filepath).<span class="title function_">pipe</span>(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;404 Not Found&#x27;</span>);</span><br><span class="line">                response.<span class="title function_">writeHead</span>(<span class="number">404</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">                response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;404 Not Found&#x27;</span>);</span><br><span class="line">            response.<span class="title function_">writeHead</span>(<span class="number">404</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">            response.<span class="title function_">end</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错时返回400:</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;clientError&#x27;</span>, <span class="function">(<span class="params">err, socket</span>) =&gt;</span> &#123;</span><br><span class="line">    socket.<span class="title function_">end</span>(<span class="string">&#x27;HTTP/1.1 400 Bad Request\r\n\r\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让服务器监听8080端口:</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at http://127.0.0.1:8080/&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>没有必要手动读取文件内容。由于<code>response</code>对象本身是一个<code>Writable Stream</code>，直接用<code>pipe()</code>方法就实现了自动读取文件内容并输出到HTTP响应。</p>
<p>在命令行运行<code>node simple-file-server.mjs</code>，然后在浏览器中输入<code>http://localhost:8080/index.html</code>：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/http-index.png" alt="http-index-page"></p>
<p>只要当前目录下存在文件<code>index.html</code>，服务器就可以把文件内容发送给浏览器。观察控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET: /index.html</span><br><span class="line">200 OK</span><br><span class="line">GET: /next/hello.png</span><br><span class="line">200 OK</span><br><span class="line">GET: /favicon.ico</span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure>
<p>第一个请求是浏览器请求<code>/</code>页面，后续请求是浏览器解析HTML后发送的其它资源请求。</p>
<h3 id="练习-3">练习</h3>
<p>在浏览器输入<code>http://localhost:8080/</code>时，会返回404，原因是程序识别出HTTP请求的不是文件，而是目录。请修改<code>simple-file-server.mjs</code>，如果遇到请求的路径是目录，则自动在目录下依次搜索<code>index.html</code>、<code>default.html</code>，如果找到了，就返回HTML文件的内容。</p>
<h3 id="参考源码-6">参考源码</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/simple-server.mjs">简单HTTP服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/http/simple-file-server.zip">HTTP文件服务器</a></li>
</ul>
<p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>
<h3 id="MD5和SHA1">MD5和SHA1</h3>
<p>MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hash = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可任意多次调用update():</span></span><br><span class="line">hash.<span class="title function_">update</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">hash.<span class="title function_">update</span>(<span class="string">&#x27;Hello, nodejs!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>)); <span class="comment">// 7e1977739c748beac0c0fd14fd26a544</span></span><br></pre></td></tr></table></figure>
<p><code>update()</code>方法默认字符串编码为<code>UTF-8</code>，也可以传入Buffer。</p>
<p>如果要计算SHA1，只需要把<code>'md5'</code>改成<code>'sha1'</code>，就可以得到SHA1的结果。还可以使用更安全的<code>sha256</code>和<code>sha512</code>。</p>
<h3 id="Hmac">Hmac</h3>
<p>Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hmac = crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha256&#x27;</span>, <span class="string">&#x27;secret-key&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hmac.<span class="title function_">update</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">hmac.<span class="title function_">update</span>(<span class="string">&#x27;Hello, nodejs!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hmac.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>)); <span class="comment">// 80f7e22570...</span></span><br></pre></td></tr></table></figure>
<p>只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。</p>
<h3 id="AES">AES</h3>
<p>AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">aes_encrypt</span>(<span class="params">key, iv, msg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cipher = crypto.<span class="title function_">createCipheriv</span>(<span class="string">&#x27;aes-256-cbc&#x27;</span>, key, iv);</span><br><span class="line">    <span class="comment">// input encoding: utf8</span></span><br><span class="line">    <span class="comment">// output encoding: hex</span></span><br><span class="line">    <span class="keyword">let</span> encrypted = cipher.<span class="title function_">update</span>(msg, <span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    encrypted += cipher.<span class="title function_">final</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">aes_decrypt</span>(<span class="params">key, iv, encrypted</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.<span class="title function_">createDecipheriv</span>(<span class="string">&#x27;aes-256-cbc&#x27;</span>, key, iv);</span><br><span class="line">    <span class="keyword">let</span> decrypted = decipher.<span class="title function_">update</span>(encrypted, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    decrypted += decipher.<span class="title function_">final</span>(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> decrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key的长度必须为32bytes:</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&#x27;Passw0rdPassw0rdPassw0rdPassw0rd&#x27;</span>;</span><br><span class="line"><span class="comment">// iv的长度必须为16bytes:</span></span><br><span class="line"><span class="keyword">let</span> iv = <span class="string">&#x27;a1b2c3d4e5f6g7h8&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="comment">// 加密:</span></span><br><span class="line"><span class="keyword">let</span> encrypted_msg = <span class="title function_">aes_encrypt</span>(key, iv, msg);</span><br><span class="line"><span class="comment">// 解密:</span></span><br><span class="line"><span class="keyword">let</span> decrypted_msg = <span class="title function_">aes_decrypt</span>(key, iv, encrypted_msg);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`AES encrypt: <span class="subst">$&#123;encrypted_msg&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`AES decrypt: <span class="subst">$&#123;decrypted_msg&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AES encrypt: 11cd65e5fe7e7448b491efabee2f326a</span><br><span class="line">AES decrypt: Hello, world!</span><br></pre></td></tr></table></figure>
<p>可以看出，加密后的字符串通过解密又得到了原始内容。</p>
<p>注意到AES有很多不同的算法，如<code>aes192</code>，<code>aes-128-ecb</code>，<code>aes-256-cbc</code>等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Node.js全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。</p>
<h3 id="Diffie-Hellman">Diffie-Hellman</h3>
<p>DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做：</p>
<ol>
<li>小明先选一个素数和一个底数，例如，素数<code>p=97</code>，底数<code>g=5</code>（底数是p的一个原根），再选择一个秘密整数<code>a=123</code>，计算<code>A=g^a mod p=34</code>，然后大声告诉小红：<code>p=97，g=5，A=34</code>；</li>
<li>小红收到小明发来的<code>p</code>，<code>g</code>，<code>A</code>后，也选一个秘密整数<code>b=456</code>，然后计算<code>B=g^b mod p=75</code>，并大声告诉小明：<code>B=75</code>；</li>
<li>小明自己计算出<code>s=B^a mod p=22</code>，小红也自己计算出<code>s=A^b mod p=22</code>，因此，最终协商的密钥<code>s</code>为<code>22</code>。</li>
</ol>
<p>在这个过程中，密钥<code>22</code>并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道<code>p=97</code>，<code>g=5</code>，<code>A=34</code>，<code>B=75</code>，由于不知道双方选的秘密整数<code>a=123</code>和<code>b=456</code>，因此无法计算出密钥<code>22</code>。</p>
<p>用crypto模块实现DH算法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xiaoming&#x27;s keys:</span></span><br><span class="line"><span class="keyword">let</span> ming = crypto.<span class="title function_">createDiffieHellman</span>(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">let</span> ming_keys = ming.<span class="title function_">generateKeys</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prime = ming.<span class="title function_">getPrime</span>();</span><br><span class="line"><span class="keyword">let</span> generator = ming.<span class="title function_">getGenerator</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Prime: &#x27;</span> + prime.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generator: &#x27;</span> + generator.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// xiaohong&#x27;s keys:</span></span><br><span class="line"><span class="keyword">let</span> hong = crypto.<span class="title function_">createDiffieHellman</span>(prime, generator);</span><br><span class="line"><span class="keyword">let</span> hong_keys = hong.<span class="title function_">generateKeys</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// exchange and generate secret:</span></span><br><span class="line"><span class="keyword">let</span> ming_secret = ming.<span class="title function_">computeSecret</span>(hong_keys);</span><br><span class="line"><span class="keyword">let</span> hong_secret = hong.<span class="title function_">computeSecret</span>(ming_keys);</span><br><span class="line"></span><br><span class="line"><span class="comment">// print secret:</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Secret of Xiao Ming: &#x27;</span> + ming_secret.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Secret of Xiao Hong: &#x27;</span> + hong_secret.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>运行后，可以得到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Prime: a8224c...deead3</span><br><span class="line">Generator: 02</span><br><span class="line">Secret of Xiao Ming: 695308...d519be</span><br><span class="line">Secret of Xiao Hong: 695308...d519be</span><br></pre></td></tr></table></figure>
<p>注意每次输出都不一样，因为素数的选择是随机的。</p>
<h3 id="RSA">RSA</h3>
<p>RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。</p>
<p>RSA算法是1977年由Ron Rivest、Adi Shamir和Leonard Adleman共同提出的，所以以他们三人的姓氏的头字母命名。</p>
<p>当小明给小红发送信息时，可以用小明自己的私钥加密，小红用小明的公钥解密，也可以用小红的公钥加密，小红用她自己的私钥解密，这就是非对称加密。相比对称加密，非对称加密只需要每个人各自持有自己的私钥，同时公开自己的公钥，不需要像AES那样由两个人共享同一个密钥。</p>
<p>在使用Node进行RSA加密前，我们先要准备好私钥和公钥。</p>
<p>首先，在命令行执行以下命令以生成一个RSA密钥对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -aes256 -out rsa-key.pem 2048</span><br></pre></td></tr></table></figure>
<p>根据提示输入密码，这个密码是用来加密RSA密钥的，加密方式指定为AES256，生成的RSA的密钥长度是2048位。执行成功后，我们获得了加密的<code>rsa-key.pem</code>文件。</p>
<p>第二步，通过上面的<code>rsa-key.pem</code>加密文件，我们可以导出原始的私钥，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem</span><br></pre></td></tr></table></figure>
<p>输入第一步的密码，我们获得了解密后的私钥。</p>
<p>类似的，我们用下面的命令导出原始的公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem</span><br></pre></td></tr></table></figure>
<p>这样，我们就准备好了原始私钥文件<code>rsa-prv.pem</code>和原始公钥文件<code>rsa-pub.pem</code>，编码格式均为PEM。</p>
<p>下面，使用<code>crypto</code>模块提供的方法，即可实现非对称加解密。</p>
<p>首先，我们用私钥加密，公钥解密：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">&#x27;node:crypto&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件加载key:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadKey</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="comment">// key实际上就是PEM编码的字符串:</span></span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">readFileSync</span>(file, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span></span><br><span class="line">    prvKey = <span class="title function_">loadKey</span>(<span class="string">&#x27;./rsa-prv.pem&#x27;</span>),</span><br><span class="line">    pubKey = <span class="title function_">loadKey</span>(<span class="string">&#x27;./rsa-pub.pem&#x27;</span>),</span><br><span class="line">    message = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥加密:</span></span><br><span class="line"><span class="keyword">let</span> enc_by_prv = crypto.<span class="title function_">privateEncrypt</span>(prvKey, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(message, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(enc_by_prv.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dec_by_pub = crypto.<span class="title function_">publicDecrypt</span>(pubKey, enc_by_prv);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dec_by_pub.<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>执行后，可以得到解密后的消息，与原始消息相同。</p>
<p>接下来我们使用公钥加密，私钥解密：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用公钥加密:</span></span><br><span class="line"><span class="keyword">let</span> enc_by_pub = crypto.<span class="title function_">publicEncrypt</span>(pubKey, <span class="title class_">Buffer</span>.<span class="title function_">from</span>(message, <span class="string">&#x27;utf8&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(enc_by_pub.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥解密:</span></span><br><span class="line"><span class="keyword">let</span> dec_by_prv = crypto.<span class="title function_">privateDecrypt</span>(prvKey, enc_by_pub);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dec_by_prv.<span class="title function_">toString</span>(<span class="string">&#x27;utf8&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>执行得到的解密后的消息仍与原始消息相同。</p>
<p>如果我们把<code>message</code>字符串的长度增加到很长，例如1M，这时，执行RSA加密会得到一个类似这样的错误：<code>data too large for key size</code>，这是因为RSA加密的原始信息必须小于Key的长度。那如何用RSA加密一个很长的消息呢？实际上，RSA并不适合加密大数据，而是先生成一个随机的AES密码，用AES加密原始信息，然后用RSA加密AES口令，这样，实际使用RSA时，给对方传的密文分两部分，一部分是AES加密的密文，另一部分是RSA加密的AES口令。对方用RSA先解密出AES口令，再用AES解密密文，即可获得明文。</p>
<h3 id="证书">证书</h3>
<p>crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。</p>
<h3 id="参考源码-7">参考源码</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/basic-modules/crypto/crypto.zip">crypto常用算法</a></li>
</ul>
<p>最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种Client/Server模式简称CS架构。</p>
<p>随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而CS架构需要每个客户端逐个升级桌面App，因此，Browser/Server模式开始流行，简称BS架构。</p>
<p>在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。</p>
<p>当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构迅速流行起来。</p>
<p>今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。</p>
<p>Web应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：</p>
<p>静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的；</p>
<p>CGI：由于静态Web页面无法与用户交互，比如用户填写了一个注册表单，静态Web页面就无法处理。要处理用户发送的动态数据，出现了Common Gateway Interface，简称CGI，用C/C++编写。</p>
<p>ASP/JSP/PHP：由于Web应用特点是修改频繁，用C/C++这样的低级语言非常不适合Web开发，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。</p>
<p>MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。<a target="_blank" rel="noopener" href="http://xn--ASPASP-yy7ir59aujt.Net">ASP发展为ASP.Net</a>，JSP和PHP也有一大堆MVC框架。</p>
<p>目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。</p>
<p>由于Node.js把JavaScript引入了服务器端，因此，原来必须使用PHP/Java/C#/Python/Ruby等其他语言来开发服务器端程序，现在可以使用Node.js开发了！</p>
<p>用Node.js开发Web服务器端，有几个显著的优势：</p>
<p>一是后端语言也是JavaScript，以前掌握了前端JavaScript的开发人员，现在可以同时编写后端代码；</p>
<p>二是前后端统一使用JavaScript，就没有切换语言的障碍了；</p>
<p>三是速度快，非常快！这得益于Node.js天生是异步的。</p>
<p>在Node.js诞生后的短短几年里，出现了无数种Web框架、ORM框架、模版引擎、测试框架、自动化构建工具，数量之多，即使是JavaScript老司机，也不免眼花缭乱。</p>
<p>常见的Web框架包括：<a target="_blank" rel="noopener" href="https://expressjs.com/">Express</a>，<a target="_blank" rel="noopener" href="https://sailsjs.org/">Sails.js</a>，<a target="_blank" rel="noopener" href="https://koajs.com/">koa</a>，<a target="_blank" rel="noopener" href="https://www.meteor.com/">Meteor</a>，<a target="_blank" rel="noopener" href="https://derbyjs.com/">DerbyJS</a>，<a target="_blank" rel="noopener" href="https://www.totaljs.com/">Total.js</a>，<a target="_blank" rel="noopener" href="http://restify.com/">restify</a>……</p>
<p>ORM框架比Web框架要少一些：<a target="_blank" rel="noopener" href="https://www.sequelizejs.com/">Sequelize</a>，<a target="_blank" rel="noopener" href="https://dresende.github.io/node-orm2/">ORM2</a>，<a target="_blank" rel="noopener" href="https://bookshelfjs.org/">Bookshelf.js</a>，<a target="_blank" rel="noopener" href="https://vincit.github.io/objection.js/">Objection.js</a>……</p>
<p>模版引擎PK：<a target="_blank" rel="noopener" href="https://jade-lang.com/">Jade</a>，<a target="_blank" rel="noopener" href="https://ejs.co/">EJS</a>，<a href="httpss://github.com/paularmstrong/swig">Swig</a>，<a target="_blank" rel="noopener" href="https://mozilla.github.io/nunjucks/">Nunjucks</a>，<a target="_blank" rel="noopener" href="https://olado.github.io/doT/">doT.js</a>……</p>
<p>测试框架包括：<a target="_blank" rel="noopener" href="https://mochajs.org/">Mocha</a>，<a target="_blank" rel="noopener" href="https://visionmedia.github.io/expresso/">Expresso</a>，<a target="_blank" rel="noopener" href="https://unitjs.com/">Unit.js</a>，<a target="_blank" rel="noopener" href="https://karma-runner.github.io/">Karma</a>……</p>
<p>构建工具有：<a target="_blank" rel="noopener" href="https://gruntjs.com/">Grunt</a>，<a target="_blank" rel="noopener" href="https://gulpjs.com/">Gulp</a>，<a target="_blank" rel="noopener" href="https://webpack.github.io/">Webpack</a>……</p>
<p>目前，在npm上已发布的开源Node.js模块数量超过了30万个。</p>
<p>有选择恐惧症的朋友，看到这里可以洗洗睡了。</p>
<p>好消息是这个教程已经帮你选好了，你只需要跟着教程一条道走到黑就可以了。</p>
<h2 id="koa">koa</h2>
<p>koa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。</p>
<h3 id="历史">历史</h3>
<h4 id="Express">Express</h4>
<p>Express是第一代最流行的web框架，它对Node.js的http进行了封装，用起来如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Example app listening on port 3000!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/file1&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;read file1 error&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/file2&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;read file2 error&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="title function_">type</span>(<span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">            res.<span class="title function_">send</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然可以用async这样的库来组织异步代码，但是用回调写异步实在是太痛苦了！</p>
<h4 id="koa-1-x">koa 1.x</h4>
<p>随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.x使用generator实现异步，代码看起来像同步的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="keyword">function</span> *() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">doReadFile1</span>();</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">yield</span> <span class="title function_">doReadFile2</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">body</span> = data;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>用generator实现异步比回调简单了不少，但是generator的本意并不是异步。Promise才是为异步设计的，但是Promise的写法……想想就复杂。为了简化异步代码，JavaScript引入了新的关键字<code>async</code>和<code>await</code>，可以轻松地把一个function变为异步模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> fs.<span class="title function_">read</span>(<span class="string">&#x27;/file1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是JavaScript标准的异步代码，非常简洁，并且易于使用。</p>
<h4 id="koa-2-x">koa 2.x</h4>
<p>koa团队并没有止步于koa 1.x，他们又开发了koa 2，和koa 1相比，koa 2完全使用Promise并配合<code>async</code>来实现异步。</p>
<p>koa 2.x的代码看上去像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">doReadFile</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/plain&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="选择哪个版本？">选择哪个版本？</h3>
<p>为了紧跟时代潮流，教程将使用最新的koa 2.x开发！</p>
<hr>
<hr>
<h3 id="创建koa工程">创建koa工程</h3>
<p>首先，我们创建一个目录<code>hello-koa</code>，作为koa工程根目录。</p>
<p>在根目录下执行<code>npm install koa</code>，我们就在当前目录下安装好了koa及其依赖项，执行完成后目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello-koa/</span><br><span class="line">├── node_modules/      &lt;-- koa以及所有依赖项</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json       &lt;-- npm描述文件</span><br></pre></td></tr></table></figure>
<p><code>package.json</code>包含了npm的依赖信息，以及项目描述等信息，<code>package-lock.json</code>是针对当前所有依赖的一个快照，目的是锁定各个依赖项的版本号。</p>
<p>我们打开<code>package.json</code>，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;koa&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.15.3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>它只有一个koa依赖，是由命令<code>npm install koa</code>写入的。</p>
<p><code>node_modules</code>是所有依赖项安装的地方，可以随时删除<code>node_modules</code>目录，然后用<code>npm install</code>重新安装。</p>
<p>直接运行<code>npm install</code>则根据<code>package.json</code>的<code>dependencies</code>信息下载安装依赖项，运行<code>npm install xyz</code>则将<code>xyz</code>添加到<code>dependencies</code>然后再安装<code>xyz</code>及其依赖项。因此，熟练的开发者可以先自己编辑<code>dependencies</code>内容，然后删除<code>node_modules</code>后重新安装所有依赖项。此外，<code>package.json</code>和<code>package-lock.json</code>应当添加至版本控制系统中，而<code>node_modules</code>则无需添加。</p>
<p>我们手动添加如下信息至<code>package.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello-koa&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello koa webapp.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;koa&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.15.3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>name</code>、<code>version</code>和<code>description</code>均可任意设置，<code>type</code>为<code>module</code>表示以ESM模块执行。</p>
<p>紧接着，我们用VS Code打开<code>hello-koa</code>目录，创建<code>app.mjs</code>文件，输入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入koa，注意导入的是大写开头的class:</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Koa</span> <span class="keyword">from</span> <span class="string">&#x27;koa&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个koa实例表示webapp本身:</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于任何请求，app将调用该异步函数处理请求：</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">// 设置响应类型和文本:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在端口3000监听:</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>对于每一个http请求，koa将调用我们传入的异步函数来处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">// 设置response的Content-Type:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    <span class="comment">// 设置response的内容:</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，参数<code>ctx</code>是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，<code>next</code>是koa传入的将要处理的下一个异步函数。</p>
<p>上面的异步函数中，我们首先用<code>await next();</code>处理下一个异步函数，然后，设置response的<code>Content-Type</code>和内容。</p>
<p>现在，我们的工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello-koa/</span><br><span class="line">├── node_modules/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<p>在命令行执行<code>node app.mjs</code>就启动了Web服务器。我们打开浏览器，输入<code>http://localhost:3000</code>，即可看到效果：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/basic/hello-koa.png" alt="koa-browser"></p>
<h3 id="koa-middleware">koa middleware</h3>
<p>让我们再仔细看看koa的执行逻辑。核心代码是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>每收到一个http请求，koa就会调用通过<code>app.use()</code>注册的async函数，并传入<code>ctx</code>和<code>next</code>参数。</p>
<p>我们可以对<code>ctx</code>操作，并设置返回内容。但是为什么要调用<code>await next()</code>？</p>
<p>原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用<code>await next()</code>来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>
<p>例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>`</span>); <span class="comment">// 打印URL</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>(); <span class="comment">// 调用下一个middleware</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>(); <span class="comment">// 调用下一个middleware</span></span><br><span class="line">    <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start; <span class="comment">// 耗费时间</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Time: <span class="subst">$&#123;ms&#125;</span>ms`</span>); <span class="comment">// 打印耗费时间</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Hello Koa!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>middleware的顺序很重要，也就是调用<code>app.use()</code>的顺序决定了middleware的顺序。</p>
<p>此外，如果一个middleware没有调用<code>await next()</code>，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">await</span> <span class="title function_">checkUserPermission</span>(ctx)) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>理解了middleware，我们就已经会用koa了！</p>
<p>最后注意<code>ctx</code>对象有一些简写的方法，例如<code>ctx.url</code>相当于<code>ctx.request.url</code>，<code>ctx.type</code>相当于<code>ctx.response.type</code>。</p>
<h3 id="参考源码-8">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/basic/hello-koa.zip">hello-koa</a></p>
<p>在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/buduijin.png" alt="buduijin"></p>
<p>正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;index page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/test&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;TEST page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span> === <span class="string">&#x27;/error&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;ERROR page&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这么写是可以运行的，但是好像有点蠢。</p>
<p>应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。</p>
<h3 id="koa-router">@koa/router</h3>
<p>为了处理URL，我们需要引入<code>@koa/router</code>这个middleware，让它负责处理URL映射。</p>
<p>我们把上一节的<code>hello-koa</code>工程复制一份，重命名为<code>url-koa</code>。</p>
<p>先用命令<code>npm install @koa/router</code>安装并在<code>package.json</code>中添加依赖项，接下来，我们修改<code>app.mjs</code>，使用<code>@koa/router</code>来处理URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Koa</span> <span class="keyword">from</span> <span class="string">&#x27;koa&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;@koa/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// log url:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析request.body:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置路由: 处理 /</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Index Page&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置路由: 处理 /hello/:name</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/hello/:name&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取:name参数:</span></span><br><span class="line">    <span class="keyword">let</span> s = ctx.<span class="property">params</span>.<span class="property">name</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Hello, <span class="subst">$&#123;s&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用router:</span></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>我们使用<code>router.get('/path', async fn)</code>来注册一个GET请求。可以在请求路径中使用带变量的<code>/hello/:name</code>，变量可以通过<code>ctx.params.name</code>访问。</p>
<p>再运行<code>app.mjs</code>，我们就可以测试不同的URL：</p>
<p>输入首页：<a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000/</a></p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/index-page.png" alt="url-index"></p>
<p>输入：<a target="_blank" rel="noopener" href="http://localhost:3000/hello/Bob">http://localhost:3000/hello/Bob</a></p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/hello-bob.png" alt="url-hello"></p>
<h3 id="处理post请求">处理post请求</h3>
<p>用<code>router.get('/path', async fn)</code>处理的是get请求。如果要处理post请求，可以用<code>router.post('/path', async fn)</code>。</p>
<p>用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都<em>不提供</em>解析request的body的功能！</p>
<p>所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到<code>ctx.request.body</code>中。<code>@koa/bodyparser</code>就是用来干这个活的。</p>
<p>我们用命令<code>npm install @koa/bodyparser</code>安装并在<code>package.json</code>中添加依赖项，然后，修改<code>app.mjs</code>，引入<code>@koa/bodyparser</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bodyParser &#125; <span class="keyword">from</span> <span class="string">&#x27;@koa/bodyparser&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在合适的位置加上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br></pre></td></tr></table></figure>
<p>由于middleware的顺序很重要，这个<code>@koa/bodyparser</code>必须在<code>router</code>之前被注册到<code>app</code>对象上。</p>
<p>现在我们就可以处理post请求了。写一个简单的登录表单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;h1&gt;Index Page&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/signin&#x27;</span>, <span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> name = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">name</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`try signin: <span class="subst">$&#123;name&#125;</span>, password: <span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;koa&#x27;</span> &amp;&amp; password === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Welcome, <span class="subst">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Signin failed!&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Retry&lt;/a&gt;&lt;/p&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意到我们用<code>let name = ctx.request.body.name || ''</code>拿到表单的<code>name</code>字段，如果该字段不存在，默认值设置为<code>''</code>。</p>
<p>类似的，put、delete、head请求也可以由router处理。</p>
<h3 id="重构">重构</h3>
<p>现在，我们已经可以处理不同的URL了，但是看看<code>app.mjs</code>，总觉得还是有点不对劲。</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/buduijin2.png" alt="still-buduijin"></p>
<p>所有的URL处理函数都放到<code>app.mjs</code>里显得很乱，而且，每加一个URL，就需要修改<code>app.mjs</code>。随着URL越来越多，<code>app.mjs</code>就会越来越长。</p>
<p>如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让<code>app.mjs</code>自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url2-koa/</span><br><span class="line">├── controller/</span><br><span class="line">│   ├── hello.mjs   &lt;-- 处理/hello/:name</span><br><span class="line">│   └── signin.mjs  &lt;-- 处理/signin</span><br><span class="line">├── app.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<p>于是我们把<code>url-koa</code>复制一份，重命名为<code>url2-koa</code>，准备重构这个项目。</p>
<p>我们先在<code>controller</code>目录下编写<code>signin.mjs</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">index</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;h1&gt;Index Page&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST /signin</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">name</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`try signin: <span class="subst">$&#123;name&#125;</span>, password: <span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;koa&#x27;</span> &amp;&amp; password === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Welcome, <span class="subst">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;Signin failed!&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Retry&lt;/a&gt;&lt;/p&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出处理函数:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="string">&#x27;GET /&#x27;</span>: index,</span><br><span class="line">    <span class="string">&#x27;POST /signin&#x27;</span>: signin</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个<code>signin.mjs</code>通过<code>export default</code>把两个URL处理函数暴露出来。</p>
<p>类似的，<code>hello.mjs</code>把一个URL处理函数暴露出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取:name参数:</span></span><br><span class="line">    <span class="keyword">let</span> s = ctx.<span class="property">params</span>.<span class="property">name</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">`&lt;h1&gt;Hello, <span class="subst">$&#123;s&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="string">&#x27;GET /hello/:name&#x27;</span>: hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们修改<code>app.mjs</code>，让它自动扫描<code>controller</code>目录，找到所有<code>js</code>文件，导入，然后注册每个URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描controller目录:</span></span><br><span class="line"><span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`scan dir <span class="subst">$&#123;dirname&#125;</span>...`</span>);</span><br><span class="line"><span class="comment">// 列举 *.mjs 文件:</span></span><br><span class="line"><span class="keyword">let</span> files = <span class="title function_">readdirSync</span>(path.<span class="title function_">join</span>(dirname, <span class="string">&#x27;controller&#x27;</span>)).<span class="title function_">filter</span>(<span class="function"><span class="params">f</span> =&gt;</span> f.<span class="title function_">endsWith</span>(<span class="string">&#x27;.mjs&#x27;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    <span class="comment">// 导入模块:</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`import controller/<span class="subst">$&#123;file&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="attr">default</span>: mapping &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./controller/<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 把每个URL映射添加到router:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">in</span> mapping) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;GET &#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 类似 &#x27;GET /hello/:name&#x27;</span></span><br><span class="line">            <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">4</span>);</span><br><span class="line">            router.<span class="title function_">get</span>(p, mapping[url]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: GET <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;POST &#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 类似 &#x27;POST /signin&#x27;</span></span><br><span class="line">            <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">5</span>);</span><br><span class="line">            router.<span class="title function_">post</span>(p, mapping[url]);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: POST <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`invalid mapping: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller-Middleware">Controller Middleware</h3>
<p>最后，我们把扫描<code>controller</code>目录和创建<code>router</code>的代码从<code>app.mjs</code>中提取出来，作为一个简单的middleware使用，命名为<code>controller.mjs</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller.mjs:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">scan</span>(<span class="params">router, controllerDir</span>) &#123;</span><br><span class="line">    <span class="comment">// 扫描controller目录:</span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`scan dir <span class="subst">$&#123;dirname&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">let</span> files = <span class="title function_">readdirSync</span>(path.<span class="title function_">join</span>(dirname, controllerDir)).<span class="title function_">filter</span>(<span class="function"><span class="params">f</span> =&gt;</span> f.<span class="title function_">endsWith</span>(<span class="string">&#x27;.mjs&#x27;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">        <span class="comment">// 导入模块:</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`import controller/<span class="subst">$&#123;file&#125;</span>...`</span>);</span><br><span class="line">        <span class="keyword">let</span> &#123; <span class="attr">default</span>: mapping &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./<span class="subst">$&#123;controllerDir&#125;</span>/<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 把每个URL映射添加到router:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">in</span> mapping) &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;GET &#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">4</span>);</span><br><span class="line">                router.<span class="title function_">get</span>(p, mapping[url]);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: GET <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.<span class="title function_">startsWith</span>(<span class="string">&#x27;POST &#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">let</span> p = url.<span class="title function_">substring</span>(<span class="number">5</span>);</span><br><span class="line">                router.<span class="title function_">post</span>(p, mapping[url]);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`mapping: POST <span class="subst">$&#123;p&#125;</span>`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`invalid mapping: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认扫描目录为 controller:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">controllerDir = <span class="string">&#x27;controller&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">scan</span>(router, controllerDir);</span><br><span class="line">    <span class="keyword">return</span> router.<span class="title function_">routes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们在<code>app.mjs</code>的代码又简化了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> controller <span class="keyword">from</span> <span class="string">&#x27;./controller.mjs&#x27;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 使用controller(), 注意controller模块导出的是async函数，要通过await调用:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">await</span> <span class="title function_">controller</span>());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>经过重新整理后的工程<code>url2-koa</code>目前具备非常好的模块化，所有处理URL的函数按功能组存放在<code>controller</code>目录，今后我们也只需要不断往这个目录下加东西就可以了，<code>app.mjs</code>保持不变。</p>
<p>最后我们整理一下koa处理一个HTTP请求的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">           │</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">┌─────────────────────┐</span><br><span class="line">│log:                 │</span><br><span class="line">│async(ctx,next) &#123;...&#125;│</span><br><span class="line">└─────────────────────┘</span><br><span class="line">           │</span><br><span class="line">           ▼</span><br><span class="line">┌─────────────────────┐</span><br><span class="line">│bodyParser()         │</span><br><span class="line">└─────────────────────┘     GET /             ┌─────────────────────┐</span><br><span class="line">           │              ┌──────────────────▶│async(ctx,next) &#123;...&#125;│</span><br><span class="line">           ▼              │                   └─────────────────────┘</span><br><span class="line">┌─────────────────────┐   │ POST /signin      ┌─────────────────────┐</span><br><span class="line">│router.routes()      ├───┼──────────────────▶│async(ctx,next) &#123;...&#125;│</span><br><span class="line">└─────────────────────┘   │                   └─────────────────────┘</span><br><span class="line">                          │ GET /hello/:name  ┌─────────────────────┐</span><br><span class="line">                          └──────────────────▶│async(ctx,next) &#123;...&#125;│</span><br><span class="line">                                              └─────────────────────┘</span><br></pre></td></tr></table></figure>
<p>一个HTTP请求是按顺序由一系列注册到koa的middleware处理的，首先由log函数处理，并通过<code>await next()</code>把请求传递到下一个middleware，紧接着是<code>bodyParser</code>处理，最后是<code>router</code>处理。在router的内部，又会根据注册到router的HTTP方法+Path来决定由哪个async函数处理请求。如果URL没有匹配到，则简单返回404。以上就是整个基于koa的webapp处理流程，非常清晰易懂。</p>
<h3 id="参考源码-9">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/url/url.zip">url</a></p>
<p>Nunjucks是什么东东？其实它是一个模板引擎。</p>
<p>那什么是模板引擎？</p>
<p>模板引擎就是基于模板配合数据构造出字符串输出的一个组件。比如下面的函数就是一个模板引擎：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">examResult</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;data.name&#125;</span>同学一年级期末考试语文<span class="subst">$&#123;data.chinese&#125;</span>分，数学<span class="subst">$&#123;data.math&#125;</span>分，位于年级第<span class="subst">$&#123;data.ranking&#125;</span>名。`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们输入数据如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">examResult</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">chinese</span>: <span class="number">78</span>,</span><br><span class="line">    <span class="attr">math</span>: <span class="number">87</span>,</span><br><span class="line">    <span class="attr">ranking</span>: <span class="number">999</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>该模板引擎把模板字符串里面对应的变量替换以后，就可以得到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小明同学一年级期末考试语文78分，数学87分，位于年级第999名。</span><br></pre></td></tr></table></figure>
<p>模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。</p>
<p>有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？</p>
<p>因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。</p>
<p>输出HTML有几个特别重要的问题需要考虑：</p>
<h4 id="转义">转义</h4>
<p>对特殊字符要转义，避免受到XSS攻击。比如，如果变量<code>name</code>的值不是<code>小明</code>，而是<code>小明&lt;script&gt;...&lt;/script&gt;</code>，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。</p>
<h4 id="格式化">格式化</h4>
<p>对不同类型的变量要格式化，比如，货币需要变成<code>$12,345.00</code>这样的格式，日期需要变成<code>2016-01-01</code>这样的格式。</p>
<h4 id="简单逻辑">简单逻辑</h4>
<p>模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; name &#125;&#125;同学，</span><br><span class="line">&#123;% if score &gt;= 90 %&#125;</span><br><span class="line">    成绩优秀，应该奖励</span><br><span class="line">&#123;% elif score &gt;=60 %&#125;</span><br><span class="line">    成绩良好，继续努力</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    不及格，建议回家打屁股</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。</p>
<h3 id="Nunjucks">Nunjucks</h3>
<p>我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。</p>
<p>如果你使用过Python的模板引擎<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/web/jinja">jinja2</a>，那么使用Nunjucks就非常简单，两者的语法几乎是一模一样的，因为Nunjucks就是用JavaScript重新实现了jinjia2。</p>
<p>从上面的例子我们可以看到，虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">view, model</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>view</code>是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。<code>model</code>就是数据，在JavaScript中，它就是一个简单的Object。<code>render</code>函数返回一个字符串，就是模板的输出。</p>
<p>下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。</p>
<p>我们创建一个<code>use-nunjucks</code>的VS Code工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use-nunjucks/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── view</span><br><span class="line">    ├── base.html    &lt;-- HTML模板文件</span><br><span class="line">    ├── extend.html  &lt;-- HTML模板文件</span><br><span class="line">    └── hello.html   &lt;-- HTML模板文件</span><br></pre></td></tr></table></figure>
<p>其中，模板文件存放在<code>view</code>目录中。</p>
<p>我们先用<code>npm install nunjucks</code>安装依赖项并在<code>package.json</code>中添加<code>nunjucks</code>的依赖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;nunjucks&quot;</span>: <span class="string">&quot;^3.2.4&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，模板引擎是可以独立使用的，并不需要依赖koa。</p>
<p>紧接着，我们要编写使用Nunjucks的函数<code>render</code>。怎么写？方法是查看Nunjucks的<a target="_blank" rel="noopener" href="https://mozilla.github.io/nunjucks/">官方文档</a>，仔细阅读后，在<code>app.js</code>中编写代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nunjucks <span class="keyword">from</span> <span class="string">&#x27;nunjucks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createEnv</span>(<span class="params">path, &#123; autoescape = <span class="literal">true</span>, noCache = <span class="literal">false</span>, watch = <span class="literal">false</span>, throwOnUndefined = <span class="literal">false</span> &#125;, filters = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> loader = <span class="keyword">new</span> nunjucks.<span class="title class_">FileSystemLoader</span>(path, &#123;</span><br><span class="line">        <span class="attr">noCache</span>: noCache,</span><br><span class="line">        <span class="attr">watch</span>: watch</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> env = <span class="keyword">new</span> nunjucks.<span class="title class_">Environment</span>(loader, &#123;</span><br><span class="line">        <span class="attr">autoescape</span>: autoescape,</span><br><span class="line">        <span class="attr">throwOnUndefined</span>: throwOnUndefined</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> filters) &#123;</span><br><span class="line">        env.<span class="title function_">addFilter</span>(name, filters[name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> env = <span class="title function_">createEnv</span>(<span class="string">&#x27;view&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">noCache</span>: <span class="literal">true</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">hex</span>: <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span> + n.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>变量<code>env</code>就表示Nunjucks模板引擎对象，它有一个<code>render(view, model)</code>方法，正好传入<code>view</code>和<code>model</code>两个参数，并返回字符串。</p>
<p>创建<code>env</code>需要的参数可以查看文档获知。我们用关键字参数作为默认值，最后使用<code>new nunjucks.FileSystemLoader('view')</code>创建一个文件系统加载器，从<code>view</code>目录读取模板。</p>
<p>我们编写一个<code>hello.html</code>模板文件，放到<code>view</code>目录下，内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，我们就可以用下面的代码来渲染这个模板：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = env.<span class="title function_">render</span>(<span class="string">&#x27;hello.html&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure>
<p>获得输出如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello 小明<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = env.<span class="title function_">render</span>(<span class="string">&#x27;hello.html&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure>
<p>获得输出如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello <span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(&quot;小明&quot;)<span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就避免了输出恶意脚本。</p>
<p>此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 循环输出名字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Fruits List<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;% for f in fruits %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; f &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Nunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。</p>
<p>更好的方式是使用继承。先定义一个基本的网页框架<code>base.html</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% block header %&#125; <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Unnamed<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> &#123;% endblock %&#125;</span><br><span class="line">&#123;% block body %&#125; <span class="tag">&lt;<span class="name">div</span>&gt;</span>No body<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#123;% endblock %&#125;</span><br><span class="line">&#123;% block footer %&#125; <span class="tag">&lt;<span class="name">div</span>&gt;</span>copyright<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>base.html</code>定义了三个可编辑的块，分别命名为<code>header</code>、<code>body</code>和<code>footer</code>。子模板可以有选择地对块进行重新定义：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; header &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block body %&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; body &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们对子模板进行渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(env.<span class="title function_">render</span>(<span class="string">&#x27;extend.html&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">header</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&#x27;bla bla bla...&#x27;</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>输出HTML如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>bla bla bla...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>copyright<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &lt;-- footer没有重定义，所以仍使用父模板的内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="性能">性能</h3>
<p>最后我们要考虑一下Nunjucks的性能。</p>
<p>对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。</p>
<p>性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。</p>
<p>好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了<code>noCache: false</code>这个参数。</p>
<p>在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。</p>
<p>Nunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。</p>
<h3 id="参考源码-10">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/template/use-nunjucks.zip">use-nunjucks</a></p>
<p>我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！</p>
<p>当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">render</span>(<span class="string">&#x27;home.html&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;Michael&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">HTTP Request │GET /Bob                     │</span><br><span class="line">             └─────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │ name = Bob</span><br><span class="line">                            ▼</span><br><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">     app.mjs │GET /:name                   │</span><br><span class="line">             │async (ctx, next) &#123;          │</span><br><span class="line">             │    ctx.render(&#x27;home.html&#x27;, &#123;│</span><br><span class="line">             │        name: ctx.params.name│</span><br><span class="line">             │    &#125;);                      │</span><br><span class="line">             │&#125;                            │</span><br><span class="line">             └─────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │ &#123;&#123; name &#125;&#125; ─▶ Bob</span><br><span class="line">                            ▼</span><br><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">    Template │&lt;html&gt;                       │</span><br><span class="line">             │&lt;body&gt;                       │</span><br><span class="line">             │    &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt;│</span><br><span class="line">             │&lt;/body&gt;                      │</span><br><span class="line">             │&lt;/html&gt;                      │</span><br><span class="line">             └─────────────────────────────┘</span><br><span class="line">                            │</span><br><span class="line">                            │ Output</span><br><span class="line">                            ▼</span><br><span class="line">             ┌─────────────────────────────┐</span><br><span class="line">        HTML │&lt;html&gt;                       │</span><br><span class="line">             │&lt;body&gt;                       │</span><br><span class="line">             │    &lt;p&gt;Hello, Bob!&lt;/p&gt;       │</span><br><span class="line">             │&lt;/body&gt;                      │</span><br><span class="line">             │&lt;/html&gt;                      │</span><br><span class="line">             └─────────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。</p>
<p>异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；</p>
<p>包含变量<code>&#123;&#123; name &#125;&#125;</code>的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>
<p>MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</p>
<p>上面的例子中，Model就是一个JavaScript对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们根据原来的<code>url2-koa</code>创建工程<code>view-koa</code>，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为<code>ctx.render(view, model)</code>的方式。</p>
<p>工程<code>koa-mvc</code>结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">koa-mvc/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── controller</span><br><span class="line">│   ├── index.mjs</span><br><span class="line">│   └── signin.mjs</span><br><span class="line">├── controller.mjs</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── static/  &lt;-- 静态资源文件</span><br><span class="line">│   ├── bootstrap.css</span><br><span class="line">│   └── favicon.ico</span><br><span class="line">├── view/  &lt;-- html模板文件</span><br><span class="line">│   ├── base.html</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── signin-failed.html</span><br><span class="line">│   └── signin-ok.html</span><br><span class="line">└── view.mjs</span><br></pre></td></tr></table></figure>
<p>在<code>package.json</code>中，我们将要用到的依赖包有：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;@koa/bodyparser&quot;: &quot;^5.1.1&quot;,</span><br><span class="line">&quot;@koa/router&quot;: &quot;^12.0.1&quot;,</span><br><span class="line">&quot;koa&quot;: &quot;^2.15.3&quot;,</span><br><span class="line">&quot;koa-mount&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">&quot;koa-static&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">&quot;nunjucks&quot;: &quot;^3.2.4&quot;</span><br></pre></td></tr></table></figure>
<p>先用<code>npm install</code>安装依赖包，然后，我们准备编写以下两个Controller：</p>
<h4 id="处理首页-GET">处理首页 GET /</h4>
<p>我们定义一个async函数处理首页URL<code>/</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">index</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    ctx.<span class="title function_">render</span>(<span class="string">&#x27;index.html&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Welcome&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到koa并没有在<code>ctx</code>对象上提供<code>render</code>方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用<code>ctx.render(view, model)</code>就完成了页面输出。</p>
<h4 id="处理登录请求-POST-signin">处理登录请求 POST /signin</h4>
<p>我们再定义一个async函数处理登录请求<code>/signin</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (email === <span class="string">&#x27;admin@example.com&#x27;</span> &amp;&amp; password === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-ok.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In OK&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Mr Bob&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-failed.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In Failed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于登录请求是一个POST，我们就用<code>ctx.request.body.&lt;name&gt;</code>拿到POST请求的数据，并给一个默认值。</p>
<p>登录成功时我们用<code>signin-ok.html</code>渲染，登录失败时我们用<code>signin-failed.html</code>渲染，所以，我们一共需要以下3个View：</p>
<ul>
<li>index.html</li>
<li>signin-ok.html</li>
<li>signin-failed.html</li>
</ul>
<h3 id="编写View">编写View</h3>
<p>在编写View的时候，我们实际上是在编写HTML页。为了让页面看起来美观大方，使用一个现成的CSS框架是非常有必要的。我们用<a target="_blank" rel="noopener" href="https://getbootstrap.com/">Bootstrap</a>这个CSS框架。从首页下载zip包后解压，我们把所有静态资源文件放到<code>/static</code>目录下，这样我们在编写HTML的时候，可以直接用Bootstrap的CSS，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/static/bootstrap.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>现在，在使用MVC之前，第一个问题来了，如何处理静态文件？</p>
<p>我们把所有静态资源文件全部放入<code>/static</code>目录，目的就是能统一处理静态文件。在koa中，我们需要编写一个middleware，处理以<code>/static/</code>开头的URL。</p>
<p>如果不想自己编写处理静态文件的middleware，可以直接使用<code>koa-mount</code>和<code>koa-static</code>组合来处理静态文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理静态文件:</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">serve</span>(<span class="string">&#x27;static&#x27;</span>)));</span><br></pre></td></tr></table></figure>
<p>上述代码大致相当于自己手写一个middleware：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断是否以指定的url开头:</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">request</span>.<span class="property">path</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;/static/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获取文件完整路径:</span></span><br><span class="line">        <span class="keyword">let</span> fp = ctx.<span class="property">request</span>.<span class="property">path</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">await</span> fs.<span class="title function_">exists</span>(ctx.<span class="property">request</span>.<span class="property">path</span>)) &#123;</span><br><span class="line">            <span class="comment">// 根据扩展名设置mime:</span></span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">type</span> = <span class="title function_">lookupMime</span>(ctx.<span class="property">request</span>.<span class="property">path</span>);</span><br><span class="line">            <span class="comment">// 读取文件内容并赋值给response.body:</span></span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="keyword">await</span> fs.<span class="title function_">readFile</span>(fp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 文件不存在:</span></span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是指定前缀的URL，继续处理下一个middleware:</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="集成Nunjucks">集成Nunjucks</h3>
<p>集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给<code>ctx</code>对象绑定一个<code>render(view, model)</code>的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。</p>
<p>我们创建一个<code>view.mjs</code>来实现这个middleware：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nunjucks <span class="keyword">from</span> <span class="string">&#x27;nunjucks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createEnv</span>(<span class="params">path, &#123; autoescape = <span class="literal">true</span>, noCache = <span class="literal">false</span>, watch = <span class="literal">false</span>, throwOnUndefined = <span class="literal">false</span> &#125;, filters = &#123;&#125;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> env = <span class="title function_">createEnv</span>(<span class="string">&#x27;view&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">noCache</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出env对象:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> env;</span><br></pre></td></tr></table></figure>
<p>使用的时候，我们在<code>app.mjs</code>添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> templateEngine <span class="keyword">from</span> <span class="string">&#x27;./view.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.context是每个请求创建的ctx的原型,</span></span><br><span class="line"><span class="comment">// 因此把render()方法绑定在原型对象上:</span></span><br><span class="line">app.<span class="property">context</span>.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params">view, model</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">response</span>.<span class="property">type</span> = <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">response</span>.<span class="property">body</span> = templateEngine.<span class="title function_">render</span>(view, <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">state</span> || &#123;&#125;, model || &#123;&#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到<code>createEnv()</code>函数和前面使用Nunjucks时编写的函数是一模一样的。</p>
<p>这里我们判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。</p>
<p>Node.js在全局变量<code>process</code>中定义了一个环境变量<code>env.NODE_ENV</code>，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为<code>'development'</code>，而部署到服务器时，环境变量应该设置为<code>'production'</code>。在编写代码的时候，要根据当前环境作不同的判断。</p>
<p><em>注意</em>：生产环境上必须配置环境变量<code>NODE_ENV = 'production'</code>，而开发环境不需要配置，实际上<code>NODE_ENV</code>可能是<code>undefined</code>，所以判断的时候，不要用<code>NODE_ENV === 'development'</code>。</p>
<p>类似的，我们在使用上面编写的处理静态文件的middleware时，也可以根据环境变量判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isProduction) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">serve</span>(<span class="string">&#x27;static&#x27;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。</p>
<h3 id="编写View-2">编写View</h3>
<p>在编写View的时候，非常有必要先编写一个<code>base.html</code>作为骨架，其他模板都继承自<code>base.html</code>，这样，才能大大减少重复工作。</p>
<p>编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了<code>base.html</code>。</p>
<h3 id="运行">运行</h3>
<p>一切顺利的话，这个<code>koa-mvc</code>工程应该可以顺利运行。运行前，我们再检查一下<code>app.mjs</code>里的middleware的顺序：</p>
<p>第一个middleware是记录URL以及页面执行时间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">const</span> execTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start;</span><br><span class="line">    ctx.<span class="property">response</span>.<span class="title function_">set</span>(<span class="string">&#x27;X-Response-Time&#x27;</span>, <span class="string">`<span class="subst">$&#123;execTime&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第二个middleware处理静态文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isProduction) &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(<span class="title function_">mount</span>(<span class="string">&#x27;/static&#x27;</span>, <span class="title function_">serve</span>(<span class="string">&#x27;static&#x27;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个middleware解析POST请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br></pre></td></tr></table></figure>
<p>最后一个middleware处理URL路由：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">await</span> <span class="title function_">controller</span>());</span><br></pre></td></tr></table></figure>
<p>现在，用<code>node app.mjs</code>运行代码，不出意外的话，在浏览器输入<code>localhost:3000/</code>，可以看到首页内容：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-index.png" alt="koa-index"></p>
<p>直接在首页登录，如果输入正确的Email和Password，进入登录成功的页面：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-signin-ok.png" alt="koa-signin-ok"></p>
<p>如果输入的Email和Password不正确，进入登录失败的页面：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-signin-failed.png" alt="koa-signin-failed"></p>
<p>怎么判断正确的Email和Password？目前我们在<code>signin.js</code>中是这么判断的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (email === <span class="string">&#x27;admin@example.com&#x27;</span> &amp;&amp; password === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，真实的网站会根据用户输入的Email和Password去数据库查询并判断登录是否成功，不过这需要涉及到Node.js环境如何操作数据库，我们后面再讨论。</p>
<p>如果要以<code>production</code>模式启动app，需要设置环境变量，可以通过以下命令启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ NODE_ENV=production node app.mjs</span><br></pre></td></tr></table></figure>
<p>这样模板缓存将生效，同时不再响应静态文件请求。</p>
<h3 id="扩展">扩展</h3>
<p>注意到<code>ctx.render</code>内部渲染模板时，Model对象并不是传入的model变量，而是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ctx.<span class="property">state</span> || &#123;&#125;, model || &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这个小技巧是为了扩展。</p>
<p>首先，<code>model || &#123;&#125;</code>确保了即使传入<code>undefined</code>，model也会变为默认值<code>&#123;&#125;</code>。<code>Object.assign()</code>会把除第一个参数外的其他参数的所有属性复制到第一个参数中。第二个参数是<code>ctx.state || &#123;&#125;</code>，这个目的是为了能把一些公共的变量放入<code>ctx.state</code>并传给View。</p>
<p>例如，某个middleware负责检查用户权限，它可以把当前用户放入<code>ctx.state</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="title function_">tryGetUserFromCookie</span>(ctx.<span class="property">request</span>);</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">        ctx.<span class="property">state</span>.<span class="property">user</span> = user;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就没有必要在每个Controller的async函数中都把user变量放入model中。</p>
<h3 id="参考源码-11">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/mvc/koa-mvc.zip">koa-mvc</a></p>
<p>自从Roy Fielding博士在2000年他的博士论文中提出<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/REST">REST</a>（Representational State Transfer）风格的软件架构模式后，REST就基本上迅速取代了复杂而笨重的SOAP，成为Web API的标准了。</p>
<p>什么是Web API呢？</p>
<p>如果我们想要获取某个电商网站的某个商品，输入<code>http://localhost:3000/products/123</code>，就可以看到id为123的商品页面，但这个结果是HTML页面，它同时混合包含了Product的数据和Product的展示两个部分。对于用户来说，阅读起来没有问题，但是，如果机器读取，就很难从HTML中解析出Product的数据。</p>
<p>如果一个URL返回的不是HTML，而是机器能直接解析的数据，这个URL就可以看成是一个Web API。比如，读取<code>http://localhost:3000/api/products/123</code>，如果能直接返回Product的数据，那么机器就可以直接读取。</p>
<p>REST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。</p>
<p>编写API有什么好处呢？由于API就是把Web App的功能全部封装了，所以，通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。</p>
<p>此外，如果我们把前端页面看作是一种用于展示的客户端，那么API就是为客户端提供数据、操作数据的接口。这种设计可以获得极高的扩展性。例如，当用户需要在手机上购买商品时，只需要开发针对iOS和Android的两个客户端，通过客户端访问API，就可以完成通过浏览器页面提供的功能，而后端代码基本无需改动。</p>
<p>当一个Web应用以API的形式对外提供功能时，整个应用的结构就扩展为：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest.png" alt="REST-arch"></p>
<p>把网页视为一种客户端，是REST架构可扩展的一个关键。</p>
<h3 id="REST-API规范">REST API规范</h3>
<p>编写REST API，实际上就是编写处理HTTP请求的async函数，不过，REST请求和普通的HTTP请求有几个特殊的地方：</p>
<ol>
<li>REST请求仍然是标准的HTTP请求，但是，除了GET请求外，POST、PUT等请求的body是JSON数据格式，请求的<code>Content-Type</code>为<code>application/json</code>；</li>
<li>REST响应返回的结果是JSON数据格式，因此，响应的<code>Content-Type</code>也是<code>application/json</code>。</li>
</ol>
<p>REST规范定义了资源的通用访问格式，虽然它不是一个强制要求，但遵守该规范可以让人易于理解。</p>
<p>例如，商品Product就是一种资源。获取所有Product的URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products</span><br></pre></td></tr></table></figure>
<p>而获取某个指定的Product，例如，id为<code>123</code>的Product，其URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products/123</span><br></pre></td></tr></table></figure>
<p>新建一个Product使用POST请求，JSON数据包含在body中，URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /api/products</span><br></pre></td></tr></table></figure>
<p>更新一个Product使用PUT请求，例如，更新id为<code>123</code>的Product，其URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /api/products/123</span><br></pre></td></tr></table></figure>
<p>删除一个Product使用DELETE请求，例如，删除id为<code>123</code>的Product，其URL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /api/products/123</span><br></pre></td></tr></table></figure>
<p>资源还可以按层次组织。例如，获取某个Product的所有评论，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products/123/reviews</span><br></pre></td></tr></table></figure>
<p>当我们只需要获取部分数据时，可通过参数限制返回的结果集，例如，返回第2页评论，每页10项，按时间排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/products/123/reviews?page=2&amp;size=10&amp;sort=time</span><br></pre></td></tr></table></figure>
<h3 id="koa处理REST">koa处理REST</h3>
<p>既然我们已经使用koa作为Web框架处理HTTP请求，因此，我们仍然可以在koa中响应并处理REST请求。</p>
<p>我们复制上一节的工程，重命名为<code>koa-rest</code>，然后准备添加REST API。</p>
<p>对于controller来说，我们只要返回如下内容即可视为一个REST API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="property">body</span> =  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">12345</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&#x27;A rest api&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>koa检测到<code>ctx.body</code>的赋值是一个JavaScript对象时，自动把这个Object变成JSON字符串输出，无需任何额外配置和代码。</p>
<p>提示</p>
<p>ctx.body是ctx.response.body的引用，两者是等同的。</p>
<p>我们给<code>signin.mjs</code>添加两个REST API：</p>
<ul>
<li><code>GET /api/users/:id</code>：根据id获取用户信息；</li>
<li><code>POST /api/signin</code>：发送一个POST请求，并返回登录结果。</li>
</ul>
<p>获取用户信息的async函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /api/users/:id</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">user_info</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> id = ctx.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">    <span class="keyword">if</span> (id === <span class="string">&#x27;12345&#x27;</span>) &#123;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">12345</span>,</span><br><span class="line">            <span class="attr">email</span>: <span class="string">&#x27;admin@example.com&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">error</span>: <span class="string">&#x27;USER_NOT_FOUND&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理登录请求的async函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (email === <span class="string">&#x27;admin@example.com&#x27;</span> &amp;&amp; password === <span class="string">&#x27;123456&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">12345</span>,</span><br><span class="line">            <span class="attr">email</span>: email,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">body</span> = &#123;</span><br><span class="line">            <span class="attr">error</span>: <span class="string">&#x27;SIGNIN_FAILED&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发生错误时，返回的信息包含<code>error</code>字段，客户端依靠该字段来判断是否出错。</p>
<p>最后导出URL处理函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="string">&#x27;POST /api/signin&#x27;</span>: signin,</span><br><span class="line">    <span class="string">&#x27;GET /api/users/:id&#x27;</span>: user_info</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以直接在浏览器测试GET请求：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest-get-ok.png" alt="GET OK"></p>
<p>输入无效的ID，返回错误：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/rest-get-error.png" alt="GET ERROR"></p>
<p>对于POST请求，我们无法直接在浏览器测试，可以用<code>curl</code>命令测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">-d &#x27;&#123;&quot;email&quot;:&quot;admin@example.com&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&#x27; \</span><br><span class="line">http://localhost:3000/api/signin</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 12345,</span><br><span class="line">  &quot;email&quot;: &quot;admin@example.com&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;Bob&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入错误的口令，返回错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">-d &#x27;&#123;&quot;email&quot;:&quot;admin@example.com&quot;,&quot;password&quot;:&quot;invalid&quot;&#125;&#x27; \</span><br><span class="line">http://localhost:3000/api/signin</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &quot;SIGNIN_FAILED&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们把登录从传统的POST表单改成了REST，因此，前端页面需要编写JavaScript代码来发送REST请求，修改HTML如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 给form加上onsubmit回调函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;signin-form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return signin()&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用JavaScript发送REST请求如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取表单输入:</span></span><br><span class="line">    <span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#signin-form&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> email = form.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=email]&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> password = form.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=password]&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="comment">// REST请求的数据:</span></span><br><span class="line">    <span class="keyword">let</span> data = &#123;</span><br><span class="line">        <span class="attr">email</span>: email,</span><br><span class="line">        <span class="attr">password</span>: password</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 发送请求:</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/api/signin&#x27;</span>, &#123;</span><br><span class="line">        <span class="comment">// 以POST方式发送:</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="comment">// Content-Type设置为JSON:</span></span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 发送数据序列化为JSON:</span></span><br><span class="line">        <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 收到响应后解析JSON数据:</span></span><br><span class="line">        resp.<span class="title function_">json</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 解析后的数据:</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">            <span class="comment">// 判断是否有error字段:</span></span><br><span class="line">            <span class="keyword">if</span> (result.<span class="property">error</span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">`Sign in failed: <span class="subst">$&#123;result.error&#125;</span>`</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 登录成功,取出name字段:</span></span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">`Welcome, <span class="subst">$&#123;result.name&#125;</span>!`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 必须返回false以取消浏览器自动提交表单:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，在koa中处理REST请求是非常简单的。<code>bodyParser()</code>这个middleware可以解析请求的JSON数据并绑定到<code>ctx.request.body</code>上，输出JSON时我们把JavaScript对象赋值给<code>ctx.response.body</code>就完成了REST请求的处理。</p>
<h3 id="参考源码-12">参考源码</h3>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/koa/rest/koa-rest.zip">koa-rest</a></p>
<p>程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。</p>
<p>而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td>Michael</td>
<td>99</td>
</tr>
<tr>
<td>Bob</td>
<td>85</td>
</tr>
<tr>
<td>Bart</td>
<td>59</td>
</tr>
<tr>
<td>Lisa</td>
<td>87</td>
</tr>
</tbody>
</table>
<p>我们可以用一个文本文件保存，一行保存一个学生，用<code>,</code>隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Michael,99</span><br><span class="line">Bob,85</span><br><span class="line">Bart,59</span><br><span class="line">Lisa,87</span><br></pre></td></tr></table></figure>
<p>还可以用JSON格式保存，也是文本文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Michael&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">99</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">85</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Bart&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">59</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Lisa&quot;</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">87</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>还可以定义各种保存格式，但是问题来了：</p>
<p>存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；</p>
<p>不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存，根本无法全部读入内存。</p>
<p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p>
<p>数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。</p>
<p>关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：</p>
<p>假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_grade.jpg" alt="grade"></p>
<p>每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_class.jpg" alt="class"></p>
<p>这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_relationship.jpg" alt="grade-classes"></p>
<p>也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。</p>
<p>根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> classes <span class="keyword">WHERE</span> grade_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果也是一个表：</p>
<table>
<thead>
<tr>
<th>grade_id</th>
<th>class_id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>11</td>
<td>一年级一班</td>
</tr>
<tr>
<td>1</td>
<td>12</td>
<td>一年级二班</td>
</tr>
<tr>
<td>1</td>
<td>13</td>
<td>一年级三班</td>
</tr>
</tbody>
</table>
<p>类似的，Class表的一行记录又可以关联到Student表的多行记录：</p>
<p><img src="https://liaoxuefeng.com/books/javascript/nodejs/web/database/table_relationship2.jpg" alt="class-students"></p>
<p>由于本教程不涉及到关系数据库的详细内容，如果你想从零学习关系数据库和基本的SQL语句，请参考<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/sql/index.html">SQL教程</a>。</p>
<h3 id="NoSQL">NoSQL</h3>
<p>你也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被他们忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？</p>
<h3 id="数据库类别">数据库类别</h3>
<p>既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：</p>
<p>付费的商用数据库：</p>
<ul>
<li>Oracle，典型的高富帅；</li>
<li>SQL Server，微软自家产品，Windows定制专款；</li>
<li>DB2，IBM的产品，听起来挺高端；</li>
<li>Sybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡。</li>
</ul>
<p>这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：</p>
<ul>
<li>MySQL，大家都在用，一般错不了；</li>
<li>PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；</li>
<li>SQLite，嵌入式数据库，适合桌面和移动应用。</li>
</ul>
<p>作为一个JavaScript全栈工程师，选择哪个免费数据库呢？这里我们用SQLite，作为嵌入式数据库，优点是不用安装任何软件，直接能用。当然，在生产环境下，应当选择MySQL或者PostgreSQL。</p>
<p>在Node.js中，访问不同的数据库需要安装不同的数据库驱动。</p>
<p>因为我们使用Sqlite，所以需要安装Sqlite的驱动。这里我们选择<code>sqlite3</code>这个驱动，它内置sqlite。</p>
<p><code>sqlite3</code>通过如下代码可以创建一个<code>db</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定模式打开test.db:</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="keyword">new</span> sqlite3.<span class="title class_">Database</span>(<span class="string">&#x27;test.db&#x27;</span>, sqlite3.<span class="property">OPEN_READWRITE</span> | sqlite3.<span class="property">OPEN_CREATE</span> | sqlite3.<span class="property">OPEN_FULLMUTEX</span>);</span><br></pre></td></tr></table></figure>
<p>我们传入了<code>OPEN_CREATE</code>参数，表示如果数据库不存在则自动创建，在开发模式下非常方便。</p>
<p><code>sqlite3</code>使用回调模式执行查询和更新操作，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query:</span></span><br><span class="line">db.<span class="title function_">all</span>(<span class="string">&#x27;SELECT * FROM users WHERE id=?&#x27;</span>, [<span class="number">1</span>], <span class="keyword">function</span> (<span class="params">err, rows</span>) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// update:</span></span><br><span class="line">db.<span class="title function_">run</span>(<span class="string">&#x27;UPDATE users SET name=? WHERE id=?&#x27;</span>, [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">1</span>], <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调模式写起来非常别扭，由于<code>sqlite3</code>没有提供Promise接口，因此无法使用await调用，怎么办？</p>
<p>答案是我们自己封装一个Promise调用，以便通过await来实现异步查询和更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.mjs:</span></span><br><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">from</span> <span class="string">&#x27;sqlite3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createDatabase</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> db = <span class="keyword">new</span> sqlite3.<span class="title class_">Database</span>(file, sqlite3.<span class="property">OPEN_READWRITE</span> | sqlite3.<span class="property">OPEN_CREATE</span> | sqlite3.<span class="property">OPEN_FULLMUTEX</span>);</span><br><span class="line">    <span class="keyword">const</span> wrapper = &#123;</span><br><span class="line">        <span class="attr">db</span>: db</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 执行update:</span></span><br><span class="line">    wrapper.<span class="property">update</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> sql = strs.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            db.<span class="title function_">run</span>(sql, ...params, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">changes</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 执行insert并返回lastID:</span></span><br><span class="line">    wrapper.<span class="property">insert</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> sql = strs.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            db.<span class="title function_">run</span>(sql, ...params, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">lastID</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 查询数据,返回array:</span></span><br><span class="line">    wrapper.<span class="property">select</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> sql = strs.<span class="title function_">join</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`sql = <span class="subst">$&#123;sql&#125;</span>, params = [<span class="subst">$&#123;params.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>]`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            db.<span class="title function_">all</span>(sql, ...params, <span class="keyword">function</span> (<span class="params">err, rows</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(rows);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 查询一行数据,不存在返回null:</span></span><br><span class="line">    wrapper.<span class="property">fetch</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">strs, ...params</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们复制前面的<code>koa-mvc</code>工程，命名为<code>sql</code>，准备用实际数据库替换写死的登录逻辑。工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── db.mjs</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>通过<code>npm install sqlite3</code>安装依赖项并添加依赖：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;sqlite3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.1.7&quot;</span></span><br></pre></td></tr></table></figure>
<p>增加了<code>db.mjs</code>，实现了对sqlite数据库的操作。</p>
<p>我们在<code>app.mjs</code>中初始化一个<code>db</code>对象并绑定到<code>app.context</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createDatabase &#125; <span class="keyword">from</span> <span class="string">&#x27;./db.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">initDb</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> email = <span class="string">&#x27;admin@example.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">    <span class="comment">// 创建db对象:</span></span><br><span class="line">    <span class="keyword">const</span> db = <span class="title function_">createDatabase</span>(<span class="string">&#x27;test.db&#x27;</span>);</span><br><span class="line">    <span class="comment">// 如果users表不存在则创建表:</span></span><br><span class="line">    <span class="keyword">await</span> db.<span class="property">update</span><span class="string">`CREATE TABLE IF NOT EXISTS users(id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, email TEXT NOT NULL UNIQUE, name TEXT NOT NULL, password TEXT NOT NULL)`</span>;</span><br><span class="line">    <span class="comment">// 查询admin用户:</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> db.<span class="property">fetch</span><span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span>`</span>;</span><br><span class="line">    <span class="comment">// 用户不存在则自动创建:</span></span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> db.<span class="property">insert</span><span class="string">`INSERT INTO users (email, name, password) VALUES (<span class="subst">$&#123;email&#125;</span>, <span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;password&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> db;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定db到app.context:</span></span><br><span class="line">app.<span class="property">context</span>.<span class="property">db</span> = <span class="keyword">await</span> <span class="title function_">initDb</span>();</span><br></pre></td></tr></table></figure>
<p>注意到<code>initDb()</code>中自动创建表和用户的代码都是为了便于开发。</p>
<p>有了数据库支持，我们就可以把<code>signin.mjs</code>写死的代码替换为查询数据库用户：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signin:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 从数据库查询用户:</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> ctx.<span class="property">db</span>.<span class="property">fetch</span><span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">if</span> (user !== <span class="literal">null</span> &amp;&amp; user.<span class="property">password</span> === password) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-ok.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In OK&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: user.<span class="property">name</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-failed.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In Failed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，我们查询数据库中某个用户的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> ctx.<span class="property">db</span>.<span class="property">fetch</span><span class="string">`SELECT * FROM users WHERE email=<span class="subst">$&#123;email&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/function/tag-function/index.html">标签函数</a>，它自动将参数变为如下调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> ctx.<span class="property">db</span>.<span class="title function_">fetch</span>([<span class="string">&#x27;SELECT * FROM users WHERE email=&#x27;</span>, <span class="string">&#x27;&#x27;</span>], email);</span><br></pre></td></tr></table></figure>
<p>在函数内部，实际执行的SQL是<code>SELECT * FROM users WHERE email=?</code>，因此，通过标签函数，我们总是以参数化形式执行SQL，避免了SQL注入。</p>
<p>执行<code>node app.mjs</code>，可以看到页面效果，同时，后台会打印出执行的SQL语句与绑定的参数。</p>
<h3 id="参考">参考</h3>
<p>参考源码：<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/database/sql/sql.zip">sql</a></p>
<p>sqlite数据库：<a target="_blank" rel="noopener" href="https://www.sqlite.org/">sqlite</a></p>
<p>sqlite3文档：<a target="_blank" rel="noopener" href="https://github.com/TryGhost/node-sqlite3">sqlite3</a></p>
<p>直接使用<code>sqlite3</code>提供的接口，我们执行数据库操作时必须提供SQL语句，比较底层。</p>
<p>考虑到数据库表是一个二维表，包含多行多列，例如一个<code>users</code>的表：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>email</th>
<th>name</th>
<th>password</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="mailto:admin@example.com">admin@example.com</a></td>
<td>Bob</td>
<td>123456</td>
</tr>
<tr>
<td>2</td>
<td><a href="mailto:lucy@example.com">lucy@example.com</a></td>
<td>Lucy</td>
<td>abcdef</td>
</tr>
<tr>
<td>3</td>
<td><a href="mailto:alice@example.com">alice@example.com</a></td>
<td>Alice</td>
<td>hello123</td>
</tr>
</tbody>
</table>
<p>每一行可以用一个JavaScript对象表示，例如第一行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">email</span>: <span class="string">&#x27;admin@example.com&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。是不是很简单？</p>
<p>但是由谁来做这个转换呢？所以ORM框架应运而生。</p>
<p>我们选择Node的ORM框架Sequelize来操作数据库。这样，我们读写的都是JavaScript对象，Sequelize帮我们把对象变成数据库中的行。</p>
<p>用Sequelize查询<code>users</code>表，代码像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findAll</span>();</span><br></pre></td></tr></table></figure>
<p>根据<code>email</code>查询一个用户，代码像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">    <span class="attr">where</span>: &#123;</span><br><span class="line">        <span class="attr">email</span>: <span class="string">&#x27;admin@example.com&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Sequelize的所有操作都是Promise，所以我们可以用await实现异步调用。</p>
<h3 id="实战">实战</h3>
<p>在使用Sequelize操作数据库之前，我们需要告诉Sequelize如何映射数据库中的每一个表。</p>
<p>以<code>users</code>表为例，我们需要定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// orm.mjs:</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Sequelize</span>, <span class="title class_">DataTypes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;sequelize&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建sequelize对象表示已连接到数据库:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sequelize = <span class="keyword">new</span> <span class="title class_">Sequelize</span>(<span class="string">&#x27;sqlite:test.db&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义User:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">User</span> = sequelize.<span class="title function_">define</span>(<span class="string">&#x27;User&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 每一列的定义:</span></span><br><span class="line">    <span class="attr">id</span>: &#123;</span><br><span class="line">        <span class="attr">primaryKey</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">autoIncrement</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">INTEGER</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">email</span>: &#123;</span><br><span class="line">        <span class="attr">unique</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">password</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">DataTypes</span>.<span class="property">STRING</span>,</span><br><span class="line">        <span class="attr">allowNull</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="comment">// 指定表名:</span></span><br><span class="line">    <span class="attr">tableName</span>: <span class="string">&#x27;users&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在定义列的时候，主键以<code>primaryKey: true</code>指定，具有唯一约束的列用<code>unique: true</code>表示，数据类型用<code>DataTypes</code>表示。</p>
<p>这样Sequelize就有了足够的信息来实现ORM。最后将<code>sequelize</code>和<code>User</code>对象导出。</p>
<p>我们根据上一节的<code>sql</code>工程结构创建<code>orm</code>工程，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql/</span><br><span class="line">├── app.mjs</span><br><span class="line">├── orm.mjs</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>删除了<code>db.mjs</code>，增加<code>orm.mjs</code>。</p>
<p>然后，通过<code>npm install sequelize sqlite3</code>安装依赖项并添加依赖：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;sequelize&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.37.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sqlite3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.1.7&quot;</span></span><br></pre></td></tr></table></figure>
<p>在<code>app.mjs</code>中，删除相关SQL操作，改为通过Sequelize初始化数据库：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sequelize, <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./orm.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">initDb</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 自动创建数据库表, 仅限开发模式:</span></span><br><span class="line">    <span class="keyword">await</span> sequelize.<span class="title function_">sync</span>();</span><br><span class="line">    <span class="comment">// 查询admin用户:</span></span><br><span class="line">    <span class="keyword">const</span> email = <span class="string">&#x27;admin@example.com&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">        <span class="attr">where</span>: &#123;</span><br><span class="line">            <span class="attr">email</span>: email</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 不存在则自动创建:</span></span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">            <span class="attr">email</span>: email,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">            <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">initDb</span>();</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>使用Sequelize时，无需绑定<code>app.context</code>，因为我们主要通过具体的Model比如<code>User</code>来操作数据库。修改<code>signin.mjs</code>如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../orm.mjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// signin:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">signin</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> email = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">email</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> password = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 调用Model.findOne()查询一行记录:</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">        <span class="attr">where</span>: &#123;</span><br><span class="line">            <span class="attr">email</span>: email</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (user !== <span class="literal">null</span> &amp;&amp; user.<span class="property">password</span> === password) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin ok!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-ok.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In OK&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: user.<span class="property">name</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;signin failed!&#x27;</span>);</span><br><span class="line">        ctx.<span class="title function_">render</span>(<span class="string">&#x27;signin-failed.html&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Sign In Failed&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>node app.mjs</code>启动服务器，可以观察到Sequelize访问数据库时打印的SQL语句。这里需要注意的是，Sequelize会为每个Model自动添加一个<code>createdAt</code>和<code>updatedAt</code>字段，用来记录创建和更新时间。因此，创建的<code>users</code>表的SQL语句为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` (</span><br><span class="line">    `id` <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT,</span><br><span class="line">    `email` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `password` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `createdAt` DATETIME <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `updatedAt` DATETIME <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="常用操作">常用操作</h3>
<p>Sequelize提供了<code>findAll()</code>和<code>findOne()</code>两种查询，分别返回多行和一行。</p>
<p><code>create()</code>操作可以存储一个对象到数据库的一行记录，<code>save()</code>和<code>destroy()</code>分别对应更新和删除操作。</p>
<p>Sequelize还提供了一对多等高级ORM功能，具体可以参考官方文档。</p>
<h3 id="参考-2">参考</h3>
<p>参考源码：<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/nodejs/web/database/orm/orm.zip">orm</a></p>
<p>Sequelize：<a target="_blank" rel="noopener" href="https://sequelize.org/">官方网站</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2024/01/18/JavaScript/JavaScript-Node-js/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../../"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../3/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 2 頁 共 24 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
