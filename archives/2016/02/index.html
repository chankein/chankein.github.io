
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>所有文章: 2016/2 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://keinchan.com/archives/2016/02/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../#about"
            >
        
        
            <img class="header-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2016/02/20/database/MySQL-explain-%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/"
                            aria-label=": MySQL explain 应用详解"
                        >
                            MySQL explain 应用详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-02-20T11:11:11+08:00">
	
		    2016 年 2 月 20 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/database/">database</a>, <a class="category-link" href="../../../categories/database/mysql/">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<h3 id="什么是explain">什么是explain</h3>
</blockquote>
<p>使用explain可以模拟优化器执行SQL查询语句，从而知道MySQL怎么处理你的SQL语句的，分析你的查询语句和表结构的性能瓶颈。</p>
<blockquote>
<p>explain能够干什么</p>
</blockquote>
<ul>
<li>读取表的顺序</li>
<li>哪些索引能够被使用</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引能够被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被物理查询</li>
</ul>
<blockquote>
<h3 id="创建一个学习用的数据库">创建一个学习用的数据库</h3>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`mydb` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;</span><br><span class="line"></span><br><span class="line">USE `mydb`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `course` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `course`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `course` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">21</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `course` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert  into</span> `course`(`id`,`name`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;语文&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;高等数学&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;视听说&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;体育&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;马克思概况&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;民族理论&#x27;</span>),(<span class="number">7</span>,<span class="string">&#x27;毛中特&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;计算机基础&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;深度学习&#x27;</span>),(<span class="number">10</span>,<span class="string">&#x27;Java程序设计&#x27;</span>),(<span class="number">11</span>,<span class="string">&#x27;c语言程序设计&#x27;</span>),(<span class="number">12</span>,<span class="string">&#x27;操作系统&#x27;</span>),(<span class="number">13</span>,<span class="string">&#x27;计算机网络&#x27;</span>),(<span class="number">14</span>,<span class="string">&#x27;计算机组成原理&#x27;</span>),(<span class="number">15</span>,<span class="string">&#x27;数据结构&#x27;</span>),(<span class="number">16</span>,<span class="string">&#x27;数据分析&#x27;</span>),(<span class="number">17</span>,<span class="string">&#x27;大学物理&#x27;</span>),(<span class="number">18</span>,<span class="string">&#x27;数字逻辑&#x27;</span>),(<span class="number">19</span>,<span class="string">&#x27;嵌入式开发&#x27;</span>),(<span class="number">20</span>,<span class="string">&#x27;需求工程&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `stu_course` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `stu_course`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `stu_course` (</span><br><span class="line">  `sid` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `cid` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`sid`,`cid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `stu_course` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert  into</span> `stu_course`(`sid`,`cid`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">1</span>,<span class="number">14</span>),(<span class="number">1</span>,<span class="number">16</span>),(<span class="number">1</span>,<span class="number">19</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">8</span>),(<span class="number">2</span>,<span class="number">9</span>),(<span class="number">2</span>,<span class="number">14</span>),(<span class="number">3</span>,<span class="number">13</span>),(<span class="number">3</span>,<span class="number">14</span>),(<span class="number">3</span>,<span class="number">20</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">9</span>),(<span class="number">4</span>,<span class="number">11</span>),(<span class="number">4</span>,<span class="number">16</span>),(<span class="number">5</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">8</span>),(<span class="number">5</span>,<span class="number">9</span>),(<span class="number">5</span>,<span class="number">11</span>),(<span class="number">5</span>,<span class="number">12</span>),(<span class="number">5</span>,<span class="number">16</span>),(<span class="number">6</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="number">14</span>),(<span class="number">6</span>,<span class="number">17</span>),(<span class="number">7</span>,<span class="number">1</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">7</span>,<span class="number">15</span>),(<span class="number">8</span>,<span class="number">2</span>),(<span class="number">8</span>,<span class="number">3</span>),(<span class="number">8</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">17</span>),(<span class="number">9</span>,<span class="number">1</span>),(<span class="number">9</span>,<span class="number">7</span>),(<span class="number">9</span>,<span class="number">16</span>),(<span class="number">9</span>,<span class="number">20</span>),(<span class="number">10</span>,<span class="number">4</span>),(<span class="number">10</span>,<span class="number">12</span>),(<span class="number">10</span>,<span class="number">14</span>),(<span class="number">10</span>,<span class="number">20</span>),(<span class="number">11</span>,<span class="number">3</span>),(<span class="number">11</span>,<span class="number">9</span>),(<span class="number">11</span>,<span class="number">16</span>),(<span class="number">12</span>,<span class="number">3</span>),(<span class="number">12</span>,<span class="number">7</span>),(<span class="number">12</span>,<span class="number">9</span>),(<span class="number">12</span>,<span class="number">12</span>),(<span class="number">13</span>,<span class="number">1</span>),(<span class="number">13</span>,<span class="number">5</span>),(<span class="number">13</span>,<span class="number">13</span>),(<span class="number">14</span>,<span class="number">1</span>),(<span class="number">14</span>,<span class="number">3</span>),(<span class="number">14</span>,<span class="number">18</span>),(<span class="number">15</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">15</span>,<span class="number">9</span>),(<span class="number">15</span>,<span class="number">15</span>),(<span class="number">16</span>,<span class="number">2</span>),(<span class="number">16</span>,<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `student` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `student`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `student` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  KEY `name` (`name`),</span><br><span class="line">  KEY `name_age` (`name`,`age`),</span><br><span class="line">  KEY `id_name_age` (`id`,`name`,`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">31</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `student` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert  into</span> `student`(`id`,`name`,`age`) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">25</span>,<span class="string">&#x27;乾隆&#x27;</span>,<span class="number">17</span>),(<span class="number">14</span>,<span class="string">&#x27;关羽&#x27;</span>,<span class="number">43</span>),(<span class="number">13</span>,<span class="string">&#x27;刘备&#x27;</span>,<span class="number">12</span>),(<span class="number">28</span>,<span class="string">&#x27;刘永&#x27;</span>,<span class="number">12</span>),(<span class="number">21</span>,<span class="string">&#x27;后裔&#x27;</span>,<span class="number">12</span>),(<span class="number">30</span>,<span class="string">&#x27;吕子乔&#x27;</span>,<span class="number">28</span>),(<span class="number">18</span>,<span class="string">&#x27;嬴政&#x27;</span>,<span class="number">76</span>),(<span class="number">22</span>,<span class="string">&#x27;孙悟空&#x27;</span>,<span class="number">21</span>),(<span class="number">4</span>,<span class="string">&#x27;安其拉&#x27;</span>,<span class="number">24</span>),(<span class="number">6</span>,<span class="string">&#x27;宋江&#x27;</span>,<span class="number">22</span>),(<span class="number">26</span>,<span class="string">&#x27;康熙&#x27;</span>,<span class="number">51</span>),(<span class="number">29</span>,<span class="string">&#x27;张伟&#x27;</span>,<span class="number">26</span>),(<span class="number">20</span>,<span class="string">&#x27;张郃&#x27;</span>,<span class="number">12</span>),(<span class="number">12</span>,<span class="string">&#x27;张飞&#x27;</span>,<span class="number">32</span>),(<span class="number">27</span>,<span class="string">&#x27;朱元璋&#x27;</span>,<span class="number">19</span>),(<span class="number">11</span>,<span class="string">&#x27;李世民&#x27;</span>,<span class="number">54</span>),(<span class="number">9</span>,<span class="string">&#x27;李逵&#x27;</span>,<span class="number">12</span>),(<span class="number">8</span>,<span class="string">&#x27;林冲&#x27;</span>,<span class="number">43</span>),(<span class="number">5</span>,<span class="string">&#x27;橘右京&#x27;</span>,<span class="number">43</span>),(<span class="number">24</span>,<span class="string">&#x27;沙和尚&#x27;</span>,<span class="number">25</span>),(<span class="number">23</span>,<span class="string">&#x27;猪八戒&#x27;</span>,<span class="number">22</span>),(<span class="number">15</span>,<span class="string">&#x27;王与&#x27;</span>,<span class="number">21</span>),(<span class="number">19</span>,<span class="string">&#x27;王建&#x27;</span>,<span class="number">23</span>),(<span class="number">10</span>,<span class="string">&#x27;王莽&#x27;</span>,<span class="number">43</span>),(<span class="number">16</span>,<span class="string">&#x27;秦叔宝&#x27;</span>,<span class="number">43</span>),(<span class="number">17</span>,<span class="string">&#x27;程咬金&#x27;</span>,<span class="number">65</span>),(<span class="number">3</span>,<span class="string">&#x27;荆轲&#x27;</span>,<span class="number">21</span>),(<span class="number">2</span>,<span class="string">&#x27;诸葛亮&#x27;</span>,<span class="number">71</span>),(<span class="number">7</span>,<span class="string">&#x27;钟馗&#x27;</span>,<span class="number">23</span>),(<span class="number">1</span>,<span class="string">&#x27;鲁班&#x27;</span>,<span class="number">21</span>);</span><br></pre></td></tr></table></figure>
<p>这个数据库实际上的业务是:学生表 - 选课表 - 课程表</p>
<blockquote>
<h3 id="如何使用explain">如何使用explain</h3>
</blockquote>
<p>使用而<code>explain</code>很简单就是，在你书写的SQL语句加一个单词 - <code>explain</code>，然后将 <code>explain</code> + SQL执行后会出现一个表，这个表会告诉你MySQL优化器是怎样执行你的SQL的。</p>
<p>就比如执行下面一句语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure>
<p>MySQL会给你反馈下面一个信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table    partitions  type    possible_keys  key       key_len  ref       rows  filtered  Extra        </span><br><span class="line">------  -----------  -------  ----------  ------  -------------  --------  -------  ------  ------  --------  -------------</span><br><span class="line">     1  SIMPLE       student  (NULL)      index   (NULL)         name_age  68       (NULL)      30    100.00  Using index  </span><br></pre></td></tr></table></figure>
<p>具体这些信息是干什么的，会对你有什么帮助，会在下面告诉你。</p>
<blockquote>
<h4 id="explain各个字段代表的意思">explain各个字段代表的意思</h4>
</blockquote>
<ul>
<li>id ：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</li>
<li>select_type ：查询类型 或者是 其他操作类型</li>
<li>table ：正在访问哪个表</li>
<li>partitions ：匹配的分区</li>
<li>type ：访问的类型</li>
<li>possible_keys ：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到</li>
<li>key ：实际使用到的索引，如果为NULL，则没有使用索引</li>
<li>key_len ：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li>
<li>ref ：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</li>
<li>rows ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数</li>
<li>filtered ：查询的表行占表的百分比</li>
<li>Extra ：包含不适合在其它列中显示但十分重要的额外信息</li>
</ul>
<p>上面介绍了每个字段的意思，可以大体看一下，下面会逐一介绍每个字段表示的啥？该关注什么？</p>
<blockquote>
<h4 id="id与table字段">id与table字段</h4>
</blockquote>
<p>为什么要将<code>id</code>和<code>table</code>放在一起讲呢？因为通过这两个字段可以<strong>完全</strong>判断出你的每一条SQL语句的执行顺序和表的查询顺序。</p>
<p>先看<code>id</code>后看<code>table</code>，<code>id</code>和<code>table</code>在SQL执行判断过程中的关系就像是足球联赛的积分榜，首先一个联赛的球队排名应该先看积分，积分越高的球队排名越靠前，当两支或多只球队的积分一样高怎么办呢？那我们就看净胜球，净胜球越多的球队，排在前面。而在<code>explain</code>中你可以把id看作是球队积分，<code>table</code>当作是净胜球。</p>
<p>比如说我们<code>explain</code>一下这一条SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    S.id,S.name,S.age,C.id,C.name</span><br><span class="line"><span class="keyword">FROM</span> course C <span class="keyword">JOIN</span> stu_course SC <span class="keyword">ON</span> C.id <span class="operator">=</span> SC.cid</span><br><span class="line"><span class="keyword">JOIN</span> student S <span class="keyword">ON</span> S.id <span class="operator">=</span> SC.sid</span><br></pre></td></tr></table></figure>
<p>结果是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys        key      key_len  ref      </span><br><span class="line">------  -----------  ------  ----------  ------  -------------------  -------  -------  ----------- </span><br><span class="line">     1  SIMPLE       SC      (NULL)      index   PRIMARY              PRIMARY  8        (NULL)     </span><br><span class="line">     1  SIMPLE       C       (NULL)      eq_ref  PRIMARY              PRIMARY  4        mydb.SC.cid </span><br><span class="line">     1  SIMPLE       S       (NULL)      eq_ref  PRIMARY,id_name_age  PRIMARY  4        mydb.SC.sid </span><br></pre></td></tr></table></figure>
<p>我们看到<code>id</code>全是1，那就说明光看id这个值是看不出来每个表的读取顺序的，那我们就来看<code>table</code>这一行，它的读取顺序是<strong>自上向下</strong>的，所以，这三个表的读取顺序应当是：SC - C - S。</p>
<p>再来看一条SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> C </span><br><span class="line"><span class="keyword">WHERE</span> C.`id` <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> SC.`cid` </span><br><span class="line">    <span class="keyword">FROM</span> stu_course <span class="keyword">AS</span> SC </span><br><span class="line">    <span class="keyword">WHERE</span> SC.`sid` <span class="operator">=</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> </span><br><span class="line">            S.`id` </span><br><span class="line">        <span class="keyword">FROM</span> student <span class="keyword">AS</span> S</span><br><span class="line">        <span class="keyword">WHERE</span>  S.`name` <span class="operator">=</span> &quot;安其拉&quot;</span><br><span class="line">    ) <span class="keyword">ORDER</span> <span class="keyword">BY</span> SC.`cid` LIMIT <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这条语句是查询结果是：一个叫安其拉的学生选的课里面，课程<code>id</code>最小的一门课的信息，然后来看一下<code>explain</code>的结果吧！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      key_len  ref    </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  -------  ------  </span><br><span class="line">     1  PRIMARY      C       (NULL)      const   PRIMARY        PRIMARY  4        const   </span><br><span class="line">     2  SUBQUERY     SC      (NULL)      ref     PRIMARY        PRIMARY  4        const  </span><br><span class="line">     3  SUBQUERY     S       (NULL)      ref     name,name_age  name     63       const </span><br></pre></td></tr></table></figure>
<p>此时我们发现id是不相同的，所以我们很容易就看出表读取的顺序了是吧！C - SC - S</p>
<p>注意！！！！！！你仔细看一下最里面的子查询是查询的哪个表，是S这张表，然后外面一层呢？是SC这张表，最外面这一层呢？是C这张表，所以执行顺序应该是啥呢？是…是…难道是S - SC - C吗？是<code>id</code>越大的<code>table</code>读取越在前面吗？是的！这就像刚才说的足球联赛积分，分数越高的球队的排序越靠前。</p>
<p>当然还有下面这种情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> C </span><br><span class="line"><span class="keyword">WHERE</span> C.`id` <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> SC.`cid` </span><br><span class="line">    <span class="keyword">FROM</span> stu_course <span class="keyword">AS</span> SC </span><br><span class="line">    <span class="keyword">WHERE</span> SC.`sid` <span class="operator">=</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> </span><br><span class="line">            S.`id` </span><br><span class="line">        <span class="keyword">FROM</span> student <span class="keyword">AS</span> S</span><br><span class="line">        <span class="keyword">WHERE</span>  S.`name` <span class="operator">=</span> &quot;安其拉&quot;</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个查询是：查询安其拉选课的课程信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      key_len  ref           </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  -------  ----------- </span><br><span class="line">     1  PRIMARY      SC      (NULL)      ref     PRIMARY        PRIMARY  4        const       </span><br><span class="line">     1  PRIMARY      C       (NULL)      eq_ref  PRIMARY        PRIMARY  4        mydb.SC.cid </span><br><span class="line">     3  SUBQUERY     S       (NULL)      ref     name,name_age  name     63       const        </span><br></pre></td></tr></table></figure>
<p>结果很明确：先看<code>id</code>应该是S表最先被读取，SC和C表<code>id</code>相同，然后table中SC更靠上，所以第二张读取的表应当是SC，最后读取C。</p>
<blockquote>
<h4 id="select-type字段">select_type字段</h4>
</blockquote>
<ul>
<li>
<p><code>SIMPLE</code> 简单查询，不包括子查询和<code>union</code>查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">JOIN</span> stu_course <span class="keyword">ON</span> student.`id` <span class="operator">=</span> sid</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table       partitions  type    possible_keys        key      </span><br><span class="line">------  -----------  ----------  ----------  ------  -------------------  --------  </span><br><span class="line">     1  SIMPLE       student     (NULL)      index   PRIMARY,id_name_age  name_age  </span><br><span class="line">     1  SIMPLE       stu_course  (NULL)      ref     PRIMARY              PRIMARY  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>PRIMARY</code> 当存在子查询时，最外面的查询被标记为主查询</p>
</li>
<li>
<p><code>SUBQUERY</code> 子查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> SC.`cid` </span><br><span class="line"><span class="keyword">FROM</span> stu_course <span class="keyword">AS</span> SC </span><br><span class="line"><span class="keyword">WHERE</span> SC.`sid` <span class="operator">=</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        S.`id` </span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">AS</span> S</span><br><span class="line">    <span class="keyword">WHERE</span>  S.`name` <span class="operator">=</span> &quot;安其拉&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      key_len  ref      </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  -------  ------ </span><br><span class="line">     1  PRIMARY      SC      (NULL)      ref     PRIMARY        PRIMARY  4        const  </span><br><span class="line">     2  SUBQUERY     S       (NULL)      ref     name,name_age  name     63       const   </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>UNION</code> 当一个查询在<code>UNION</code>关键字之后就会出现<code>UNION</code></p>
</li>
<li>
<p><code>UNION RESULT</code> 连接几个表查询后的结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type   table       partitions  type    possible_keys        key      </span><br><span class="line">------  ------------  ----------  ----------  ------  -------------------  ------- </span><br><span class="line">     1  PRIMARY       student     (NULL)      const   PRIMARY,id_name_age  PRIMARY  </span><br><span class="line">     2  UNION         student     (NULL)      const   PRIMARY,id_name_age  PRIMARY </span><br><span class="line">(NULL)  UNION RESULT  &lt;union1,2&gt;  (NULL)      ALL     (NULL)               (NULL)   </span><br></pre></td></tr></table></figure>
<p>上面可以看到第三行<code>table</code>的值是<code>&lt;union1,2&gt;</code></p>
</li>
<li>
<p><code>DERIVED</code> 在<code>FROM</code>列表中包含的子查询被标记为<code>DERIVED</code>（衍生），MySQL<br>
会递归执行这些子查询，把结果放在临时表中<br>
MySQL5.7+ 进行优化了，增加了derived_merge（派生合并），默认开启，可加快查询效率</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sun_ashe/article/details/89522394">如果你想了解更详细的派生合并请点击这里</a></p>
<p>当你的MySQL是5.7及以上版本时你要将derived_merge关闭后才能看到<code>DERIVED</code> 状态</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session optimizer_switch<span class="operator">=</span><span class="string">&#x27;derived_merge=off&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;derived_merge=off&#x27;</span>; </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">    <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">JOIN</span> stu_course <span class="keyword">AS</span> SC </span><br><span class="line">    <span class="keyword">ON</span> S.`id` <span class="operator">=</span> SC.`sid`</span><br><span class="line">) <span class="keyword">AS</span> SSC</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table       partitions  type    possible_keys        key       </span><br><span class="line">------  -----------  ----------  ----------  ------  -------------------  -------- </span><br><span class="line">     1  PRIMARY      &lt;derived2&gt;  (NULL)      ALL     (NULL)               (NULL)    </span><br><span class="line">     2  DERIVED      S           (NULL)      index   PRIMARY,id_name_age  name_age </span><br><span class="line">     2  DERIVED      SC          (NULL)      ref     PRIMARY              PRIMARY  </span><br></pre></td></tr></table></figure>
<p>上面我们观察，最外层的主查询的表是<derived2>,而S和SC表的<code>select_type</code>都是<code>DERIVED</code>,这说明S和SC都被用来做衍生查询，而这两张表查询的结果组成了名为<derived2>的衍生表，而衍生表的命名就是<code>&lt;select_type + id&gt;</code>。</p>
</li>
</ul>
<blockquote>
<h4 id="partitions字段">partitions字段</h4>
</blockquote>
<p>该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。</p>
<blockquote>
<h4 id="type字段">type字段</h4>
</blockquote>
<p><strong>注意！！！注意！！！重点来了！</strong></p>
<p>首先说一下这个字段，要记住以下10个状态，（从左往右，越靠左边的越优秀）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>NULL</code> MySQL能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引</p>
<p>有没有这样一种疑惑，不查询索引也不查询表那你的数据是从哪里来的啊？谁说<code>SELECT</code>语句必须查询某样东西了？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">5</span><span class="operator">*</span><span class="number">7</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key     </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  ------ </span><br><span class="line">     1  SIMPLE       (NULL)  (NULL)      (NULL)  (NULL)         (NULL) </span><br></pre></td></tr></table></figure>
<p>我就简简单单算个数不好吗？好啊😊。。。</p>
<p>但是！！如果只是这样的话我们还<code>explain</code>个毛线啊！我很闲吗？</p>
<p>存在这样一种情况，大家都知道索引是将数据在B+Tree中进行排序了，所以你的查询速率才这么高，那么B+树的最边上的叶子节点是不是要么是最大值要么是最小值啊？既然你都知道了，那MySQL比你更知道啊！当你要查询最大值或者最小值时，MySQL会直接到你的索引得分叶子节点上直接拿，所以不用访问表或者索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(id) <span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key    </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  ------ </span><br><span class="line">     1  SIMPLE       (NULL)  (NULL)      (NULL)  (NULL)         (NULL) </span><br></pre></td></tr></table></figure>
<p>但是！你要记住，<code>NULL</code>的前提是你已经建立了索引。</p>
</li>
<li>
<p><code>SYSTEM</code> 表只有一行记录（等于系统表），这是<code>const</code>类型的特列，平时不大会出现，可以忽略。</p>
</li>
<li>
<p><code>const</code> 表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或<code>uique</code>索引，因为只匹配一行数据，所以很快，如主键置于<code>where</code>列表中，MySQL就能将该查询转换为一个常量。</p>
<p>简单来说，<code>const</code>是直接按主键或唯一键读取。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      const   PRIMARY        PRIMARY  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>eq_ref</code> 用于联表查询的情况，按联表的主键或唯一键联合查询。</p>
<p>多表<code>join</code>时，对于来自前面表的每一行，在<strong>当前表中只能找到一行</strong>。这可能是除了<code>system</code>和<code>const</code>之外最好的类型。当主键或唯一非<code>NULL</code>索引的所有字段都被用作<code>join</code>联接时会使用此类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">JOIN</span> stu_course <span class="keyword">AS</span> SC <span class="keyword">ON</span>  S.`id` <span class="operator">=</span> SC.`cid`</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key     </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  </span><br><span class="line">     1  SIMPLE       SC      (NULL)      index   (NULL)         PRIMARY  </span><br><span class="line">     1  SIMPLE       S       (NULL)      eq_ref  PRIMARY        PRIMARY </span><br></pre></td></tr></table></figure>
<p>以上面查询为例，我们观察<code>id</code>和<code>table</code>会知道，先是从SC表中取出一行数据，然后再S表查找匹配的数据，我们观察，SC中取出cid和S表中的id比较，毫无疑问因为id是S表中的主键（不重复），所以只能出现一个id与cid的值相同。所以！满足条件 S 表的 <code>type</code>为<code>eq_ref</code>。</p>
</li>
<li>
<p><code>ref</code> 可以用于单表扫描或者连接。如果是连接的话，驱动表的一条记录能够在被驱动表中通过非唯一（主键）属性所在索引中匹配多行数据，或者是在单表查询的时候通过非唯一（主键）属性所在索引中查到一行数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">JOIN</span> stu_course <span class="keyword">AS</span> SC <span class="keyword">ON</span> S.id <span class="operator">=</span> SC.`sid`</span><br></pre></td></tr></table></figure>
<p>不要在意SQL，以上SQL没有实际查询的意义只是用于表达用例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key      </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  -------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      ALL     PRIMARY        (NULL)   </span><br><span class="line">     1  SIMPLE       SC      (NULL)      ref     PRIMARY        PRIMARY  </span><br></pre></td></tr></table></figure>
<p>SC的主键索引是（cid,sid）所以sid列中肯定是重复的数据，虽然在后面的<code>key</code>中显示使用了主键索引。然后，就很明确了S.id一行能在SC表中通过索引查询到多行数据。</p>
<p>下面是单表了，写一个例子，但是不细讲了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">WHERE</span> S.`name` <span class="operator">=</span> &quot;张飞&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key        </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  ---------- </span><br><span class="line">     1  SIMPLE       S       (NULL)      ref     index_name     index_name</span><br></pre></td></tr></table></figure>
<p>注意<code>name</code>字段是有索引的哈！！！</p>
</li>
<li>
<p><code>ref_or_null</code> 类似ref，但是可以搜索值为<code>NULL</code>的行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">WHERE</span> S.`name` <span class="operator">=</span> &quot;张飞&quot; <span class="keyword">OR</span> S.`name` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type         possible_keys  key        </span><br><span class="line">------  -----------  ------  ----------  -----------  -------------  ----------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      ref_or_null  index_name     index_name  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>index_merge</code> 表示查询使用了两个以上的索引，最后取交集或者并集，常见<code>and</code> ，<code>or</code>的条件使用了不同的索引，官方排序这个在<code>ref_or_null</code>之后，但是实际上由于要读取多个索引，性能可能大部分时间都不如<code>range</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> S <span class="keyword">WHERE</span> S.`name` <span class="keyword">LIKE</span> &quot;张%&quot; <span class="keyword">OR</span> S.`age` <span class="operator">=</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type         possible_keys         key                   </span><br><span class="line">------  -----------  ------  ----------  -----------  --------------------  -------------------- </span><br><span class="line">     1  SIMPLE       S       (NULL)      index_merge  index_name,index_age  index_name,index_age </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>range</code> 索引范围查询，常见于使用 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN()或者like等运算符的查询中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> S.`age` <span class="keyword">FROM</span> student  <span class="keyword">AS</span> S <span class="keyword">WHERE</span> S.`age` <span class="operator">&gt;</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys         key         </span><br><span class="line">------  -----------  ------  ----------  ------  --------------------  ----------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      range   index_name,index_age  index_name  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>index</code> <code>index</code>只遍历索引树，通常比<code>All</code>快。因为，索引文件通常比数据文件小，也就是虽然<code>all</code>和<code>index</code>都是读全表，但<code>index</code>是从索引中读取的，而<code>all</code>是从硬盘读的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> S.`name` <span class="keyword">FROM</span> student <span class="keyword">AS</span> S </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table   partitions  type    possible_keys  key         </span><br><span class="line">------  -----------  ------  ----------  ------  -------------  ----------  </span><br><span class="line">     1  SIMPLE       S       (NULL)      index   (NULL)         index_name  </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ALL</code> 如果一个查询的<code>type</code>是<code>All</code>,并且表的数据量很大，那么请解决它！！！</p>
</li>
</ul>
<blockquote>
<h4 id="possible-keys字段">possible_keys字段</h4>
</blockquote>
<p>这个表里面存在且可能会被使用的索引，可能会在这个字段下面出现，但是一般都以<code>key</code>为准。</p>
<blockquote>
<h4 id="key字段">key字段</h4>
</blockquote>
<p>实际使用的索引，如果为<code>null</code>,则没有使用索引，否则会显示你使用了哪些索引，查询中若使用了覆盖索引（查询的列刚好是索引），则该索引仅出现在<code>key</code>列表。</p>
<blockquote>
<h4 id="ref字段">ref字段</h4>
</blockquote>
<p>显示哪些列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值。</p>
<blockquote>
<h4 id="rows字段和Filter字段">rows字段和Filter字段</h4>
</blockquote>
<p><code>rows</code>是根据表的统计信息和索引的选用情况，优化器大概帮你估算出你执行这行函数所需要查询的行数。</p>
<p><code>Filter</code>是查询的行数与总行数的比值。其实作用与<code>rows</code>差不多，都是数值越小，效率越高。</p>
<blockquote>
<h4 id="Extra字段">Extra字段</h4>
</blockquote>
<p>这一字段包含不适合在其他列显示，但是也非常重要的额外信息。</p>
<ul>
<li>
<p><code>Using filesort</code> 表示当SQL中有一个地方需要对一些数据进行排序的时候，优化器找不到能够使用的索引，所以只能使用外部的索引排序，外部排序就不断的在磁盘和内存中交换数据，这样就摆脱不了很多次磁盘IO，以至于SQL执行的效率很低。反之呢？由于索引的底层是B+Tree实现的，他的叶子节点本来就是有序的，这样的查询能不爽吗？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> course <span class="keyword">AS</span> C <span class="keyword">ORDER</span> <span class="keyword">BY</span> C.`name` </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type    possible_keys  key     key_len  ref       rows  filtered  Extra           </span><br><span class="line">------  -------------  ------  -------  ------  ------  --------  ----------------</span><br><span class="line">ALL     (NULL)         (NULL)  (NULL)   (NULL)      20    100.00  Using filesort  </span><br></pre></td></tr></table></figure>
<p>没有给<code>C.name</code>建立索引，所以在根据<code>C.name</code>排序的时候，他就使用了外部排序</p>
</li>
<li>
<p><code>Using tempporary</code> 表示在对MySQL查询结果进行排序时，使用了临时表,这样的查询效率是比外部排序更低的，常见于<code>order by</code>和<code>group by</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> C.`name` <span class="keyword">FROM</span> course <span class="keyword">AS</span> C <span class="keyword">GROUP</span> <span class="keyword">BY</span> C.`name`</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">possible_keys  key     key_len  ref       rows  filtered  Extra                            </span><br><span class="line">-------------  ------  -------  ------  ------  --------  ---------------------------------</span><br><span class="line">(NULL)         (NULL)  (NULL)   (NULL)      20    100.00  Using temporary; Using filesort  </span><br></pre></td></tr></table></figure>
<p>上面这个查询就是同时触发了<code>Using temporary</code>和<code>Using filesort</code>，可谓是雪上加霜。</p>
</li>
<li>
<p><code>Using index</code> 表示使用了索引，很优秀👍。</p>
</li>
<li>
<p><code>Using where</code> 使用了<code>where</code>但是好像没啥用。</p>
</li>
<li>
<p><code>Using join buffer</code> 表明使用了连接缓存,比如说在查询的时候，多表<code>join</code>的次数非常多，那么将配置文件中的缓冲区的<code>join buffer</code>调大一些。</p>
</li>
<li>
<p><code>impossible where</code> 筛选条件没能筛选出任何东西</p>
</li>
<li>
<p><code>distinct</code> 优化<code>distinct</code>操作，在找到第一匹配的元组后即停止找同样值的动作</p>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2016/02/20/database/MySQL-explain-%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2016/02/16/database/MySQL%E4%BC%98%E5%8C%96-12%E7%A7%8D%E6%8F%90%E5%8D%87SQL%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/"
                            aria-label=": MySQL优化:12种提升SQL执行效率的有效方法"
                        >
                            MySQL优化:12种提升SQL执行效率的有效方法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-02-16T10:46:38+08:00">
	
		    2016 年 2 月 16 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/database/">database</a>, <a class="category-link" href="../../../categories/database/mysql/">mysql</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>在数据库管理和优化的世界里，MySQL作为一个流行的关系型数据库管理系统，其性能优化是任何数据密集型应用成功的关键。优化MySQL数据库不仅可以显著提高SQL查询的效率，还能确保数据的稳定性和可靠性。</p>
<p>在本文中，我将介绍12种提升SQL执行效率的有效方法，并通过实用的代码示例来具体展示如何实施这些优化策略。</p>
<h2 id="1、使用索引优化查询">1、使用索引优化查询</h2>
<p><strong>使用场景</strong>：当你的数据库表中有大量数据，而你需要频繁进行搜索查询时，索引是提高查询效率的关键。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们有一个员工表 employees</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为department_id字段创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_department <span class="keyword">ON</span> employees(department_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用索引进行查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一步是创建一个包含<strong>id</strong>, <strong>name</strong>, <strong>department_id</strong>字段的<strong>employees</strong>表。</p>
<p>然后为<strong>department_id</strong>字段创建一个索引<strong>idx_department</strong>。这个操作会让基于<strong>department_id</strong>的查询更快。</p>
<p>最后，我们执行一个查询，利用创建的索引，从而提高查询效率。</p>
<h2 id="2、优化查询语句">2、优化查询语句</h2>
<p><strong>使用场景</strong>：避免使用高成本的SQL操作，如<strong>SELECT</strong> *，尽量指定需要的列，减少数据传输和处理时间。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不推荐的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一个查询语句使用了<strong>SELECT</strong> *，它会获取所有列，这在数据量大时非常低效。</p>
<p>第二个查询仅请求需要的<strong>id</strong>和<strong>name</strong>列，减少了数据处理的负担。</p>
<h2 id="3、使用查询缓存">3、使用查询缓存</h2>
<p><strong>使用场景</strong>：当相同的查询被频繁执行时，使用查询缓存可以避免重复的数据库扫描。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启用查询缓存</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> query_cache_size <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> query_cache_type <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行查询</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>通过设置<strong>query_cache_size</strong>和<strong>query_cache_type</strong>，我们启用了查询缓存。</p>
<p>当我们执行查询时，MySQL会检查缓存中是否已经有了该查询的结果，如果有，则直接返回结果，避免了重复的数据库扫描。</p>
<h2 id="4、避免全表扫描">4、避免全表扫描</h2>
<p><strong>使用场景</strong>：当表中数据量巨大时，全表扫描会非常耗时。通过使用合适的查询条件来避免全表扫描，可以显著提高查询效率。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们需要查询员工表中特定部门的员工</span></span><br><span class="line"><span class="comment">-- 不推荐的查询方式，会导致全表扫描</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">AND</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一个查询使用了模糊匹配<strong>LIKE</strong>，但缺乏有效的过滤条件，可能导致全表扫描。</p>
<p>第二个查询在<strong>name</strong>字段的模糊匹配前，增加了对<strong>department_id</strong>的条件过滤，这样就可以先缩小查找范围，避免全表扫描。</p>
<h2 id="5、使用JOIN代替子查询">5、使用JOIN代替子查询</h2>
<p><strong>使用场景</strong>：在需要关联多个表的复杂查询中，使用JOIN代替子查询可以提高查询效率。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们有一个部门表 departments</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> departments (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不推荐的子查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的JOIN查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.<span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.id <span class="keyword">WHERE</span> departments.name <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一个查询使用了子查询，这在执行时可能效率较低，特别是当子查询或主查询的结果集较大时。</p>
<p>第二个查询使用了<strong>JOIN</strong>操作，这通常比子查询更有效，尤其是在处理大型数据集时。</p>
<h2 id="6、合理分页">6、合理分页</h2>
<p><strong>使用场景</strong>：在处理大量数据的列表展示时，合理的分页策略可以减少单次查询的负担，提高响应速度。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们需要分页显示员工信息</span></span><br><span class="line"><span class="comment">-- 不推荐的分页方式，尤其是当offset值很大时</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">10000</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的分页方式，使用更高效的条件查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10000</span> LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>第一个查询使用了<strong>LIMIT</strong>和较大的偏移量<strong>offset</strong>，在大数据集上执行时会逐行扫描跳过大量记录，效率低下。</p>
<p>第二个查询通过在<strong>WHERE</strong>子句中添加条件来避免不必要的扫描，从而提高分页效率。</p>
<h2 id="7、利用分区提高性能">7、利用分区提高性能</h2>
<p><strong>使用场景</strong>：对于大型表，特别是那些行数以百万计的表，使用分区可以提高查询性能和数据管理效率。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设我们需要对一个大型的订单表 orders 进行分区</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (order_id)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> ( <span class="keyword">YEAR</span>(order_date) ) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p2020 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2021</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2021 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2022 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2023</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询特定年份的订单</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2021-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>我们为<strong>orders</strong>表创建了基于<strong>order_date</strong>字段的年份范围分区。</p>
<p>查询特定年份的数据时，MySQL只会在相关分区中搜索，提高了查询效率。</p>
<h2 id="8、利用批处理减少I-O操作">8、利用批处理减少I/O操作</h2>
<p><strong>使用场景</strong>：在进行大量数据插入或更新时，批处理可以减少数据库的I/O操作次数，从而提高性能。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量插入数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> employees (name, department_id)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;张三&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">&#x27;李四&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">&#x27;王五&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">    <span class="comment">-- 更多记录</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量更新数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> department_id <span class="operator">=</span> <span class="keyword">CASE</span> name</span><br><span class="line">    <span class="keyword">WHEN</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">THEN</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">WHEN</span> <span class="string">&#x27;李四&#x27;</span> <span class="keyword">THEN</span> <span class="number">2</span></span><br><span class="line">    <span class="comment">-- 更多条件</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">IN</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="comment">-- 更多名称);</span></span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>在批量插入示例中，我们一次性插入多条记录，而不是对每条记录进行单独的插入操作。</p>
<p>在批量更新示例中，我们使用<strong>CASE</strong>语句一次性更新多条记录，这比单独更新每条记录更有效率。</p>
<h2 id="9、使用临时表优化复杂查询">9、使用临时表优化复杂查询</h2>
<p><strong>使用场景</strong>：对于复杂的多步骤查询，使用临时表可以存储中间结果，从而简化查询并提高性能。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个临时表来存储中间结果</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_employees</span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> emp_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用临时表进行查询</span></span><br><span class="line"><span class="keyword">SELECT</span> departments.name, temp_employees.emp_count</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">JOIN</span> temp_employees <span class="keyword">ON</span> departments.id <span class="operator">=</span> temp_employees.department_id;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>首先，我们通过聚合查询创建了一个临时表<strong>temp_employees</strong>，用于存储每个部门的员工计数。</p>
<p>然后，我们将这个临时表与部门表<strong>departments</strong>进行连接查询，这样的查询通常比直接在原始表上执行复杂的聚合查询要高效。</p>
<h2 id="10、优化数据类型">10、优化数据类型</h2>
<p><strong>使用场景</strong>：在设计数据库表时，选择合适的数据类型对性能有显著影响。优化数据类型可以减少存储空间，提高查询效率。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原始表结构</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> example (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    description TEXT,</span><br><span class="line">    created_at DATETIME,</span><br><span class="line">    is_active <span class="type">BOOLEAN</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后的表结构</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> optimized_example (</span><br><span class="line">    id MEDIUMINT AUTO_INCREMENT,</span><br><span class="line">    description <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    created_at <span class="type">DATE</span>,</span><br><span class="line">    is_active TINYINT(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>在原始表中，使用了<strong>INT</strong>和<strong>TEXT</strong>这样的宽泛类型，这可能会占用更多的存储空间。</p>
<p>在优化后的表中，<strong>id</strong>字段改为<strong>MEDIUMINT</strong>，<strong>description</strong>改为长度有限的<strong>VARCHAR(255)</strong>，<strong>created_at</strong>只存储日期，而<strong>is_active</strong>使用**TINYINT(1)**来表示布尔值。这样的优化减少了每行数据的大小，提高了存储效率。</p>
<h2 id="11、避免使用函数和操作符">11、避免使用函数和操作符</h2>
<p><strong>使用场景</strong>：在WHERE子句中避免对列使用函数或操作符，可以让MySQL更有效地使用索引。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不推荐的查询方式，使用了函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(birth_date) <span class="operator">=</span> <span class="number">1980</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 推荐的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> birth_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;1980-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1980-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>在第一个查询中，使用**YEAR()**函数会导致MySQL无法利用索引，因为它必须对每行数据应用函数。</p>
<p>第二个查询直接使用日期范围，这样MySQL可以有效利用<strong>birth_date</strong>字段的索引。</p>
<h2 id="12、合理使用正规化和反正规化">12、合理使用正规化和反正规化</h2>
<p><strong>使用场景</strong>：数据库设计中的正规化可以减少数据冗余，而反正规化可以提高查询效率。合理平衡这两者，可以获得最佳性能。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正规化设计</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> departments (</span><br><span class="line">    department_id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (department_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (department_id) <span class="keyword">REFERENCES</span> departments(department_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 反正规化设计</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> employees_denormalized (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<p>在正规化设计中，<strong>departments</strong>和<strong>employees</strong>表被分开，减少了数据冗余，但可能需要JOIN操作来获取完整信息。</p>
<p>在反正规化设计中，<strong>employees_denormalized</strong>表通过直接包含部门信息来简化查询，提高读取性能，但可能会增加数据冗余和更新成本。</p>
<h2 id="总结">总结</h2>
<p>以上提到的优化方法只是众多MySQL优化技术中的一小部分。在实际应用中，应根据具体的数据模式和查询需求灵活选择最合适的优化策略。数据库优化是一个持续的过程，定期的性能评估和调优是保持数据库高效运行的关键。通过实践这些优化技巧，你可以显著提升数据库的性能和响应速度。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2016/02/16/database/MySQL%E4%BC%98%E5%8C%96-12%E7%A7%8D%E6%8F%90%E5%8D%87SQL%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 頁 共 1 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 235 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
