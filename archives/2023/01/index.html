
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>所有文章: 2023/1 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/archives/2023/01/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../#about"
            >
        
        
            <img class="header-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/30/Teraform/Terraform-%E5%B0%8F%E6%8A%80%E5%B7%A7/"
                            aria-label=": Terraform-小技巧"
                        >
                            Terraform-小技巧
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-30T17:43:45+08:00">
	
		    2023 年 1 月 30 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%88%9B%E5%BB%BA"><strong>1.9.1.1.</strong> 有条件创建</a></li>
</ul>
<p><a href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%88%9B%E5%BB%BA"></a></p>
<h2 id="1-9-1-1-有条件创建"><a href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%88%9B%E5%BB%BA"></a>1.9.1.1. 有条件创建</h2>
<p>Terraform被设计成声明式而非命令式，例如没有常见的 <code>if</code> 条件语句，后来才加上了 <code>count</code> 和 <code>for_each</code> 实现的循环语句(但循环的次数必须是在 <code>plan</code> 阶段就能够确认的，无法根据其他 <code>resource</code> 的输出动态决定)</p>
<p>有时候我们需要根据某种条件来判断是否创建一个资源。虽然我们无法使用if来完成条件判断，但我们还有 <code>count</code> 和 <code>for_each</code> 可以帮助我们完成这个目标。</p>
<p>我们以 UCloud 为例，假如我们正在编写一个旨在被复用的模块，模块的逻辑要创建一台虚拟机，我们的代码可以是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data ucloud_vpcs &quot;default&quot; &#123;</span><br><span class="line">  name_regex = &quot;^Default&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;centos&quot; &#123;</span><br><span class="line">  name_regex = &quot;^CentOS 7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  availability_zone = &quot;cn-bj2-02&quot;</span><br><span class="line">  image_id = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type = &quot;n-basic-2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;uhost_id&quot; &#123;</span><br><span class="line">  value = ucloud_instance.web.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单。但是如果我们想进一步，让模块的调用者决定创建的主机是否要搭配一个弹性公网 IP 该怎么办？</p>
<p>我们可以在上面的代码后面接上这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;allocate_public_ip&quot; &#123;</span><br><span class="line">  description = &quot;Decide whether to allocate a public ip and bind it to the host&quot;</span><br><span class="line">  type = bool</span><br><span class="line">  default = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_eip&quot; &quot;public_ip&quot; &#123;</span><br><span class="line">  count = var.allocate_public_ip ? 1 : 0</span><br><span class="line">  name = &quot;public_ip_for_$&#123;ucloud_instance.web.name&#125;&quot;</span><br><span class="line">  internet_type = &quot;bgp&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_eip_association&quot; &quot;public_ip_binding&quot; &#123;</span><br><span class="line">  count = var.allocate_public_ip ? 1 : 0</span><br><span class="line">  eip_id = ucloud_eip.public_ip[0].id</span><br><span class="line">  resource_id = ucloud_instance.web.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先创建了名为 <code>allocate_public_ip</code> 的输入变量，然后在编写弹性 IP 相关资源代码的时候都声明了 <code>count</code> 参数，值使用了条件表达式，根据 <code>allocate_public_ip</code> 这个输入变量的值决定是 <code>1</code> 还是 <code>0</code>。这实际上实现了按条件创建资源。</p>
<p>需要注意的是，由于我们使用了 <code>count</code>，所以现在弹性 IP 相关的资源实际上是多实例资源类型的。我们在 <code>ucloud_eip_association.public_ip_binding</code> 中引用 <code>ucloud_eip.public</code> 时，还是要加上访问下标。由于 <code>ucloud_eip_association.public_ip_binding</code> 与 <code>ucloud_eip.public</code> 实际上是同生同死，所以在这里他们之间的引用还比较简单；如果是其他没有声明 <code>count</code> 的资源引用它们的话，还要针对 <code>allocate_public_ip</code> 为 <code>false</code> 时 <code>ucloud_eip.public</code> 实际为空做相应处理，比如在 <code>output</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output &quot;public_ip&quot; &#123;</span><br><span class="line">  value = join(&quot;&quot;, ucloud_eip.public_ip[*].public_ip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>join</code> 函数就可以在即使没有创建弹性 IP 时也能返回空字符串。或者我们也可以用条件表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output &quot;public_ip&quot; &#123;</span><br><span class="line">  value = length(ucloud_eip.public_ip[*].public_ip) &gt; 0 ? ucloud_eip.public_ip[0].public_ip : &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC"><strong>1.9.2.1.</strong> 依赖反转</a></li>
</ul>
<p><a href="#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC"></a></p>
<h2 id="1-9-2-1-依赖反转"><a href="#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC"></a>1.9.2.1. 依赖反转</h2>
<p>Terraform 编排的基础设施对象彼此之间可能互相存在依赖关系，有时我们在编写一些旨在重用的模块时，模块内定义的资源可能本身需要依赖其他一些资源，这些资源可能已经存在，也可能有待创建。</p>
<p>举一个例子，假设我们编写了一个模块，定义了在 UCloud 上同一个 VPC 中的两台服务器；第一台服务器部署了一个 Web 应用，它被分配在一个 DMZ 子网里；第二台服务器部署了一个数据库，它被分配在一个内网子网里。现在的问题是，在我们编写模块时，我们并没有关于 VPC 和子网的任何信息，我们甚至连服务器应该部署在哪个可用区都不知道。VPC 和子网可能已经存在，也可以有待创建。</p>
<p>我们可以定义这样的一个模块代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    ucloud = &#123;</span><br><span class="line">      source  = &quot;ucloud/ucloud&quot;</span><br><span class="line">      version = &quot;~&gt;1.22.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;network_config&quot; &#123;</span><br><span class="line">  type = object(&#123;</span><br><span class="line">    vpc_id         = string</span><br><span class="line">    web_app_config = object(&#123;</span><br><span class="line">      az        = string</span><br><span class="line">      subnet_id = string</span><br><span class="line">    &#125;)</span><br><span class="line">    db_config      = object(&#123;</span><br><span class="line">      az        = string</span><br><span class="line">      subnet_id = string</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;web_app&quot; &#123;</span><br><span class="line">  name_regex = &quot;^WebApp&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;mysql&quot; &#123;</span><br><span class="line">  name_regex = &quot;^MySql 5.7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web_app&quot; &#123;</span><br><span class="line">  availability_zone = var.network_config.web_app_config.az</span><br><span class="line">  image_id          = data.ucloud_images.web_app.images[0].id</span><br><span class="line">  instance_type     = &quot;n-basic-2&quot;</span><br><span class="line">  vpc_id            = var.network_config.vpc_id</span><br><span class="line">  subnet_id         = var.network_config.web_app_config.subnet_id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;mysql&quot; &#123;</span><br><span class="line">  availability_zone = var.network_config.db_config.az</span><br><span class="line">  image_id          = data.ucloud_images.mysql.images[0].id</span><br><span class="line">  instance_type     = &quot;n-basic-2&quot;</span><br><span class="line">  vpc_id            = var.network_config.vpc_id</span><br><span class="line">  subnet_id         = var.network_config.db_config.subnet_id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中我们把依赖的网络参数定义为一个复杂类型，一个强类型对象结构。这样的话模块代码就不用再关注网络层究竟是查询而来的还是创建的，模块中只定义了抽象的网络层定义，其具体实现由调用者从外部注入，从而实现了依赖反转。</p>
<p>如果调用者需要创建网络层，那么代码可以是这样的(假设我们把前面编写的模块保存在 <code>./machine</code> 目录下而成为一个内嵌模块)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  cidr_blocks = [</span><br><span class="line">    &quot;192.168.0.0/16&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_subnet&quot; &quot;dmz&quot; &#123;</span><br><span class="line">  cidr_block = &quot;192.168.0.0/24&quot;</span><br><span class="line">  vpc_id     = ucloud_vpc.vpc.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_subnet&quot; &quot;db&quot; &#123;</span><br><span class="line">  cidr_block = &quot;192.168.1.0/24&quot;</span><br><span class="line">  vpc_id     = ucloud_vpc.vpc.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;machine&quot; &#123;</span><br><span class="line">  source         = &quot;./machine&quot;</span><br><span class="line">  network_config = &#123;</span><br><span class="line">    vpc_id         = ucloud_vpc.vpc.id</span><br><span class="line">    web_app_config = &#123;</span><br><span class="line">      az        = &quot;cn-bj2-02&quot;</span><br><span class="line">      subnet_id = ucloud_subnet.dmz.id</span><br><span class="line">    &#125;</span><br><span class="line">    db_config      = &#123;</span><br><span class="line">      az        = &quot;cn-bj2-02&quot;</span><br><span class="line">      subnet_id = ucloud_subnet.db.id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者我们想使用现存的网络来托管服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">data &quot;ucloud_vpcs&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  name_regex = &quot;^AVeryImportantVpc&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_subnets&quot; dmz_subnet &#123;</span><br><span class="line">  vpc_id     = data.ucloud_vpcs.vpc.vpcs[0].id</span><br><span class="line">  name_regex = &quot;^DMZ&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_subnets&quot; &quot;db_subnet&quot; &#123;</span><br><span class="line">  vpc_id     = data.ucloud_vpcs.vpc.vpcs[0].id</span><br><span class="line">  name_regex = &quot;^DataBase&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;machine&quot; &#123;</span><br><span class="line">  source         = &quot;./machine&quot;</span><br><span class="line">  network_config = &#123;</span><br><span class="line">    vpc_id         = data.ucloud_vpcs.vpc.vpcs[0].id</span><br><span class="line">    web_app_config = &#123;</span><br><span class="line">      az        = &quot;cn-bj2-02&quot;</span><br><span class="line">      subnet_id = data.ucloud_subnets.dmz_subnet.subnets[0].id</span><br><span class="line">    &#125;</span><br><span class="line">    db_config      = &#123;</span><br><span class="line">      az        = &quot;cn-bj2-02&quot;</span><br><span class="line">      subnet_id = data.ucloud_subnets.db_subnet.subnets[0].id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于模块代码中对网络层的定义是抽象的，并没有指定必须是 <code>resource</code> 或是 <code>data</code>，所以使得模块的调用者可以自己决定如何构造模块的依赖层，作为参数注入模块。</p>
<ul>
<li><a href="#%E5%A4%9A%E5%8F%AF%E7%94%A8%E5%8C%BA%E5%88%86%E5%B8%83"><strong>1.9.3.1.</strong> 多可用区分布</a></li>
</ul>
<p><a href="#%E5%A4%9A%E5%8F%AF%E7%94%A8%E5%8C%BA%E5%88%86%E5%B8%83"></a></p>
<h2 id="1-9-3-1-多可用区分布"><a href="#%E5%A4%9A%E5%8F%AF%E7%94%A8%E5%8C%BA%E5%88%86%E5%B8%83"></a>1.9.3.1. 多可用区分布</h2>
<p>这是一个相当常见的小技巧。多数公有云为了高可用性，都在单一区域内提供了多可用区的设计。一个可区是一个逻辑上的数据中心，单个可用区可能由于各种自然灾害、网络故障而导致不可用，所以公有云应用部署高可用应用应时刻考虑跨可用区设计。</p>
<p>假如我们想要创建 N 台不同的云主机实例，在 Terraform 0.12 之前的版本中，我们只能用 <code>count</code> 配合模运算来达成这个目的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;az&quot; &#123;</span><br><span class="line">  type    = list(string)</span><br><span class="line">  default = [</span><br><span class="line">    &quot;cn-bj2-03&quot;,</span><br><span class="line">    &quot;cn-bj2-04&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;instance_count&quot; &#123;</span><br><span class="line">  type    = number</span><br><span class="line">  default = 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;centos&quot; &#123;</span><br><span class="line">  name_regex = &quot;^CentOS 7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  count             = var.instance_count</span><br><span class="line">  availability_zone = var.az[count.index % length(var.az)]</span><br><span class="line">  image_id          = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type     = &quot;n-standard-1&quot;</span><br><span class="line">  charge_type       = &quot;dynamic&quot;</span><br><span class="line">  name              = &quot;$&#123;var.az[count.index % length(var.az)]&#125;-$&#123;floor(count.index/length(var.az))&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说就是使用 <code>count</code> 创建多实例资源时，用 <code>var.az[count.index % length(var.az)]</code> 可以循环使用每个可用区，使得机器尽可能均匀分布在各个可用区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply -auto-approve</span><br><span class="line">data.ucloud_images.centos: Refreshing state...</span><br><span class="line">ucloud_instance.web[2]: Creating...</span><br><span class="line">ucloud_instance.web[0]: Creating...</span><br><span class="line">ucloud_instance.web[1]: Creating...</span><br><span class="line">ucloud_instance.web[3]: Creating...</span><br><span class="line">ucloud_instance.web[2]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[0]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[1]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[3]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[2]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[0]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[1]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[3]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[2]: Creation complete after 22s [<span class="built_in">id</span>=uhost-txa2owrp]</span><br><span class="line">ucloud_instance.web[3]: Creation complete after 24s [<span class="built_in">id</span>=uhost-v3qxdbju]</span><br><span class="line">ucloud_instance.web[1]: Creation complete after 26s [<span class="built_in">id</span>=uhost-td3x545p]</span><br><span class="line">ucloud_instance.web[0]: Still creating... [30s elapsed]</span><br><span class="line">ucloud_instance.web[0]: Still creating... [40s elapsed]</span><br><span class="line">ucloud_instance.web[0]: Creation complete after 43s [<span class="built_in">id</span>=uhost-scq1prqj]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 4 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure>
<p>我们可以看一下创建的主机信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">$ terraform show</span><br><span class="line"><span class="comment"># data.ucloud_images.centos:</span></span><br><span class="line">data <span class="string">&quot;ucloud_images&quot;</span> <span class="string">&quot;centos&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">id</span>          = <span class="string">&quot;475496684&quot;</span></span><br><span class="line">    ids         = [</span><br><span class="line">        <span class="string">&quot;uimage-22noyd&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-3p0wg0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-4keil1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-aqvo5l&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-f1chxn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-hq5elw&quot;</span>,</span><br><span class="line">        <span class="string">&quot;uimage-rkn1v2&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">    images      = [</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-23T17:39:46+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.0 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.0 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-16T21:05:03+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-f1chxn&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.2 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.2 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-09-09T11:40:31+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot; &quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-aqvo5l&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.4 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.4 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2020-05-07T17:40:42+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">                <span class="string">&quot;CloudInit&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-hq5elw&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.6 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.6 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-16T21:05:05+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-3p0wg0&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.3 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.3 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-16T21:05:02+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-4keil1&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.1 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.1 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            availability_zone = <span class="string">&quot;cn-bj2-02&quot;</span></span><br><span class="line">            create_time       = <span class="string">&quot;2019-04-16T21:04:53+08:00&quot;</span></span><br><span class="line">            description       = <span class="string">&quot;&quot;</span></span><br><span class="line">            features          = [</span><br><span class="line">                <span class="string">&quot;NetEnhanced&quot;</span>,</span><br><span class="line">                <span class="string">&quot;HotPlug&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">            <span class="built_in">id</span>                = <span class="string">&quot;uimage-22noyd&quot;</span></span><br><span class="line">            name              = <span class="string">&quot;CentOS 7.5 64位&quot;</span></span><br><span class="line">            os_name           = <span class="string">&quot;CentOS 7.5 64位&quot;</span></span><br><span class="line">            os_type           = <span class="string">&quot;linux&quot;</span></span><br><span class="line">            size              = 20</span><br><span class="line">            status            = <span class="string">&quot;Available&quot;</span></span><br><span class="line">            <span class="built_in">type</span>              = <span class="string">&quot;base&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    most_recent = <span class="literal">false</span></span><br><span class="line">    name_regex  = <span class="string">&quot;^CentOS 7&quot;</span></span><br><span class="line">    total_count = 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ucloud_instance.web[1]:</span></span><br><span class="line">resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">    auto_renew        = <span class="literal">true</span></span><br><span class="line">    availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span></span><br><span class="line">    boot_disk_size    = 20</span><br><span class="line">    boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">    charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">    cpu               = 1</span><br><span class="line">    cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span></span><br><span class="line">    create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span></span><br><span class="line">    disk_set          = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">id</span>      = <span class="string">&quot;df06380a-00e1-42df-8c07-eec67d817f97&quot;</span></span><br><span class="line">            is_boot = <span class="literal">true</span></span><br><span class="line">            size    = 20</span><br><span class="line">            <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    expire_time       = <span class="string">&quot;2020-11-29T00:09:06+08:00&quot;</span></span><br><span class="line">    <span class="built_in">id</span>                = <span class="string">&quot;uhost-td3x545p&quot;</span></span><br><span class="line">    image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span></span><br><span class="line">    instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">    ip_set            = [</span><br><span class="line">        &#123;</span><br><span class="line">            internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">            ip            = <span class="string">&quot;10.9.44.37&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    memory            = 4</span><br><span class="line">    name              = <span class="string">&quot;cn-bj2-04-0&quot;</span></span><br><span class="line">    private_ip        = <span class="string">&quot;10.9.44.37&quot;</span></span><br><span class="line">    root_password     = (sensitive value)</span><br><span class="line">    security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">    status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">    subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">    tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">    vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ucloud_instance.web[2]:</span></span><br><span class="line">resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">    auto_renew        = <span class="literal">true</span></span><br><span class="line">    availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">    boot_disk_size    = 20</span><br><span class="line">    boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">    charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">    cpu               = 1</span><br><span class="line">    cpu_platform      = <span class="string">&quot;Intel/IvyBridge&quot;</span></span><br><span class="line">    create_time       = <span class="string">&quot;2020-11-28T23:09:01+08:00&quot;</span></span><br><span class="line">    disk_set          = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">id</span>      = <span class="string">&quot;1d7f07c9-7342-431b-85bb-d3ee0022063d&quot;</span></span><br><span class="line">            is_boot = <span class="literal">true</span></span><br><span class="line">            size    = 20</span><br><span class="line">            <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    expire_time       = <span class="string">&quot;2020-11-29T00:09:02+08:00&quot;</span></span><br><span class="line">    <span class="built_in">id</span>                = <span class="string">&quot;uhost-txa2owrp&quot;</span></span><br><span class="line">    image_id          = <span class="string">&quot;uimage-pxplaj&quot;</span></span><br><span class="line">    instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">    ip_set            = [</span><br><span class="line">        &#123;</span><br><span class="line">            internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">            ip            = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    memory            = 4</span><br><span class="line">    name              = <span class="string">&quot;cn-bj2-03-1&quot;</span></span><br><span class="line">    private_ip        = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">    root_password     = (sensitive value)</span><br><span class="line">    security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">    status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">    subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">    tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">    vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ucloud_instance.web[3]:</span></span><br><span class="line">resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">    auto_renew        = <span class="literal">true</span></span><br><span class="line">    availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span></span><br><span class="line">    boot_disk_size    = 20</span><br><span class="line">    boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">    charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">    cpu               = 1</span><br><span class="line">    cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span></span><br><span class="line">    create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span></span><br><span class="line">    disk_set          = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">id</span>      = <span class="string">&quot;31e2cad6-79a1-4475-a9f5-2c5c95605b18&quot;</span></span><br><span class="line">            is_boot = <span class="literal">true</span></span><br><span class="line">            size    = 20</span><br><span class="line">            <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    expire_time       = <span class="string">&quot;2020-11-29T00:09:04+08:00&quot;</span></span><br><span class="line">    <span class="built_in">id</span>                = <span class="string">&quot;uhost-v3qxdbju&quot;</span></span><br><span class="line">    image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span></span><br><span class="line">    instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">    ip_set            = [</span><br><span class="line">        &#123;</span><br><span class="line">            internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">            ip            = <span class="string">&quot;10.9.85.40&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    memory            = 4</span><br><span class="line">    name              = <span class="string">&quot;cn-bj2-04-1&quot;</span></span><br><span class="line">    private_ip        = <span class="string">&quot;10.9.85.40&quot;</span></span><br><span class="line">    root_password     = (sensitive value)</span><br><span class="line">    security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">    status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">    subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">    tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">    vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ucloud_instance.web[0]:</span></span><br><span class="line">resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">    auto_renew        = <span class="literal">true</span></span><br><span class="line">    availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">    boot_disk_size    = 20</span><br><span class="line">    boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">    charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">    cpu               = 1</span><br><span class="line">    cpu_platform      = <span class="string">&quot;Intel/IvyBridge&quot;</span></span><br><span class="line">    create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span></span><br><span class="line">    disk_set          = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">id</span>      = <span class="string">&quot;da27595d-9645-4883-bf95-87b9076ab7e4&quot;</span></span><br><span class="line">            is_boot = <span class="literal">true</span></span><br><span class="line">            size    = 20</span><br><span class="line">            <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    expire_time       = <span class="string">&quot;2020-11-29T00:09:04+08:00&quot;</span></span><br><span class="line">    <span class="built_in">id</span>                = <span class="string">&quot;uhost-scq1prqj&quot;</span></span><br><span class="line">    image_id          = <span class="string">&quot;uimage-pxplaj&quot;</span></span><br><span class="line">    instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">    ip_set            = [</span><br><span class="line">        &#123;</span><br><span class="line">            internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">            ip            = <span class="string">&quot;10.9.107.152&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">    memory            = 4</span><br><span class="line">    name              = <span class="string">&quot;cn-bj2-03-0&quot;</span></span><br><span class="line">    private_ip        = <span class="string">&quot;10.9.107.152&quot;</span></span><br><span class="line">    root_password     = (sensitive value)</span><br><span class="line">    security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">    status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">    subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">    tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">    vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主机的确是均匀地分散在两个可用区了。</p>
<p>但是这样做在调整可用区时会发生大问题，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;az&quot; &#123;</span><br><span class="line">  type = list(string)</span><br><span class="line">  default = [</span><br><span class="line">    &quot;cn-bj2-03&quot;,</span><br><span class="line">#    &quot;cn-bj2-04&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们禁用了 <code>cn-bj2-04</code> 可用区，按道理我们期待的变更计划应该是将两台原本属于 <code>cn-bj2-04</code> 的主机删除，在 <code>cn-bj2-03</code> 可用区新增两台主机。让我们看看会发生什么：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">$ terraform plan</span><br><span class="line">Refreshing Terraform state in-memory prior to plan...</span><br><span class="line">The refreshed state will be used to calculate this plan, but will not be</span><br><span class="line">persisted to <span class="built_in">local</span> or remote state storage.</span><br><span class="line"></span><br><span class="line">data.ucloud_images.centos: Refreshing state... [<span class="built_in">id</span>=475496684]</span><br><span class="line">ucloud_instance.web[0]: Refreshing state... [<span class="built_in">id</span>=uhost-scq1prqj]</span><br><span class="line">ucloud_instance.web[3]: Refreshing state... [<span class="built_in">id</span>=uhost-v3qxdbju]</span><br><span class="line">ucloud_instance.web[2]: Refreshing state... [<span class="built_in">id</span>=uhost-txa2owrp]</span><br><span class="line">ucloud_instance.web[1]: Refreshing state... [<span class="built_in">id</span>=uhost-td3x545p]</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">An execution plan has been generated and is shown below.</span><br><span class="line">Resource actions are indicated with the following symbols:</span><br><span class="line">  ~ update in-place</span><br><span class="line">-/+ destroy and <span class="keyword">then</span> create replacement</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[1] must be replaced</span></span><br><span class="line">-/+ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      ~ auto_renew        = <span class="literal">true</span> -&gt; (known after apply)</span><br><span class="line">      ~ availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03&quot;</span> <span class="comment"># forces replacement</span></span><br><span class="line">      ~ boot_disk_size    = 20 -&gt; (known after apply)</span><br><span class="line">      ~ boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; (known after apply)</span><br><span class="line">        charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      ~ cpu               = 1 -&gt; (known after apply)</span><br><span class="line">      ~ cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      ~ disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;df06380a-00e1-42df-8c07-eec67d817f97&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      ~ expire_time       = <span class="string">&quot;2020-11-29T00:09:06+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ <span class="built_in">id</span>                = <span class="string">&quot;uhost-td3x545p&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">        instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      ~ ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.44.37&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      ~ memory            = 4 -&gt; (known after apply)</span><br><span class="line">      ~ name              = <span class="string">&quot;cn-bj2-04-0&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-1&quot;</span></span><br><span class="line">      ~ private_ip        = <span class="string">&quot;10.9.44.37&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      ~ root_password     = (sensitive value)</span><br><span class="line">      ~ security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ status            = <span class="string">&quot;Running&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; (known after apply)</span><br><span class="line">        tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      ~ vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[2] will be updated in-place</span></span><br><span class="line">  ~ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">        auto_renew        = <span class="literal">true</span></span><br><span class="line">        availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">        boot_disk_size    = 20</span><br><span class="line">        boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">        charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">        cpu               = 1</span><br><span class="line">        cpu_platform      = <span class="string">&quot;Intel/IvyBridge&quot;</span></span><br><span class="line">        create_time       = <span class="string">&quot;2020-11-28T23:09:01+08:00&quot;</span></span><br><span class="line">        disk_set          = [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">id</span>      = <span class="string">&quot;1d7f07c9-7342-431b-85bb-d3ee0022063d&quot;</span></span><br><span class="line">                is_boot = <span class="literal">true</span></span><br><span class="line">                size    = 20</span><br><span class="line">                <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">        expire_time       = <span class="string">&quot;2020-11-29T00:09:02+08:00&quot;</span></span><br><span class="line">        <span class="built_in">id</span>                = <span class="string">&quot;uhost-txa2owrp&quot;</span></span><br><span class="line">        image_id          = <span class="string">&quot;uimage-pxplaj&quot;</span></span><br><span class="line">        instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">        ip_set            = [</span><br><span class="line">            &#123;</span><br><span class="line">                internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">                ip            = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">        memory            = 4</span><br><span class="line">      ~ name              = <span class="string">&quot;cn-bj2-03-1&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-2&quot;</span></span><br><span class="line">        private_ip        = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">        root_password     = (sensitive value)</span><br><span class="line">        security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">        status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">        subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">        tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">        vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[3] must be replaced</span></span><br><span class="line">-/+ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      ~ auto_renew        = <span class="literal">true</span> -&gt; (known after apply)</span><br><span class="line">      ~ availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03&quot;</span> <span class="comment"># forces replacement</span></span><br><span class="line">      ~ boot_disk_size    = 20 -&gt; (known after apply)</span><br><span class="line">      ~ boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; (known after apply)</span><br><span class="line">        charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      ~ cpu               = 1 -&gt; (known after apply)</span><br><span class="line">      ~ cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      ~ disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;31e2cad6-79a1-4475-a9f5-2c5c95605b18&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      ~ expire_time       = <span class="string">&quot;2020-11-29T00:09:04+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ <span class="built_in">id</span>                = <span class="string">&quot;uhost-v3qxdbju&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">        instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      ~ ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.85.40&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      ~ memory            = 4 -&gt; (known after apply)</span><br><span class="line">      ~ name              = <span class="string">&quot;cn-bj2-04-1&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-3&quot;</span></span><br><span class="line">      ~ private_ip        = <span class="string">&quot;10.9.85.40&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      ~ root_password     = (sensitive value)</span><br><span class="line">      ~ security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ status            = <span class="string">&quot;Running&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; (known after apply)</span><br><span class="line">        tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      ~ vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 2 to add, 1 to change, 2 to destroy.</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Note: You didn<span class="string">&#x27;t specify an &quot;-out&quot; parameter to save this plan, so Terraform</span></span><br><span class="line"><span class="string">can&#x27;</span>t guarantee that exactly these actions will be performed <span class="keyword">if</span></span><br><span class="line"><span class="string">&quot;terraform apply&quot;</span> is subsequently run.</span><br></pre></td></tr></table></figure>
<p>变更计划与期望略有不同。我们仔细看细节：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ucloud_instance.web[2] will be updated in-place</span></span><br><span class="line">~ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      auto_renew        = <span class="literal">true</span></span><br><span class="line">      availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">      boot_disk_size    = 20</span><br><span class="line">      boot_disk_type    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">      charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      cpu               = 1</span><br><span class="line">      cpu_platform      = <span class="string">&quot;Intel/IvyBridge&quot;</span></span><br><span class="line">      create_time       = <span class="string">&quot;2020-11-28T23:09:01+08:00&quot;</span></span><br><span class="line">      disk_set          = [</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">id</span>      = <span class="string">&quot;1d7f07c9-7342-431b-85bb-d3ee0022063d&quot;</span></span><br><span class="line">              is_boot = <span class="literal">true</span></span><br><span class="line">              size    = 20</span><br><span class="line">              <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">      ]</span><br><span class="line">      expire_time       = <span class="string">&quot;2020-11-29T00:09:02+08:00&quot;</span></span><br><span class="line">      <span class="built_in">id</span>                = <span class="string">&quot;uhost-txa2owrp&quot;</span></span><br><span class="line">      image_id          = <span class="string">&quot;uimage-pxplaj&quot;</span></span><br><span class="line">      instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      ip_set            = [</span><br><span class="line">          &#123;</span><br><span class="line">              internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              ip            = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">      ]</span><br><span class="line">      memory            = 4</span><br><span class="line">    ~ name              = <span class="string">&quot;cn-bj2-03-1&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-2&quot;</span></span><br><span class="line">      private_ip        = <span class="string">&quot;10.9.45.234&quot;</span></span><br><span class="line">      root_password     = (sensitive value)</span><br><span class="line">      security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span></span><br><span class="line">      status            = <span class="string">&quot;Running&quot;</span></span><br><span class="line">      subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span></span><br><span class="line">      tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>原本名为 <code>cn-bj2-03-1</code> 的主机被更名为 <code>cn-bj2-03-2</code> 了，原本属于 <code>cn-bj2-04</code> 的第一台主机的变更计划是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"># ucloud_instance.web[1] must be replaced</span></span><br><span class="line">-/+ resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      ~ auto_renew        = <span class="literal">true</span> -&gt; (known after apply)</span><br><span class="line">      ~ availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03&quot;</span> <span class="comment"># forces replacement</span></span><br><span class="line">      ~ boot_disk_size    = 20 -&gt; (known after apply)</span><br><span class="line">      ~ boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; (known after apply)</span><br><span class="line">        charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      ~ cpu               = 1 -&gt; (known after apply)</span><br><span class="line">      ~ cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ create_time       = <span class="string">&quot;2020-11-28T23:09:04+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      ~ disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;df06380a-00e1-42df-8c07-eec67d817f97&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      ~ expire_time       = <span class="string">&quot;2020-11-29T00:09:06+08:00&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ <span class="built_in">id</span>                = <span class="string">&quot;uhost-td3x545p&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">        instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      ~ ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.44.37&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      ~ memory            = 4 -&gt; (known after apply)</span><br><span class="line">      ~ name              = <span class="string">&quot;cn-bj2-04-0&quot;</span> -&gt; <span class="string">&quot;cn-bj2-03-1&quot;</span></span><br><span class="line">      ~ private_ip        = <span class="string">&quot;10.9.44.37&quot;</span> -&gt; (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      ~ root_password     = (sensitive value)</span><br><span class="line">      ~ security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ status            = <span class="string">&quot;Running&quot;</span> -&gt; (known after apply)</span><br><span class="line">      ~ subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; (known after apply)</span><br><span class="line">        tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      ~ vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; (known after apply)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>它的名字从 <code>cn-bj2-04-0</code> 变成了 <code>cn-bj2-03-1</code>。</p>
<p>仔细想想，实际上这是一个比较低效的变更计划。原本属于 <code>cn-bj2-03</code> 的两台主机应该不做任何变更，只需要删除 <code>cn-bj2-04</code> 的主机，再补充两台 <code>cn-bj2-03</code> 的主机即可。这是因为我们使用的是 <code>count</code>，而 <code>count</code> 只看元素在列表中的序号。当我们删除一个可用区时，实际上会引起主机序号的重大变化，导致出现大量低效的变更，这就是我们在讲 <code>count</code> 与 <code>for_each</code> 时强调过的，如果创建的资源实例彼此之间几乎完全一致，那么 <code>count</code> 比较合适。否则，那么使用 <code>for_each</code> 会更加安全。</p>
<p>让我们尝试使用 <code>for_each</code> 改写这段逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;az&quot; &#123;</span><br><span class="line">  type    = list(string)</span><br><span class="line">  default = [</span><br><span class="line">    &quot;cn-bj2-03&quot;,</span><br><span class="line">    &quot;cn-bj2-04&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;instance_count&quot; &#123;</span><br><span class="line">  type    = number</span><br><span class="line">  default = 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  instance_names = [for i in range(var.instance_count):&quot;$&#123;var.az[i%length(var.az)]&#125;-$&#123;floor(i/length(var.az))&#125;&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;ucloud_images&quot; &quot;centos&quot; &#123;</span><br><span class="line">  name_regex = &quot;^CentOS 7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  for_each          = toset(local.instance_names)</span><br><span class="line">  name              = each.value</span><br><span class="line">  availability_zone = var.az[index(local.instance_names, each.value) % length(var.az)]</span><br><span class="line">  image_id          = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type     = &quot;n-standard-1&quot;</span><br><span class="line">  charge_type       = &quot;dynamic&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了生成主机独一无二的名字，我们首先用 <code>range</code> 函数生成了一个序号集合，比如目标主机数是 <code>4</code>，那么 <code>range(4)</code> 的结果就是 <code>[0, 1, 2, 3]</code>；然后我们通过取模运算使得名字前缀在可用区列表之间循环递增，最后用 <code>floor(i/length(var.az))</code> 计算出当前序号对应在当前可用区是第几台。例如 4 号主机在第二个可用区就是第二台，生成的名字应该就是 <code>cn-bj-04-1</code>。</p>
<p>执行结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply -auto-approve</span><br><span class="line">data.ucloud_images.centos: Refreshing state...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Creating...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Creating...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Creating...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Creating...</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Creation complete after 21s [<span class="built_in">id</span>=uhost-fjci1i4o]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Creation complete after 23s [<span class="built_in">id</span>=uhost-bkkhmref]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Creation complete after 26s [<span class="built_in">id</span>=uhost-amosgdaa]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Still creating... [30s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Still creating... [40s elapsed]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Creation complete after 45s [<span class="built_in">id</span>=uhost-kltudgnf]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 4 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure>
<p>如果我们去掉一个可用区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;az&quot; &#123;</span><br><span class="line">  type = list(string)</span><br><span class="line">  default = [</span><br><span class="line">    &quot;cn-bj2-03&quot;,</span><br><span class="line">#    &quot;cn-bj2-04&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以检查一下执行计划：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">$ terraform plan</span><br><span class="line">Refreshing Terraform state in-memory prior to plan...</span><br><span class="line">The refreshed state will be used to calculate this plan, but will not be</span><br><span class="line">persisted to <span class="built_in">local</span> or remote state storage.</span><br><span class="line"></span><br><span class="line">data.ucloud_images.centos: Refreshing state... [<span class="built_in">id</span>=475496684]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-1&quot;</span>]: Refreshing state... [<span class="built_in">id</span>=uhost-amosgdaa]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-0&quot;</span>]: Refreshing state... [<span class="built_in">id</span>=uhost-bkkhmref]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-03-0&quot;</span>]: Refreshing state... [<span class="built_in">id</span>=uhost-kltudgnf]</span><br><span class="line">ucloud_instance.web[<span class="string">&quot;cn-bj2-04-1&quot;</span>]: Refreshing state... [<span class="built_in">id</span>=uhost-fjci1i4o]</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">An execution plan has been generated and is shown below.</span><br><span class="line">Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line">  - destroy</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[&quot;cn-bj2-03-2&quot;] will be created</span></span><br><span class="line">  + resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      + auto_renew        = (known after apply)</span><br><span class="line">      + availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">      + boot_disk_size    = (known after apply)</span><br><span class="line">      + boot_disk_type    = (known after apply)</span><br><span class="line">      + charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      + cpu               = (known after apply)</span><br><span class="line">      + cpu_platform      = (known after apply)</span><br><span class="line">      + create_time       = (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      + disk_set          = (known after apply)</span><br><span class="line">      + expire_time       = (known after apply)</span><br><span class="line">      + <span class="built_in">id</span>                = (known after apply)</span><br><span class="line">      + image_id          = <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">      + instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      + ip_set            = (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      + memory            = (known after apply)</span><br><span class="line">      + name              = <span class="string">&quot;cn-bj2-03-2&quot;</span></span><br><span class="line">      + private_ip        = (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      + root_password     = (sensitive value)</span><br><span class="line">      + security_group    = (known after apply)</span><br><span class="line">      + status            = (known after apply)</span><br><span class="line">      + subnet_id         = (known after apply)</span><br><span class="line">      + tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      + vpc_id            = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[&quot;cn-bj2-03-3&quot;] will be created</span></span><br><span class="line">  + resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      + auto_renew        = (known after apply)</span><br><span class="line">      + availability_zone = <span class="string">&quot;cn-bj2-03&quot;</span></span><br><span class="line">      + boot_disk_size    = (known after apply)</span><br><span class="line">      + boot_disk_type    = (known after apply)</span><br><span class="line">      + charge_type       = <span class="string">&quot;dynamic&quot;</span></span><br><span class="line">      + cpu               = (known after apply)</span><br><span class="line">      + cpu_platform      = (known after apply)</span><br><span class="line">      + create_time       = (known after apply)</span><br><span class="line">      + data_disk_size    = (known after apply)</span><br><span class="line">      + data_disk_type    = (known after apply)</span><br><span class="line">      + disk_set          = (known after apply)</span><br><span class="line">      + expire_time       = (known after apply)</span><br><span class="line">      + <span class="built_in">id</span>                = (known after apply)</span><br><span class="line">      + image_id          = <span class="string">&quot;uimage-rkn1v2&quot;</span></span><br><span class="line">      + instance_type     = <span class="string">&quot;n-standard-1&quot;</span></span><br><span class="line">      + ip_set            = (known after apply)</span><br><span class="line">      + isolation_group   = (known after apply)</span><br><span class="line">      + memory            = (known after apply)</span><br><span class="line">      + name              = <span class="string">&quot;cn-bj2-03-3&quot;</span></span><br><span class="line">      + private_ip        = (known after apply)</span><br><span class="line">      + remark            = (known after apply)</span><br><span class="line">      + root_password     = (sensitive value)</span><br><span class="line">      + security_group    = (known after apply)</span><br><span class="line">      + status            = (known after apply)</span><br><span class="line">      + subnet_id         = (known after apply)</span><br><span class="line">      + tag               = <span class="string">&quot;Default&quot;</span></span><br><span class="line">      + vpc_id            = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[&quot;cn-bj2-04-0&quot;] will be destroyed</span></span><br><span class="line">  - resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      - auto_renew        = <span class="literal">true</span> -&gt; null</span><br><span class="line">      - availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; null</span><br><span class="line">      - boot_disk_size    = 20 -&gt; null</span><br><span class="line">      - boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; null</span><br><span class="line">      - charge_type       = <span class="string">&quot;dynamic&quot;</span> -&gt; null</span><br><span class="line">      - cpu               = 1 -&gt; null</span><br><span class="line">      - cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; null</span><br><span class="line">      - create_time       = <span class="string">&quot;2020-11-28T22:35:53+08:00&quot;</span> -&gt; null</span><br><span class="line">      - disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;b214d840-ffec-4958-a3da-3580846fd2a3&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; null</span><br><span class="line">      - expire_time       = <span class="string">&quot;2020-11-28T23:35:53+08:00&quot;</span> -&gt; null</span><br><span class="line">      - <span class="built_in">id</span>                = <span class="string">&quot;uhost-bkkhmref&quot;</span> -&gt; null</span><br><span class="line">      - image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; null</span><br><span class="line">      - instance_type     = <span class="string">&quot;n-standard-1&quot;</span> -&gt; null</span><br><span class="line">      - ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.48.82&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; null</span><br><span class="line">      - memory            = 4 -&gt; null</span><br><span class="line">      - name              = <span class="string">&quot;cn-bj2-04-0&quot;</span> -&gt; null</span><br><span class="line">      - private_ip        = <span class="string">&quot;10.9.48.82&quot;</span> -&gt; null</span><br><span class="line">      - root_password     = (sensitive value)</span><br><span class="line">      - security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; null</span><br><span class="line">      - status            = <span class="string">&quot;Running&quot;</span> -&gt; null</span><br><span class="line">      - subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; null</span><br><span class="line">      - tag               = <span class="string">&quot;Default&quot;</span> -&gt; null</span><br><span class="line">      - vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ucloud_instance.web[&quot;cn-bj2-04-1&quot;] will be destroyed</span></span><br><span class="line">  - resource <span class="string">&quot;ucloud_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      - auto_renew        = <span class="literal">true</span> -&gt; null</span><br><span class="line">      - availability_zone = <span class="string">&quot;cn-bj2-04&quot;</span> -&gt; null</span><br><span class="line">      - boot_disk_size    = 20 -&gt; null</span><br><span class="line">      - boot_disk_type    = <span class="string">&quot;local_normal&quot;</span> -&gt; null</span><br><span class="line">      - charge_type       = <span class="string">&quot;dynamic&quot;</span> -&gt; null</span><br><span class="line">      - cpu               = 1 -&gt; null</span><br><span class="line">      - cpu_platform      = <span class="string">&quot;Intel/Broadwell&quot;</span> -&gt; null</span><br><span class="line">      - create_time       = <span class="string">&quot;2020-11-28T22:35:53+08:00&quot;</span> -&gt; null</span><br><span class="line">      - disk_set          = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - <span class="built_in">id</span>      = <span class="string">&quot;6a3f274f-e072-4a46-90f8-edc7dbaa27f7&quot;</span></span><br><span class="line">              - is_boot = <span class="literal">true</span></span><br><span class="line">              - size    = 20</span><br><span class="line">              - <span class="built_in">type</span>    = <span class="string">&quot;local_normal&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; null</span><br><span class="line">      - expire_time       = <span class="string">&quot;2020-11-28T23:35:53+08:00&quot;</span> -&gt; null</span><br><span class="line">      - <span class="built_in">id</span>                = <span class="string">&quot;uhost-fjci1i4o&quot;</span> -&gt; null</span><br><span class="line">      - image_id          = <span class="string">&quot;uimage-dhe5m2&quot;</span> -&gt; null</span><br><span class="line">      - instance_type     = <span class="string">&quot;n-standard-1&quot;</span> -&gt; null</span><br><span class="line">      - ip_set            = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - internet_type = <span class="string">&quot;Private&quot;</span></span><br><span class="line">              - ip            = <span class="string">&quot;10.9.176.28&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; null</span><br><span class="line">      - memory            = 4 -&gt; null</span><br><span class="line">      - name              = <span class="string">&quot;cn-bj2-04-1&quot;</span> -&gt; null</span><br><span class="line">      - private_ip        = <span class="string">&quot;10.9.176.28&quot;</span> -&gt; null</span><br><span class="line">      - root_password     = (sensitive value)</span><br><span class="line">      - security_group    = <span class="string">&quot;firewall-juhsrlvr&quot;</span> -&gt; null</span><br><span class="line">      - status            = <span class="string">&quot;Running&quot;</span> -&gt; null</span><br><span class="line">      - subnet_id         = <span class="string">&quot;subnet-dtu3dgpr&quot;</span> -&gt; null</span><br><span class="line">      - tag               = <span class="string">&quot;Default&quot;</span> -&gt; null</span><br><span class="line">      - vpc_id            = <span class="string">&quot;uvnet-f1c3jq2b&quot;</span> -&gt; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 2 to add, 0 to change, 2 to destroy.</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Note: You didn<span class="string">&#x27;t specify an &quot;-out&quot; parameter to save this plan, so Terraform</span></span><br><span class="line"><span class="string">can&#x27;</span>t guarantee that exactly these actions will be performed <span class="keyword">if</span></span><br><span class="line"><span class="string">&quot;terraform apply&quot;</span> is subsequently run.</span><br></pre></td></tr></table></figure>
<p>可以看到，原来属于 <code>cn-bj2-03</code> 的两台主机原封不动，删除了属于 <code>cn-bj2-04</code> 的两台主机，并且在 <code>cn-bj2-03</code> 可用区新增两台主机。</p>
<ul>
<li><a href="#provisioner-%E4%B8%8E-userdata"><strong>1.9.4.1.</strong> provisioner 与 user_data</a></li>
</ul>
<p><a href="#provisioner-%E4%B8%8E-userdata"></a></p>
<h2 id="1-9-4-1-provisioner-与-user-data"><a href="#provisioner-%E4%B8%8E-userdata"></a>1.9.4.1. provisioner 与 user_data</h2>
<p>我们在介绍资源时介绍了<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#provisioner-%E5%92%8C-connection">预置器 <code>provisioner</code></a>。同时不少公有云厂商的虚拟机都提供了 cloud-init 功能，可以让我们在虚拟机实例第一次启动时执行一段自定义的脚本来执行一些初始化操作。例如我们在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/1.Terraform%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C/">Terraform 初步体验</a>一章里举的例子，在 UCloud 主机第一次启动时我们通过 <code>user_data</code> 来调用 yum 安装并配置了 ngnix 服务。预置器与 cloud-init 都可以用于初始化虚拟机，那么我们应该用哪一种呢？</p>
<p>首先要指出的是，<code>provisioner</code> 的官方文档里明确指出，由于预置器内部的行为 Terraform 无法感知，无法将它执行的变更纳入到声明式的代码管理中，所以预置器应被作为最后的手段使用，那么也就是说，如果 cloud-init 能够满足我们的要求，那么我们应该优先使用 cloud-init。</p>
<p>但是仍然存在一些 cloud-init 无法满足的场景。例如一个最常见的情况是，比如我们要在 cloud-init 当中格式化卷，后续的所有操作都必须在主机成功格式化并挂载卷之后才能顺利进行下去。但是比如 <code>aws_instance</code>，它的创建是不会等待 <code>user_data</code> 代码执行完成的，只要虚拟机创建成功开始启动，Terraform 就会认为资源创建完成从而继续后续的创建了。</p>
<p>解决这个问题目前来看还是只能依靠预置器。我们以一段 UCloud 云主机代码为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  availability_zone         = &quot;cn-bj2-03&quot;</span><br><span class="line">  image_id                  = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type             = &quot;n-standard-1&quot;</span><br><span class="line">  charge_type               = &quot;dynamic&quot;</span><br><span class="line">  network_interface &#123;</span><br><span class="line">    eip_internet_type = &quot;bgp&quot;</span><br><span class="line">    eip_charge_mode   = &quot;traffic&quot;</span><br><span class="line">    eip_bandwidth     = 1</span><br><span class="line">  &#125;</span><br><span class="line">  delete_eips_with_instance = true</span><br><span class="line">  root_password             = var.root_password</span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123;</span><br><span class="line">    connection &#123;</span><br><span class="line">      type     = &quot;ssh&quot;</span><br><span class="line">      host     = [for ipset in self.ip_set: ipset.ip if ipset.internet_type==&quot;BGP&quot;][0]</span><br><span class="line">      user     = &quot;root&quot;</span><br><span class="line">      password = var.root_password</span><br><span class="line">      timeout  = &quot;1h&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    inline = [</span><br><span class="line">      &quot;sleep 1h&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在资源声明中附加了一个 <code>remote-exec</code> 类型的预置器，它的 <code>host</code> 取值使用了 <code>self.ip_set</code>，<code>self</code> 在当前上下文中指代 <code>provisioner</code> 所属的 <code>ucloud_instance.web</code>，<code>ip_set</code> 是 <code>ucloud_instance</code> 的一个输出属性，内含云主机的内网 IP 以及绑定的弹性公网 IP 信息。我们用一个 <code>for</code> 表达式过滤出弹性公网 IP 地址，然后使用 ssh 连接。预置器执行的脚本代码很简单，休眠一小时。如果我们执行这段代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply -auto-approve</span><br><span class="line">data.ucloud_images.centos: Refreshing state...</span><br><span class="line">ucloud_instance.web: Creating...</span><br><span class="line">ucloud_instance.web: Still creating... [10s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [20s elapsed]</span><br><span class="line">ucloud_instance.web: Provisioning with <span class="string">&#x27;remote-exec&#x27;</span>...</span><br><span class="line">ucloud_instance.web (remote-exec): Connecting to remote host via SSH...</span><br><span class="line">ucloud_instance.web (remote-exec):   Host: 106.75.87.148</span><br><span class="line">ucloud_instance.web (remote-exec):   User: root</span><br><span class="line">ucloud_instance.web (remote-exec):   Password: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Private key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Certificate: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   SSH Agent: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Checking Host Key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web: Still creating... [30s elapsed]</span><br><span class="line">ucloud_instance.web (remote-exec): Connecting to remote host via SSH...</span><br><span class="line">ucloud_instance.web (remote-exec):   Host: 106.75.87.148</span><br><span class="line">ucloud_instance.web (remote-exec):   User: root</span><br><span class="line">ucloud_instance.web (remote-exec):   Password: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Private key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Certificate: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   SSH Agent: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Checking Host Key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web: Still creating... [40s elapsed]</span><br><span class="line">ucloud_instance.web (remote-exec): Connecting to remote host via SSH...</span><br><span class="line">ucloud_instance.web (remote-exec):   Host: 106.75.87.148</span><br><span class="line">ucloud_instance.web (remote-exec):   User: root</span><br><span class="line">ucloud_instance.web (remote-exec):   Password: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Private key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Certificate: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec):   SSH Agent: <span class="literal">true</span></span><br><span class="line">ucloud_instance.web (remote-exec):   Checking Host Key: <span class="literal">false</span></span><br><span class="line">ucloud_instance.web (remote-exec): Connected!</span><br><span class="line">ucloud_instance.web: Still creating... [50s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m0s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m10s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m20s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m30s elapsed]</span><br><span class="line">ucloud_instance.web: Still creating... [1m40s elapsed]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>不出所料的话，该过程会持续一小时，也就是说，无论预置器脚本中执行的操作耗时多长，<code>ucloud_instance</code> 的创建都会等待它完成，或是触发超时。</p>
<p>在这里我们可以使用这种方法的前提是我们使用的 UCloud 云主机的资源定义允许我们定义资源时声明 <code>network_interface</code> 属性，直接绑定一个公网 IP。如果我们使用的云厂商 Provider 无法让我们在创建主机时绑定公网 IP，而是必须事后绑定弹性 IP 呢？又或者，初始化脚本必须在云主机成功绑定了云盘之后才能成功运行？这种情况下我们还有最后的武器，就是 <code>null_resource</code>。</p>
<p><code>null_resource</code> 可能是 Terraform 体系中最“不 Terraform”的存在，它就是我们用来在 Terraform 这样一个声明式世界里干各种命令式脏活的工具。<code>null_resouce</code> 本身是一个空的 <code>resource</code>，只有一个名为 <code>triggers</code> 的参数以及 <code>id</code> 作为输出属性。</p>
<p>我们看下这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">data &quot;ucloud_images&quot; &quot;centos&quot; &#123;</span><br><span class="line">  name_regex = &quot;^CentOS 7&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_eip&quot; &quot;eip&quot; &#123;</span><br><span class="line">  internet_type = &quot;bgp&quot;</span><br><span class="line">  bandwidth     = 1</span><br><span class="line">  charge_mode   = &quot;traffic&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_disk&quot; &quot;data_disk&quot; &#123;</span><br><span class="line">  availability_zone = &quot;cn-bj2-03&quot;</span><br><span class="line">  disk_size         = 10</span><br><span class="line">  charge_type       = &quot;dynamic&quot;</span><br><span class="line">  disk_type         = &quot;data_disk&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  availability_zone = &quot;cn-bj2-03&quot;</span><br><span class="line">  image_id          = data.ucloud_images.centos.images[0].id</span><br><span class="line">  instance_type     = &quot;n-standard-1&quot;</span><br><span class="line">  charge_type       = &quot;dynamic&quot;</span><br><span class="line">  root_password     = var.root_password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_eip_association&quot; &quot;eip_association&quot; &#123;</span><br><span class="line">  eip_id      = ucloud_eip.eip.id</span><br><span class="line">  resource_id = ucloud_instance.web.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_disk_attachment&quot; &quot;data_disk&quot; &#123;</span><br><span class="line">  availability_zone = &quot;cn-bj2-03&quot;</span><br><span class="line">  disk_id           = ucloud_disk.data_disk.id</span><br><span class="line">  instance_id       = ucloud_instance.web.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;null_resource&quot; &quot;web_init&quot; &#123;</span><br><span class="line">  depends_on = [</span><br><span class="line">    ucloud_eip_association.eip_association,</span><br><span class="line">    ucloud_disk_attachment.data_disk</span><br><span class="line">  ]</span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123;</span><br><span class="line">    connection &#123;</span><br><span class="line">      type     = &quot;ssh&quot;</span><br><span class="line">      host     = ucloud_eip.eip.public_ip</span><br><span class="line">      user     = &quot;root&quot;</span><br><span class="line">      password = var.root_password</span><br><span class="line">    &#125;</span><br><span class="line">    inline = [</span><br><span class="line">      &quot;echo hello&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们假设需要远程执行的操纵是必须在云盘挂载成功以后才可以运行的，那么我们可以声明一个 <code>null_resource</code>，把 <code>provisioner</code> 声明放在那里，通过显式声明 <code>depends_on</code> 确保它的执行一定是在云盘挂载结束以后。</p>
<p>另外这个例子里我们运行的脚本非常简单，考虑一种更加复杂一些的场景，我们运行的脚本是通过文件读取的，我们希望在文件内容发生变化时能够重新在服务器上运行该脚本，这时我们可以使用 <code>null_resource</code> 的 <code>triggers</code> 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;null_resource&quot; &quot;web_init&quot; &#123;</span><br><span class="line">  depends_on = [</span><br><span class="line">    ucloud_eip_association.eip_association,</span><br><span class="line">    ucloud_disk_attachment.data_disk</span><br><span class="line">  ]</span><br><span class="line">  triggers = &#123;</span><br><span class="line">    script_hash = filemd5(&quot;$&#123;path.module&#125;/init.sh&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123;</span><br><span class="line">    connection &#123;</span><br><span class="line">      type     = &quot;ssh&quot;</span><br><span class="line">      host     = ucloud_eip.eip.public_ip</span><br><span class="line">      user     = &quot;root&quot;</span><br><span class="line">      password = var.root_password</span><br><span class="line">    &#125;</span><br><span class="line">    script = &quot;$&#123;path.module&#125;/init.sh&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>provisioner</code> 运行的脚本是通过 <code>script</code> 参数传入的脚本文件路径，而我们通过 <code>filemd5</code> 函数把文件内容的哈希值传入了 <code>triggers</code>。<code>triggers</code> 会在值发生改变时触发 <code>null_resource</code> 的重建，这样脚本发生些许变化都会导致重新执行。</p>
<p>官方文档上还给出了对于 <code>triggers</code> 的另一个妙用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;cluster&quot; &#123;</span><br><span class="line">  count = 3</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;null_resource&quot; &quot;cluster&quot; &#123;</span><br><span class="line">  # Changes to any instance of the cluster requires re-provisioning</span><br><span class="line">  triggers = &#123;</span><br><span class="line">    cluster_instance_ids = &quot;$&#123;join(&quot;,&quot;, aws_instance.cluster.*.id)&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # Bootstrap script can run on any instance of the cluster</span><br><span class="line">  # So we just choose the first in this case</span><br><span class="line">  connection &#123;</span><br><span class="line">    host = &quot;$&#123;element(aws_instance.cluster.*.public_ip, 0)&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provisioner &quot;remote-exec&quot; &#123;</span><br><span class="line">    # Bootstrap script called with private_ip of each node in the clutser</span><br><span class="line">    inline = [</span><br><span class="line">      &quot;bootstrap-cluster.sh $&#123;join(&quot; &quot;, aws_instance.cluster.*.private_ip)&#125;&quot;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里，我们需要所有 AWS 主机的内网 IP 参与才能够成功初始化集群，可能是类似 Kafka 或是 RabbitMQ 这样的应用，我们需要把集群节点的IP写入配置文件。如何确保未来机器数量发生调整以后，机器上的配置文件始终能够获得完整的集群内网 IP 信息，这里使用 <code>triggers</code> 就可以轻松完成目标。</p>
<p>另外在绝大多数生产环境中，服务器都不允许拥有独立的公网 IP，或是禁止从服务器对外服务的公网 IP 直接连接 ssh。这时一般我们会在集群中配置一台堡垒机，通过堡垒机进行跳转连接。可以访问<a target="_blank" rel="noopener" href="https://www.terraform.io/docs/provisioners/connection.html#connecting-through-a-bastion-host-with-ssh">通过堡垒机使用SSH的官方文档</a>获取详细信息，在此不再赘述。</p>
<h2 id="destroy-provisioner中使用变量"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">destroy-provisioner中使用变量</a></h2>
<ul>
<li>
<p><a href="#destroy-provisioner-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><strong>1.9.5.1.</strong> destroy-provisioner 中使用变量</a></p>
</li>
<li>
<p><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><strong>1.9.5.1.1.</strong> 解决方法</a></p>
</li>
</ul>
<p><a href="#destroy-provisioner-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"></a></p>
<h2 id="1-9-5-1-destroy-provisioner-中使用变量"><a href="#destroy-provisioner-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"></a>1.9.5.1. destroy-provisioner 中使用变量</h2>
<p>我们可以在定义一个 <code>provisioner</code> 块时设置 <code>when</code> 为 <code>destroy</code>，资源在销毁<strong>之前</strong>会首先执行 <code>provisioner</code>，可以帮助我们执行一些析构逻辑。但是如果我们在 Destroy-Provisioner 中引用了变量的话，比如这样的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">&quot;aws_volume_attachment&quot;</span> <span class="string">&quot;attachement_myservice&quot;</span> &#123;</span><br><span class="line">  count         = <span class="string">&quot;$&#123;length(var.network_myservice_subnet_ids)&#125;&quot;</span></span><br><span class="line">  device_name   = <span class="string">&quot;/dev/xvdg&quot;</span></span><br><span class="line">  volume_id     =   <span class="string">&quot;$&#123;element(aws_ebs_volume.ebs_myservice.*.id, count.index)&#125;&quot;</span></span><br><span class="line">  instance_id   =   <span class="string">&quot;$&#123;element(aws_instance.myservice.*.id, count.index)&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">  provisioner <span class="string">&quot;local-exec&quot;</span> &#123;</span><br><span class="line">    command = <span class="string">&quot;aws ec2 stop-instances --instance-ids $&#123;element(aws_instance.myservice.*.id, count.index)&#125; --region $&#123;var.region&#125; &amp;&amp; sleep 30&quot;</span></span><br><span class="line">    when = <span class="string">&quot;destroy&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们会看见这样的报错信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|  Error: Invalid reference from destroy provisioner</span><br><span class="line">│ </span><br><span class="line">│ Destroy-time provisioners and their connection configurations may only reference attributes of the related resource, via &#x27;self&#x27;, &#x27;count.index&#x27;, or &#x27;each.key&#x27;.</span><br><span class="line">│ </span><br><span class="line">│ References to other resources during the destroy phase can cause dependency cycles and interact poorly with create_before_destroy.</span><br></pre></td></tr></table></figure>
<p>从 <code>0.12</code> 开始 Terraform 会对在 Destroy-Time Provisioner 中引用除 <code>self</code>、<code>count.index</code>、<code>each.key</code> 以外的变量做警告，从 <code>0.13</code> 开始则会直接报错。</p>
<h2 id="1-9-5-1-1-解决方法"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"></a>1.9.5.1.1. 解决方法</h2>
<p>目前官方推荐的做法是把需要引用的变量值通过 <code>triggers</code> “捕获”一下再引用，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">&quot;null_resource&quot;</span> <span class="string">&quot;foo&quot;</span> &#123;</span><br><span class="line">  triggers &#123;</span><br><span class="line">    interpreter = <span class="keyword">var</span>.local_exec_interpreter</span><br><span class="line">  &#125;</span><br><span class="line">  provisioner &#123;</span><br><span class="line">    when = destroy</span><br><span class="line"></span><br><span class="line">    interpreter = self.triggers.interpreter</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方法就可以避免这个问题。</p>
<ul>
<li>
<p><a href="#%E5%88%A9%E7%94%A8-nullresource-%E7%9A%84-triggers-%E8%A7%A6%E5%8F%91%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E6%9B%B4%E6%96%B0"><strong>1.9.6.1.</strong> 利用 null_resource 的 triggers 触发其他资源更新</a></p>
</li>
<li>
<p><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><strong>1.9.6.1.1.</strong> 问题描述</a></p>
</li>
<li>
<p><a href="#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"><strong>1.9.6.1.2.</strong> 问题原因</a></p>
</li>
<li>
<p><a href="#%E5%B7%A7%E7%94%A8-nullresource-%E7%9A%84-triggers"><strong>1.9.6.1.3.</strong> 巧用 null_resource 的 triggers</a></p>
</li>
<li>
<p><a href="#%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%AE%9E%E9%AA%8C"><strong>1.9.6.1.4.</strong> 一个小实验</a></p>
</li>
</ul>
<p><a href="#%E5%88%A9%E7%94%A8-nullresource-%E7%9A%84-triggers-%E8%A7%A6%E5%8F%91%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E6%9B%B4%E6%96%B0"></a></p>
<h2 id="1-9-6-1-利用-null-resource-的-triggers-触发其他资源更新"><a href="#%E5%88%A9%E7%94%A8-nullresource-%E7%9A%84-triggers-%E8%A7%A6%E5%8F%91%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E6%9B%B4%E6%96%B0"></a>1.9.6.1. 利用 null_resource 的 triggers 触发其他资源更新</h2>
<p>社区有人提了一个 Terraform 问题，他写了这样一段 Terraform 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_key_vault_secret&quot; &quot;service_bus_connection_string&quot; &#123;</span><br><span class="line">  name = &quot;service-bus-connection-string&quot;</span><br><span class="line"></span><br><span class="line">  value        = azurerm_servicebus_topic_authorization_rule.mysb.primary_connection_string</span><br><span class="line">  key_vault_id = azurerm_key_vault.main.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;azurerm_function_app&quot; &quot;main&quot; &#123;</span><br><span class="line">  name                = &quot;myfn&quot;</span><br><span class="line">  location            = azurerm_resource_group.main.location</span><br><span class="line">  resource_group_name = azurerm_resource_group.main.name</span><br><span class="line"></span><br><span class="line">  app_service_plan_id = azurerm_app_service_plan.main.id</span><br><span class="line"></span><br><span class="line">  enable_builtin_logging = true</span><br><span class="line">  https_only             = true</span><br><span class="line">  os_type                = &quot;linux&quot;</span><br><span class="line"></span><br><span class="line">  storage_account_name       = azurerm_storage_account.main.name</span><br><span class="line">  storage_account_access_key = azurerm_storage_account.main.primary_access_key</span><br><span class="line"></span><br><span class="line">  version = &quot;~3&quot;</span><br><span class="line"></span><br><span class="line">  app_settings = &#123;</span><br><span class="line">    AzureWebJobsServiceBus      = &quot;@Microsoft.KeyVault(SecretUri=$&#123;azurerm_key_vault_secret.service_bus_connection_string.id&#125;)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意思大概是他把一段含有机密信息的连接字符串保存在 Azure KeyVault 服务中，然后创建了一个 Azure Faas 函数，通过 KeyVault 机密引用地址传递该机密。</p>
<h2 id="1-9-6-1-1-问题描述"><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"></a>1.9.6.1.1. 问题描述</h2>
<p>这位老兄发现，如果他修改了机密的内容，也就是 <code>azurerm_key_vault_secret</code> 声明里的 <code>value = azurerm_servicebus_topic_authorization_rule.mysb.primary_connection_string</code> 这一段的值的时候，KeyVault 保存的机密内容的确会正确更新，但 Azure Function 读取到的还是旧的机密引用地址，也就是这段代码中得到的 KeyVault 机密引用地址没有更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app_settings = &#123;</span><br><span class="line">  AzureWebJobsServiceBus      = &quot;@Microsoft.KeyVault(SecretUri=$&#123;azurerm_key_vault_secret.service_bus_connection_string.id&#125;)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更加奇怪的是，这之后他什么都没有做，只是重新再执行一次 <code>terraform apply</code>，该引用地址又被正确更新了？！</p>
<h2 id="1-9-6-1-2-问题原因"><a href="#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"></a>1.9.6.1.2. 问题原因</h2>
<p>因为 KeyVault Secret 被设计成是不可变的，所以更新 <code>azurerm_key_vault_secret</code> 的 <code>value</code> 会导致资源被重新创建。Terraform 官网上的相关文档中对该参数的定义如下：</p>
<blockquote>
<p><code>value</code> - (Required) Specifies the value of the Key Vault Secret.</p>
</blockquote>
<p>在 Terraform 中 ，一个参数如果被标记为 <code>Required</code>，那么它不但是必填项，同时类似数据库记录的主键的概念，主键不同的记录被认定是两条不同的记录，修改记录的主键值可以看作是删除重建之。Terraform 资源的 <code>Required</code> 参数如果发生变化会触发重新创建资源，这就导致了修改 <code>value</code> 后，该 <code>azurerm_key_vault_secret</code> 的 <code>id</code> 也会发生变化。</p>
<p>那么为什么在 <code>azurerm_key_vault_secret</code> 被重新创建之后，我们会发现 <code>azurerm_function_app</code> 中引用的 <code>id</code> 没有变化呢？</p>
<p>Terraform 的工作流含有 Plan 和 Apply 两个主要阶段，首先会分析 Terraform 代码，调用 <code>terraform refresh</code>（可以用参数跳过该步骤）读取资源在云端目前的最新状态，再加上 State 文件中记录的状态，三个状态对比出一个执行计划，使得最终产生的云端状态能够符合当前代码描述的状态。</p>
<p>就这个场景而言，Terraform 能够意识到 <code>azurerm_key_vault_secret</code> 的参数发生了变化，这会导致某种程度的更新，但它无法意识到这个更新会导致 <code>azurerm_key_vault_secret</code> 的 <code>id</code> 发生变化，进而导致 <code>azurerm_function_app</code> 也必须进行更新，所以就发生了他第一次执行 <code>terraform apply</code> 后看到的情况。</p>
<p>当他第二次执行 <code>terraform apply</code> 时，Terraform 记录的 State 文件里，<code>azurerm_key_vault_secret</code> 的 <code>id</code>和<code>azurerm_function_app</code> 里使用的 <code>id</code> 已经对不上了，这时 Terraform 会再生成一个更新 <code>azurerm_function_app</code> 的 Plan，执行后一切恢复正常。</p>
<p>有没有办法让 <code>azurerm_function_app</code> 能在第一次生成 Plan 时就感知到这个变更？</p>
<h2 id="1-9-6-1-3-巧用-null-resource-的-triggers"><a href="#%E5%B7%A7%E7%94%A8-nullresource-%E7%9A%84-triggers"></a>1.9.6.1.3. 巧用 null_resource 的 triggers</h2>
<p>HashiCorp 提供了一个非常常用的内建 Provider —— <code>null</code>。其中最知名的资源就是 <code>null_resource</code> 了，一般它都是和 <code>provisioner</code> 搭配出现，可以用来在某些资源创建完成后执行一些自定义脚本等等。但是它还有一个很有用的参数：</p>
<blockquote>
<p>The <code>triggers</code> argument allows specifying an arbitrary set of values that, when changed, will cause the resource to be replaced.</p>
</blockquote>
<p><code>triggers</code> 参数可以用来指向一些值，只要这些值的内容发生了变动，会导致 <code>null_resource</code> 资源被重新创建，从而生成一个新的 <code>id</code>。</p>
<h2 id="1-9-6-1-4-一个小实验"><a href="#%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%AE%9E%E9%AA%8C"></a>1.9.6.1.4. 一个小实验</h2>
<p>我们尝试构建一个简单的实验环境来验证一下，首先是这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_key_vault_secret&quot; &quot;example&quot; &#123;</span><br><span class="line">  name         = &quot;secret-sauce&quot;</span><br><span class="line">  value        = &quot;szechuan&quot;</span><br><span class="line">  key_vault_id = azurerm_key_vault.example.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;local_file&quot; &quot;output&quot; &#123;</span><br><span class="line">  filename = &quot;$&#123;path.module&#125;/output.txt&quot;</span><br><span class="line">  content = azurerm_key_vault_secret.example.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个 <code>azurerm_key_vault_secret</code>，然后把它的 <code>id</code> 输出到一个文件里。随后我们复制一下该文件，比如叫 <code>output.bak</code> 好了。随后我们修改 <code>azurerm_key_vault_secret</code> 的 <code>value</code> 到一个新的值，执行 <code>terraform apply</code> 以后，我们会发现 <code>output.txt</code> 与 <code>output.bak</code> 的内容完全一样，说明 <code>value</code> 的更新并没有触发 <code>local_file</code> 的更新。</p>
<p>随后我们把代码改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_key_vault_secret&quot; &quot;example&quot; &#123;</span><br><span class="line">  name         = &quot;secret-sauce&quot;</span><br><span class="line">  value        = &quot;szechuan2&quot;</span><br><span class="line">  key_vault_id = azurerm_key_vault.example.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;null_resource&quot; &quot;example&quot; &#123;</span><br><span class="line">  triggers = &#123;</span><br><span class="line">    trigger = azurerm_key_vault_secret.example.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;local_file&quot; &quot;output&quot; &#123;</span><br><span class="line">  filename = &quot;$&#123;path.module&#125;/output.txt&quot;</span><br><span class="line">  content = null_resource.example.id == null_resource.example.id ? azurerm_key_vault_secret.example.id : &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在代码中插入了一个 <code>null_resource</code>，并设置 <code>triggers</code> 的内容，盯住 <code>azurerm_key_vault_secret.example.value</code>。在 <code>value</code> 发生变化时，<code>null_resource</code> 的 <code>id</code> 也会发生变化。</p>
<p>然后我们在 <code>local_file</code> 的代码中，<code>content</code> 的赋值改成了这样一个三目表达式：<code>null_resource.example.id == null_resource.example.id ? azurerm_key_vault_secret.example.id : &quot;&quot;</code>。这个表达式里实际上 <code>null_resource.example.id</code> 是不起作用的，自己等于自己的永真条件会导致仍然使用 <code>azurerm_key_vault_secret.example.id</code> 作为值，但是由于掺入了 <code>null_resource.example.id</code>，使得 Terraform 在第一次计算 Plan 时就感知到 <code>local_file</code> 的内容发生了变化，从而使得我们可以一次 <code>terraform apply</code> 搞定。</p>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8-nullresource-%E6%90%AD%E9%85%8D-replacetriggeredby-%E6%9B%B4%E6%96%B0%E6%97%A0%E6%B3%95%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9%E7%9A%84%E5%B1%9E%E6%80%A7"><strong>1.9.7.1.</strong> 利用 null_resource 搭配 replace_triggered_by 更新无法从服务端读取内容的属性</a></li>
</ul>
<p><a href="#%E5%88%A9%E7%94%A8-nullresource-%E6%90%AD%E9%85%8D-replacetriggeredby-%E6%9B%B4%E6%96%B0%E6%97%A0%E6%B3%95%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9%E7%9A%84%E5%B1%9E%E6%80%A7"></a></p>
<h2 id="1-9-7-1-利用-null-resource-搭配-replace-triggered-by-更新无法从服务端读取内容的属性"><a href="#%E5%88%A9%E7%94%A8-nullresource-%E6%90%AD%E9%85%8D-replacetriggeredby-%E6%9B%B4%E6%96%B0%E6%97%A0%E6%B3%95%E4%BB%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9%E7%9A%84%E5%B1%9E%E6%80%A7"></a>1.9.7.1. 利用 null_resource 搭配 replace_triggered_by 更新无法从服务端读取内容的属性</h2>
<p>曾经处理的一个提问，有人写了这样一段 Terraform 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_container_group&quot; &quot;this&quot; &#123;</span><br><span class="line">  name                = var.name</span><br><span class="line">  location            = var.location</span><br><span class="line">  resource_group_name = var.resource_group_name</span><br><span class="line">  ip_address_type     = &quot;Private&quot;</span><br><span class="line">  network_profile_id  = azurerm_network_profile.this.id</span><br><span class="line">  os_type             = &quot;Linux&quot;</span><br><span class="line"></span><br><span class="line">  container &#123;</span><br><span class="line">    name   = &quot;someName&quot;</span><br><span class="line">    image  = &quot;someImage&quot;</span><br><span class="line">    cpu    = &quot;0.5&quot;</span><br><span class="line">    memory = &quot;0.5&quot;</span><br><span class="line"></span><br><span class="line">    commands = [&quot;some&quot;, &quot;commands&quot;]</span><br><span class="line"></span><br><span class="line">    ports &#123;</span><br><span class="line">      port     = 53</span><br><span class="line">      protocol = &quot;UDP&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    volume &#123;</span><br><span class="line">      mount_path = &quot;/app/conf&quot;</span><br><span class="line">      name       = &quot;someName&quot;</span><br><span class="line">      read_only  = true</span><br><span class="line">      secret = &#123;</span><br><span class="line">        Corefile = base64encode(someContent)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tags = var.tags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果每次执行 <code>apply</code> 操作时，都会发现 Terraform 试图重建这个容器：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># module.dns_forwarder.azurerm_container_group.this must be replaced</span><br><span class="line">-/+ resource &quot;azurerm_container_group&quot; &quot;this&quot; &#123;</span><br><span class="line">      ~ exposed_port        = [</span><br><span class="line">          - &#123;</span><br><span class="line">              - port     = 53</span><br><span class="line">              - protocol = &quot;UDP&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        ] -&gt; (known after apply)</span><br><span class="line">      + fqdn                = (known after apply)</span><br><span class="line">      ~ id                  = &quot;/subscriptions/&lt;mySubId&gt;/resourceGroups/&lt;myRgName&gt;/providers/Microsoft.ContainerInstance/containerGroups/&lt;myContainerGroupName&gt;&quot; -&gt; (known after apply)</span><br><span class="line">      ~ ip_address          = &quot;someIp&quot; -&gt; (known after apply)</span><br><span class="line">        name                = &quot;someName&quot;</span><br><span class="line">      - tags                = &#123;&#125; -&gt; null</span><br><span class="line">        # (6 unchanged attributes hidden)</span><br><span class="line"></span><br><span class="line">      ~ container &#123;</span><br><span class="line">          - environment_variables        = &#123;&#125; -&gt; null</span><br><span class="line">            name                         = &quot;someName&quot;</span><br><span class="line">          - secure_environment_variables = (sensitive value)</span><br><span class="line">            # (4 unchanged attributes hidden)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          ~ volume &#123;</span><br><span class="line">                name       = &quot;someName&quot;</span><br><span class="line">              ~ secret     = (sensitive value) # forces replacement</span><br><span class="line">                # (3 unchanged attributes hidden)</span><br><span class="line">            &#125;</span><br><span class="line">            # (1 unchanged block hidden)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个问题的原因是 API 在读取容器信息时不会返回 <code>volume</code> 的 <code>secret</code> 数据，这其实是一个还挺合理的设定，机密数据的确不应该可以直接从 API 返回，但这就导致 Terraform 每次制定变更计划时都会试图重新设置这个值(因为会理解成服务端这个值被修改成了空)，而容器是不可变的，要修改容器的任何配置都会导致容器被重建。</p>
<p>有没有办法能够避免这种问题？经验告诉我们，可以使用 <code>ignore_changes</code> 让 Terraform 忽略这个属性的变更来避免重建，但如果 <code>secret</code> 真的变了怎么办？</p>
<p>我们可以这样干，第一，在 <code>azurerm_container_group</code> 添加这样一段 <code>lifecycle</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lifecycle &#123;</span><br><span class="line">    ignore_changes       = [container[0].volume[0].secret]</span><br><span class="line">    replace_triggered_by = [null_resource.secret_trigger.id]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会忽略 <code>secret</code> 的变化，但我们同时声明了一个 <code>replace_triggered_by</code>，在 <code>null_resource.secret_trigger.id</code> 的值发生变化时可以删除重建 <code>azurerm_container_group</code> 实例。</p>
<p>其次，我们把 <code>secret</code> 的内容提取到一个 <code>local</code> 里，这时 <code>azurerm_container_group</code> 的 <code>volume</code> 看起来大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">volume &#123;</span><br><span class="line">    mount_path = &quot;/app/conf&quot;</span><br><span class="line">    name       = &quot;somename&quot;</span><br><span class="line">    read_only  = true</span><br><span class="line">    secret     = &#123;</span><br><span class="line">      Corefile = local.secret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>local.secret</code> 存放着使用的机密数据。这时我们再定义一个 <code>null_resource</code> 充当触发器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  secret = base64encode(&quot;abcdefg&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;null_resource&quot; &quot;secret_trigger&quot; &#123;</span><br><span class="line">  triggers = &#123;</span><br><span class="line">    trigger = local.secret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在机密数据真的发生变化的时候，<code>triggers</code> 会触发 <code>null_resource</code> 的重建，导致 <code>null_resource.secret_trigger.id</code> 发生变化，进而触发 <code>azurerm_container_group</code> 的重建。</p>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E8%BE%93%E5%87%BA%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E"><strong>1.9.8.1.</strong> 创建资源的条件依赖另一个资源的输出时怎么办</a></li>
</ul>
<p><a href="#%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E8%BE%93%E5%87%BA%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E"></a></p>
<h2 id="1-9-8-1-创建资源的条件依赖另一个资源的输出时怎么办"><a href="#%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E8%BE%93%E5%87%BA%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E"></a>1.9.8.1. 创建资源的条件依赖另一个资源的输出时怎么办</h2>
<p>我们在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/8.%E6%8A%80%E5%B7%A7/1.%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%88%9B%E5%BB%BA">有条件创建</a>当中介绍了如何可以通过判断用户的输入参数来决定是否要创建某个资源，让我们来看一下这样一个 Module 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;vpc_id&quot; &#123;</span><br><span class="line">  type    = string</span><br><span class="line">  default = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  count       = var.vpc_id == null ? 1 : 0</span><br><span class="line">  cidr_blocks = [&quot;10.0.0.0/16&quot;]</span><br><span class="line">  name        = &quot;vpc&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_subnet&quot; &quot;subnet&quot; &#123;</span><br><span class="line">  cidr_block = &quot;10.0.0.0/24&quot;</span><br><span class="line">  vpc_id     = var.vpc_id == null ? ucloud_vpc.vpc[0].id : var.vpc_id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想在 Module 中创建一个 <code>ucloud_subnet</code>，用户可以输入一个 <code>vpc_id</code> 配置给它，也可以不输入，这时 Module 会创建一个 <code>ucloud_vpc</code> 来用。</p>
<p>假如我们使用这个模块，不传入 <code>vpc_id</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module vpc &#123;</span><br><span class="line">  source = &quot;./vpc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码生成的 Plan 内容如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  # module.vpc.ucloud_subnet.subnet will be created</span><br><span class="line">  + resource &quot;ucloud_subnet&quot; &quot;subnet&quot; &#123;</span><br><span class="line">      + cidr_block  = &quot;10.0.0.0/24&quot;</span><br><span class="line">      + create_time = (known after apply)</span><br><span class="line">      + id          = (known after apply)</span><br><span class="line">      + name        = (known after apply)</span><br><span class="line">      + remark      = (known after apply)</span><br><span class="line">      + tag         = &quot;Default&quot;</span><br><span class="line">      + vpc_id      = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  # module.vpc.ucloud_vpc.vpc[0] will be created</span><br><span class="line">  + resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">      + cidr_blocks  = [</span><br><span class="line">          + &quot;10.0.0.0/16&quot;,</span><br><span class="line">        ]</span><br><span class="line">      + create_time  = (known after apply)</span><br><span class="line">      + id           = (known after apply)</span><br><span class="line">      + name         = &quot;vpc&quot;</span><br><span class="line">      + network_info = (known after apply)</span><br><span class="line">      + remark       = (known after apply)</span><br><span class="line">      + tag          = &quot;Default&quot;</span><br><span class="line">      + update_time  = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 2 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure>
<p>完全符合预期。假如我们希望由模块的调用者来创建 Vpc 的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  cidr_blocks = [&quot;10.0.0.0/16&quot;]</span><br><span class="line">  name        = &quot;vpc&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module vpc &#123;</span><br><span class="line">  source = &quot;./vpc&quot;</span><br><span class="line"></span><br><span class="line">  vpc_id = ucloud_vpc.vpc.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们执行 <code>terraform plan</code> 的话，会得到这样的结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">╷</span><br><span class="line">│ Error: Invalid count argument</span><br><span class="line">│ </span><br><span class="line">│   on vpc/main.tf line 16, in resource &quot;ucloud_vpc&quot; &quot;vpc&quot;:</span><br><span class="line">│   16:   count       = var.vpc_id == null ? 1 : 0</span><br><span class="line">│ </span><br><span class="line">│ The &quot;count&quot; value depends on resource attributes that cannot be determined until apply, so Terraform cannot predict how many instances will be created. To work around this,</span><br><span class="line">│ use the -target argument to first apply only the resources that the count depends on.</span><br><span class="line">╵</span><br></pre></td></tr></table></figure>
<p>Terraform 试图向我们抱怨，我们在 <code>count</code> 参数的表达式里使用了一个必须在 <code>apply</code> 阶段才能知道的值，所以它无法在 <code>plan</code> 阶段就计算出 <code>count</code> 的值。它建议我们先用 <code>terraform apply</code> 命令搭配 <code>-target</code> 参数把 Vpc 先创建出来，消除后续计算 Plan 时尚不知晓的值来解决这个问题。</p>
<p>这当然是一种很麻烦的方法，所以我们在设计 Module 时就要考虑到这种问题。有一种很简单的方法可以解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;vpc&quot; &#123;</span><br><span class="line">  type    = object(</span><br><span class="line">    &#123;</span><br><span class="line">      id = string</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  default = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">  count       = var.vpc == null ? 1 : 0</span><br><span class="line">  cidr_blocks = [&quot;10.0.0.0/16&quot;]</span><br><span class="line">  name        = &quot;vpc&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;ucloud_subnet&quot; &quot;subnet&quot; &#123;</span><br><span class="line">  cidr_block = &quot;10.0.0.0/24&quot;</span><br><span class="line">  vpc_id     = var.vpc == null ? ucloud_vpc.vpc[0].id : var.vpc.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把用来判断创建条件的输入参数类型改成 <code>object</code>，调用 Module 的代码就变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  # ucloud_vpc.vpc will be created</span><br><span class="line">  + resource &quot;ucloud_vpc&quot; &quot;vpc&quot; &#123;</span><br><span class="line">      + cidr_blocks  = [</span><br><span class="line">          + &quot;10.0.0.0/16&quot;,</span><br><span class="line">        ]</span><br><span class="line">      + create_time  = (known after apply)</span><br><span class="line">      + id           = (known after apply)</span><br><span class="line">      + name         = &quot;vpc&quot;</span><br><span class="line">      + network_info = (known after apply)</span><br><span class="line">      + remark       = (known after apply)</span><br><span class="line">      + tag          = &quot;Default&quot;</span><br><span class="line">      + update_time  = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  # module.vpc.ucloud_subnet.subnet will be created</span><br><span class="line">  + resource &quot;ucloud_subnet&quot; &quot;subnet&quot; &#123;</span><br><span class="line">      + cidr_block  = &quot;10.0.0.0/24&quot;</span><br><span class="line">      + create_time = (known after apply)</span><br><span class="line">      + id          = (known after apply)</span><br><span class="line">      + name        = (known after apply)</span><br><span class="line">      + remark      = (known after apply)</span><br><span class="line">      + tag         = &quot;Default&quot;</span><br><span class="line">      + vpc_id      = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 2 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure>
<p>成功计算出 Plan。请注意虽然这个 Plan 仍然是创建两个资源，但 <code>ucloud_vpc</code> 资源并不是 Module 创建的。</p>
<p>这个方法的原理就是虽然 <code>var.vpc.id</code> 仍然是一个只有在 <code>apply</code> 阶段才能知道的值，但 <code>var.vpc</code> 本身是一个在 <code>plan</code> 阶段就可以知道的值，直接可以判读它是否为 <code>null</code>，所以该方法可以绕过这个限制。</p>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8-createbeforedestroy-%E8%B0%83%E6%95%B4%E8%B5%84%E6%BA%90-update-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><strong>1.9.9.1.</strong> 利用 create_before_destroy 调整资源 Update 的执行顺序</a></li>
</ul>
<p><a href="#%E5%88%A9%E7%94%A8-createbeforedestroy-%E8%B0%83%E6%95%B4%E8%B5%84%E6%BA%90-update-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"></a></p>
<h2 id="1-9-9-1-利用-create-before-destroy-调整资源-Update-的执行顺序"><a href="#%E5%88%A9%E7%94%A8-createbeforedestroy-%E8%B0%83%E6%95%B4%E8%B5%84%E6%BA%90-update-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"></a>1.9.9.1. 利用 create_before_destroy 调整资源 Update 的执行顺序</h2>
<p>最近处理了一个问题，有人写了这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;azurerm&quot; &#123;</span><br><span class="line">  features &#123;</span><br><span class="line">    resource_group &#123;</span><br><span class="line">      prevent_deletion_if_contains_resources = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;azurerm_resource_group&quot; &quot;rg&quot; &#123;</span><br><span class="line">  location = &quot;eastus&quot;</span><br><span class="line">  name     = &quot;example&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  environments = toset([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;azurerm_public_ip&quot; &quot;lb&quot; &#123;</span><br><span class="line">  for_each = local.environments</span><br><span class="line"></span><br><span class="line">  name                = &quot;frontend-lb-$&#123;each.key&#125;&quot;</span><br><span class="line">  location            = azurerm_resource_group.rg.location</span><br><span class="line">  resource_group_name = azurerm_resource_group.rg.name</span><br><span class="line">  allocation_method   = &quot;Static&quot;</span><br><span class="line">  ip_version          = &quot;IPv4&quot;</span><br><span class="line">  sku                 = &quot;Standard&quot;</span><br><span class="line">  zones               = [1, 2, 3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;azurerm_lb&quot; &quot;this&quot; &#123;</span><br><span class="line">  name                = &quot;azurelb&quot;</span><br><span class="line">  location            = azurerm_resource_group.rg.location</span><br><span class="line">  resource_group_name = azurerm_resource_group.rg.name</span><br><span class="line">  sku                 = &quot;Standard&quot;</span><br><span class="line"></span><br><span class="line">  dynamic &quot;frontend_ip_configuration&quot; &#123;</span><br><span class="line">    for_each = local.environments</span><br><span class="line">    content &#123;</span><br><span class="line">      name                 = frontend_ip_configuration.key</span><br><span class="line">      public_ip_address_id = azurerm_public_ip.lb[frontend_ip_configuration.key].id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当他从 <code>local.environments</code> 中删除一个元素，然后执行 <code>terraform apply</code> 时，他遇到了下面的问题：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">│ Error: deleting Public Ip Address: (Name &quot;azurelb&quot; / Resource Group &quot;example&quot;): network.PublicIPAddressesClient#Delete: Failure sending request: StatusCode=400 -- Original Error: Code=&quot;PublicIPAddressCannotBeDeleted&quot; Message=&quot;Public IP address /subscriptions/subscription-id/resourceGroups/resource-group/providers/Microsoft.Network/publicIPAddresses/one can not be deleted since it is still allocated to resource /subscriptions/subscription-id/resourceGroups/resource-group/providers/Microsoft.Network/loadBalancers/azurelb/frontendIPConfigurations/one. In order to delete the public IP, disassociate/detach the Public IP address from the resource.  To learn how to do this, see aka.ms/deletepublicip.&quot; Details=[]</span><br></pre></td></tr></table></figure>
<p>这其实是一个还挺常见的问题，<code>azurerm_lb.this</code> 依赖于 <code>azurerm_public_ip.lb[index]</code>，正确的变更顺序应该是先更新 <code>azurerm_lb.this</code>，再删除 <code>azurerm_public_ip.lb</code> 的成员，但是 Terraform 默认的执行顺序会首先尝试执行删除操作，这时因为 ip 仍然被 LoadBalancer 使用着，所以会引发一个错误。</p>
<p>解决方法是给 <code>azurerm_public.lb</code> 添加一个 <code>create_before_destroy</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_public_ip&quot; &quot;lb&quot; &#123;</span><br><span class="line">  for_each = local.environments</span><br><span class="line"></span><br><span class="line">  name                = &quot;frontend-lb-$&#123;each.key&#125;&quot;</span><br><span class="line">  location            = azurerm_resource_group.rg.location</span><br><span class="line">  resource_group_name = azurerm_resource_group.rg.name</span><br><span class="line">  allocation_method   = &quot;Static&quot;</span><br><span class="line">  ip_version          = &quot;IPv4&quot;</span><br><span class="line">  sku                 = &quot;Standard&quot;</span><br><span class="line">  zones               = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    create_before_destroy = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create_before_destroy</code> 名字里虽然看起来是与 Create 有关，实际上它也会将 Update 与 Create 放在一起调整，声明该参数后实际上是将 <code>azurerm_public_ip.lb</code> 的 Delete 推迟到执行 Update 之后再执行了，该问题得解。</p>
<ul>
<li>
<p><a href="#terraform-%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96"><strong>1.9.10.1.</strong> Terraform 与自动化</a></p>
</li>
<li>
<p><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84-terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E4%BD%9C%E6%B5%81"><strong>1.9.10.1.1.</strong> 自动化的 Terraform 命令行工作流</a></p>
</li>
<li>
<p><a href="#%E6%8E%A7%E5%88%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%AD%E7%9A%84-terraform-%E8%BE%93%E5%87%BA"><strong>1.9.10.1.2.</strong> 控制自动化中的 Terraform 输出</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C-plan-%E5%92%8C-apply"><strong>1.9.10.1.3.</strong> 在不同的机器上运行 plan 和 apply</a></p>
</li>
<li>
<p><a href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%A1%E6%89%B9%E8%AE%A1%E5%88%92"><strong>1.9.10.1.4.</strong> 交互式审批计划</a></p>
</li>
<li>
<p><a href="#%E8%87%AA%E5%8A%A8%E6%89%B9%E5%87%86%E8%AE%A1%E5%88%92"><strong>1.9.10.1.5.</strong> 自动批准计划</a></p>
</li>
<li>
<p><a href="#%E7%94%A8-terraform-plan-%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95-pull-requests"><strong>1.9.10.1.6.</strong> 用 terraform plan 命令测试 Pull Requests</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2"><strong>1.9.10.1.7.</strong> 多环境部署</a></p>
</li>
<li>
<p><a href="#%E9%A2%84%E5%85%88%E5%AE%89%E8%A3%85%E7%9A%84%E6%8F%92%E4%BB%B6"><strong>1.9.10.1.8.</strong> 预先安装的插件</a></p>
</li>
</ul>
<p><a href="#terraform-%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96"></a></p>
<h2 id="1-9-10-1-Terraform-与自动化"><a href="#terraform-%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96"></a>1.9.10.1. Terraform 与自动化</h2>
<p>如果团队使用 Terraform 作为变更管理和部署管道的核心工具，可能需要以某种自动化方式编排 Terraform 的运行，以确保运行之间的一致性，并提供其他有趣的功能，例如与版本控制系统钩子的集成。</p>
<p>Terraform 的自动化可以有多种形式，并且程度不同。一些团队继续在本地运行 Terraform，但使用脚本代码来准备一致的工作目录来运行 Terraform，而另一些团队则完全在 Jenkins 等 CI 工具中运行 Terraform。</p>
<p>本篇涵盖了实现此类自动化时应考虑的一些事项，既确保 Terraform 的安全运行，又适应 Terraform 工作流程中当前需要仔细注意的一些限制。它假设 Terraform 将在非交互式环境中运行，无法在终端提示输入。对于脚本代码来说不一定如此，但在 CI 工具中运行时通常如此。</p>
<h2 id="1-9-10-1-1-自动化的-Terraform-命令行工作流"><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84-terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E4%BD%9C%E6%B5%81"></a>1.9.10.1.1. 自动化的 Terraform 命令行工作流</h2>
<p>在自动化流程中运行 Terraform 时，重点通常是核心的 <code>plan</code>/<code>apply</code> 循环。那么，使用 Terraform 命令行的流程大体如下：</p>
<ol>
<li>初始化 Terraform 工作目录。</li>
<li>针对当前代码，为产生变化的资源计算变更计划</li>
<li>让操作员审查计划，以确保其可接受</li>
<li>应用计划描述的更改。</li>
</ol>
<p>步骤 1、2 和 4 可以使用熟悉的 Terraform 命令以及一些附加选项来执行：</p>
<ul>
<li><code>terraform init -input=false</code> 初始化工作目录。</li>
<li><code>terraform plan -out=tfplan -input=false</code> 创建计划文件并将其保存到名为 <code>tfplan</code> 的本地文件。</li>
<li><code>terraform apply -input=false tfplan</code> 执行存储在文件 <code>tfplan</code> 中的计划。</li>
</ul>
<p><code>-input=false</code> 参数命令 Terraform 不应尝试提示输入，而是要求配置文件或命令行提供所有必要的值。因此，可能需要在 <code>terraform plan</code> 上使用 <code>-var</code> 和 <code>-var-file</code> 参数来指定所有传统上在交互式使用下手动输入的变量值。</p>
<p>强烈建议使用支持远程状态的 Backend，因为 Terraform 可以自动将持久保存状态，后续运行可以在找回并更新状态。选择支持状态锁定的 Backend 还将提供针对 Terraform 并发运行的竞争安全保障。</p>
<h2 id="1-9-10-1-2-控制自动化中的-Terraform-输出"><a href="#%E6%8E%A7%E5%88%B6%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%AD%E7%9A%84-terraform-%E8%BE%93%E5%87%BA"></a>1.9.10.1.2. 控制自动化中的 Terraform 输出</h2>
<p>默认情况下，一些 Terraform 命令会提示用户下一步可能执行的步骤，通常包括具体的下一步要运行的命令。</p>
<p>自动化工具通常会封装正在运行的命令的具体细节，只提供抽象的步骤，这时 Terraform 输出的此类消息反而令人困惑，且无法操作，如果它们无意中鼓励用户完全绕过自动化工具，则可能还是有害的。</p>
<p>当环境变量 <code>TF_IN_AUTOMATION</code> 设置为任何非空值时，Terraform 会对其输出进行一些细微调整，不再强调要运行的特定命令。所做的具体更改会随着时间的推移而变化，但一般来说，Terraform 发现该变量时，会认为存在某种包装了 Terraform 的应用程序，它们会帮助用户进行下一步。</p>
<p>为了降低复杂性，该功能主要针对 Terraform 主要的工作流程命令实现。无论该变量为何值如何，其他辅助命令仍可能会产生命令行建议。</p>
<h2 id="1-9-10-1-3-在不同的机器上运行-plan-和-apply"><a href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C-plan-%E5%92%8C-apply"></a>1.9.10.1.3. 在不同的机器上运行 plan 和 apply</h2>
<p>在 CI 工具中运行时，可能很难或无法确保 <code>plan</code> 和 <code>apply</code> 命令在同一台计算机上的同一目录中运行，并且所有的文件都保持相同。</p>
<p>在不同的机器上运行 <code>plan</code> 和 <code>apply</code> 需要一些额外的步骤来确保正确的行为。稳健的策略如下：</p>
<ul>
<li><code>plan</code> 完成后，保存整个工作目录，包括 <code>init</code> 期间创建的 <code>.terraform</code> 子目录，并将其保存在 <code>apply</code> 阶段可以访问得到的位置。常见的选择是作为所选 CI 工具中的“Build Artifact”。</li>
<li>在运行 <code>apply</code> 之前，获取上一步中创建的存档并将其解压到相同的绝对路径。这会重新创建 <code>plan</code> 后出现的所有内容，避免在 <code>plan</code> 步骤期间创建本地文件的奇怪问题。</li>
</ul>
<p>Terraform 目前为此类自动化系统设置了一些必须满足的前提条件：</p>
<ul>
<li>保存的计划文件可以包含子模块的绝对路径以及代码中引用的其他数据文件。因此，必须确保在相同的绝对路径中还原保存的工作目录。这通常是通过在某种隔离中运行 Terraform 来实现的，例如可以控制文件系统布局的 Docker 容器。</li>
<li>Terraform 假设该计划将在与其创建时相同的操作系统和 CPU 架构上 Apply。例如，这意味着无法在 Windows 计算机上创建计划，然后将其应用到 Linux 服务器上。</li>
<li>Terraform 期望用于生成计划的 Provider 程序插件在应用计划时可用且相同，以确保正确执行计划。如果在创建和应用计划之间升级 Terraform 或任何插件，将会产生错误。</li>
<li>Terraform 无法自动检测用于创建计划的凭据是否授予对用于应用该计划的相同资源的访问权限。如果对每个凭据使用不同的凭据（例如，使用只读凭据生成计划），那么确保两套凭据在它们所属的相应服务的帐户中保持一致非常重要。</li>
</ul>
<p><strong>警告</strong>：计划文件包含代码的完整副本、计划所要应用的状态数据以及传递给 <code>terraform plan</code> 的所有变量。如果其中包含任意敏感数据，则包含计划文件的存档工作目录应受到相应保护。对于 Provider 使用的身份验证凭据，建议尽可能使用环境变量，因为这些变量不会被包含在计划中或由 Terraform 以任何其他方式保存到磁盘。</p>
<h2 id="1-9-10-1-4-交互式审批计划"><a href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%A1%E6%89%B9%E8%AE%A1%E5%88%92"></a>1.9.10.1.4. 交互式审批计划</h2>
<p>自动化 Terraform 工作流程的另一个挑战是需要在计划和应用之间进行交互式审批步骤。为了稳健地实现这一点，重要的是要确保一次只能有一个计划未完成，或者两个步骤相互连接，以便批准计划将足够的信息传递到应用步骤，以确保应用正确的计划，与后来也存在的一些计划相反。</p>
<p>不同的 CI 工具以不同的方式解决这个问题，但通常这是通过构建管道功能实现的，其中可以按顺序应用不同的步骤，后面的步骤可以访问前面步骤生成的数据。</p>
<p>推荐的方法是一次只允许一个计划处于未应用状态。应用计划时，针对同一状态生成的任何其他现有计划都会失效，因为现在必须相对于新状态重新计算它们。通过强制计划按顺序获得批准（或驳回），可以避免这种情况。</p>
<h2 id="1-9-10-1-5-自动批准计划"><a href="#%E8%87%AA%E5%8A%A8%E6%89%B9%E5%87%86%E8%AE%A1%E5%88%92"></a>1.9.10.1.5. 自动批准计划</h2>
<p>虽然强烈建议对生产环境应用计划前要进行人工审查，但有时在预生产或开发环境中部署时需要采取更自动化的方法。</p>
<p>如果不需要手动批准，可以使用更简单的命令序列：</p>
<ul>
<li><code>terraform init -input=false</code></li>
<li><code>terraform apply -input=false -auto-approve</code></li>
</ul>
<p><code>apply</code> 命令的这个变体隐式地创建一个新计划，然后立即应用它。 <code>-auto-approve</code> 选项告诉 Terraform 在应用计划之前不需要对计划进行交互式批准。</p>
<p><strong>警告</strong>：当 Terraform 有权对基础设施进行破坏性更改时，始终建议对计划进行人工审查，除非在发生意外更改时可以容忍停机。仅对非关键基础设施使用自动批准。</p>
<h2 id="1-9-10-1-6-用-terraform-plan-命令测试-Pull-Requests"><a href="#%E7%94%A8-terraform-plan-%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95-pull-requests"></a>1.9.10.1.6. 用 terraform plan 命令测试 Pull Requests</h2>
<p><code>terraform plan</code> 可以用来对 Terraform 配置的有效性进行某些有限的验证，而不影响实际的基础设施。尽管 <code>plan</code> 命令会更新状态以匹配实际资源，从而确保准确的计划，但更新后的状态文件并不会持久保存，因此可以安全地使用该命令来生成仅为了帮助代码审查而创建的“一次性”计划。</p>
<p>实现此类工作流程时，可以在相关代码审查工具（例如，Github Pull Request）中使用钩子，为每个正在审查的新提交触发 CI 工具。在这种情况下，Terraform 可以按如下方式运行：</p>
<ul>
<li><code>terraform plan -input=false</code></li>
</ul>
<p>与在“主”工作流程中一样，可能需要根据需要设置 <code>-var</code> 或 <code>-var-file</code>。在这种情况下不使用 <code>-out</code> 选项，因为为代码审查目的而生成的计划永远不会被应用。相反，一旦合并更改，就可以从主版本控制分支创建并应用新计划。</p>
<p><strong>警告</strong>：请注意，通过输入变量或环境变量将敏感秘密数据传递给 Terraform 将使任何可以提交 PR 的人都可以看到，因此在开源项目或任何私人项目上必须谨慎使用此流程部分，或所有贡献者不应能够直接访问凭据等。</p>
<h2 id="1-9-10-1-7-多环境部署"><a href="#%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2"></a>1.9.10.1.7. 多环境部署</h2>
<p>Terraform 的自动化通常会被用来创建数个相同的配置，比如为预发布、测试或多租户基础设施等场景生成平行的环境。这种情况下的自动化可以帮助确保为每个环境使用正确的设置，并且在每次操作之前正确配置工作目录。</p>
<p>多环境编排最有趣的两个命令是 <code>terraform init</code> 和 <code>terraform workspace</code>。前者可以与其他参数一起使用，以针对环境之间的差异定制 Backend 配置，而后者可用于在单个 Backend 中存储的相同配置的多个状态之间安全切换。</p>
<p>如果可能，建议对所有环境使用单一后端配置，并使用 <code>terraform workspace</code> 命令在工作空间之间切换：</p>
<ul>
<li><code>terraform init -input=false</code></li>
<li><code>terraform workspace select QA</code></li>
</ul>
<p>在此使用模型中，Backend 存储中使用固定的命名方案，以允许多个状态共存，而无需任何进一步的配置。</p>
<p>或者，自动化工具可以将环境变量 <code>TF_WORKSPACE</code> 设置为现有工作空间名称，这将覆盖使用 <code>terraform workspace select</code> 命令所做的任何选择。建议仅在非交互式使用中使用此环境变量，因为在本地 shell 环境中，很容易忘记设置该变量并将变更应用到错误的状态。</p>
<p>在一些更复杂的情况下，不可能跨环境共享相同的 Backend 配置。例如，环境可能运行在完全独立的不同帐户的服务里，因此需要对 Backend 本身使用不同的凭据或端点。在这种情况下，可以通过 <code>terraform init</code> 的 <code>-backend-config</code> 选项覆盖后端配置设置。</p>
<h2 id="1-9-10-1-8-预先安装的插件"><a href="#%E9%A2%84%E5%85%88%E5%AE%89%E8%A3%85%E7%9A%84%E6%8F%92%E4%BB%B6"></a>1.9.10.1.8. 预先安装的插件</h2>
<p>在默认使用情况下，<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/12.init.html"><code>terraform init</code></a> 会自动下载并安装代码中使用的所有 Provider 程序的插件，并将它们放置在 <code>.terraform</code> 目录的子目录中。这为简单的情况提供了更简单的工作流程，并允许每段代码可以使用不同版本的插件。</p>
<p>在自动化环境中，可能需要禁用此行为，而是提供一组已安装在运行 Terraform 的系统上的固定插件。这样就避免了每次执行时重新下载插件的开销，并允许系统管理员控制可以使用哪些插件。</p>
<p>要使用此机制，请在系统上的某个位置创建一个 Terraform 运行时会将插件可执行文件放入其中的目录。已发布的插件文件可在 <a target="_blank" rel="noopener" href="https://releases.hashicorp.com/">releases.hashicorp.com</a> 上下载。请务必下载适合目标操作系统和体系结构的文件。</p>
<p>提取必要的插件后，新插件目录的内容将如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lah /usr/lib/custom-terraform-plugins</span></span><br><span class="line">-rwxrwxr-x 1 user user  84M Jun 13 15:13 terraform-provider-aws-v1.0.0-x3</span><br><span class="line">-rwxrwxr-x 1 user user  84M Jun 13 15:15 terraform-provider-rundeck-v2.3.0-x3</span><br><span class="line">-rwxrwxr-x 1 user user  84M Jun 13 15:15 terraform-provider-mysql-v1.2.0-x3</span><br></pre></td></tr></table></figure>
<p>文件名末尾的版本信息很重要，它使得 Terraform 可以推断每个插件的版本号。可以安装同一 Provider 程序插件的多个版本，Terraform 将使用与 Terraform 代码中的 Provider 程序版本约束相匹配的最新版本。</p>
<p>填充此目录后，可以使用 <code>terraform init</code> 的 <code>-plugin-dir</code> 选项跳过常规的自动下载和插件发现行为：</p>
<ul>
<li><code>terraform init -input=false -plugin-dir=/usr/lib/custom-terraform-plugins</code></li>
</ul>
<p>使用该组参数时，只有给定目录中的插件可以被使用。这使系统管理员可以对执行环境进行强力控制，但另一方面，它会阻止使用尚未安装到本地插件目录中的较新插件版本。哪种方法更合适将取决于每个组织内的特定情况。</p>
<p>还可以通过创建 <code>terraform.d/plugins/OS_ARCH</code> 目录与配置一起提前安装插件，在自动下载其他插件之前将搜索该目录。 <code>-get-plugins=false</code> 参数可禁止 Terraform 自动下载其他插件。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/30/Teraform/Terraform-%E5%B0%8F%E6%8A%80%E5%B7%A7/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/29/Teraform/Terraform-%E6%B5%8B%E8%AF%95/"
                            aria-label=": Terraform-测试"
                        >
                            Terraform-测试
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-29T17:43:45+08:00">
	
		    2023 年 1 月 29 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#%E6%B5%8B%E8%AF%95"><strong>1.8.1.</strong> 测试</a></p>
</li>
<li>
<p><a href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%88%96%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><strong>1.8.1.1.</strong> 集成测试或单元测试</a></p>
</li>
<li>
<p><a href="#%E8%AF%AD%E6%B3%95"><strong>1.8.1.2.</strong> 语法</a></p>
</li>
<li>
<p><a href="#%E7%A4%BA%E4%BE%8B"><strong>1.8.1.2.1.</strong> 示例</a></p>
</li>
<li>
<p><a href="#run-%E5%9D%97"><strong>1.8.1.3.</strong> run 块</a></p>
</li>
<li>
<p><a href="#%E6%96%AD%E8%A8%80"><strong>1.8.1.3.1.</strong> 断言</a></p>
</li>
<li>
<p><a href="#variable-%E5%9D%97"><strong>1.8.1.4.</strong> variable 块</a></p>
</li>
<li>
<p><a href="#%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%88%96%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E5%8F%98%E9%87%8F"><strong>1.8.1.4.1.</strong> 通过命令行或定义文件指定变量</a></p>
</li>
<li>
<p><a href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E4%BC%98%E5%85%88%E7%BA%A7"><strong>1.8.1.4.2.</strong> 变量定义优先级</a></p>
</li>
<li>
<p><a href="#%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"><strong>1.8.1.4.3.</strong> 变量中的引用</a></p>
</li>
<li>
<p><a href="#provider-%E5%9D%97"><strong>1.8.1.5.</strong> provider 块</a></p>
</li>
<li>
<p><a href="#module-%E5%9D%97"><strong>1.8.1.6.</strong> module 块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%8A%B6%E6%80%81"><strong>1.8.1.6.1.</strong> 模块状态</a></p>
</li>
<li>
<p><a href="#%E9%A2%84%E6%9C%9F%E5%A4%B1%E8%B4%A5"><strong>1.8.1.7.</strong> 预期失败</a></p>
</li>
</ul>
<p><a href="#%E6%B5%8B%E8%AF%95"></a></p>
<h2 id="1-8-1-测试"><a href="#%E6%B5%8B%E8%AF%95"></a>1.8.1. 测试</h2>
<p>-&gt; <strong>注意：</strong> 该测试框架在 Terraform v1.6.0 及以后版本中可用。</p>
<p>Terraform 测试功能允许模块作者验证配置变更不会引入破坏性更改。测试针对特定的、临时的资源进行，防止对现有的基础设施或状态产生任何风险。</p>
<h2 id="1-8-1-1-集成测试或单元测试"><a href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%88%96%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"></a>1.8.1.1. 集成测试或单元测试</h2>
<p>默认情况下，Terraform 测试会创建真实的基础设施，并可以对这些基础设施进行断言和验证。这相当于集成测试，它通过调用 Terraform 创建基础设施并对其进行验证来测试 Terraform 的核心功能。</p>
<p>你可以通过更新 <a href="#run-%E5%9D%97"><code>run</code></a> 块中的 <code>command</code> 属性（下面有示例）来覆盖默认的测试行为。默认情况下，每个 <code>run</code> 块都会执行 <code>command = apply</code>，命令 Terraform 对你的配置执行完整的 <code>apply</code> 操作。将 <code>command</code> 值替换为 <code>command = plan</code> 会告诉 Terraform 不为这个 <code>run</code> 块创建新的基础设施。这将允许测试作者验证他们的基础设施中的逻辑操作和自定义条件，相当于编写了单元测试。</p>
<p>Terraform v1.7.0 引入了在 <code>terraform test</code> 执行期间模拟 Provider 返回数据的能力。这可以用于编写更详细和完整的单元测试。</p>
<h2 id="1-8-1-2-语法"><a href="#%E8%AF%AD%E6%B3%95"></a>1.8.1.2. 语法</h2>
<p>每个 Terraform 测试都保存在一个测试文件中。Terraform 根据文件扩展名发现测试文件：<code>.tftest.hcl</code> 或 <code>.tftest.json</code>。</p>
<p>每个测试文件包含以下根级别的属性和块：</p>
<ul>
<li>一个到多个 <a href="#run-%E5%9D%97"><code>run</code></a> 块。</li>
<li>零个到一个 <a href="#variable-%E5%9D%97"><code>variables</code></a> 块。</li>
<li>零个到多个 <a href="#provider-%E5%9D%97"><code>provider</code></a> 块。</li>
</ul>
<p>Terraform 按顺序执行 <code>run</code> 块，模拟一系列直接在配置目录中执行的 Terraform 命令。 <code>variables</code> 和 <code>provider</code> 块的顺序并不重要，Terraform 在测试操作开始时处理这些块中的所有值。我们建议首先在测试文件的开头定义你的 <code>variables</code> 和 <code>provider</code> 块。</p>
<h3 id="1-8-1-2-1-示例"><a href="#%E7%A4%BA%E4%BE%8B"></a>1.8.1.2.1. 示例</h3>
<p>以下示例演示了一个简单的 Terraform 配置，该配置创建了一个 AWS S3 存储桶，并使用输入变量来修改其名称。我们将创建一个示例测试文件（如下）来验证存储桶的名称是否如预期那样被创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># main.tf</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">    region = &quot;eu-central-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;bucket_prefix&quot; &#123;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;bucket&quot; &#123;</span><br><span class="line">  bucket = &quot;$&#123;var.bucket_prefix&#125;-bucket&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;bucket_name&quot; &#123;</span><br><span class="line">  value = aws_s3_bucket.bucket.bucket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下测试文件运行了一个单独的Terraform <code>plan</code> 命令，该命令创建了S3存储桶，然后通过检查实际名称是否与预期名称匹配，来验证计算名称的逻辑是否正确。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># valid_string_concat.tftest.hcl</span><br><span class="line"></span><br><span class="line">variables &#123;</span><br><span class="line">  bucket_prefix = &quot;test&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;valid_string_concat&quot; &#123;</span><br><span class="line"></span><br><span class="line">  command = plan</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.bucket.bucket == &quot;test-bucket&quot;</span><br><span class="line">    error_message = &quot;S3 bucket name did not match expected&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-8-1-3-run-块"><a href="#run-%E5%9D%97"></a>1.8.1.3. run 块</h2>
<p>每个 <code>run</code> 块都有以下字段和块：</p>
<table>
<thead>
<tr>
<th>字段或块名称</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>command</code></td>
<td>一个可选属性，可以是 <code>apply</code> 或 <code>plan</code>。</td>
<td><code>apply</code></td>
</tr>
<tr>
<td><code>plan_options.mode</code></td>
<td>一个可选属性，可以是 <code>normal</code> 或 <code>refresh-only</code>。</td>
<td><code>normal</code></td>
</tr>
<tr>
<td><code>plan_options.refresh</code></td>
<td>一个可选的 <code>bool</code> 属性。</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>plan_options.replace</code></td>
<td>一个可选属性，包含一个资源地址列表，引用测试配置中的资源。</td>
<td></td>
</tr>
<tr>
<td><code>plan_options.target</code></td>
<td>一个可选属性，包含一个资源地址列表，引用测试配置中的资源。</td>
<td></td>
</tr>
<tr>
<td><a href="#variable-%E5%9D%97"><code>variables</code></a></td>
<td>一个可选的 <code>variables</code> 块。</td>
<td></td>
</tr>
<tr>
<td><a href="#module-%E5%9D%97"><code>module</code></a></td>
<td>一个可选的 <code>module</code> 块。</td>
<td></td>
</tr>
<tr>
<td><a href="#provider-%E5%9D%97"><code>providers</code></a></td>
<td>一个可选的 <code>providers</code> 属性。</td>
<td></td>
</tr>
<tr>
<td><a href="#%E6%96%AD%E8%A8%80"><code>assert</code></a></td>
<td>可选的 <code>assert</code> 块。</td>
<td></td>
</tr>
<tr>
<td><code>expect_failures</code></td>
<td>一个可选属性。</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>command</code> 属性和 <code>plan_options</code> 块告诉 Terraform 对于每个 <code>run</code> 块执行哪个命令和选项。如果您没有指定 <code>command</code> 属性或 <code>plan_options</code> 块，那么默认操作是普通的 <code>terraform apply</code> 操作。</p>
<p><code>command</code> 属性指明操作应该是一个 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan"><code>plan</code></a> 操作还是一个 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/4.apply"><code>apply</code></a> 操作。</p>
<p><code>plan_options</code> 块允许测试的作者定义他们通常需要通过命令行标志和选项定义的 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/cli/commands/plan#planning-modes">plan mode</a> 和 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/cli/commands/plan#planning-options">选项</a>。我们将在 <a href="#variable-%E5%9D%97">变量</a> 部分介绍 <code>-var</code> 和 <code>-var-file</code> 选项。</p>
<h3 id="1-8-1-3-1-断言"><a href="#%E6%96%AD%E8%A8%80"></a>1.8.1.3.1. 断言</h3>
<p>Terraform 测试的 <code>run</code> 块断言是<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/expressions/custom-conditions">自定义条件</a>，由<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/expressions/custom-conditions">条件</a>和<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/expressions/custom-conditions#error-messages">错误消息</a>组成。</p>
<p>在 Terraform 测试命令执行结束时，Terraform 会将所有失败的断言作为测试通过或失败状态的一部分展示出来。</p>
<h4 id="断言中的引用"><a href="#%E6%96%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"></a>断言中的引用</h4>
<p>测试中的断言可以引用主 Terraform 配置中的其他自定义条件可用的任何现有<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/8.%E8%A1%A8%E8%BE%BE%E5%BC%8F#%E5%BC%95%E7%94%A8%E5%91%BD%E5%90%8D%E5%80%BC">命名值</a>。</p>
<p>此外，测试断言可以直接引用当前和先前 <code>run</code> 块的输出。比如引用了<a href="#%E7%A4%BA%E4%BE%8B">上一个示例</a>中的输出的一个合法的表达式条件：<code>condition = output.bucket_name == &quot;test_bucket&quot;</code>。</p>
<h2 id="1-8-1-4-variable-块"><a href="#variable-%E5%9D%97"></a>1.8.1.4. variable 块</h2>
<p>你可以直接在你的测试文件中为 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F">输入变量</a> 设置值。</p>
<p>你可以在测试文件的根级别或者 <code>run</code> 块内部定义 <code>variables</code> 块。Terraform 将测试文件中的所有变量值传递到文件中的所有 <code>run</code> 块。你可以通过在某个 <code>run</code> 块中直接设置变量值来覆盖从根部继承的值。</p>
<p>在上述 <a href="#%E7%A4%BA%E4%BE%8B">示例</a> 的测试文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># variable_precedence.tftest.hcl</span><br><span class="line"></span><br><span class="line">variables &#123;</span><br><span class="line">  bucket_prefix = &quot;test&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;uses_root_level_value&quot; &#123;</span><br><span class="line"></span><br><span class="line">  command = plan</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.bucket.bucket == &quot;test-bucket&quot;</span><br><span class="line">    error_message = &quot;S3 bucket name did not match expected&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;overrides_root_level_value&quot; &#123;</span><br><span class="line"></span><br><span class="line">  command = plan</span><br><span class="line"></span><br><span class="line">  variables &#123;</span><br><span class="line">    bucket_prefix = &quot;other&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.bucket.bucket == &quot;other-bucket&quot;</span><br><span class="line">    error_message = &quot;S3 bucket name did not match expected&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们添加了第二个 <code>run</code> 块，该块指定 <code>bucket_prefix</code> 变量值为 <code>other</code>，覆盖了测试文件提供的，并在第一个 <code>run</code> 块中使用的值 —— <code>test</code>。</p>
<h3 id="1-8-1-4-1-通过命令行或定义文件指定变量"><a href="#%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%88%96%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E5%8F%98%E9%87%8F"></a>1.8.1.4.1. 通过命令行或定义文件指定变量</h3>
<p>除了通过测试文件指定变量值外，Terraform <code>test</code> 命令还支持指定变量值的其他方法。</p>
<p>您可以通过 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">命令行</a> 和 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F#%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6">变量定义文件</a> 为所有测试指定变量值。</p>
<p>像普通的 Terraform 命令一样，Terraform 会自动加载测试目录中定义的任何变量文件。自动变量文件包括 <code>terraform.tfvars</code>、<code>terraform.tfvars.json</code>，以及所有以 <code>.auto.tfvars</code> 或 <code>.auto.tfvars.json</code> 结尾的文件。</p>
<p><strong>注意：</strong> 从测试目录中的自动变量文件加载的变量值只适用于在同一测试目录中定义的测试。以所有其他方式定义的变量将适用于给定测试运行中的所有测试。</p>
<p>这在使用敏感变量值和设置 Provider 配置时特别有用。否则，测试文件可能会直接暴露这些敏感值。</p>
<h3 id="1-8-1-4-2-变量定义优先级"><a href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E4%BC%98%E5%85%88%E7%BA%A7"></a>1.8.1.4.2. 变量定义优先级</h3>
<p>除了测试文件中设置的变量值，<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%BC%98%E5%85%88%E7%BA%A7">变量定义优先级</a> 在测试中保持不变。在测试文件中定义的变量具有最高优先级，可以覆盖环境变量、变量文件或命令行输入。</p>
<p>对于在测试目录中定义的测试，任何在测试目录的自动变量文件中定义的变量值都将覆盖主配置目录的自动变量文件中定义的值。</p>
<h3 id="1-8-1-4-3-变量中的引用"><a href="#%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"></a>1.8.1.4.3. 变量中的引用</h3>
<p>在 <code>run</code> 块中定义的 <code>variable</code> 中可以引用在先前 <code>run</code> 块中执行的模块的输出和在更高优先级定义的变量。</p>
<p>例如，以下代码块显示了变量如何引用更高优先级的变量和先前的 <code>run</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">variables &#123;</span><br><span class="line">  global_value = &quot;some value&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;run_block_one&quot; &#123;</span><br><span class="line">  variables &#123;</span><br><span class="line">    local_value = var.global_value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">  # 这里应该有一些测试断言</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;run_block_two&quot; &#123;</span><br><span class="line">  variables &#123;</span><br><span class="line">    local_value = run.run_block_one.output_one</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">  # 这里应该有一些测试断言</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面，<code>run_block_one</code> 中的 <code>local_value</code> 从 <code>global_value</code> 变量获取值。如果你想给多个变量分配相同的值，这种模式很有用。你可以在文件级别一次指定一个变量的值，然后与不同的变量共享它。</p>
<p>相比之下，<code>run_block_two</code> 中的 <code>local_value</code> 引用了 <code>run_block_one</code> 的 <code>output_one</code> 的输出值。这种模式对于在 <code>run</code> 块之间传递值特别有用，特别是如果 <code>run</code> 块正在执行<a href="#module-%E5%9D%97">模块</a>部分中详细描述的不同模块。</p>
<h2 id="1-8-1-5-provider-块"><a href="#provider-%E5%9D%97"></a>1.8.1.5. provider 块</h2>
<p>您可以通过使用 <code>provider</code> 和 <code>providers</code> 块和属性，在测试文件中设置或覆盖 Terraform 代码所需的 Provider。</p>
<p>您可以在 Terraform 测试文件的根级别，定义 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/providers/configuration"><code>provider</code> 块</a>，就像在 Terraform <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/providers">配置代码中</a>创建它们一样。然后，Terraform 会将这些 <code>provider</code> 块传递到其配置中，每个 <code>run</code> 块执行时都是如此。</p>
<p>默认情况下，您指定的每个 Provider 都直接在每个 <code>run</code> 块中可用。您可以通过使用 <code>providers</code> 属性在特定 <code>run</code> 块中设置 Provider 的可用性。这个块的行为和语法与 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/meta-arguments/module-providers">providers meta-argument</a> 的行为相匹配。</p>
<p>如果您在测试文件中不提供 Provider 配置，Terraform 会尝试使用 Provider 的默认设置初始化其配置中的所有 Provider。例如，任何旨在配置 Provider 的环境变量仍然可用，并且 Terraform 可以使用它们来创建默认 Provider。</p>
<p>下面，我们将扩展我们之前的 <a href="#%E7%A4%BA%E4%BE%8B">示例</a>，用测试代码而不是 Terraform 配置代码来指定 <code>region</code>。在这个示例中，我们将测试以下配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># main.tf</span><br><span class="line"></span><br><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;bucket_prefix&quot; &#123;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;bucket&quot; &#123;</span><br><span class="line">  bucket = &quot;$&#123;var.bucket_prefix&#125;-bucket&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;bucket_name&quot; &#123;</span><br><span class="line">  value = aws_s3_bucket.bucket.bucket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在可以在以下测试文件中定义如下的 <code>provider</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># customised_provider.tftest.hcl</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">    region = &quot;eu-central-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables &#123;</span><br><span class="line">  bucket_prefix = &quot;test&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;valid_string_concat&quot; &#123;</span><br><span class="line"></span><br><span class="line">  command = plan</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.bucket.bucket == &quot;test-bucket&quot;</span><br><span class="line">    error_message = &quot;S3 bucket name did not match expected&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们也可以创建一个更复杂的示例配置，使用多个 Provider 以及别名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># main.tf</span><br><span class="line"></span><br><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source                = &quot;hashicorp/aws&quot;</span><br><span class="line">      configuration_aliases = [aws.secondary]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;bucket_prefix&quot; &#123;</span><br><span class="line">  default = &quot;test&quot;</span><br><span class="line">  type    = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;primary_bucket&quot; &#123;</span><br><span class="line">  bucket = &quot;$&#123;var.bucket_prefix&#125;-primary&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;secondary_bucket&quot; &#123;</span><br><span class="line">  provider = aws.secondary</span><br><span class="line">  bucket   = &quot;$&#123;var.bucket_prefix&#125;-secondary&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的测试文件中，我们可以设定多个 Provider：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># customised_providers.tftest.hcl</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;secondary&quot;</span><br><span class="line">  region = &quot;eu-central-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;providers&quot; &#123;</span><br><span class="line"></span><br><span class="line">  command = plan</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.primary_bucket.bucket == &quot;test-primary&quot;</span><br><span class="line">    error_message = &quot;invalid value for primary S3 bucket&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.secondary_bucket.bucket == &quot;test-secondary&quot;</span><br><span class="line">    error_message = &quot;invalid value for secondary S3 bucket&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以在特定 <code>run</code> 块中声明特定的 Provider：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># main.tf</span><br><span class="line"></span><br><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source                = &quot;hashicorp/aws&quot;</span><br><span class="line">      configuration_aliases = [aws.secondary]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_region&quot; &quot;primary&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_region&quot; &quot;secondary&quot; &#123;</span><br><span class="line">  provider = aws.secondary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;bucket_prefix&quot; &#123;</span><br><span class="line">  default = &quot;test&quot;</span><br><span class="line">  type    = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;primary_bucket&quot; &#123;</span><br><span class="line">  bucket = &quot;$&#123;var.bucket_prefix&#125;-$&#123;data.aws_region.primary.name&#125;-primary&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;secondary_bucket&quot; &#123;</span><br><span class="line">  provider = aws.secondary</span><br><span class="line">  bucket   = &quot;$&#123;var.bucket_prefix&#125;-$&#123;data.aws_region.secondary.name&#125;-secondary&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的测试文件可以为不同的 <code>run</code> 块配置的 Provider：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># customised_providers.tftest.hcl</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;secondary&quot;</span><br><span class="line">  region = &quot;eu-central-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;tertiary&quot;</span><br><span class="line">  region = &quot;eu-west-2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;default_providers&quot; &#123;</span><br><span class="line"></span><br><span class="line">  command = plan</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.primary_bucket.bucket == &quot;test-us-east-1-primary&quot;</span><br><span class="line">    error_message = &quot;invalid value for primary S3 bucket&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.secondary_bucket.bucket == &quot;test-eu-central-1-secondary&quot;</span><br><span class="line">    error_message = &quot;invalid value for secondary S3 bucket&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;customised_providers&quot; &#123;</span><br><span class="line"></span><br><span class="line">  command = plan</span><br><span class="line"></span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws           = aws</span><br><span class="line">    aws.secondary = aws.tertiary</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.primary_bucket.bucket == &quot;test-us-east-1-primary&quot;</span><br><span class="line">    error_message = &quot;invalid value for primary S3 bucket&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition     = aws_s3_bucket.secondary_bucket.bucket == &quot;test-eu-west-2-secondary&quot;</span><br><span class="line">    error_message = &quot;invalid value for secondary S3 bucket&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 在使用 <code>command = apply</code> 运行测试时，<code>run</code> 块之间切换 Provider 可能会导致运行和测试失败，因为由一个 Provider 定义创建的资源在被另一个修改时将无法使用。</p>
<p>从 Terraform v1.7.0 开始，<code>provider</code> 块也可以引用测试文件变量和 <code>run</code> 块输出。这意味着测试框架可以从一个 Provider 获取凭证和其他设置信息，并在初始化第二个 Provider 时使用这些信息。</p>
<p>在下面的示例中，首先初始化 <code>vault</code> Provider，然后在一个设置模块中使用它来提取 <code>aws</code> Provider 的凭证。有关 setup 模块的更多信息，请参阅 <a href="#module-%E5%9D%97">模块</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">provider &quot;vault&quot; &#123;</span><br><span class="line">  # ... vault configuration ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region     = &quot;us-east-1&quot;</span><br><span class="line"></span><br><span class="line">  # The `aws` provider can reference the outputs of the &quot;vault_setup&quot; run block.</span><br><span class="line">  access_key = run.vault_setup.aws_access_key</span><br><span class="line">  secret_key = run.vault_setup.aws_secret_key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;vault_setup&quot; &#123;</span><br><span class="line">  module &#123;</span><br><span class="line">    # This module should only include reference to the Vault provider. Terraform</span><br><span class="line">    # will automatically work out which providers to supply based on the module</span><br><span class="line">    # configuration. The tests will error if a run block requires access to a</span><br><span class="line">    # provider that references outputs from a run block that has not executed.</span><br><span class="line">    source = &quot;./testing/vault-setup&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;use_aws_provider&quot; &#123;</span><br><span class="line">  # This run block can then use both the `aws` and `vault` providers, as the</span><br><span class="line">  # previous run block provided all the data required for the `aws` provider.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-8-1-6-module-块"><a href="#module-%E5%9D%97"></a>1.8.1.6. module 块</h2>
<p>您可以修改特定的 <code>run</code> 块执行的模块。</p>
<p>默认情况下，Terraform 针对正在测试的配置代码，依次执行所有 <code>run</code> 块中设定的命令。Terraform 在您执行 <code>terraform test</code> 命令的目录（或者您用 <code>-chdir</code> 参数指向的目录）内测试配置。每个 <code>run</code> 块也允许用户使用 <code>module</code> 块更改目标配置。</p>
<p>与传统的 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><code>module</code> 块</a>不同，测试文件中的 <code>module</code> 块 <em>仅</em> 支持 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97#%E6%A8%A1%E5%9D%97%E6%BA%90"><code>source</code></a> 属性和 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97#%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F"><code>version</code></a> 属性。通常通过传统的 <code>module</code> 块提供的其余属性应由 <code>run</code> 块内的替代属性和块提供。</p>
<p><strong>注意：</strong> Terraform 测试文件只支持 <code>source</code> 属性中的 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84">本地</a> 和 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97#terraform-registry">注册表</a> 模块。</p>
<p>在执行其他模块时，<code>run</code> 块内的所有其他块和属性都受支持，<code>assert</code> 块执行时使用来自其他模块的值。这在 <a href="#%E6%A8%A1%E5%9D%97%E7%8A%B6%E6%80%81">模块状态</a> 中有更详细的说明。</p>
<p>测试文件中 <code>modules</code> 块的两个示例用例是：</p>
<ol>
<li>一个设置模块，为待测 Terraform 配置代码创建测试所需的基础设施。</li>
<li>一个加载模块，用于加载和验证 Terraform 配置代码未直接创建的次要基础设施（如数据源）。</li>
</ol>
<p>以下示例演示了这两种用例。</p>
<p>首先，我们有一个模块，它将创建并将多个文件加载到已创建的 S3 存储桶中。这是我们要测试的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># main.tf</span><br><span class="line"></span><br><span class="line">variable &quot;bucket&quot; &#123;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;files&quot; &#123;</span><br><span class="line">  type = map(string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_s3_bucket&quot; &quot;bucket&quot; &#123;</span><br><span class="line">  bucket = var.bucket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_object&quot; &quot;object&quot; &#123;</span><br><span class="line">  for_each = var.files</span><br><span class="line"></span><br><span class="line">  bucket = data.aws_s3_bucket.bucket.id</span><br><span class="line">  key = each.key</span><br><span class="line">  source = each.value</span><br><span class="line"></span><br><span class="line">  etag = filemd5(each.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们使用配置模块创建这个 S3 存储桶，这样在测试时就可以使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># testing/setup/main.tf</span><br><span class="line"></span><br><span class="line">variable &quot;bucket&quot; &#123;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;bucket&quot; &#123;</span><br><span class="line">  bucket = var.bucket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，我们使用一个加载模块，读取 S3 存储桶中的文件。这是一个比较牵强的例子，因为我们完全可以直接在创建这些文件的模块中创建这些数据源，但它在这里可以很好地演示如何编写测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># testing/loader/main.tf</span><br><span class="line"></span><br><span class="line">variable &quot;bucket&quot; &#123;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_s3_objects&quot; &quot;objects&quot; &#123;</span><br><span class="line">  bucket = var.bucket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们使用测试文件把刚才创建的多个助手模块以及待测模块编织在一起形成一个有效的测试配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># file_count.tftest.hcl</span><br><span class="line"></span><br><span class="line">variables &#123;</span><br><span class="line">  bucket = &quot;my_test_bucket&quot;</span><br><span class="line">  files = &#123;</span><br><span class="line">    &quot;file-one.txt&quot;: &quot;data/files/file_one.txt&quot;</span><br><span class="line">    &quot;file-two.txt&quot;: &quot;data/files/file_two.txt&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;setup&quot; &#123;</span><br><span class="line">  # Create the S3 bucket we will use later.</span><br><span class="line"></span><br><span class="line">  module &#123;</span><br><span class="line">    source = &quot;./testing/setup&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;execute&quot; &#123;</span><br><span class="line">  # This is empty, we just run the configuration under test using all the default settings.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;verify&quot; &#123;</span><br><span class="line">  # Load and count the objects created in the &quot;execute&quot; run block.</span><br><span class="line"></span><br><span class="line">  module &#123;</span><br><span class="line">    source = &quot;./testing/loader&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition = length(data.aws_s3_objects.objects.keys) == 2</span><br><span class="line">    error_message = &quot;created the wrong number of s3 objects&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-1-6-1-模块状态"><a href="#%E6%A8%A1%E5%9D%97%E7%8A%B6%E6%80%81"></a>1.8.1.6.1. 模块状态</h3>
<p>当 Terraform 执行 <code>terraform test</code> 命令时，Terraform 会为每个测试文件在内存中维护一个或多个状态文件。</p>
<p>总是至少有一个状态文件维护在测试下的 Terraform 配置代码的状态。这个状态文件由所有没有 <code>module</code> 块指定要加载的替代模块的 <code>run</code> 块共享。</p>
<p>此外，Terraform 加载的每个替代模块都有一个状态文件。一个替代模块的状态文件被执行给定模块的所有 <code>run</code> 块共享。</p>
<p>Terraform 团队对任何需要手动状态管理或在 <code>test</code> 命令中对同一状态执行不同配置的用例感兴趣。如果你有一个用例，请提交一个 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/terraform/issues/new/choose">issue</a>并与我们分享。</p>
<p>以下示例使用注释来解释每个 <code>run</code> 块的状态文件的来源。在下面的示例中，Terraform 创建并管理了总共三个状态文件。第一个状态文件是针对测试下的主模块，第二个是针对设置模块，第三个是针对加载模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">run &quot;setup&quot; &#123;</span><br><span class="line"></span><br><span class="line">  # This run block references an alternate module and is the first run block</span><br><span class="line">  # to reference this particular alternate module. Therefore, Terraform creates</span><br><span class="line">  # and populates a new empty state file for this run block.</span><br><span class="line"></span><br><span class="line">  module &#123;</span><br><span class="line">    source = &quot;./testing/setup&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;init&quot; &#123;</span><br><span class="line"></span><br><span class="line">  # This run block does not reference an alternate module, so it uses the main</span><br><span class="line">  # state file for the configuration under test. As this is the first run block</span><br><span class="line">  # to reference the main configuration, the previously empty state file now</span><br><span class="line">  # contains the resources created by this run block.</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    # In practice we&#x27;d do some interesting checks and tests here but the</span><br><span class="line">    # assertions aren&#x27;t important for this example.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # ... more assertions ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;update_setup&quot; &#123;</span><br><span class="line"></span><br><span class="line">  # We&#x27;ve now re-referenced the setup module, so the state file that was created</span><br><span class="line">  # for the first &quot;setup&quot; run block will be reused. It will contain any</span><br><span class="line">  # resources that were created as part of the other run block before this run</span><br><span class="line">  # block executes and will be updated with any changes made by this run block</span><br><span class="line">  # after.</span><br><span class="line"></span><br><span class="line">  module &#123;</span><br><span class="line">    source = &quot;./testing/setup&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  variables &#123;</span><br><span class="line">    # In practice, we&#x27;d likely make some changes to the module compared to the</span><br><span class="line">    # first run block here. Otherwise, there would be no point recalling the</span><br><span class="line">    # module.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;update&quot; &#123;</span><br><span class="line"></span><br><span class="line">  # As with the &quot;init&quot; run block, we are executing against the main configuration</span><br><span class="line">  # again. This means we&#x27;d load the main state file that was initially populated</span><br><span class="line">  # by the &quot;init&quot; run block, and any changes made by this &quot;run&quot; block will be</span><br><span class="line">  # carried forward to any future run blocks that execute against the main</span><br><span class="line">  # configuration.</span><br><span class="line"></span><br><span class="line">  # ... updated variables ...</span><br><span class="line"></span><br><span class="line">  # ... assertions ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;loader&quot; &#123;</span><br><span class="line"></span><br><span class="line">  # This run block is now referencing our second alternate module so will create</span><br><span class="line">  # our third and final state file. The other two state files are managing</span><br><span class="line">  # resources from the main configuration and resources from the setup module.</span><br><span class="line">  # We are getting a new state file for this run block as the loader module has</span><br><span class="line">  # not previously been referenced by any run blocks.</span><br><span class="line"></span><br><span class="line">  module &#123;</span><br><span class="line">    source = &quot;./testing/loader&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模块的清理"><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%B8%85%E7%90%86"></a>模块的清理</h4>
<p>在测试文件执行结束时，Terraform 会试图销毁在该测试文件执行过程中创建的每个资源。当 Terraform 加载替代模块时，Terraform 销毁这些对象的顺序很重要。例如，在第一个 <a href="#module-%E5%9D%97">模块</a> 示例中，Terraform 不能在 “execute” <code>run</code> 块中创建的对象之前销毁在 “setup” <code>run</code> 块中创建的资源，因为我们在 “setup” 步骤中创建的 S3 桶在包含对象的情况下无法被销毁。</p>
<p>Terraform 按照 <code>run</code> 块的反向顺序销毁资源。在最近的 <a href="#%E6%A8%A1%E5%9D%97%E7%8A%B6%E6%80%81">例子</a> 中，有三个状态文件。一个用于主状态，一个用于 <code>./testing/loader</code> 模块，还有一个用于 <code>./testing/setup</code> 模块。由于 <code>./testing/loader</code> 状态文件最近被最后一个运行块引用，因此首先被销毁。主状态文件将被第二个销毁，因为它被 “update” <code>run</code> 块引用。然后 <code>./testing/setup</code> 状态文件将被最后销毁。</p>
<p>请注意，前两个 <code>run</code> 块 “setup” 和 “init” 在销毁操作中不做任何事情，因为它们的状态文件被后续的 run 块使用，并且已经被销毁。</p>
<p>如果你使用单个设置模块作为替代模块，并且它首先执行，或者你不使用任何替代模块，那么销毁顺序不会影响你。更复杂的情况可能需要仔细考虑，以确保资源的销毁可以自动完成。</p>
<h2 id="1-8-1-7-预期失败"><a href="#%E9%A2%84%E6%9C%9F%E5%A4%B1%E8%B4%A5"></a>1.8.1.7. 预期失败</h2>
<p>默认情况下，如果在执行 Terraform 测试文件期间，任何<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/expressions/custom-conditions">自定义条件</a>，包括 <code>check</code> 块断言失败，则整体命令会将测试报告为失败。</p>
<p>然而，我们经常想要测试代码运行失败时的行为。Terraform 为此用例提供了 <code>expect_failures</code> 属性。</p>
<p>在每个 <code>run</code> 块中，<code>expect_failures</code> 属性可以设置应该导致自定义条件检查失败的可检查对象（资源，数据源，检查块，输入变量和输出）的列表。如果您指定的可检查对象报告问题，测则试通过，如果没有报告错误，那么测试总体上失败。</p>
<p>您仍然可以在 <code>expect_failures</code> 块附近编写断言，但您应该注意，除了 <code>check</code> 块断言外，所有自定义条件都会停止 Terraform 的执行。这在测试执行期间仍然适用，所以这些断言应该只考虑你确定会在可检查对象应该失败之前可知的值。您可以使用引用或在主配置中的 <code>depends_on</code> 元参数来管理这一点。</p>
<p>这也意味着，除了 <code>check</code> 块，你只能可靠地包含一个可检查的对象。我们支持在 <code>expect_failures</code> 属性中列出可检查对象的列表，仅用于 <code>check</code> 块。</p>
<p>下面的一个快速示例演示了测试输入变量的 <code>validation</code> 块。配置文件接受一个必须是偶数的单一输入变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># main.tf</span><br><span class="line"></span><br><span class="line">variable &quot;input&quot; &#123;</span><br><span class="line">  type = number</span><br><span class="line"></span><br><span class="line">  validation &#123;</span><br><span class="line">    condition = var.input % 2 == 0</span><br><span class="line">    error_message = &quot;must be even number&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试文件包含了两个 <code>run</code> 块。一个验证了我们的自定义条件在偶数条件下是通过的，另一个验证输入奇数时会失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># input_validation.tftest.hcl</span><br><span class="line"></span><br><span class="line">variables &#123;</span><br><span class="line">  input = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;zero&quot; &#123;</span><br><span class="line">  # The variable defined above is even, so we expect the validation to pass.</span><br><span class="line"></span><br><span class="line">  command = plan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &quot;one&quot; &#123;</span><br><span class="line">  # This time we set the variable is odd, so we expect the validation to fail.</span><br><span class="line"></span><br><span class="line">  command = plan</span><br><span class="line"></span><br><span class="line">  variables &#123;</span><br><span class="line">    input = 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  expect_failures = [</span><br><span class="line">    var.input,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：Terraform 只期望在 <code>run</code> 块的 <code>command</code> 属性指定的操作中出现失败。</p>
<p>在使用 <code>command = apply</code> 的 <code>run</code> 块中使用 <code>expect_failures</code> 时要小心。一个 <code>run</code> 块中的 <code>command = apply</code> 如果期望自定义条件失败，那么如果该自定义条件在 <code>plan</code> 期间失败，整体将会失败。</p>
<p>这在逻辑上是正确的，因为 <code>run</code> 块期望能够运行应用操作，但由于 <code>plan</code> 失败而不能运行，但这也可能会引起混淆，因为即使那个失败被标记为预期的，你还是会在诊断中看到失败。</p>
<p>有时，Terraform 在计划阶段不执行自定义条件，因为该条件依赖于只有在 Terraform 创建引用资源后才可用的计算属性。在这些情况下，你可以在设置 <code>command = apply</code> 时使用 <code>expect_failures</code> 块。然而，大多数情况下，我们建议只在 <code>command = plan</code> 时使用 <code>expect_failures</code>。</p>
<p><strong>注意</strong>：预期的失败只适用于用户定义的自定义条件。</p>
<p>除了在可检查对象中指定的预期失败之外的其他种类的失败仍会导致整体测试失败。例如，一个期望布尔值作为输入的变量，如果 Terraform 收到的是错误的值类型，即使该变量包含在 <code>expect_failures</code> 属性中，也会导致周围的测试失败。</p>
<p><code>expect_failures</code> 属性包含在其中是为了允许作者测试他们的配置和任何定义的逻辑。像前面的例子中的类型不匹配错误，不是 Terraform 作者应该担心和测试的事情，因为 Terraform 本身会处理强制类型约束。因此，你只能在自定义条件中 <code>expect_failures</code>。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/29/Teraform/Terraform-%E6%B5%8B%E8%AF%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/"
                            aria-label=": Terraform-命令行2"
                        >
                            Terraform-命令行2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-28T17:43:45+08:00">
	
		    2023 年 1 月 28 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#refresh"><strong>1.7.16.1.</strong> refresh</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.16.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#refresh"></a></p>
<h2 id="1-7-16-1-refresh"><a href="#refresh"></a>1.7.16.1. refresh</h2>
<p><code>terraform refresh</code> 命令将实际存在的基础设施对象的状态同步到状态文件中记录的对象状态。它可以用来检测真实状态与记录状态之间的漂移并更新状态文件。</p>
<blockquote>
<p>警告！！！该命令已在最新版本 Terraform 中被废弃，因为该命令的默认行为在当前用户错误配置了使用的云平台令牌时会引发对状态文件错误的变更。</p>
</blockquote>
<p>该命令并不会修改基础设施对象，只修改<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">状态文件</a>。</p>
<p>我们一般不需要使用该命令，因为 Terraform 会自动执行相同的刷新操作，作为在 <code>terraform plan</code> 和 <code>terraform apply</code> 命令中创建计划的一部分。本命令在这里主要是为了向后兼容，但我们不建议使用它，因为它没有提供在更新状态之前检查操作效果的机会。</p>
<h2 id="1-7-16-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.16.1.1. 用法</h2>
<p><code>terraform refresh [options]</code></p>
<p>该命令本质上是以下命令的别名，具有完全相同的效果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -refresh-only -auto-approve</span><br></pre></td></tr></table></figure>
<p>因此，该命令支持所有 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/4.apply.html"><code>terraform apply</code></a> 所支持的参数，除了它不接受一个现存的变更计划文件，不允许选择 “refresh only” 之外的模式，并且始终应用 <code>-auto-approve</code> 选项。</p>
<p>自动执行 <code>refresh</code> 是很危险的，因为如果当前用户错误配置了使用的 Provider 的令牌，那么 Terraform 会错误地以为当前状态文件中记录的所有资源都被删除了，随即从状态文件中无预警地删除所有相关记录。</p>
<p>我们推荐运行如下命令来取得相同的效果，同时可以在修改状态文件之前预览即将对其作出的修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -refresh-only</span><br></pre></td></tr></table></figure>
<p>该命令将会在交互界面中提示用户检测到的变更，并提示用户确认执行。</p>
<p><code>terraform apply</code> 和 <code>terraform plan</code> 命令的 <code>-refresh-only</code> 选项是从 Terraform v0.15.4 版本开始被引入的。对更早的版本，用户只能直接使用 <code>terraform refresh</code> 命令，同时要小心本篇警告过的危险副作用。尽可能避免显式使用 <code>terraform refresh</code> 命令，Terraform 在执行 <code>terraform plan</code> 和 <code>terraform apply</code> 命令时都会自动执行刷新状态的操作以生成变更计划，尽可能依赖该机制来维持状态文件的同步。</p>
<h2 id="show"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">show</a></h2>
<ul>
<li>
<p><a href="#show"><strong>1.7.17.1.</strong> show</a></p>
</li>
<li>
<p><a href="#json-%E8%BE%93%E5%87%BA"><strong>1.7.17.1.1.</strong> JSON 输出</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.17.1.2.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#show"></a></p>
<h2 id="1-7-17-1-show"><a href="#show"></a>1.7.17.1. show</h2>
<p><code>terraform show</code> 命令从状态文件或是变更计划文件中打印人类可读的输出信息。这可以用来检查变更计划以确定所有操作都是符合预期的，或是审查当前的状态文件。</p>
<p>可以通过添加 <code>-json</code> 参数输出机器可读的 JSON 格式输出。</p>
<p>需要注意的是，使用 <code>-json</code> 输出时所有标记为 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"><code>sensitive</code></a> 的敏感数据都会以明文形式被输出。</p>
<h2 id="1-7-17-1-1-JSON-输出"><a href="#json-%E8%BE%93%E5%87%BA"></a>1.7.17.1.1. JSON 输出</h2>
<p>可以使用 <code>terraform show -json</code> 命令打印 JSON 格式的状态信息。</p>
<p>如果指定了一个变更计划文件，<code>terraform show -json</code> 会以 JSON 格式记录变更计划、配置以及当前状态。</p>
<p>如果在写入状态文件后更新了包含新架构版本的 Provider 程序，则需要先升级状态，然后才能使用 <code>show -json</code> 显示状态。如果要查看计划，必须先在不使用 <code>-refresh=false</code> 的情况下创建计划文件。如果要查看当前状态，请先运行 <code>terraform refresh</code>。</p>
<h2 id="1-7-17-1-2-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.17.1.2. 用法</h2>
<p><code>terraform show [options] [file]</code></p>
<p>您可以将为 <code>file</code> 指定状态文件或计划文件的路径。如果不指定文件路径，Terraform 将显示最新的状态快照。</p>
<p>该命令支持以下参数：</p>
<ul>
<li><code>-json</code>：以 JSON 格式输出</li>
<li><code>-no-color</code>：与 <code>apply</code> 类似，不再赘述</li>
</ul>
<h2 id="state"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">state</a></h2>
<ul>
<li>
<p><a href="#state"><strong>1.7.18.1.</strong> state</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E8%BF%9C%E7%A8%8B%E7%8A%B6%E6%80%81"><strong>1.7.18.1.2.</strong> 远程状态</a></p>
</li>
<li>
<p><a href="#%E5%A4%87%E4%BB%BD"><strong>1.7.18.1.3.</strong> 备份</a></p>
</li>
<li>
<p><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%8B%E5%A5%BD"><strong>1.7.18.1.4.</strong> 命令行友好</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80"><strong>1.7.18.1.5.</strong> 资源地址</a></p>
</li>
</ul>
<p><a href="#state"></a></p>
<h2 id="1-7-18-1-state"><a href="#state"></a>1.7.18.1. state</h2>
<p><code>terraform state</code> 命令可以用来进行复杂的状态管理操作。随着你对 Terraform 的使用越来越深入，有时候你需要对状态文件进行一些修改。由于我们在状态管理章节中提到过的，状态文件的格式属于 HashiCorp 未公开的私有格式，所以直接修改状态文件是不适合的，我们可以使用 <code>terraform state</code> 命令来执行修改。</p>
<p>该命令含有数个子命令，我们会一一介绍。</p>
<h2 id="1-7-18-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.1.1. 用法</h2>
<p><code>terraform state &lt;subcommand&gt; [options] [args]</code></p>
<h2 id="1-7-18-1-2-远程状态"><a href="#%E8%BF%9C%E7%A8%8B%E7%8A%B6%E6%80%81"></a>1.7.18.1.2. 远程状态</h2>
<p>所有的 <code>state</code> 子命令都可以搭配本地状态文件以及远程状态使用。使用远程状态时读写操作可能用时稍长，因为读写都要通过网络完成。备份文件仍然会被写入本地磁盘。</p>
<h2 id="1-7-18-1-3-备份"><a href="#%E5%A4%87%E4%BB%BD"></a>1.7.18.1.3. 备份</h2>
<p>所有会修改状态文件的 <code>terraform state</code> 子命令都会生成备份文件。可以通过 <code>-backup</code> 参数指定备份文件的位置。</p>
<p>只读子命令(例如 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/1.list.html"><code>list</code></a> )由于不会修改状态，所以不会生成备份文件。</p>
<p>注意修改状态的 <code>state</code> 子命令无法禁用备份。由于状态文件的敏感性，Terraform 强制所有修改状态的子命令都必须生成备份文件。如果你不想保存备份，可以手动删除。</p>
<h2 id="1-7-18-1-4-命令行友好"><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%8B%E5%A5%BD"></a>1.7.18.1.4. 命令行友好</h2>
<p><code>state</code> 子命令的输出以及命令结构都被设计得易于同 Unix 下其他命令行工具搭配使用，例如 grep、awk 等等。同样的，输出结果也可以在 Windows 上轻松使用 PowerShell 处理。</p>
<p>对于复杂场景，我们建议使用管道组合 <code>state</code> 子命令与其他命令行工具一同使用。</p>
<h2 id="1-7-18-1-5-资源地址"><a href="#%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80"></a>1.7.18.1.5. 资源地址</h2>
<p><code>state</code> 子命令中大量使用了资源地址，我们在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址</a>章节中做了相关的介绍。</p>
<h2 id="list"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">list</a></h2>
<ul>
<li>
<p><a href="#list"><strong>1.7.18.1.1.</strong> list</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.1.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%B5%84%E6%BA%90"><strong>1.7.18.1.1.2.</strong> 例子：列出所有资源</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AE%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80%E8%BF%87%E6%BB%A4"><strong>1.7.18.1.1.3.</strong> 例子：根据资源地址过滤</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%A8%A1%E5%9D%97%E8%BF%87%E6%BB%A4"><strong>1.7.18.1.1.4.</strong> 例子：根据模块过滤</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AEid%E8%BF%87%E6%BB%A4"><strong>1.7.18.1.1.5.</strong> 例子：根据ID过滤</a></p>
</li>
</ul>
<p><a href="#list"></a></p>
<h2 id="1-7-18-1-1-list"><a href="#list"></a>1.7.18.1.1. list</h2>
<p><code>terraform state list</code> 命令可以列出<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">状态文件</a>中记录的资源对象。</p>
<h2 id="1-7-18-1-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.1.1.1. 用法</h2>
<p><code>terraform state list [options] [address...]</code></p>
<p>该命令会根据 address 列出状态文件中相关资源的信息(如果给定了 address 的话)。如果没有给定 address，那么所有资源都会被列出。</p>
<p>列出的资源根据模块深度以及字典序进行排序，这意味着根模块的资源在前，越深的子模块定义的资源越在后。</p>
<p>对于复杂的基础设施，状态文件可能包含成千上万到的资源对象。可以指定一个或多个资源地址来进行过滤。</p>
<p>可以使用的可选参数有：</p>
<ul>
<li><code>-state=path</code>：指定使用的状态文件地址。默认为 <code>terraform.tfstate</code>。使用远程 Backend 时该参数设置无效</li>
<li><code>-id=id</code>：要显示的资源 ID</li>
</ul>
<h2 id="1-7-18-1-1-2-例子：列出所有资源"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%B5%84%E6%BA%90"></a>1.7.18.1.1.2. 例子：列出所有资源</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state list</span><br><span class="line">aws_instance.foo</span><br><span class="line">aws_instance.bar[0]</span><br><span class="line">aws_instance.bar[1]</span><br><span class="line">module.elb.aws_elb.main</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-1-1-3-例子：根据资源地址过滤"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AE%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80%E8%BF%87%E6%BB%A4"></a>1.7.18.1.1.3. 例子：根据资源地址过滤</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state list aws_instance.bar</span><br><span class="line">aws_instance.bar[0]</span><br><span class="line">aws_instance.bar[1]</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-1-1-4-例子：根据模块过滤"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%A8%A1%E5%9D%97%E8%BF%87%E6%BB%A4"></a>1.7.18.1.1.4. 例子：根据模块过滤</h2>
<p>该例子列出给定模块及其子模块的所有资源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state list module.elb</span><br><span class="line">module.elb.aws_elb.main</span><br><span class="line">module.elb.module.secgroups.aws_security_group.sg</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-1-1-5-例子：根据ID过滤"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%A0%B9%E6%8D%AEid%E8%BF%87%E6%BB%A4"></a>1.7.18.1.1.5. 例子：根据ID过滤</h2>
<p>此示例将仅列出在命令行中指定 ID 的资源，查找特定资源在代码中的位置时非常有用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state list -<span class="built_in">id</span>=sg-1234abcd</span><br><span class="line">module.elb.aws_security_group.sg</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#mv"><strong>1.7.18.2.1.</strong> mv</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.2.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.7.18.2.1.2.</strong> 例子：重命名一个资源</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B0%86%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%A7%BB%E5%8A%A8%E8%BF%9B%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.7.18.2.1.3.</strong> 例子：将一个资源移动进一个模块</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E8%BF%9B%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.7.18.2.1.4.</strong> 例子：移动一个模块进入另一个模块</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81%E6%96%87%E4%BB%B6"><strong>1.7.18.2.1.5.</strong> 例子：移动一个模块到另一个状态文件</a></p>
</li>
<li>
<p><a href="#%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89-count-%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.18.2.1.6.</strong> 移动一个带有 count 参数的资源</a></p>
</li>
<li>
<p><a href="#%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89-foreach-%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.18.2.1.7.</strong> 移动一个带有 for_each 参数的资源</a></p>
</li>
</ul>
<p><a href="#mv"></a></p>
<h2 id="1-7-18-2-1-mv"><a href="#mv"></a>1.7.18.2.1. mv</h2>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">Terraform 状态</a>的主要功能是记录下代码中的资源实例地址与其代表的远程对象之间的绑定。通常，Terraform 会自动更新状态以响应应用计划时采取的操作，例如删除已被删除的远程对象的绑定。</p>
<p>在修改了 <code>resource</code> 块名称，或是将资源移动到代码中的不同模块时，如果想保留现有的远程对象，可以使用 <code>terraform state mv</code> 命令。</p>
<h2 id="1-7-18-2-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.2.1.1. 用法</h2>
<p><code>terraform state mv [options] SOURCE DESTINATION</code></p>
<p>Terraform 将在当前状态中查找与给定地址匹配的资源实例、资源或模块，如果找到，则将原本由源地址跟踪的远程对象移动到目标地址下。</p>
<p>源地址和目标地址都必须使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址语法</a>，并且它们引用对象的类型必须相同：我们只能将一个资源实例移动到另一个资源实例，将整个模块实例移动到另一个整个模块实例，等等。此外，如果我们要移动资源或资源实例，则只能将其移动到具有相同资源类型的新地址。</p>
<p><code>terraform state mv</code> 最常见的用途是当我们在代码中重命名 <code>resource</code> 块，或是将 <code>resource</code> 块移动到子模块中时，这两种情况都是为了保留现有对象但以新地址跟踪它。默认情况下，Terraform 会将移动或重命名资源配置理解为删除旧对象并在新地址创建新对象的请求，因此 <code>terraform state mv</code> 允许我们已经存在的对象附加到Terraform 中的新地址上。</p>
<p>警告：如果我们在多人协作环境中使用 Terraform，则必须确保当我们使用 <code>terraform state mv</code> 进行代码重构时，我们与同事进行了仔细沟通，以确保没有人在我们的配置更改和 terraform 状态之间进行任何其他更改mv 命令，因为否则他们可能会无意中创建一个计划，该计划将销毁旧对象并在新地址创建新对象。</p>
<p>该命令提供以下可选参数：</p>
<ul>
<li><code>-dry-run</code>：报告与给定地址匹配的所有资源实例。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</li>
<li><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</li>
</ul>
<h2 id="1-7-18-2-1-2-例子：重命名一个资源"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.7.18.2.1.2. 例子：重命名一个资源</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker&#x27;</span> <span class="string">&#x27;packet_device.helper&#x27;</span></span><br><span class="line">...</span><br><span class="line">-resource <span class="string">&quot;packet_device&quot;</span> <span class="string">&quot;worker&quot;</span> &#123;</span><br><span class="line">+resource <span class="string">&quot;packet_device&quot;</span> <span class="string">&quot;helper&quot;</span> &#123;</span><br><span class="line">   <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-2-1-3-例子：将一个资源移动进一个模块"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B0%86%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%A7%BB%E5%8A%A8%E8%BF%9B%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"></a>1.7.18.2.1.3. 例子：将一个资源移动进一个模块</h2>
<p>如果我们最初在根模块中编写了资源，但现在希望将其重构进子模块，则可以将 <code>resource</code> 块移动到子模块代码中，删除根模块中的原始资源，然后运行以下命令告诉 Terraform 将其视为一次移动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker&#x27;</span> <span class="string">&#x27;module.app.packet_device.worker&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，新资源具有相同的名称，但模块地址不同。如果新的模块组织建议不同的命名方案，您还可以同时更改资源名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> packet_device.worker module.worker.packet_device.main</span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-2-1-4-例子：移动一个模块进入另一个模块"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E8%BF%9B%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"></a>1.7.18.2.1.4. 例子：移动一个模块进入另一个模块</h2>
<p>我们还可以将整个模块重构为子模块。在配置中，将代表模块的 <code>module</code> 块移动到不同的模块中，然后使用如下命令将更改配对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;module.app&#x27;</span> <span class="string">&#x27;module.parent.module.app&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-2-1-5-例子：移动一个模块到另一个状态文件"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81%E6%96%87%E4%BB%B6"></a>1.7.18.2.1.5. 例子：移动一个模块到另一个状态文件</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> -state-out=other.tfstate <span class="string">&#x27;module.app&#x27;</span> <span class="string">&#x27;module.app&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-18-2-1-6-移动一个带有-count-参数的资源"><a href="#%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89-count-%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.18.2.1.6. 移动一个带有 count 参数的资源</h2>
<p>使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#count"><code>count</code> 元参数</a>定义的资源具有多个实例，每个实例都由一个整数标识。我们可以通过在给定地址中包含显式索引来选择特定实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker[0]&#x27;</span> <span class="string">&#x27;packet_device.helper[0]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>不使用 <code>count</code> 或 <code>for_each</code> 的资源只有一个资源实例，其地址与资源本身相同，因此我们可以从不包含索引的地址移动到包含索引的地址，或相反：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.main&#x27;</span> <span class="string">&#x27;packet_device.all[0]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>方括号 (<code>[</code>, <code>]</code>) 在某些 shell 中具有特殊含义，因此您可能需要引用或转义地址，以便将其逐字传递给 Terraform。上面的示例显示了 Unix 风格 shell 的典型引用语法。</p>
<h2 id="1-7-18-2-1-7-移动一个带有-for-each-参数的资源"><a href="#%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89-foreach-%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.18.2.1.7. 移动一个带有 for_each 参数的资源</h2>
<p>使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#for_each"><code>for_each</code> 元参数</a>定义的资源具有多个实例，每个实例都由一个字符串标识。我们可以通过在给定地址中包含显式的键来选择特定实例。</p>
<p>但是，字符串的语法包含引号，并且引号符号通常在命令 shell 中具有特殊含义，因此我们需要为正在使用的 shell 使用适当的引用和/或转义语法。例如：</p>
<p>Linux、MacOS 以及 Unix：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker[&quot;example123&quot;]&#x27;</span> <span class="string">&#x27;packet_device.helper[&quot;example456&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>PowerShell：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> terraform state <span class="built_in">mv</span> <span class="string">&#x27;packet_device.worker[\&quot;example123\&quot;]&#x27;</span> <span class="string">&#x27;packet_device.helper[\&quot;example456\&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Windows 命令行（<code>cmd.exe</code>）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state mv packet_device.worker[\&quot;example123\&quot;] packet_device.helper[\&quot;example456\&quot;]</span><br></pre></td></tr></table></figure>
<p>除了使用字符串而不是整数作为实例键之外，<code>for_each</code> 资源的处理与 <code>count</code> 资源类似，因此具有和不具有索引组件的相同地址组合都是有效的，如上一节所述。</p>
<ul>
<li>
<p><a href="#pull"><strong>1.7.18.3.1.</strong> pull</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.3.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#pull"></a></p>
<h2 id="1-7-18-3-1-pull"><a href="#pull"></a>1.7.18.3.1. pull</h2>
<p><code>terraform state pull</code> 命令可以从远程 Backend 中人工下载状态并输出。该命令也可搭配本地状态文件使用。</p>
<h2 id="1-7-18-3-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.3.1.1. 用法</h2>
<p><code>terraform state pull</code></p>
<p>该命令下载当前位置对应的状态文件，并以原始格式打印到标准输出流。</p>
<p>由于状态文件使用 JSON 格式，该功能可以搭配例如 <a target="_blank" rel="noopener" href="https://stedolan.github.io/jq/">jq</a> 这样的命令行工具使用，也可以用来人工修改状态文件。</p>
<p>注意：Terraform 状态文件必须采用 UTF-8 格式，不带字节顺序标记 (BOM)。对于 Windows 上的 PowerShell，使用 Set-Content 自动以 UTF-8 格式对文件进行编码。例如，运行 <code>terraform state pull</code> | <code>sc terraform.tfstate</code></p>
<h2 id="push"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">push</a></h2>
<ul>
<li>
<p><a href="#push"><strong>1.7.18.4.1.</strong> push</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.4.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#push"></a></p>
<h2 id="1-7-18-4-1-push"><a href="#push"></a>1.7.18.4.1. push</h2>
<p><code>terraform push</code> 命令被用来手动上传本地状态文件到远程 Backend。该命令也可以被用在当前使用的本地状态文件上。</p>
<p>该命令应该很少使用。它时一种需要对远程状态进行手动干预的情况下使用的工具。</p>
<h2 id="1-7-18-4-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.4.1.1. 用法</h2>
<p><code>terraform state push [options] PATH</code></p>
<p>该命令会把 PATH 位置的状态文件推送到当前使用的 Backend 上(可以是当前使用的 terraform.tfstate 文件)。</p>
<p>如果 PATH 为 <code>-</code>，则从标准输入流读取要推送的状态数据。该数据在写入目标状态之前被完全加载到内存中并进行验证。</p>
<p>注意：Terraform 状态文件必须采用 UTF-8 格式，不带字节顺序标记 (BOM)。对于 Windows 上的 PowerShell，使用 Set-Content 自动以 UTF-8 格式对文件进行编码。例如，运行 <code>terraform state push | sc terraform.tfstate</code>。</p>
<p>Terraform 会进行一系列检查以防止你进行一些不安全的变更：</p>
<ul>
<li>检查 lineage：如果两个状态文件的 lineage 值不同，Terraform 会禁止推送。一个不同的 lineage 说明两个状态文件描述的是完全不同的基础设而你可能会因此丢失重要数据</li>
<li>序列号检查：如果目标状态文件的 serial 值大于你要推送的状态的 serial 值，Terraform 会禁止推送。一个更高的 serial 值说明目标状态文件已经无法与要推送的状态文件对应上了</li>
</ul>
<p>这两种检查都可以通过添加 <code>-force</code> 参数禁用，但<strong>不推荐这样做</strong>。如果禁用安全检查直接推送，那么目标状态文件将被覆盖。</p>
<h2 id="replace-provider"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">replace-provider</a></h2>
<ul>
<li>
<p><a href="#replace-provider"><strong>1.7.18.5.1.</strong> replace-provider</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.5.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E6%A0%B7%E4%BE%8B"><strong>1.7.18.5.1.2.</strong> 样例</a></p>
</li>
</ul>
<p><a href="#replace-provider"></a></p>
<h2 id="1-7-18-5-1-replace-provider"><a href="#replace-provider"></a>1.7.18.5.1. replace-provider</h2>
<p><code>terraform state replace-provider</code> 命令可以替换<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">状态文件</a>中资源对象所使用的 Provider.</p>
<h2 id="1-7-18-5-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.5.1.1. 用法</h2>
<p><code>terraform state replace-provider [options] FROM_PROVIDER_FQN TO_PROVIDER_FQN</code></p>
<p>该命令会更新所有使用 from 的 Provider 的资源，将它们使用的 Provider 更新为 to Provider。这让我们可以更新状态文件中资源所使用的 Provider 的源。</p>
<p>该命令在进行任意修改之前会先生成一个备份文件。备份机制不可关闭。</p>
<p>支持以下可选参数：</p>
<ul>
<li><code>-auto-approve</code>：跳过交互式提示确认环节</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=0s</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</li>
<li><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</li>
</ul>
<h2 id="1-7-18-5-1-2-样例"><a href="#%E6%A0%B7%E4%BE%8B"></a>1.7.18.5.1.2. 样例</h2>
<p>下面的示例将 <code>hashicorp/aws</code> Provider 程序替换为 <code>acme</code> 的复刻版本，该 Provider 托管在 <code>registry.acme.corp</code> 的私有注册表中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state replace-provider hashicorp/aws registry.acme.corp/acme/aws</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#rm"><strong>1.7.18.6.1.</strong> rm</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.6.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.7.18.6.1.1.1.</strong> 删除一个资源</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.7.18.6.1.1.2.</strong> 删除一个模块</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%86%85%E8%B5%84%E6%BA%90"><strong>1.7.18.6.1.1.3.</strong> 删除一个模块内资源</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8Ecount%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.18.6.1.1.4.</strong> 删除一个声明count的资源</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8Eforeach%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.18.6.1.1.5.</strong> 删除一个声明for_each的资源</a></p>
</li>
</ul>
<p><a href="#rm"></a></p>
<h2 id="1-7-18-6-1-rm"><a href="#rm"></a>1.7.18.6.1. rm</h2>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">Terraform 状态</a>的主要功能是记录下代码中的资源实例地址与其代表的远程对象之间的绑定。通常，Terraform 会自动更新状态以响应应用计划时采取的操作，例如删除已被删除的远程对象的绑定。</p>
<p><code>terraform state rm</code> 命令可以用来从状态文件中删除对象和实际远程对象的绑定，该命令只是删除绑定，不会删除实际存在的远程对象，删除后 Terraform 会“忘记”这个对象的存在。</p>
<p>注意：从 Terraform v1.7.0 开始支持 <code>removed</code> 块。与 <code>terraform state rm</code> 命令不同，您可以使用 <code>removed</code> 块一次删除多个资源，并且您可以将删除操作作为正常计划和执行工作流程的一部分进行审查。了解有关将 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90"><code>removed</code> 块与资源一起使用</a>以及将 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/4.%E9%87%8D%E6%9E%84.html#%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"><code>removed</code> 块与模块一起使用</a>的更多信息。</p>
<h2 id="1-7-18-6-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.6.1.1. 用法</h2>
<p><code>terraform state rm [options] ADDRESS...</code></p>
<p>Terraform 将在状态中搜索与给定<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址</a>匹配的任何实例，并删除所有实例对应的记录，以便 Terraform 将不再跟踪相应的远程对象。</p>
<p>这意味着尽管这些对象仍将继续存在于远程系统中，但后续的 <code>terraform plan</code> 会尝试新建这些被“遗忘”的实例。根据远程系统施加的约束，如果这些对象的名称或其他标识符与仍然存在的旧对象发生冲突，创建这些对象可能会失败。</p>
<p>可以使用如下可选参数：</p>
<ul>
<li><code>-dry-run</code>：报告与给定地址匹配的所有资源实例（由于此时并未执行删除，所以 Terraform 这时还不会“遗忘”任何资源）。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</li>
<li><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</li>
</ul>
<h3 id="1-7-18-6-1-1-1-删除一个资源"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.7.18.6.1.1.1. 删除一个资源</h3>
<p>下面的例子演示了如何让 Terraform “遗忘”所有类型为 <code>packet_device</code>，并且名为 <code>worker</code> 的资源实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;packet_device.worker&#x27;</span></span><br></pre></td></tr></table></figure>
<p>不使用 <code>count</code> 或 <code>for_each</code> 的资源只有一个实例，因此该示例也是选择该单个实例的正确语法。</p>
<h3 id="1-7-18-6-1-1-2-删除一个模块"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97"></a>1.7.18.6.1.1.2. 删除一个模块</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;module.foo&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-6-1-1-3-删除一个模块内资源"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%86%85%E8%B5%84%E6%BA%90"></a>1.7.18.6.1.1.3. 删除一个模块内资源</h3>
<p>要选择在子模块中定义的资源，我们必须指定该模块的路径作为资源地址的一部分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;module.foo.packet_device.worker&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-6-1-1-4-删除一个声明count的资源"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8Ecount%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.18.6.1.1.4. 删除一个声明count的资源</h3>
<p>使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#count"><code>count</code> 元参数</a>定义的资源具有多个实例，每个实例都由一个整数标识。我们可以通过在给定地址中包含显式索引来选择特定实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;packet_device.worker[0]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>方括号 (<code>[</code>, <code>]</code>) 在某些 shell 中具有特殊含义，因此我们可能需要引用或转义地址，以便将其逐字传递给 Terraform。上面的例子使用了 Unix 风格 shell 的典型引用语法。</p>
<h3 id="1-7-18-6-1-1-5-删除一个声明for-each的资源"><a href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8Eforeach%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.18.6.1.1.5. 删除一个声明for_each的资源</h3>
<p>使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#for_each"><code>for_each</code> 元参数</a>定义的资源具有多个实例，每个实例都由一个字符串标识。我们可以通过在给定地址中包含显式密钥来选择特定实例。</p>
<p>但是，字符串的语法包含引号，并且引号符号通常在命令 shell 中具有特殊含义，因此我们需要为我们正在使用的 shell 使用适当的引用和/或转义语法。例如：</p>
<p>Linux, MacOS, and Unix：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state <span class="built_in">rm</span> <span class="string">&#x27;packet_device.worker[&quot;example&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>PowerShell：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> terraform state <span class="built_in">rm</span> <span class="string">&#x27;packet_device.worker[\&quot;example\&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Windows命令行（<code>cmd.exe</code>）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state rm packet_device.worker[\&quot;example\&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="show-2"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">show</a></h2>
<ul>
<li>
<p><a href="#show"><strong>1.7.18.7.1.</strong> show</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.18.7.1.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E7%A4%BA%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.7.18.7.1.1.2.</strong> 展示单个资源</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E7%A4%BA%E5%8D%95%E4%B8%AA%E6%A8%A1%E5%9D%97%E8%B5%84%E6%BA%90"><strong>1.7.18.7.1.1.3.</strong> 展示单个模块资源</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E7%A4%BA%E5%A3%B0%E6%98%8Ecount%E8%B5%84%E6%BA%90%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"><strong>1.7.18.7.1.1.4.</strong> 展示声明count资源中特定实例</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E7%A4%BA%E5%A3%B0%E6%98%8Eforeach%E8%B5%84%E6%BA%90%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"><strong>1.7.18.7.1.1.5.</strong> 展示声明for_each资源中特定实例</a></p>
</li>
</ul>
<p><a href="#show"></a></p>
<h2 id="1-7-18-7-1-show"><a href="#show"></a>1.7.18.7.1. show</h2>
<p><code>terraform state show</code> 命令可以展示状态文件中单个资源的属性。</p>
<h3 id="1-7-18-7-1-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.18.7.1.1.1. 用法</h3>
<p><code>terraform state show [options] ADDRESS</code></p>
<p>该命令需要指定一个资源地址。资源地址需要遵循<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址格式</a>。</p>
<p>该命令支持以下可选参数：</p>
<ul>
<li><code>-state=path</code>：指向状态文件的路径。默认情况下是 <code>terraform.tfstate</code>。如果启用了远程 Backend 则该参数设置无效</li>
</ul>
<p><code>terraform state show</code> 的输出被设计成人类可读而非机器可读。如果想要从输出中提取数据，请使用 <code>terraform show -json</code>。</p>
<h3 id="1-7-18-7-1-1-2-展示单个资源"><a href="#%E5%B1%95%E7%A4%BA%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.7.18.7.1.1.2. 展示单个资源</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show <span class="string">&#x27;packet_device.worker&#x27;</span></span><br><span class="line"><span class="comment"># packet_device.worker:</span></span><br><span class="line">resource <span class="string">&quot;packet_device&quot;</span> <span class="string">&quot;worker&quot;</span> &#123;</span><br><span class="line">    billing_cycle = <span class="string">&quot;hourly&quot;</span></span><br><span class="line">    created       = <span class="string">&quot;2015-12-17T00:06:56Z&quot;</span></span><br><span class="line">    facility      = <span class="string">&quot;ewr1&quot;</span></span><br><span class="line">    hostname      = <span class="string">&quot;prod-xyz01&quot;</span></span><br><span class="line">    <span class="built_in">id</span>            = <span class="string">&quot;6015bg2b-b8c4-4925-aad2-f0671d5d3b13&quot;</span></span><br><span class="line">    locked        = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-7-1-1-3-展示单个模块资源"><a href="#%E5%B1%95%E7%A4%BA%E5%8D%95%E4%B8%AA%E6%A8%A1%E5%9D%97%E8%B5%84%E6%BA%90"></a>1.7.18.7.1.1.3. 展示单个模块资源</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show <span class="string">&#x27;module.foo.packet_device.worker&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-7-1-1-4-展示声明count资源中特定实例"><a href="#%E5%B1%95%E7%A4%BA%E5%A3%B0%E6%98%8Ecount%E8%B5%84%E6%BA%90%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"></a>1.7.18.7.1.1.4. 展示声明count资源中特定实例</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show <span class="string">&#x27;packet_device.worker[0]&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-18-7-1-1-5-展示声明for-each资源中特定实例"><a href="#%E5%B1%95%E7%A4%BA%E5%A3%B0%E6%98%8Eforeach%E8%B5%84%E6%BA%90%E4%B8%AD%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"></a>1.7.18.7.1.1.5. 展示声明for_each资源中特定实例</h3>
<p>Linux, MacOS, and Unix：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show <span class="string">&#x27;packet_device.worker[&quot;example&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>PowerShell：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> terraform state show <span class="string">&#x27;packet_device.worker[\&quot;example\&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Windows命令行：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform state show packet_device.worker[\&quot;example\&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#taint"><strong>1.7.19.1.</strong> taint</a></p>
</li>
<li>
<p><a href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95"><strong>1.7.19.1.1.</strong> 推荐的替代方法</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.19.1.2.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E6%A0%87%E8%AE%B0%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.7.19.1.3.</strong> 标记单个资源</a></p>
</li>
<li>
<p><a href="#%E6%A0%87%E8%AE%B0%E4%BD%BF%E7%94%A8foreach%E5%88%9B%E5%BB%BA%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"><strong>1.7.19.1.4.</strong> 标记使用for_each创建的资源的特定实例</a></p>
</li>
<li>
<p><a href="#%E6%A0%87%E8%AE%B0%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90"><strong>1.7.19.1.5.</strong> 标记模块中的资源</a></p>
</li>
</ul>
<p><a href="#taint"></a></p>
<h2 id="1-7-19-1-taint"><a href="#taint"></a>1.7.19.1. taint</h2>
<p><code>terrform taint</code> 命令可以手动标记某个Terraform管理的资源有&quot;污点&quot;，强迫在下一次执行apply时删除并重建之。</p>
<p>该命令并不会修改基础设施，而是在状态文件中的某个资源对象上标记污点。当一个资源对象被标记了污点，在下一次 <code>plan</code> 操作时会计划将之删除并且重建，<code>apply</code> 操作会执行这个变更。</p>
<p>强迫重建某个资源可以使你能够触发某种副作用。举例来说，你想重新执行某个预置器操作，或是某些人绕过 Terraform 修改了虚拟机状态，而你想将虚拟机重置。</p>
<p>注意为某个资源标记污点并重建之会影响到所有依赖该资源的对象。举例来说，一条 DNS 记录使用了服务器的 IP 地址，我们在服务器上标记污点会导致 IP 发生变化从而影响到 DNS 记录。这种情况下可以使用 <code>plan</code> 命令查看变更计划。</p>
<p>警告：此命令已被弃用。从 Terraform v0.15.2 开始，我们建议使用 <code>-replace</code> 选项和 <code>terraform apply</code> 代替（详细信息如下）。</p>
<h2 id="1-7-19-1-1-推荐的替代方法"><a href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95"></a>1.7.19.1.1. 推荐的替代方法</h2>
<p>从 Terraform v0.15.2 开始，我们建议使用 <code>terraform apply</code> 的 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan.html#plan-%E9%80%89%E9%A1%B9"><code>-replace</code> 选项</a>来强制 Terraform 替换对象，即使没有发生需要变更的配置更改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -replace=<span class="string">&quot;aws_instance.example[0]&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们推荐使用 <code>-replace</code> 参数，因为这可以在 Terraform 计划中显示将要发生的变更，让我们在采取任何会影响系统的操作之前了解计划将如何影响我们的基础设施。当我们使用 <code>terraform taint</code> 时，其他用户有可能可以在我们审查变更之前针对标记的对象创建新的变更计划。</p>
<h2 id="1-7-19-1-2-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.19.1.2. 用法</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform taint [options] &lt;address&gt;</span><br></pre></td></tr></table></figure>
<p><code>address</code> 参数是要标记污点的资源地址。该地址格式遵循<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80.html">资源地址语法</a>，例如：</p>
<ul>
<li><code>aws_instance.foo</code></li>
<li><code>aws_instance.bar[1]</code></li>
<li><code>aws_instance.baz[\&quot;key\&quot;]</code> （资源地址中的引号必须在命令行中转义，这样它们就不会被 shell 解释）</li>
<li><code>module.foo.module.bar.aws_instance.qux</code></li>
</ul>
<p>该命令可以使用如下可选参数：</p>
<ul>
<li><code>-allow-missing</code>：如果声明该参数，那么即使资源不存在，命令也会返回成功(状态码0)。对于其他异常情况，该命令可能仍会返回错误，例如读取或写入状态时出现问题。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</li>
<li><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</li>
<li><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</li>
</ul>
<h2 id="1-7-19-1-3-标记单个资源"><a href="#%E6%A0%87%E8%AE%B0%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.7.19.1.3. 标记单个资源</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform taint aws_security_group.allow_all</span><br><span class="line">The resource aws_security_group.allow_all <span class="keyword">in</span> the module root has been marked as tainted.</span><br></pre></td></tr></table></figure>
<h2 id="1-7-19-1-4-标记使用for-each创建的资源的特定实例"><a href="#%E6%A0%87%E8%AE%B0%E4%BD%BF%E7%94%A8foreach%E5%88%9B%E5%BB%BA%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AE%9E%E4%BE%8B"></a>1.7.19.1.4. 标记使用for_each创建的资源的特定实例</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform taint <span class="string">&quot;module.route_tables.azurerm_route_table.rt[\&quot;DefaultSubnet\&quot;]&quot;</span></span><br><span class="line">The resource module.route_tables.azurerm_route_table.rt[<span class="string">&quot;DefaultSubnet&quot;</span>] <span class="keyword">in</span> the module root has been marked as tainted.</span><br></pre></td></tr></table></figure>
<h2 id="1-7-19-1-5-标记模块中的资源"><a href="#%E6%A0%87%E8%AE%B0%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90"></a>1.7.19.1.5. 标记模块中的资源</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform taint <span class="string">&quot;module.couchbase.aws_instance.cb_node[9]&quot;</span></span><br><span class="line">Resource instance module.couchbase.aws_instance.cb_node[9] has been marked as tainted.</span><br></pre></td></tr></table></figure>
<p>虽然我们推荐模块深度不要超过1，但是我们仍然可以标记多层模块中的资源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform taint <span class="string">&quot;module.child.module.grandchild.aws_instance.example[2]&quot;</span></span><br><span class="line">Resource instance module.child.module.grandchild.aws_instance.example[2] has been marked as tainted.</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#validate"><strong>1.7.20.1.</strong> validate</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.20.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#json-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><strong>1.7.20.1.2.</strong> JSON 输出格式</a></p>
</li>
<li>
<p><a href="#%E6%BA%90%E4%BD%8D%E7%BD%AE%EF%BC%88source-position%EF%BC%89"><strong>1.7.20.1.2.1.</strong> 源位置（Source Position）</a></p>
</li>
<li>
<p><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC"><strong>1.7.20.1.2.2.</strong> 表达式值</a></p>
</li>
</ul>
<p><a href="#validate"></a></p>
<h2 id="1-7-20-1-validate"><a href="#validate"></a>1.7.20.1. validate</h2>
<p><code>terraform validate</code> 命令可以检查目录下 Terraform 代码，只检查语法文件，不会访问诸如远程 Backend、Provider 的 API 等远程资源。</p>
<p><code>validate</code> 检查代码的语法是否合法以及一致，不管输入变量以及现存状态。</p>
<p>自动运行此命令是安全的，例如作为文本编辑器中的保存后检查或作为 CI 系统中可复用的测试步骤。</p>
<p><code>validate</code> 命令需要已初始化的工作目录，所有引用的插件与模块都被安装完毕。如果只想检查语法而不想与 Backend 交互，可以这样初始化工作目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform init -backend=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>要验证特定运行上下文中的配置（特定目标工作空间、输入变量值等），请改用 <code>terraform plan</code> 命令，其中包括隐式验证检查。</p>
<h2 id="1-7-20-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.20.1.1. 用法</h2>
<p><code>terraform validate [options]</code></p>
<p>默认情况下 <code>validate</code> 命令不需要任何参数就可以在当前工作目录下进行检查。</p>
<p>可以使用如下可选参数：</p>
<ul>
<li>-json：使用 JSON 格式输出机器可读的结果</li>
<li>-no-color：禁止使用彩色输出</li>
</ul>
<h2 id="1-7-20-1-2-JSON-输出格式"><a href="#json-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"></a>1.7.20.1.2. JSON 输出格式</h2>
<p>当您使用 <code>-json</code> 选项时，Terraform 将生成 JSON 格式的验证结果，使得我们可以将之与验证结果的工具进行集成，例如在文本编辑器中突出显示错误。</p>
<p>与所有 JSON 输出选项一样，Terraform 在开始验证任务之前就可能会遇到错误，因此输出的错误可能不会是 JSON 格式的。因此，使用 Terraform 输出的外部软件应该准备好在 stdout 上读取到非有效 JSON 的数据，然后将其视为一般错误情况。</p>
<p>输出包含一个 <code>format_version</code> 键，从 Terraform 1.1.0 开始，其值为“1.0”。该版本的语义是：</p>
<ul>
<li>对于向后兼容的变更或新增字段，我们将增加 minor 版本号，例如 <code>&quot;1.1&quot;</code>。这种变更会忽略所有不认识的对象属性，以保持与未来其他 minor 版本的前向兼容。</li>
<li>对于不向后兼容的变更，我们将增加 major 版本，例如 <code>&quot;2.0&quot;</code>。不同的 major 版本之间的数据无法直接传递。</li>
</ul>
<p>我们只会在 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/v1-compatibility-promises">Terraform 1.0 兼容性承诺</a>的范围内更新 major 版本。</p>
<p>在正常情况下，Terraform 会将 JSON 对象打印到标准输出流。顶级 JSON 对象将具有以下属性：</p>
<ul>
<li><code>valid</code>（bool）：总体验证结果结论，如果 Terraform 认为当前配置有效，则为 <code>true</code>；如果检测到任何错误，则为 <code>false</code>。</li>
<li><code>error_count</code>（number）：零或正整数，给出 Terraform 检测到的错误计数。如果 <code>valid</code> 为 <code>true</code>，则 <code>error_count</code> 将始终为零，因为错误的存在表明配置无效。</li>
<li><code>warning_count</code>（number）：零或正整数，给出 Terraform 检测到的警告计数。警告不会导致 Terraform 认为配置无效，但用户应考虑并尝试解决它们。</li>
<li><code>diagnostics</code>（对象数组）：嵌套对象的 JSON 数组，每个对象描述来自 Terraform 的错误或警告。</li>
</ul>
<p><code>diagnostics</code> 中的对象拥有如下属性：</p>
<ul>
<li><code>severity</code>（string）：字符串关键字，可以是 <code>&quot;error&quot;</code> 或 <code>&quot;warning&quot;</code>，指示诊断严重性。 <code>error</code> 的存在会导致 Terraform 认为配置无效，而 <code>warning</code> 只是对用户的建议或警告，不会阻止代码运行。Terraform 的后续版本可能会引入新的严重性等级，因此解析错误信息时应该准备好接受并忽略他们不了解的 <code>severity</code> 值。</li>
<li><code>summary</code>（string）：诊断报告的问题性质的简短描述。</li>
</ul>
<p>在 Terraform 易于阅读的的诊断消息中，<code>summary</code> 充当诊断的一种“标题”，打印在 “Error:” 或 “Warning:” 指示符之后。</p>
<p>摘要通常是简短的单个句子，但如果返回错误的子系统并没有设计成返回全面的诊断信息时，就只能把整个错误信息作为摘要返回，导致较长的摘要。这种情况下，摘要可能包含换行符，渲染摘要信息时需要注意。</p>
<ul>
<li><code>detail</code>（string）：可选的附加消息，提供有关问题的更多详细信息。</li>
</ul>
<p>在 Terraform 易于阅读的的诊断消息中，详细信息提供了标题和源位置引用之后出现的文本段落。</p>
<p>详细消息通常是多个段落，并且可能散布有非段落行，因此旨在向用户呈现详细消息的工具应该区分没有前导空格的行，将它们视为段落，以及有前导空格的行，将它们视为预格式化文本。然后，渲染器应该对段落进行软换行以适合渲染容器的宽度，但保留预格式化的行不换行。</p>
<p>一些 Terraform 详细消息包含使用 ASCII 字符来标记项目符号的近似项目符号列表。这不是官方承诺，因此渲染器应避免依赖它，而应将这些行视为段落或预格式化文本。此格式的未来版本可能会为其他文本约定定义附加规则，但将保持向后兼容性。</p>
<ul>
<li><code>range</code>（对象）：引用与诊断消息相关的配置源代码的一部分的可选对象。对于错误，这通常指示被检测为无效的特定块头、属性或表达式的边界。</li>
</ul>
<p>源范围是一个具有 <code>filename</code> 属性的对象，该 <code>filename</code> 为当前工作目录的相对路径，然后两个属性 <code>start</code> 和 <code>end</code> 本身都是描述源位置的对象，如下所述。</p>
<p>并非所有诊断消息都与配置的特定部分相关，因此对于不相关的诊断消息，<code>range</code> 将被省略或为 <code>null</code>。</p>
<p><code>snippet</code>（对象）：可选对象，包括与诊断消息相关的配置源代码的摘录。</p>
<p><code>snippet</code> 信息包括了：</p>
<ul>
<li><code>context</code>（string）：诊断的根上下文的可选摘要。例如，这可能是包含触发诊断的表达式的 <code>resource</code> 块。对于某些诊断，此信息不可用，并且此属性将为空。</li>
<li><code>code</code>（string）：Terraform 配置的片段，包括诊断源。可能包含多行，并且可能包括触发诊断的表达式周围的附加配置源代码。</li>
<li><code>start_line</code>（number）：从一开始的行计数，表示源文件中代码摘录开始的位置。该值不一定与 <code>range.start.line</code> 相同，因为 <code>code</code> 可能在诊断源之前包含一行或多行上下文。</li>
<li><code>highlight_start_offset</code>（number）：代码字符串中从零开始的字符偏移量，指向触发诊断的表达式的开头。</li>
<li><code>highlight_end_offset</code>（number）：代码字符串中从零开始的字符偏移量，指向触发诊断的表达式的末尾。</li>
<li><code>values</code>（对象数组）：包含零个或多个表达式值，帮助我们理解复杂表达式中的诊断来源。这些表达式值对象如下所述。</li>
</ul>
<h3 id="1-7-20-1-2-1-源位置（Source-Position）"><a href="#%E6%BA%90%E4%BD%8D%E7%BD%AE%EF%BC%88source-position%EF%BC%89"></a>1.7.20.1.2.1. 源位置（Source Position）</h3>
<p>在诊断对象的 <code>range</code> 属性中源位置对象具有以下属性：</p>
<ul>
<li><code>byte</code>（number）：指定文件中从零开始的字节偏移量。</li>
<li><code>line</code>（number）：从一开始的行计数，指向文件中相关位置的行。</li>
<li><code>column</code>（number）：从一开始的列计数，指向 <code>line</code> 对应的行开头开始的 Unicode 字符计数位置。 <code>start</code> 位置是包含的（数学的 <code>[]</code>），而 <code>end</code> 位置是不包含的（数学的 <code>()</code>）。用于特定错误消息的确切位置仅供人类解读。</li>
</ul>
<h3 id="1-7-20-1-2-2-表达式值"><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC"></a>1.7.20.1.2.2. 表达式值</h3>
<p>表达式值对象提供有关触发诊断的表达式一部分的值的附加信息。当使用 <code>for_each</code> 或类似结构时，这特别有用，以便准确识别哪些值导致错误。该对象有两个属性：</p>
<ul>
<li>
<p><code>traversal</code> (string)：类似 HCL 的可遍历表达式字符串，例如 <code>var.instance_count</code>。复杂的索引键值可能会被省略，因此该属性并非总是合法、可解析的 HCL。该字符串的内容旨在便于人类阅读。</p>
</li>
<li>
<p><code>statement</code>（string）：一个简短的英语片段，描述触发诊断时表达式的值。该字符串的内容旨在便于人类阅读，并且在 Terraform 的未来版本中可能会发生变化。</p>
</li>
<li>
<p><a href="#untaint"><strong>1.7.21.1.</strong> untaint</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.21.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#untaint"></a></p>
<h2 id="1-7-21-1-untaint"><a href="#untaint"></a>1.7.21.1. untaint</h2>
<p>Terraform 有一个名为“tainted”的标记，用于跟踪可能损坏的对象，该命令已被废弃，应使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/19.taint.html#%E6%8E%A8%E8%8D%90%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95"><code>terraform apply -replace</code> 代替</a>。</p>
<p>如果创建一个资源的操作由多个步骤组成，操作期间其中之一的操作发生错误，Terraform 会自动将对象标记为“受污染”，因为 Terraform 无法确定该对象是否处于完整功能状态。</p>
<p><code>terraform untaint</code> 命令可以手动清除一个 Terraform 管理的资源对象上的污点，恢复它在状态文件中的状态。它是 <code>terraform taint</code> 的逆向操作。</p>
<p>该命令不会修改实际的基础设施资源，只会在资源文件中清除资源对象上的污点标记。</p>
<p>如果我们从对象中删除污点标记，但后来发现它还是损坏了，则可以使用如下命令创建并应用一个计划来替换受损的资源对象，而无需首先重新在该对象上标记污点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -replace=<span class="string">&quot;aws_instance.example[0]&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-21-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.21.1.1. 用法</h2>
<p><code>terraform untaint [options] address</code></p>
<p>name参数是要清除污点的资源的资源名称。<a target="_blank" rel="noopener" href="http://xn--TYPE-uh5f160avsuivle8ft43b9e3c.NAME">该参数的格式为TYPE.NAME</a>，比如aws_instance.foo。</p>
<p>可以使用如下可选参数：</p>
<ul>
<li><code>-allow-missing</code>：如果声明该参数，那么即使资源不存在，命令也会返回成功(状态码0)。对于其他异常情况，该命令可能仍会返回错误，例如读取或写入状态时出现问题。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
<li><code>-no-color</code>：关闭彩色输出。在无法解释输出色彩的终端中运行 Terraform 时请使用此参数。</li>
</ul>
<p>以下是使用 <code>local</code> Backend 时可用的遗留参数：</p>
<ul>
<li>
<p><code>-backup=FILENAME</code>：指定源状态文件的备份地址，默认为源状态文件加上&quot;.backup&quot;后缀</p>
</li>
<li>
<p><code>-bakcup-out=FILENAME</code>：指定目标状态文件的备份地址，默认为目标状态文件加上&quot;.backup&quot;后缀</p>
</li>
<li>
<p><code>-state=FILENAME</code>：源状态文件地址，默认为当前 Backend 或是&quot;terraform.tfstate&quot;</p>
</li>
<li>
<p><code>-state-out=FILENAME</code>：目标状态文件地址。如果不指定则使用源状态文件。可以是一个已经存在的文件或新建一个文件</p>
</li>
<li>
<p><a href="#workspace"><strong>1.7.22.1.</strong> workspace</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#workspace"></a></p>
<h2 id="1-7-22-1-workspace"><a href="#workspace"></a>1.7.22.1. workspace</h2>
<p><code>terraform workspace</code> 命令可以用来管理当前使用的工作区。我们在状态管理章节中介绍过<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html#%E7%8A%B6%E6%80%81%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AD%98%E5%82%A8">工作区</a>的概念。</p>
<p>该命令包含一系列子命令，我们将会一一介绍。</p>
<h2 id="1-7-22-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.1.1. 用法</h2>
<p><code>terraform workspace &lt;subcommand&gt; [options] [args]</code></p>
<ul>
<li>
<p><a href="#list"><strong>1.7.22.1.1.</strong> list</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.1.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#list"></a></p>
<h2 id="1-7-22-1-1-list"><a href="#list"></a>1.7.22.1.1. list</h2>
<p><code>terraform workspace list</code> 命令列出当前存在的工作区。</p>
<h2 id="1-7-22-1-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.1.1.1. 用法</h2>
<p><code>terraform workspace list [DIR]</code></p>
<p>该命令会打印出存在的工作区。当前工作会使用 <code>*</code> 号标记：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace list</span><br><span class="line">  default</span><br><span class="line">* development</span><br><span class="line">  jsmith-test</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#select"><strong>1.7.22.2.1.</strong> select</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.2.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#select"></a></p>
<h2 id="1-7-22-2-1-select"><a href="#select"></a>1.7.22.2.1. select</h2>
<p><code>terraform workspace select</code> 命令用来选择使用的工作区。</p>
<h2 id="1-7-22-2-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.2.1.1. 用法</h2>
<p><code>terraform workspace select NAME [DIR]</code></p>
<p>NAME 指定的工作区必须已经存在：</p>
<p>该命令支持以下参数</p>
<ul>
<li><code>-or-create</code>：如果指定的工作区不存在，则创建之。默认为 <code>false</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace list</span><br><span class="line">  default</span><br><span class="line">* development</span><br><span class="line">  jsmith-test</span><br><span class="line"></span><br><span class="line">$ terraform workspace <span class="keyword">select</span> default</span><br><span class="line">Switched to workspace <span class="string">&quot;default&quot;</span>.</span><br></pre></td></tr></table></figure>
<h2 id="new"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">new</a></h2>
<ul>
<li>
<p><a href="#new"><strong>1.7.22.3.1.</strong> new</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.3.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#new"></a></p>
<h2 id="1-7-22-3-1-new"><a href="#new"></a>1.7.22.3.1. new</h2>
<p><code>terraform workspace new</code> 命令用来创建新的工作区。</p>
<h2 id="1-7-22-3-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.3.1.1. 用法</h2>
<p><code>terraform workspace new [OPTIONS] NAME [DIR]</code></p>
<p>该命令使用给定名字创建一个新的工作区。不可存在同名工作区。</p>
<p>如果使用了 <code>-state</code> 参数，那么给定路径的状态文件会被拷贝到新工作区。</p>
<p>该命令支持以下可选参数：</p>
<ul>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。默认为 <code>0s</code>。</li>
<li><code>-state=path</code>：用来初始化新环境所使用的状态文件路径</li>
</ul>
<p>创建新工作区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace new example</span><br><span class="line">Created and switched to workspace <span class="string">&quot;example&quot;</span>!</span><br><span class="line"></span><br><span class="line">You<span class="string">&#x27;re now on a new, empty workspace. Workspaces isolate their state,</span></span><br><span class="line"><span class="string">so if you run &quot;terraform plan&quot; Terraform will not see any existing state</span></span><br><span class="line"><span class="string">for this configuration.</span></span><br></pre></td></tr></table></figure>
<p>使用状态文件创建新工作区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace new -state=old.terraform.tfstate example</span><br><span class="line">Created and switched to workspace <span class="string">&quot;example&quot;</span>.</span><br><span class="line"></span><br><span class="line">You<span class="string">&#x27;re now on a new, empty workspace. Workspaces isolate their state,</span></span><br><span class="line"><span class="string">so if you run &quot;terraform plan&quot; Terraform will not see any existing state</span></span><br><span class="line"><span class="string">for this configuration.</span></span><br></pre></td></tr></table></figure>
<h2 id="delete"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">delete</a></h2>
<ul>
<li>
<p><a href="#delete"><strong>1.7.22.4.1.</strong> delete</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.4.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#delete"></a></p>
<h2 id="1-7-22-4-1-delete"><a href="#delete"></a>1.7.22.4.1. delete</h2>
<p><code>terraform workspace delete</code> 命令被用以删除已经存在的工作区。</p>
<h2 id="1-7-22-4-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.4.1.1. 用法</h2>
<p><code>terraform workspace delete [OPTIONS] NAME [DIR]</code></p>
<p>该命令被用以删除已经存在的工作区。</p>
<p>被删除的工作区必须已经存在，并且<strong>不可以删除当前正在使用的工作区</strong>。如果工作区状态不是空的（存在跟踪中的远程对象），Terraform 会禁止删除，除非声明 <code>-force</code> 参数。</p>
<p>另外，不同的 Backend 在没有 <code>-force</code> 参数时可能会有不同的限制，以实现对工作区的安全删除，例如检查工作区是否已上锁。</p>
<p>如果使用 <code>-force</code> 删除非空工作区，那么原本跟踪的资源的状态就将处于&quot;dangling&quot;，也就是实际基础设施资源仍然存在，但脱离了 Terraform的 管理。有时我们希望这样，只是希望当前 Terraform 项目不再管理这些资源，交由其他项目管理。但大多数情况下并非这样，所以 Terraform 默认会禁止删除非空工作区。</p>
<p>该命令可以使用如下可选参数：</p>
<ul>
<li><code>-force</code>：删除含有非空状态文件的工作区。默认为 <code>false</code>。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。默认为 <code>0s</code>。</li>
</ul>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace delete example</span><br><span class="line">Deleted workspace <span class="string">&quot;example&quot;</span>.</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#show"><strong>1.7.22.5.1.</strong> show</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.22.5.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#show"></a></p>
<h2 id="1-7-22-5-1-show"><a href="#show"></a>1.7.22.5.1. show</h2>
<p><code>terraform workspace show</code> 命令被用以输出当前使用的工作区。</p>
<h2 id="1-7-22-5-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.22.5.1.1. 用法</h2>
<p><code>terraform workspace show</code></p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace show</span><br><span class="line">development</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#test"><strong>1.7.23.1.</strong> test</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.23.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E4%B8%80%E8%88%AC%E5%8F%82%E6%95%B0"><strong>1.7.23.1.2.</strong> 一般参数</a></p>
</li>
<li>
<p><a href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><strong>1.7.23.1.3.</strong> 状态管理</a></p>
</li>
<li>
<p><a href="#terraform-%E6%B5%8B%E8%AF%95%E6%B8%85%E7%90%86"><strong>1.7.23.1.3.1.</strong> Terraform 测试清理</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8-hcp-terraform-%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><strong>1.7.23.1.4.</strong> 在 HCP Terraform 上运行测试</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%8E%E5%91%BD%E4%BB%A4"><strong>1.7.23.1.5.</strong> 例子：测试的目录结构与命令</a></p>
</li>
<li>
<p><a href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><strong>1.7.23.1.5.1.</strong> 另一种测试目录结构</a></p>
</li>
</ul>
<p><a href="#test"></a></p>
<h2 id="1-7-23-1-test"><a href="#test"></a>1.7.23.1. test</h2>
<p><code>terraform test</code> 命令读取 Terraform 测试文件并执行其中的测试。</p>
<p><code>test</code> 命令和测试文件对于想要验证和测试其旨在被复用的模块的作者特别有用。我们也可以使用 <code>test</code> 命令来验证根模块。</p>
<h2 id="1-7-23-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.23.1.1. 用法</h2>
<p><code>terraform test [options]</code></p>
<p>该命令在当前目录和指定的测试目录（默认情况下是 <code>test</code> 目录）中搜索所有 Terraform 测试文件，并执行指定的测试。有关测试文件的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/">测试</a>。</p>
<p>Terraform 然后会根据测试文件的规范执行一系列 Terraform 的 <code>plan</code> 或 <code>apply</code> 命令，并根据测试文件的规范验证相关计划和状态文件。</p>
<p>警告：Terraform 测试命令可以创建真正的基础设施，但可能会产生成本。请参阅 <a href="#terraform-%E6%B5%8B%E8%AF%95%E6%B8%85%E7%90%86">Terraform 测试清理</a>部分，了解确保创建的基础设施被清理的最佳实践。</p>
<h2 id="1-7-23-1-2-一般参数"><a href="#%E4%B8%80%E8%88%AC%E5%8F%82%E6%95%B0"></a>1.7.23.1.2. 一般参数</h2>
<p>Terraform <code>test</code> 命令支持以下参数：</p>
<ul>
<li><code>-cloud-run=&lt;module source&gt;</code> - 通过 HCP Terraform 远程运行针对指定的 Terraform 私有注册表模块的测试。</li>
<li><code>-filter=testfile</code> - 将 <code>terraform test</code> 操作限制为指定的测试文件。</li>
<li><code>-json</code> - 显示测试结果的机器可读 JSON 输出。</li>
<li><code>-test-directory=&lt;relative directory&gt;</code> - 指定 Terraform 查找测试文件的目录。请注意，Terraform 始终在主代码目录中加载测试文件。默认的测试目录是 <code>tests</code>。</li>
<li><code>-verbose</code> - 根据每个运行块的 <code>command</code> 属性打印出测试文件中每个 <code>run</code> 块的计划或状态。</li>
</ul>
<h2 id="1-7-23-1-3-状态管理"><a href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"></a>1.7.23.1.3. 状态管理</h2>
<p>每个 Terraform 测试文件在执行时都会在内存中从无到有地维护所需的所有 Terraform 状态。该状态完全独立于被测代码的任何现有状态，因此您可以安全地执行 Terraform 测试命令，而不会影响任何已存在的基础设施。</p>
<h3 id="1-7-23-1-3-1-Terraform-测试清理"><a href="#terraform-%E6%B5%8B%E8%AF%95%E6%B8%85%E7%90%86"></a>1.7.23.1.3.1. Terraform 测试清理</h3>
<p>Terraform <code>test</code> 命令可以创建真实的基础设施。一旦 Terraform 完全执行了所有测试文件，Terraform 就会尝试销毁所有遗留的基础设施。如果无法销毁，Terraform 会报告由它创建但无法销毁的资源列表。</p>
<p>我们应该密切监视测试命令的输出，以确保 Terraform 清理了它创建的基础设施，否则需要执行手动清理。我们建议为目标 Provider 创建专用的测试帐户，这样可以定期安全地清除该帐户内的资源，确保不会意外地留下昂贵的资源。</p>
<p>Terraform 还提供诊断，解释为什么它无法自动清理。我们应该检查这些诊断，以确保未来的清理操作成功。</p>
<h2 id="1-7-23-1-4-在-HCP-Terraform-上运行测试"><a href="#%E5%9C%A8-hcp-terraform-%E4%B8%8A%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"></a>1.7.23.1.4. 在 HCP Terraform 上运行测试</h2>
<p>我们可以使用 <code>-cloud-run</code> 参数在 HCP Terraform 上远程执行测试。</p>
<p><code>-cloud-run</code> 参数接受私有注册表模块地址。此参数针对 HCP Terraform 用户界面中指定的私有模块运行测试。</p>
<p>我们必须提供来自私有注册表的模块，而不是公共 Terraform 注册表。</p>
<p>在使用该参数之前，您必须执行 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/cli/commands/login"><code>terraform login</code></a>，并确保您的 <code>host</code> 参数与目标模块的私有注册表主机名匹配。</p>
<h2 id="1-7-23-1-5-例子：测试的目录结构与命令"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%8E%E5%91%BD%E4%BB%A4"></a>1.7.23.1.5. 例子：测试的目录结构与命令</h2>
<p>以下目录结构表示包含测试和配置（setup）模块的 Terraform 模块的示例目录树：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">|-- main.tf</span><br><span class="line">|-- outputs.tf</span><br><span class="line">|-- terraform.tf</span><br><span class="line">|-- variables.tf</span><br><span class="line">|-- tests/</span><br><span class="line">|   |-- validations.tftest.hcl</span><br><span class="line">|   |-- outputs.tftest.hcl</span><br><span class="line">|-- testing/</span><br><span class="line">    |-- setup/</span><br><span class="line">        |-- main.tf</span><br><span class="line">        |-- outputs.tf</span><br><span class="line">        |-- terraform.tf</span><br><span class="line">        |-- variables.tf</span><br></pre></td></tr></table></figure>
<p>在项目的根目录下，有一些典型的 Terraform 配置文件：<code>main.tf</code>、<code>outputs.tf</code>、<code>terraform.tf</code> 和 <code>variables.tf</code>。测试文件 <code>validations.tftest.hcl</code> 和 <code>outputs.tftest.hcl</code> 位于默认测试目录 <code>tests</code> 中。</p>
<p>另外 <code>testing</code> 目录下有一个为测试而存在的<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/#module-%E5%9D%97">设置(setup)模块</a></p>
<p>要执行测试，我们应该从代码根目录运行 <code>terraform test</code>，如同运行 <code>terraform plan</code> 或 <code>terraform apply</code> 一样。尽管实际的测试文件位于内嵌的 <code>tests</code> 目录中，但 Terraform 仍从主代码目录执行。</p>
<p>可以使用 <code>-filter</code> 参数指定执行特定的测试文件。</p>
<p>Linux、Mac 操作系统和 UNIX 下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform <span class="built_in">test</span> -filter=tests/validations.tftest.hcl</span><br></pre></td></tr></table></figure>
<p>PowerShell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform <span class="built_in">test</span> -filter=<span class="string">&#x27;tests\validations.tftest.hcl&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Windows <code>cmd.exe</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform <span class="built_in">test</span> -filter=tests\validations.tftest.hcl</span><br></pre></td></tr></table></figure>
<h3 id="1-7-23-1-5-1-另一种测试目录结构"><a href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"></a>1.7.23.1.5.1. 另一种测试目录结构</h3>
<p>在上面的示例中，测试文件位于默认的 <code>tests</code> 目录中。测试文件也可以直接包含在主代码目录中：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">|-- main.tf</span><br><span class="line">|-- outputs.tf</span><br><span class="line">|-- terraform.tf</span><br><span class="line">|-- variables.tf</span><br><span class="line">|-- validations.tftest.hcl</span><br><span class="line">|-- outputs.tftest.hcl</span><br><span class="line">|-- testing/</span><br><span class="line">    |-- setup/</span><br><span class="line">        |-- main.tf</span><br><span class="line">        |-- outputs.tf</span><br><span class="line">        |-- terraform.tf</span><br><span class="line">        |-- variables.tf</span><br></pre></td></tr></table></figure>
<p>测试文件的位置不会影响 <code>terraform test</code> 的运行。测试文件的所有引用以及其中的绝对文件路径都应相对于主代码目录。</p>
<p>我们还可以使用 <code>-test-directory</code> 参数来更改测试文件的位置。例如， <code>terraform test -test-directory=testing</code> 将命令 Terraform 从 <code>testing</code> 目录加载测试，而不是 <code>tests</code>。</p>
<p>测试目录必须位于主代码目录下，但可以多层嵌套。</p>
<blockquote>
<p>注意：无论 <code>-test-directory</code> 的值为何，根代码目录中的测试文件始终会被加载。</p>
</blockquote>
<p>我们不建议更改默认测试目录。这些自定义选项是为那些在 <code>terraform test</code> 功能发布之前可能已在其代码中包含了 <code>tests</code> 子模块的代码作者准备的。一般来说，应始终使用默认的 <code>tests</code> 目录。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/28/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/26/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C1/"
                            aria-label=": Terraform-命令行1"
                        >
                            Terraform-命令行1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-26T17:43:45+08:00">
	
		    2023 年 1 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#terraform%E5%91%BD%E4%BB%A4%E8%A1%8C"><strong>1.7.1.</strong> Terraform命令行</a></p>
</li>
<li>
<p><a href="#%E9%80%9A%E8%BF%87--chdir-%E5%8F%82%E6%95%B0%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><strong>1.7.1.1.</strong> 通过 -chdir 参数切换工作目录</a></p>
</li>
<li>
<p><a href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><strong>1.7.1.2.</strong> 自动补全</a></p>
</li>
<li>
<p><a href="#%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF"><strong>1.7.1.3.</strong> 版本信息</a></p>
</li>
<li>
<p><a href="#checkpoint%E6%9C%8D%E5%8A%A1"><strong>1.7.1.4.</strong> Checkpoint服务</a></p>
</li>
</ul>
<p><a href="#terraform%E5%91%BD%E4%BB%A4%E8%A1%8C"></a></p>
<h2 id="1-7-1-Terraform命令行"><a href="#terraform%E5%91%BD%E4%BB%A4%E8%A1%8C"></a>1.7.1. Terraform命令行</h2>
<p>我们在前面的的章节中主要介绍了如何书写和组织Terraform代码，下面我们要介绍一下如何使用Terraform命令行工具来应用这些代码，并且管理和操作我们的云端基础设施。</p>
<p>Terraform是用Go语言编写的，所以它的交付物只有一个可执行命令行文件：terraform。在Terraform执行发生错误时，terraform进程会返回一个非零值，所以在脚本代码中我们可以轻松判断执行是否成功。</p>
<p>我们可以在命令行中输入terraform来查看所有可用的子命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ terraform</span><br><span class="line">Usage: terraform [-version] [-<span class="built_in">help</span>] &lt;<span class="built_in">command</span>&gt; [args]</span><br><span class="line"></span><br><span class="line">The available commands <span class="keyword">for</span> execution are listed below.</span><br><span class="line">The most common, useful commands are shown first, followed by</span><br><span class="line">less common or more advanced commands. If you<span class="string">&#x27;re just getting</span></span><br><span class="line"><span class="string">started with Terraform, stick with the common commands. For the</span></span><br><span class="line"><span class="string">other commands, please read the help and docs before usage.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Common commands:</span></span><br><span class="line"><span class="string">    apply              Builds or changes infrastructure</span></span><br><span class="line"><span class="string">    console            Interactive console for Terraform interpolations</span></span><br><span class="line"><span class="string">    destroy            Destroy Terraform-managed infrastructure</span></span><br><span class="line"><span class="string">    env                Workspace management</span></span><br><span class="line"><span class="string">    fmt                Rewrites config files to canonical format</span></span><br><span class="line"><span class="string">    get                Download and install modules for the configuration</span></span><br><span class="line"><span class="string">    graph              Create a visual graph of Terraform resources</span></span><br><span class="line"><span class="string">    import             Import existing infrastructure into Terraform</span></span><br><span class="line"><span class="string">    init               Initialize a Terraform working directory</span></span><br><span class="line"><span class="string">    login              Obtain and save credentials for a remote host</span></span><br><span class="line"><span class="string">    logout             Remove locally-stored credentials for a remote host</span></span><br><span class="line"><span class="string">    output             Read an output from a state file</span></span><br><span class="line"><span class="string">    plan               Generate and show an execution plan</span></span><br><span class="line"><span class="string">    providers          Prints a tree of the providers used in the configuration</span></span><br><span class="line"><span class="string">    refresh            Update local state file against real resources</span></span><br><span class="line"><span class="string">    show               Inspect Terraform state or plan</span></span><br><span class="line"><span class="string">    taint              Manually mark a resource for recreation</span></span><br><span class="line"><span class="string">    untaint            Manually unmark a resource as tainted</span></span><br><span class="line"><span class="string">    validate           Validates the Terraform files</span></span><br><span class="line"><span class="string">    version            Prints the Terraform version</span></span><br><span class="line"><span class="string">    workspace          Workspace management</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">All other commands:</span></span><br><span class="line"><span class="string">    0.12upgrade        Rewrites pre-0.12 module source code for v0.12</span></span><br><span class="line"><span class="string">    0.13upgrade        Rewrites pre-0.13 module source code for v0.13</span></span><br><span class="line"><span class="string">    debug              Debug output management (experimental)</span></span><br><span class="line"><span class="string">    force-unlock       Manually unlock the terraform state</span></span><br><span class="line"><span class="string">    push               Obsolete command for Terraform Enterprise legacy (v1)</span></span><br><span class="line"><span class="string">    state              Advanced state management</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-1-1-通过-chdir-参数切换工作目录"><a href="#%E9%80%9A%E8%BF%87--chdir-%E5%8F%82%E6%95%B0%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"></a>1.7.1.1. 通过 -chdir 参数切换工作目录</h2>
<p>运行Terraform时一般要首先切换当前工作目录到包含有想要执行的根模块<code>.tf</code>代码文件的目录下（比如使用<code>cd</code>命令），这样Terraform才能够自动发现要执行的代码文件以及参数文件。</p>
<p>在某些情况下——尤其是将Terraform封装进某些自动化脚本时，如果能够从其他路径直接执行特定路径下的根模块代码将会十分的方便。为了达到这一目的，Terraform目前支持一个全局参数<code>-chdir=...</code>，你可以在任意子命令的参数中使用该参数指定要执行的代码路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">terraform -<span class="built_in">chdir</span>=environments/production apply</span></span><br></pre></td></tr></table></figure>
<p><code>-chdir</code>参数指引Terraform在执行具体子命令之前切换工作目录，这意味着使用该参数后Terraform将会在指定路径下读写文件，而非当前工作目录下的文件。</p>
<p>在两种场景下Terraform会坚持使用<strong>当前工作目录而非指定的目录</strong>，即使是我们通过<code>-chdir</code>指定了一个目标路径：</p>
<ul>
<li>Terraform处理命令行配置文件中的设置而非执行某个具体的子命令时，该阶段发生在解析<code>-chdir</code>参数之前</li>
<li>如果你需要使用当前工作目录下的文件作为你配置的一部分时，你可以通过在代码中使用<code>path.cwd</code>变量获得对当前工作路径的引用，而不是<code>-chdir</code>所指定的路径。可以通过使用<code>path.root</code>来获取代表根模块所在的路径。</li>
</ul>
<h2 id="1-7-1-2-自动补全"><a href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"></a>1.7.1.2. 自动补全</h2>
<p>如果你使用的是bash或是zsh，那么可以轻松安装自动补全：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform -install-autocomplete</span><br></pre></td></tr></table></figure>
<p>卸载自动补全也很容易：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform -uninstall-autocomplete</span><br></pre></td></tr></table></figure>
<p>目前自动补全并没有覆盖到所有子命令。</p>
<h2 id="1-7-1-3-版本信息"><a href="#%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF"></a>1.7.1.3. 版本信息</h2>
<p>Terraform命令行会与HashiCorp的<a target="_blank" rel="noopener" href="https://checkpoint.hashicorp.com/">Checkpoint</a>服务交互来检查当前版本是否有更新或是关键的安全公告。</p>
<p>可以通过执行terraform version命令来检查是否有新版本可用。</p>
<h2 id="1-7-1-4-Checkpoint服务"><a href="#checkpoint%E6%9C%8D%E5%8A%A1"></a>1.7.1.4. Checkpoint服务</h2>
<p>Terraform会收集一些不涉及用户身份信息或是主机信息的数据发送给Checkpoint服务。一个匿名ID会被发送到Checkpoint来消除重复的告警信息。我们可以关闭与Checkpoint的交互。</p>
<p>我们可以设置CHECKPOINT_DISABLE环境变量的值为任意非空值来完全关闭HashiCorp所有产品与Checkpoint的交互。另外，我们也可以通过设置命令行配置文件来关闭这些功能：</p>
<ul>
<li>
<p>disable_checkpoint：设置为true可以完全关闭与Checkpoint的交互</p>
</li>
<li>
<p>disable_checkpoint_signature：设置为true可以阻止向Checkpoint发送匿名ID</p>
</li>
<li>
<p><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6terraformrc-%E6%88%96-terraformrc"><strong>1.7.1.1.</strong> 命令行配置文件(.terraformrc 或 terraform.rc)</a></p>
</li>
<li>
<p><a href="#%E4%BD%8D%E7%BD%AE"><strong>1.7.1.1.1.</strong> 位置</a></p>
</li>
<li>
<p><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95"><strong>1.7.1.1.2.</strong> 配置文件语法</a></p>
</li>
<li>
<p><a href="#%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE"><strong>1.7.1.1.3.</strong> 可用配置</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E5%AE%89%E8%A3%85"><strong>1.7.1.1.4.</strong> Provider 的安装</a></p>
</li>
<li>
<p><a href="#%E6%98%BE%E5%BC%8F%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AE"><strong>1.7.1.1.4.1.</strong> 显式安装方法配置</a></p>
</li>
<li>
<p><a href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E7%9B%AE%E5%BD%95"><strong>1.7.1.1.5.</strong> 隐式的本地镜像目录</a></p>
</li>
<li>
<p><a href="#provider-%E6%8F%92%E4%BB%B6%E7%BC%93%E5%AD%98"><strong>1.7.1.1.6.</strong> Provider 插件缓存</a></p>
</li>
<li>
<p><a href="#%E5%85%81%E8%AE%B8-provider-%E7%BC%93%E5%AD%98%E8%B7%B3%E8%BF%87%E4%BE%9D%E8%B5%96%E9%94%81%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5"><strong>1.7.1.1.7.</strong> 允许 Provider 缓存跳过依赖锁文件检查</a></p>
</li>
</ul>
<p><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6terraformrc-%E6%88%96-terraformrc"></a></p>
<h2 id="1-7-1-1-命令行配置文件-terraformrc-或-terraform-rc"><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6terraformrc-%E6%88%96-terraformrc"></a>1.7.1.1. 命令行配置文件(.terraformrc 或 terraform.rc)</h2>
<p>命令行配置文件为每个用户配置了命令行的行为，适用于所有的 Terraform 工作目录，这与我们编写的 Terraform 代码是分开的。</p>
<h2 id="1-7-1-1-1-位置"><a href="#%E4%BD%8D%E7%BD%AE"></a>1.7.1.1.1. 位置</h2>
<p>配置文件的位置取决于用户使用的操作系统：</p>
<ul>
<li>Windows 平台上，文件名必须是 <code>terraform.rc</code>，位置必须在相关用户的 <code>%APPDATA%</code> 目录下。这个目录的物理路径取决于 Windows 的版本以及系统配置；在 PowerShell 中查看 <code>$env:APPDATA</code> 可以找到对应的路径</li>
<li>在其他操作系统上，文件名必须是 <code>.terraformrc</code>(注意第一个是 <code>.</code>)，位置必须是在相关用户的 <code>HOME</code> 目录</li>
</ul>
<p>在 Windows 上创建配置文件时，要注意 Windows Explorer 默认隐藏文件扩展名的行为。Terraform 不会把 <code>terraform.rc.txt</code> 文件识别为命令行配置文件，而默认情况下 Windows Explorer 会将它的文件名显示为 <code>terraform.rc</code> (隐藏了扩展名的缘故)。可以在 PowerShell 或命令行中使用 <code>dir</code> 命令来确认文件名。</p>
<p>可以通过设置 <code>TF_CLI_CONFIG_FILE</code> 环境变量的方式来修改配置文件的位置。</p>
<h2 id="1-7-1-1-2-配置文件语法"><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95"></a>1.7.1.1.2. 配置文件语法</h2>
<p>配置文件本身如同 <code>.tf</code> 文件那样也采用HCL语法，但使用不同的属性和块。以下是常见语法的演示，后续的部分会详细介绍这些配置项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugin_cache_dir   = &quot;$HOME/.terraform.d/plugin-cache&quot;</span><br><span class="line">disable_checkpoint = true</span><br></pre></td></tr></table></figure>
<h2 id="1-7-1-1-3-可用配置"><a href="#%E5%8F%AF%E7%94%A8%E9%85%8D%E7%BD%AE"></a>1.7.1.1.3. 可用配置</h2>
<p>命令行配置文件中可以设置的配置项有：</p>
<ul>
<li><code>credentials</code>：使用 Terraform Cloud 服务或 Terraform 企业版时使用的凭据</li>
<li><code>credentials_helper</code>：配置一个外部的用于读写 Terraform Cloud 或 Terraform 企业版凭据的帮助程序</li>
<li><code>disable_checkpoint</code>：设置为 <code>true</code> 可以完全关闭与 Checkpoint 的交互</li>
<li><code>disable_checkpoint_signature</code>：设置为 <code>true</code> 可以阻止向 Checkpoint 发送匿名 ID</li>
<li><code>plugin_cache_dir</code>：开启插件缓存，我们在介绍 Provider 的章节中介绍过</li>
<li><code>provider_installation</code>：定制化执行 <code>terraform init</code> 时安装插件的行为</li>
</ul>
<p>鉴于本教程无意涉及与 Terraform Cloud 或企业版相关的部分，所以我们会略过对 credentials 和 credentials_helper 的介绍；插件缓存的相关知识我们在 Provider 章节中已做过介绍，在此先偷懒略过。感兴趣的读者可以自行查阅<a target="_blank" rel="noopener" href="https://www.terraform.io/docs/commands/cli-config.html#credentials-1">相关文档</a></p>
<h2 id="1-7-1-1-4-Provider-的安装"><a href="#provider-%E7%9A%84%E5%AE%89%E8%A3%85"></a>1.7.1.1.4. Provider 的安装</h2>
<p>默认情况下 Terraform 从官方 Provider Registry 下载安装 Provider 插件。Provider 在 Registry 中的原始地址采用类似 <code>registry.terraform.io/hashicorp/aws</code> 的编码规则。通常为了简便，Terraform 允许省略地址中的主机名部分 <code>registry.terraform.io</code>，所以我们可以直接使用地址 <code>hashicorp/aws</code>。</p>
<p>有时无法直接从官方 Registry 下载插件，例如我们要在一个与公网隔离的环境中运行 Terraform 时。为了允许 Terraform 工作在这样的环境下，有一些可选方法允许我们从其他地方获取 Provider 插件。</p>
<h3 id="1-7-1-1-4-1-显式安装方法配置"><a href="#%E6%98%BE%E5%BC%8F%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AE"></a>1.7.1.1.4.1. 显式安装方法配置</h3>
<p>可以在命令行配置文件中定义一个 <code>provider_installation</code> 块来修改 Terraform 默认的插件安装行为，命令 Terraform 使用本地的 Registry 镜像服务，或是使用一些用户修改过的插件。</p>
<p>通常 <code>provider_installation</code> 块的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">provider_installation &#123;</span><br><span class="line">  filesystem_mirror &#123;</span><br><span class="line">    path    = &quot;/usr/share/terraform/providers&quot;</span><br><span class="line">    include = [&quot;example.com/*/*&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">  direct &#123;</span><br><span class="line">    exclude = [&quot;example.com/*/*&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>provider_installation</code> 块中每一个内嵌块都指定了一种安装方式。每一种安装方式都可以同时包含 <code>include</code> 与 <code>exclude</code> 模式来指定安装方式使用的 Provider 类型。在上面的例子里，我们把所有原先位于 <code>example.com</code> 这个 Registry 存储中的 Provider 设置成只能从本地文件系统的 <code>/usr/share/terraform/providers</code> 镜像存储中寻找并安装，而其他的 Provider 只能从它们原先的 Registry 存储下载安装。</p>
<p>如果你为一种安装方式同时设置了 <code>include</code> 与 <code>exclude</code>，那么 <code>exclude</code> 模式将拥有更高的优先级。举例：包含<code>registry.terraform.io/hashicorp/*</code>但排除<code>registry.terraform.io/hashicorp/dns</code>将对所有<code>hashicorp</code>空间下的插件有效，但是<code>hashicorp/dns</code>除外。</p>
<p>和Terraform代码文件中Provider的<code>source</code>属性一样的是，在<code>provider_installation</code>里你也可以省略<code>registry.terraform.io/</code>的前缀，甚至是使用通配符时亦是如此。比如，<code>registry.terraform.io/hashicorp/*</code>和<code>hashicorp/*</code>是等价的；<code>*/*</code>是<code>registry.terraform.io/*/*</code>的缩写，<strong>而不是</strong><code>*/*/*</code>的缩写。</p>
<p>目前支持的安装方式如下：</p>
<ul>
<li><code>direct</code>：要求直接从原始的Registry服务下载。该方法不需要额外参数。</li>
<li><code>filesystem_mirror</code>：一个本地存有 Provider 插件拷贝的目录。该方法需要一个额外的参数 <code>path</code> 来指定存有插件拷贝的目录路径。 Terraform 期待给定路径的目录内通过路径来描述插件的一些元信息。支持一下两种目录结构：
<ul>
<li>打包式布局： <code>HOSTNAME/NAMESPACE/TYPE/terraform-provider-TYPE_VERSION_TARGET.zip</code> 的格式指定了一个从原始 Registry 获取的包含插件的发行版 zip 文件</li>
<li>解压式布局：<code>HOSTNAME/NAMESPACE/TYPE/VERSION/TARGET</code> 式一个包含有 Provider 插件发行版 zip 文件解压缩后内容物的目录 这两种布局下，<code>VERSION</code> 都是代表着插件版本的字符串，比如 <code>2.0.0</code>；<code>TARGET</code> 则指定了插件发行版对应的目标平台，例如 <code>darwin_amd64</code>、<code>linux_arm</code>、<code>windows_amd64</code> 等等。</li>
</ul>
</li>
</ul>
<p>如果使用解压式布局，Terraform 在安装插件时会尝试创建一个到镜像目录的符号连接来避免拷贝文件夹。打包式布局则不会这样做，因为 Terraform 必须在安装插件时解压发行版文件。</p>
<p>你可以指定多个<code>filesystem_mirror</code>块来指定多个不同的目录。</p>
<ul>
<li><code>network_mirror</code>：指定一个 HTTPS 服务地址提供 Provider 插件的拷贝，不论这些插件原先属于哪些 Registry 服务。该方法需要一个额外参数 <code>url</code> 来指定镜像服务的地址，<code>url</code> 地址必须使用 <code>https:</code> 作为前缀，<strong>以斜杠结尾</strong>。 Terraform期待该地址指定的服务实现了 <a target="_blank" rel="noopener" href="https://www.terraform.io/docs/internals/provider-network-mirror-protocol.html">Provider网络镜像协议</a>，这是一种被设计用来托管插件拷贝的网站所需要实现的协议，在此我们不展开讨论。</li>
</ul>
<p><strong>需要特别注意的是，请不要使用不可信的 <code>network_mirror</code> 地址。Terraform 会验证镜像站点的 TLS 证书以确认身份，但一个拥有合法 TLS 证书的镜像站可能会提供包含恶意内容的插件文件。</strong></p>
<ul>
<li><code>dev_overrides</code>：指定使用本地的开发版本插件。有时我们想要对 Provider 代码做一些修改，为了调试本地代码编译后的插件，可以使用 <code>dev_overrides</code> 指定使用本地编译的版本。</li>
</ul>
<p>例如，我们想要调试本地修改过的 UCloud Provider 插件，我们可以从 github 上克隆该项目源代码，修改完代码后，编译一个可执行版本(以Mac OS为例)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ GOOS=darwin GOARCH=arm64 go build -o bin/terraform-provider-ucloud</span><br><span class="line">$ <span class="built_in">chmod</span> +x bin/terraform-provider-ucloud</span><br></pre></td></tr></table></figure>
<p>然后编写如下<code>provider_installation</code>配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provider_installation&#123;</span><br><span class="line">  dev_overrides &#123;</span><br><span class="line">    &quot;ucloud/ucloud&quot; = &quot;PATH_TO_PROJECT/terraform-provider-ucloud/&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Terraform 代码中要求了 <code>source</code> 为 <code>ucloud/ucloud</code> 的 Provider 时，执行 <code>terraform init</code> 仍然会报错，抱怨找不到 <code>ucloud/ucloud</code> 这个 Provider，但执行 <code>terraform plan</code> 或是 <code>terraform apply</code> 等操作时可以顺利执行，此时 Terraform 会使用路径指定的本地 Provider 插件。这种方式比较适合于调试本地 Provider 插件代码。</p>
<p>对于上述的几种插件安装方式，Terraform 会尝试通过 <code>include</code> 和 <code>exclude</code> 模式匹配 Provider，遍历匹配的安装方式，选择一个符合 Terraform 代码中对插件版本约束的最新版本。如果你拥有一个插件的特定版本的本地镜像，并且你希望 Terraform 只使用这个本地镜像，那么你需要移除 <code>direct</code> 安装方式，或是在 <code>direct</code> 中通过<code>exclude</code> 参数排除特定的 Provider。</p>
<h2 id="1-7-1-1-5-隐式的本地镜像目录"><a href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E7%9B%AE%E5%BD%95"></a>1.7.1.1.5. 隐式的本地镜像目录</h2>
<p>如果命令行配置文件中没有包含 <code>provider_installation</code> 块，那么 Terraform 会生成一个隐式的配置。该隐式配置包含了一个 <code>filesystem_mirror</code> 方法以及一个 <code>direct</code> 方法。</p>
<p>在不同的操作系统上，Terraform 会选择不同的路径作为隐式 <code>filesystem_mirror</code> 路径：</p>
<ul>
<li>Windows：<code>%APPDATA%/terraform.d/plugins</code> 以及 <code>%APPDATA%/HashiCorp/Terraform/plugins</code></li>
<li>Mac OS X：<code>$HOME/.terraform.d/plugins/</code>，<code>~/Library/Application Support/io.terraform/plugins</code> 以及 <code>/Library/Application Support/io.terraform/plugins</code></li>
<li>Linux 以及其他 Unix 风格系统：<code>$HOME/.terraform.d/plugins/</code>，以及配置的 <a target="_blank" rel="noopener" href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG 基础目录</a>后接 <code>terraform/plugins</code>。如果没有设置 XDG 环境变量，Terraform 会使用 <code>~/.local/share/terraform/plugins</code>，<code>/usr/local/share/terraform/plugins</code>，以及 <code>/usr/share/terraform/plugins</code></li>
</ul>
<p>Terraform 会在启动时为上述路径的每一个目录创建一个隐式 <code>filesystem_mirror</code> 块。另外如果当前工作目录下包含有 <code>terraform.d/plugins</code> 目录，那么也会为它创建一个隐式 <code>filesystem_mirror</code> 块。</p>
<p>相对于任意多个隐式 <code>filesystem_mirror</code> 块，Terraform 同时也会创建一个隐式 <code>direct</code> 块。Terraform 会扫描所有文件系统镜像目录，对找到的 Provider 自动从 <code>direct</code> 块中排除出去（这种自动的 <code>exclude</code> 行为只对隐式 <code>direct</code> 块有效。如果你在 <code>provider_installation</code> 块中显式指定了 <code>direct</code> 块，那么你需要自己显式定义 <code>exclude</code> 规则）。</p>
<p>TODO:<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/cli/config/config-file#provider-plugin-cache">https://developer.hashicorp.com/terraform/cli/config/config-file#provider-plugin-cache</a></p>
<h2 id="1-7-1-1-6-Provider-插件缓存"><a href="#provider-%E6%8F%92%E4%BB%B6%E7%BC%93%E5%AD%98"></a>1.7.1.1.6. Provider 插件缓存</h2>
<h2 id="1-7-1-1-7-允许-Provider-缓存跳过依赖锁文件检查"><a href="#%E5%85%81%E8%AE%B8-provider-%E7%BC%93%E5%AD%98%E8%B7%B3%E8%BF%87%E4%BE%9D%E8%B5%96%E9%94%81%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5"></a>1.7.1.1.7. 允许 Provider 缓存跳过依赖锁文件检查</h2>
<ul>
<li>
<p><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><strong>1.7.2.1.</strong> 环境变量</a></p>
</li>
<li>
<p><a href="#tflog"><strong>1.7.2.1.1.</strong> TF_LOG</a></p>
</li>
<li>
<p><a href="#tflogpath"><strong>1.7.2.1.2.</strong> TF_LOG_PATH</a></p>
</li>
<li>
<p><a href="#tfinput"><strong>1.7.2.1.3.</strong> TF_INPUT</a></p>
</li>
<li>
<p><a href="#tfvarname"><strong>1.7.2.1.4.</strong> TF_VAR_name</a></p>
</li>
<li>
<p><a href="#tfcliargs-%E4%BB%A5%E5%8F%8A-tfcliargsname"><strong>1.7.2.1.5.</strong> TF_CLI_ARGS 以及 TF_CLI_ARGS_name</a></p>
</li>
<li>
<p><a href="#tfdatadir"><strong>1.7.2.1.6.</strong> TF_DATA_DIR</a></p>
</li>
<li>
<p><a href="#tfworkspace"><strong>1.7.2.1.7.</strong> TF_WORKSPACE</a></p>
</li>
<li>
<p><a href="#tfinautomation"><strong>1.7.2.1.8.</strong> TF_IN_AUTOMATION</a></p>
</li>
<li>
<p><a href="#tfregistrydiscoveryretry"><strong>1.7.2.1.9.</strong> TF_REGISTRY_DISCOVERY_RETRY</a></p>
</li>
<li>
<p><a href="#tfregistryclienttimeout"><strong>1.7.2.1.10.</strong> TF_REGISTRY_CLIENT_TIMEOUT</a></p>
</li>
<li>
<p><a href="#tfcliconfigfile"><strong>1.7.2.1.11.</strong> TF_CLI_CONFIG_FILE</a></p>
</li>
<li>
<p><a href="#tfplugincachedir"><strong>1.7.2.1.12.</strong> TF_PLUGIN_CACHE_DIR</a></p>
</li>
<li>
<p><a href="#tfignore"><strong>1.7.2.1.13.</strong> TF_IGNORE</a></p>
</li>
</ul>
<p><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"></a></p>
<h2 id="1-7-2-1-环境变量"><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"></a>1.7.2.1. 环境变量</h2>
<p>Terraform使用一系列的环境变量来定制化各方面的行为。如果只是想简单使用Terraform，我们并不需要设置这些环境变量；但他们可以在一些不常见的场景下帮助我们改变Terraform的默认行为，或者是出于调试目的修改输出日志的级别。</p>
<h2 id="1-7-2-1-1-TF-LOG"><a href="#tflog"></a>1.7.2.1.1. TF_LOG</h2>
<p>该环境变量可以设定 Terraform 内部日志的输出级别，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TF_LOG=TRACE</span><br></pre></td></tr></table></figure>
<p>Terraform 日志级别有 <code>TRACE</code>、<code>DEBUG</code>、<code>INFO</code>、<code>WARN</code> 和 <code>ERROR</code>。<code>TRACE</code> 包含的信息最多也最冗长，如果 <code>TF_LOG</code> 被设定为这五级以外的值时 Terraform 会默认使用 <code>TRACE</code>。</p>
<p>如果在使用 Terraform 的过程中遇到未知的错误并怀疑是 Terraform 或相关插件的 bug，请设置 <code>TF_LOG</code> 级别后收集输出的日志并提交给相关人员。</p>
<p>有志于获取 Terraform 认证的读者请注意，该知识点近乎属于必考。</p>
<h2 id="1-7-2-1-2-TF-LOG-PATH"><a href="#tflogpath"></a>1.7.2.1.2. TF_LOG_PATH</h2>
<p>该环境变量可以设定日志文件保存的位置。注意，如果TF_LOG_PATH被设置了，那么 <code>TF_LOG</code> 也必须被设置。举例来说，想要始终把日志输出到当前工作目录，我们可以这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TF_LOG_PATH=./terraform.log</span><br></pre></td></tr></table></figure>
<h2 id="1-7-2-1-3-TF-INPUT"><a href="#tfinput"></a>1.7.2.1.3. TF_INPUT</h2>
<p>该环境变量设置为 <code>&quot;false&quot;</code> 或 <code>&quot;0&quot;</code> 时，等同于运行 Terraform 相关命令行命令时添加了参数 <code>-input=false</code>。如果你想在自动化环境下避免 Terraform 通过命令行的交互式提示要求给定输入变量的值而是直接报错时(无 <code>default</code> 值的输入变量，无法通过任何途径获得值)可以设置该环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TF_INPUT=0</span><br></pre></td></tr></table></figure>
<h2 id="1-7-2-1-4-TF-VAR-name"><a href="#tfvarname"></a>1.7.2.1.4. TF_VAR_name</h2>
<p>我们在介绍输入变量赋值时介绍过，可以通过设置名为 <code>TF_VAR_name</code> 的环境变量来为名为 <code>&quot;name&quot;</code> 的输入变量赋值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TF_VAR_region=us-west-1</span><br><span class="line">$ <span class="built_in">export</span> TF_VAR_ami=ami-049d8641</span><br><span class="line">$ <span class="built_in">export</span> TF_VAR_alist=<span class="string">&#x27;[1,2,3]&#x27;</span></span><br><span class="line">$ <span class="built_in">export</span> TF_VAR_amap=<span class="string">&#x27;&#123; foo = &quot;bar&quot;, baz = &quot;qux&quot; &#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-2-1-5-TF-CLI-ARGS-以及-TF-CLI-ARGS-name"><a href="#tfcliargs-%E4%BB%A5%E5%8F%8A-tfcliargsname"></a>1.7.2.1.5. TF_CLI_ARGS 以及 TF_CLI_ARGS_name</h2>
<p><code>TF_CLI_ARGS</code> 的值指定了附加给命令行的额外参数，这使得在自动化 CI 环境下可以轻松定制 Terraform 的默认行为。</p>
<p>该参数的值会被直接插入在子命令后(例如 plan)以及通过命令行指定的参数之前。这种做法确保了环境变量参数优先于通过命令行传递的参数。</p>
<p>例如，执行这样的命令：<code>TF_CLI_ARGS=&quot;-input=false&quot; terraform apply -force</code>，它等价于手工执行 <code>terraform apply -input=false -force</code>。</p>
<p><code>TF_CLI_ARGS</code> 变量影响所有的 Terraform 命令。如果你只想影响某个特定的子命令，可以使用 <code>TF_CLI_ARGS_name</code> 变量。例如：<code>TF_CLI_ARGS_plan=&quot;-refresh=false&quot;</code>，就只会针对 <code>plan</code> 子命令起作用。</p>
<p>该环境变量的值会与通过命令行传入的参数一样被解析，你可以在值里使用单引号和双引号来定义字符串，多个参数之间以空格分隔。</p>
<h2 id="1-7-2-1-6-TF-DATA-DIR"><a href="#tfdatadir"></a>1.7.2.1.6. TF_DATA_DIR</h2>
<p><code>TF_DATA_DIR</code> 可以修改 Terraform 保存在每个工作目录下的数据的位置。一般来说，Terraform 会把这些数据写入当前工作目录下的 <code>.terraform</code> 文件夹内，但这一位置可以通过设置 <code>TF_DATA_DIR</code> 来修改。</p>
<p>大部分情况下我们不应该设置该变量，但有时我们不得不这样做，比如默认路径下我们无权写入数据时。</p>
<p>该数据目录被用来保存下一次执行任意命令时需要读取的数据，所以必须被妥善保存，并确保所有的 Terraform 命令都可以一致地读写它，否则 Terraform 会找不到 Provider 插件、模块代码以及其他文件。</p>
<h2 id="1-7-2-1-7-TF-WORKSPACE"><a href="#tfworkspace"></a>1.7.2.1.7. TF_WORKSPACE</h2>
<p>多环境部署时，可以使用此环境变量而非 <code>terraform workspace select your_workspace</code> 来切换 workspace。使用 <code>TF_WORKSPACE</code> 允许设置使用的工作区。</p>
<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export TF_WORKSPACE=your_workspace</span><br></pre></td></tr></table></figure>
<p>建议仅在非交互式使用中使用此环境变量，因为在本地 shell 环境中，很容易忘记设置了该变量并将变更执行到错误的环境中。</p>
<p>可以在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/22.workspace/index">这里</a>阅读工作区的更多信息。</p>
<h2 id="1-7-2-1-8-TF-IN-AUTOMATION"><a href="#tfinautomation"></a>1.7.2.1.8. TF_IN_AUTOMATION</h2>
<p>如果该变量被设置为非空值，Terraform 会意识到自己运行在一个自动化环境下，从而调整自己的输出以避免给出关于该执行什么子命令的建议。这可以使得输出更加一致且减少非必要的信息量。</p>
<h2 id="1-7-2-1-9-TF-REGISTRY-DISCOVERY-RETRY"><a href="#tfregistrydiscoveryretry"></a>1.7.2.1.9. TF_REGISTRY_DISCOVERY_RETRY</h2>
<p>该变量定义了尝试从 registry 拉取插件或模块代码遇到错误时的重试次数。</p>
<h2 id="1-7-2-1-10-TF-REGISTRY-CLIENT-TIMEOUT"><a href="#tfregistryclienttimeout"></a>1.7.2.1.10. TF_REGISTRY_CLIENT_TIMEOUT</h2>
<p>该变量定义了发送到 registry 连接请求的超时时间，默认值为 10 秒。可以这样设置超时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TF_REGISTRY_CLIENT_TIMEOUT=15</span><br></pre></td></tr></table></figure>
<h2 id="1-7-2-1-11-TF-CLI-CONFIG-FILE"><a href="#tfcliconfigfile"></a>1.7.2.1.11. TF_CLI_CONFIG_FILE</h2>
<p>该变量设定了 Terraform 命令行配置文件的位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TF_CLI_CONFIG_FILE=<span class="string">&quot;<span class="variable">$HOME</span>/.terraformrc-custom&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-2-1-12-TF-PLUGIN-CACHE-DIR"><a href="#tfplugincachedir"></a>1.7.2.1.12. TF_PLUGIN_CACHE_DIR</h2>
<p><code>TF_PLUGIN_CACHE_DIR</code> 环境变量是<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6#provider-%E6%8F%92%E4%BB%B6%E7%BC%93%E5%AD%98">配置插件缓存目录</a>的另一种方法。你也可以使用 <code>TF_PLUGIN_CACHE_MAY_BREAK_DEPENDENCY_LOCK_FILE</code> 环境变量设置 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6#%E5%85%81%E8%AE%B8-provider-%E7%BC%93%E5%AD%98%E8%B7%B3%E8%BF%87%E4%BE%9D%E8%B5%96%E9%94%81%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5"><code>plugin_cache_may_break_dependency_lock_file</code> 配置项</a></p>
<h2 id="1-7-2-1-13-TF-IGNORE"><a href="#tfignore"></a>1.7.2.1.13. TF_IGNORE</h2>
<p>如果 <code>TF_IGNORE</code> 设置为 <code>&quot;trace&quot;</code>，Terraform 会在调试信息中输出被忽略的文件和目录。该配置与 <code>.terraformignore</code> 文件搭配时对调试大型代码仓库相当有用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export TF_IGNORE=trace</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80"><strong>1.7.3.1.</strong> 资源地址</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84"><strong>1.7.3.1.1.</strong> 模块路径</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80%E5%BD%A2%E5%BC%8F"><strong>1.7.3.1.2.</strong> 资源地址形式</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97%E4%B8%8E%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%E7%B4%A2%E5%BC%95"><strong>1.7.3.1.3.</strong> 多实例模块与资源的访问索引</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90"><strong>1.7.3.1.4.</strong> 例子</a></p>
</li>
<li>
<p><a href="#count-%E7%9A%84%E4%BE%8B%E5%AD%90"><strong>1.7.3.1.4.1.</strong> count 的例子</a></p>
</li>
<li>
<p><a href="#foreach-%E7%9A%84%E4%BE%8B%E5%AD%90"><strong>1.7.3.1.4.2.</strong> for_each 的例子</a></p>
</li>
</ul>
<p><a href="#%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80"></a></p>
<h2 id="1-7-3-1-资源地址"><a href="#%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80"></a>1.7.3.1. 资源地址</h2>
<p>在编码时我们有时会需要引用一些资源的输出属性或是一些模块的输出值，这都涉及到如何在代码中引用特定模块或是资源。另外在执行某些命令行操作时也需要我们显式指定一些目标资源，这时我们要掌握Terraform的资源路径规则。</p>
<p>一个资源地址是用以在一个庞大的基础设施中精确引用一个特定资源对象的字符串。一个地址由两部分组成：<code>[module path][resource spec]</code>。</p>
<h2 id="1-7-3-1-1-模块路径"><a href="#%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84"></a>1.7.3.1.1. 模块路径</h2>
<p>一个模块路径在模块树上定位了一个特定模块。它的形式是这样的：<code>module.module_name[module index]</code></p>
<ul>
<li><code>module</code>：<code>module</code> 关键字标记了这时一个子模块而非根模块。在路径中可以包含多个 <code>module</code> 关键字</li>
<li><code>module_name</code>：用户定义的模块名</li>
<li><code>[module index]</code>：(可选)访问多个子模块中特定实例的索引，由方括号包围</li>
</ul>
<p>一个不包含具体资源的地址，例如 <code>module.foo</code> 代表了模块内所有的资源(如果只是单个模块而不是多实例模块)，或者是多实例模块的所有实例。要指代特定模块实例的所有资源，需要在地址中附带下标，例如 <code>module.foo[0]</code>。</p>
<p>如果地址中模块部分被省略，那么地址就指代根模块资源。</p>
<p>这里有一个包含多个 <code>module</code> 关键字应用于多实例模块的例子：<code>module.foo[0].module.bar[&quot;a&quot;]</code>。</p>
<p>要注意的是，由于模块的 <code>count</code> 和 <code>for_each</code> 元参数是 Terraform 0.13 开始引进的，所以多实例模块地址也只能在 0.13 及之后的版本使用。</p>
<h2 id="1-7-3-1-2-资源地址形式"><a href="#%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80%E5%BD%A2%E5%BC%8F"></a>1.7.3.1.2. 资源地址形式</h2>
<p>一个资源地址定位了代码中特定资源对象，它的形式是这样的：<code>resource_type.resource_name[resource index]</code></p>
<ul>
<li><code>resource_type</code>：资源类型</li>
<li><code>resource_name</code>：用户定义的资源名称</li>
<li><code>[resource index]</code>：(可选)访问多实例资源中特定资源实例的索引，由方括号包围</li>
</ul>
<h2 id="1-7-3-1-3-多实例模块与资源的访问索引"><a href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97%E4%B8%8E%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%E7%B4%A2%E5%BC%95"></a>1.7.3.1.3. 多实例模块与资源的访问索引</h2>
<p>以下规约适用于访问多实例模块及资源时使用的索引值：</p>
<ul>
<li><code>[N]</code>：当使用 <code>count</code> 元参数时N是一个自然数。如果省略，并且 <code>count</code> &gt; 1，那么指代所有的实例</li>
<li><code>[&quot;INDEX&quot;]</code>：当使用 <code>for_each</code> 元参数时 <code>INDEX</code> 是一个字母数字混合的字符串</li>
</ul>
<h2 id="1-7-3-1-4-例子"><a href="#%E4%BE%8B%E5%AD%90"></a>1.7.3.1.4. 例子</h2>
<h3 id="1-7-3-1-4-1-count-的例子"><a href="#count-%E7%9A%84%E4%BE%8B%E5%AD%90"></a>1.7.3.1.4.1. count 的例子</h3>
<p>给定一个代码定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line">  count = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定一个地址：<code>aws_instance.web[3]</code>，它指代的是最后一个名为 <code>web</code> 的 <code>aws_instance</code> 实例；给定地址 <code>aws_instance.web</code>，指代的是所有名为 <code>web</code> 的 <code>aws_instance</code> 实例。</p>
<h3 id="1-7-3-1-4-2-for-each-的例子"><a href="#foreach-%E7%9A%84%E4%BE%8B%E5%AD%90"></a>1.7.3.1.4.2. for_each 的例子</h3>
<p>给定如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line">  for_each = &#123;</span><br><span class="line">    &quot;terraform&quot;: &quot;value1&quot;,</span><br><span class="line">    &quot;resource&quot;:  &quot;value2&quot;,</span><br><span class="line">    &quot;indexing&quot;:  &quot;value3&quot;,</span><br><span class="line">    &quot;example&quot;:   &quot;value4&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>地址 <code>aws_instance.web[&quot;example&quot;]</code> 引用的是 <code>aws_instance.web</code> 中键为 <code>&quot;example&quot;</code> 的实例。</p>
<ul>
<li>
<p><a href="#apply"><strong>1.7.4.1.</strong> apply</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.4.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E8%87%AA%E5%8A%A8-plan-%E6%A8%A1%E5%BC%8F"><strong>1.7.4.1.2.</strong> 自动 Plan 模式</a></p>
</li>
<li>
<p><a href="#%E6%97%A2%E6%9C%89-plan-%E6%A8%A1%E5%BC%8F"><strong>1.7.4.1.3.</strong> 既有 Plan 模式</a></p>
</li>
<li>
<p><a href="#plan-%E5%8F%82%E6%95%B0"><strong>1.7.4.1.4.</strong> Plan 参数</a></p>
</li>
<li>
<p><a href="#apply-%E5%8F%82%E6%95%B0"><strong>1.7.4.1.5.</strong> Apply 参数</a></p>
</li>
<li>
<p><a href="#%E6%8C%87%E5%AE%9A%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><strong>1.7.4.1.6.</strong> 指定其他配置文件目录</a></p>
</li>
</ul>
<p><a href="#apply"></a></p>
<h2 id="1-7-4-1-apply"><a href="#apply"></a>1.7.4.1. apply</h2>
<p>Terraform 最重要的命令就是 <code>apply</code>。<code>apply</code> 命令可以生成执行计划(可选)并执行之，使得基础设施资源状态符合代码的描述。</p>
<h2 id="1-7-4-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.4.1.1. 用法</h2>
<p><code>terraform apply [options] [plan file]</code></p>
<p>Terraform 的 Apply 有两种模式：自动 Plan 模式以及既有 Plan 模式。</p>
<h2 id="1-7-4-1-2-自动-Plan-模式"><a href="#%E8%87%AA%E5%8A%A8-plan-%E6%A8%A1%E5%BC%8F"></a>1.7.4.1.2. 自动 Plan 模式</h2>
<p>当我们运行 <code>terraform apply</code> 而不指定计划文件时，Terraform 会自动创建一个新的执行计划，就像我们已运行 <code>terraform plan</code> 一样，提示我们批准该计划，并采取指示的操作。我们可以使用所有 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan#plan-%E6%A8%A1%E5%BC%8F">plan 模式</a>和 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan#plan-%E9%80%89%E9%A1%B9">plan 选项</a>来自定义 Terraform 创建计划的方式。</p>
<p>我们可以设置 <code>-auto-approve</code> 选项来要求 Terraform 跳过确认直接执行计划。</p>
<p><strong>警告</strong>：如果使用 <code>-auto-approve</code>，建议确保没有人可以在 Terraform 工作流程之外更改我们的基础设施。这可以最大限度地降低不可预测的变更和配置漂移的风险。</p>
<h2 id="1-7-4-1-3-既有-Plan-模式"><a href="#%E6%97%A2%E6%9C%89-plan-%E6%A8%A1%E5%BC%8F"></a>1.7.4.1.3. 既有 Plan 模式</h2>
<p>当您将<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan#outputfile">既有的计划文件</a>传递给 <code>terraform apply</code> 时，Terraform 会执行既有的计划中的操作，而不提示确认。在自动化运行 Terraform 时，可能需要使用由这样的两个步骤组成的工作流。</p>
<p>我们在应用计划之前可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/17.show"><code>terraform show</code></a> 检查既有的计划文件。</p>
<p>使用既有的计划时，我们无法指定任何其他计划模式或选项。这些选项只会影响 Terraform 关于采取哪些操作的决策，而这些决策的最终结果已经在计划文件中包含了。</p>
<h2 id="1-7-4-1-4-Plan-参数"><a href="#plan-%E5%8F%82%E6%95%B0"></a>1.7.4.1.4. Plan 参数</h2>
<p>在未提供既有计划文件时，<code>terraform apply</code> 命令支持 <code>terraform plan</code> 命令所支持的所有 Plan 模式参数以及 Plan 选项参数。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan#plan-%E6%A8%A1%E5%BC%8F">Plan 模式参数</a>：包括 <code>-destroy</code>（创建销毁所有远程对象的计划）和 <code>-refresh-only</code>（创建更新 Terraform 状态和根模块输出值的计划）。</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan#plan-%E9%80%89%E9%A1%B9">Plan 选项参数</a>：包括指定 Terraform 应替换哪些资源实例、设置 Terraform 输入变量等的参数。</li>
</ul>
<h2 id="1-7-4-1-5-Apply-参数"><a href="#apply-%E5%8F%82%E6%95%B0"></a>1.7.4.1.5. Apply 参数</h2>
<p>下面的参数可以更改 apply 命令的执行方式和 apply 操作生成的报告格式。</p>
<ul>
<li><code>-auto-approve</code>：跳过交互确认步骤，直接执行变更。此选项将被忽略，因为 Terraform 认为我们指定了计划文件即已批准执行，因此在这种情况下永远不会提示。</li>
<li><code>-compact-warnings</code>：以紧凑的形式显示所有警告消息，其中仅包含摘要消息，除非输出信息中存在至少一个错误，因此警告文本中可能包含有错误的上下文信息。</li>
<li><code>-input=true</code>：禁用 Terraform 的所有交互式提示。请注意，这也会阻止 Terraform 提示交互式批准计划，这时 Terraform 将保守地假设您不希望应用该计划，从而导致操作失败。如果您希望在非交互式上下文中运行 Terraform，请参阅 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/8.%E6%8A%80%E5%B7%A7/10.terraform%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96">Terraform 与自动化</a> 了解一些不同的方法。</li>
<li><code>-json</code>：启用机器可读的 JSON UI 输出。这意味着 <code>-input=false</code>，因此配置 <code>variable</code> 值都已赋值才能继续。要启用此参数，您还必须启用 <code>-auto-approve</code> 标志或指定既有的计划文件。</li>
<li><code>-lock=false</code>：执行时是否先锁定状态文件。如果其他人可能同时对同一工作区运行命令，则这是危险的。</li>
<li><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则命令 Terraform 为上锁操作设置一个超时时长。持续时间语法是一个数字后跟一个时间单位字母，例如“3s”表示三秒。</li>
<li><code>-no-color</code>：关闭彩色输出。在无法解释输出色彩的终端中运行 Terraform 时请使用此参数。</li>
<li><code>-parallelism=n</code>：限制 Terraform <a target="_blank" rel="noopener" href="https://www.terraform.io/docs/internals/graph.html#walking-the-graph">遍历图</a>时的最大并行度，默认值为 <code>10</code>(考试高频考点)</li>
</ul>
<p>当配置中只使用了 <code>local</code> Backend 时，<code>terraform apply</code> 还支持以下三个遗留参数：</p>
<ul>
<li><code>-backup-path</code>：保存备份文件的路径。默认等于 <code>-state-out</code> 参数后加上 <code>&quot;.backup&quot;</code> 后缀。设置为 <code>&quot;-&quot;</code> 可关闭</li>
<li><code>-state=path</code>：保存状态文件的路径，默认值是 <code>&quot;terraform.tfstate&quot;</code>。如果使用了远程 Backend 该参数设置无效。该参数不影响其他命令，比如执行 <code>init</code> 时会找不到它设置的状态文件。如果要使得所有命令都可以使用同一个特定位置的状态文件，请使用 Local Backend</li>
<li><code>-state-out=path</code>：写入更新的状态文件的路径，默认情况使用 <code>-state</code> 的值。该参数在使用远程 Backend 时设置无效</li>
</ul>
<h2 id="1-7-4-1-6-指定其他配置文件目录"><a href="#%E6%8C%87%E5%AE%9A%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"></a>1.7.4.1.6. 指定其他配置文件目录</h2>
<p>Terraform v0.13 及更早版本接受提供目录路径的附加位置参数，在这种情况下，Terraform 将使用该目录作为根模块而不是当前工作目录。</p>
<p>该用法在 Terraform v0.14 中已弃用，并在 Terraform v0.15 中删除。如果您的工作流程需要修改根模块目录，请改用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/index#%E9%80%9A%E8%BF%87--chdir-%E5%8F%82%E6%95%B0%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><code>-chdir</code> 全局选项</a>，该选项适用于所有命令，并使 Terraform 始终在给定目录中查找它通常在当前工作目录中读取或写入的所有文件。</p>
<p>如果我们之前使用此遗留模式时同时需要 Terraform 将 <code>.terraform</code> 子目录写入当前工作目录，即使根模块目录已被覆盖，请使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/2.%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F#tf_data_dir"><code>TF_DATA_DIR</code> 环境变量</a>命令 Terraform 将 <code>.terraform</code> 目录写入其他位置，而不是当前工作目录。</p>
<ul>
<li>
<p><a href="#console"><strong>1.7.5.1.</strong> console</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.5.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E8%84%9A%E6%9C%AC%E5%8C%96"><strong>1.7.5.1.2.</strong> 脚本化</a></p>
</li>
<li>
<p><a href="#%E8%BF%9C%E7%A8%8B%E7%8A%B6%E6%80%81"><strong>1.7.5.1.3.</strong> 远程状态</a></p>
</li>
<li>
<p><a href="#%E6%90%AD%E9%85%8D%E6%97%A2%E6%9C%89%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C"><strong>1.7.5.1.4.</strong> 搭配既有计划文件运行</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90"><strong>1.7.5.1.5.</strong> 例子</a></p>
</li>
</ul>
<p><a href="#console"></a></p>
<h2 id="1-7-5-1-console"><a href="#console"></a>1.7.5.1. console</h2>
<p>有时我们想要一个安全的调试工具来帮助我们确认某个表达式是否合法，或者表达式的值是否符合预期，这时我们可以使用 <code>terraform console</code> 启动一个交互式控制台。</p>
<h2 id="1-7-5-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.5.1.1. 用法</h2>
<p><code>terraform console [options] [options]</code></p>
<p>console 命令提供了一个用以执行和测试各种<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/8.%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">表达式</a>的命令行控制台。在编码时如果我们不确定某个表达式的最终结果时(例如使用字符串模版)，我们可以在这个控制台中搭配当前状态文件中的数据进行各种测试。</p>
<p>如果当前状态是空的或还没有创建状态文件，那么控制台可以用来测试各种表达式语法以及内建函数。假如当前根模块有状态，<code>console</code> 命令将会对状态加锁，这使得我们无法在运行其他可能会修改状态的操作时使用 <code>console</code> 命令。</p>
<p>在控制台中可以使用 <code>exit</code> 命令或是 Ctrl-C 或是 Ctrl-D 退出。</p>
<p>当使用的是 <code>local</code> Backend 时，<code>terraform console</code> 可以使用 <code>-state</code> 遗留参数：</p>
<ul>
<li><code>-state=path</code>：指向本机状态文件的路径。表达式计算会使用该状态文件中记录的值。如果没有指定，则会使用当前工作区(Workspace)关联的状态文件</li>
</ul>
<h2 id="1-7-5-1-2-脚本化"><a href="#%E8%84%9A%E6%9C%AC%E5%8C%96"></a>1.7.5.1.2. 脚本化</h2>
<p><code>terraform console</code> 命令可以搭配非交互式脚本使用，可以使用管道符将其他命令输出接入控制台执行。如果没有发生错误，只有最终结果会被打印。</p>
<p>样例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;split(&quot;,&quot;, &quot;foo,bar,baz&quot;)&#x27;</span> | terraform console</span><br><span class="line">tolist([</span><br><span class="line">  <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">  <span class="string">&quot;baz&quot;</span>,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="1-7-5-1-3-远程状态"><a href="#%E8%BF%9C%E7%A8%8B%E7%8A%B6%E6%80%81"></a>1.7.5.1.3. 远程状态</h2>
<p>如果使用了远程 Backend 存储状态，Terraform 会从远程 Backend 读取当前工作区的状态数据来计算表达式。</p>
<h2 id="1-7-5-1-4-搭配既有计划文件运行"><a href="#%E6%90%AD%E9%85%8D%E6%97%A2%E6%9C%89%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C"></a>1.7.5.1.4. 搭配既有计划文件运行</h2>
<p>默认情况下，<code>terraform console</code> 根据当前 Terraform 状态计算表达式，因此对于尚未通过 Apply 创建的资源实例，结果通常非常有限。</p>
<p>您可以使用 <code>-plan</code> 选项首先生成执行计划，就像运行 <code>terraform plan</code> 一样，然后根据<em>计划的</em>状态进行计算，以描述 Terraform 期望在应用计划后应得的值。这通常会在控制台提示出现之前引发更长的延迟，但作为回报，可知的表达式范围中将有一组更完整的可用值。</p>
<p>一个好的 Terraform 配置代码，在 Plan 阶段不应对实际远程对象进行任何修改，但我们可以编写一个在 Plan 时可以执行重要操作的配置。例如，使用 <code>hashcorp/external</code> Provider 程序的 <code>external</code> 数据源的配置可能会在 Plan 阶段运行设置的的外部命令，这意味着该外部命令也会被 <code>terraform console -plan</code> 运行。</p>
<p>我们不建议编写在 Plan 阶段进行更改的配置。如果您不顾该建议而编写了此类配置，则在 Plan 模式下针对该配置使用控制台时请务必小心。</p>
<h2 id="1-7-5-1-5-例子"><a href="#%E4%BE%8B%E5%AD%90"></a>1.7.5.1.5. 例子</h2>
<p><code>terraform console</code> 命令将从配置的 Backend 读取当前工作目录中的 Terraform 配置和 Terraform 状态文件，以便可以根据配置和状态文件中的值计算表达式。</p>
<p>假设我们有如下的 <code>main.tf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;apps&quot; &#123;</span><br><span class="line">  type = map(any)</span><br><span class="line">  default = &#123;</span><br><span class="line">    &quot;foo&quot; = &#123;</span><br><span class="line">      &quot;region&quot; = &quot;us-east-1&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;bar&quot; = &#123;</span><br><span class="line">      &quot;region&quot; = &quot;eu-west-1&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;baz&quot; = &#123;</span><br><span class="line">      &quot;region&quot; = &quot;ap-south-1&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;random_pet&quot; &quot;example&quot; &#123;</span><br><span class="line">  for_each = var.apps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>terraform console</code> 会进入交互式 shell，我们可以在其中计算表达式：</p>
<p>打印一个 map：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; var.apps.foo</span><br><span class="line">&#123;</span><br><span class="line">  &quot;region&quot; = &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据给定值过滤 map：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; for key, value in var.apps : key =&gt; value if value.region == &quot;us-east-1&quot; &#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;foo&quot; = &#123;</span><br><span class="line">    &quot;region&quot; = &quot;us-east-1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确认特定值是否为尚不知晓（Known after apply）值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; random_pet.example</span><br><span class="line">(known after apply)</span><br></pre></td></tr></table></figure>
<p>测试各种函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cidrnetmask(&quot;172.16.0.0/12&quot;)</span><br><span class="line">&quot;255.240.0.0&quot;</span><br></pre></td></tr></table></figure>
<h2 id="destroy"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">destroy</a></h2>
<ul>
<li>
<p><a href="#destroy"><strong>1.7.6.1.</strong> destroy</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.6.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#destroy"></a></p>
<h2 id="1-7-6-1-destroy"><a href="#destroy"></a>1.7.6.1. destroy</h2>
<p><code>terraform destroy</code> 命令可以用来销毁并回收所有由 Terraform 配置所管理的基础设施资源。</p>
<p>虽然我们一般不会删除长期存在于生产环境中的对象，但有时我们会用 Terraform 管理用于开发目的的临时基础设施，在这种情况下，您可以在完成后使用 <code>terraform destroy</code> 来方便地清理所有这些临时资源。</p>
<h2 id="1-7-6-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.6.1.1. 用法</h2>
<p><code>terraform destroy [options]</code></p>
<p>该命令是以下命令的快捷方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -destroy</span><br></pre></td></tr></table></figure>
<p>因此，此命令接受 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/4.apply"><code>terraform apply</code></a> 所支持的大部分选项，但是它不支持 <code>-destroy</code> 模式搭配指定计划文件的用法。</p>
<p>我们还可以通过运行以下命令创建推测性销毁计划，以查看销毁的效果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan -destroy</span><br></pre></td></tr></table></figure>
<p>该命令会以 <code>destroy</code> 模式运行 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan"><code>terraform plan</code></a> 命令，显示准备要销毁的变更，但不予执行。</p>
<p><strong>注意</strong>：<code>terraform apply</code> 的 <code>-destroy</code> 选项仅存在于 Terraform v0.15.2 及更高版本中。对于早期版本，必须使用 <code>terraform destroy</code> 才能获得 <code>terraform apply -destroy</code> 的效果。</p>
<ul>
<li>
<p><a href="#fmt"><strong>1.7.7.1.</strong> fmt</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.7.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#fmt"></a></p>
<h2 id="1-7-7-1-fmt"><a href="#fmt"></a>1.7.7.1. fmt</h2>
<p><code>terraform fmt</code> 命令被用来格式化 Terraform 代码文件的格式和规范。该命令会对代码文件应用我们之前介绍过的<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/10.%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.html">代码风格规范</a>中的一些规定，另外会针对可读性对代码做些微调整。</p>
<p>其他具有生成Terraform代码文件功能的命令会按照terraform fmt的标准来生成代码，所以请在项目中遵循fmt的代码风格以保持代码风格的统一。</p>
<p>其他那些会生成 Terraform 代码的 Terraform 命令，生成的代码都会符合 <code>terraform fmt</code> 所强制推行的格式，因此对我们自己编写的文件使用该命令可以保持所有代码风格的一致。</p>
<p>Terraform 不同版本的代码风格规范会有些微不同，所以在升级 Terraform 后我们建议要对代码执行一次 <code>terraform fmt</code>。</p>
<p>我们不会将修改 <code>terraform fmt</code> 执行的格式规则视作是 Terraform 新版本的破坏性变更（意为，不同版本的 <code>terraform fmt</code> 可能会对代码做不同的格式化），但我们的目标是最大限度地减少对那些已符合 Terraform 文档中显示的样式示例的代码的更改。添加新的格式规则时，他们通常会按照文档中代码示例中展示的新规则来制定，因此我们建议遵循文档中的样式，即使这些文档中的样式尚未被 <code>terraform fmt</code> 强制执行。</p>
<p>格式化决定始终是主观的，因此您可能不同意 <code>terraform fmt</code> 做出的决定。该命令是被设计成固执己见的，并且没有自定义选项，因为它的主要目标是鼓励不同 Terraform 代码库之间风格的一致性，即使所选的风格永远不可能是每个人都喜欢的。</p>
<p>我们建议代码作者在编写 Terraform 模块时遵循 <code>terraform fmt</code> 应用的样式约定，但如果您发现结果特别令人反感，那么您可以选择不使用此命令，并可能选择使用第三方格式化工具。如果您选择使用第三方工具，那么您还应该在 Terraform 自动生成的文件上运行它，以获得手写文件和生成文件之间的一致性。</p>
<h2 id="1-7-7-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.7.1.1. 用法</h2>
<p><code>terraform fmt [options] [target...]</code></p>
<p>默认情况下，<code>fmt</code> 会扫描当前文件夹以寻找代码文件。如果 <code>[target...]</code> 参数指向一个目录，那么 <code>fmt</code> 会扫描该目录。如果 <code>[target...]</code> 参数是一个文件，那么 <code>fmt</code> 只会处理那个文件。如果 <code>[target...]</code> 参数是一个减号(<code>-</code>)，那么 <code>fmt</code> 命令会从标准输入中读取(STDIN)。</p>
<p>该命令支持以下参数：</p>
<ul>
<li>
<p><code>-list=false</code>：不列出包含不一致风格的文件</p>
</li>
<li>
<p><code>-write=false</code>：不要重写输入文件(通过 <code>-check</code> 参数实现，或是使用标准输入流时)</p>
</li>
<li>
<p><code>-diff</code>：展示格式差异</p>
</li>
<li>
<p><code>-check</code>：检查输入是否合规。返回状态码 0 则代表所有输入的代码风格都是合规，反之则不是 0，并且会打印一份包含了文件内容不合规的文件名清单。</p>
</li>
<li>
<p><code>-recursive</code>：是否递归处理所有子文件夹。默认情况下为 <code>false</code>(只有当前文件夹会被处理，不涉及内嵌子模块)</p>
</li>
<li>
<p><a href="#force-unlock"><strong>1.7.8.1.</strong> force-unlock</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.8.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#force-unlock"></a></p>
<h2 id="1-7-8-1-force-unlock"><a href="#force-unlock"></a>1.7.8.1. force-unlock</h2>
<p>手动解除状态锁。</p>
<p>这个命令不会修改你的基础设施，它只会删除当前工作区对应的状态锁。具体操作步骤取决于使用的 Backend。本地状态文件无法被其他进程解锁。</p>
<h2 id="1-7-8-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.8.1.1. 用法</h2>
<p><code>terraform force-unlock [options] LOCK_ID</code></p>
<p>参数：</p>
<ul>
<li><code>-force=true</code>：解锁时不提示确认</li>
</ul>
<p>需要注意的是，就像我们在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86#lockid">状态管理篇</a>当中介绍过的那样，每一个状态锁都有一个锁 ID。Terraform 为了确保我们解除正确的状态锁，所以会要求我们显式输入锁 ID。</p>
<p>一般情况下我们不需要强制解锁，只有在 Terraform 异常终止，来不及解除锁时需要我们手动强制解除锁。错误地解除状态锁可能会导致状态混乱，所以请小心使用。</p>
<ul>
<li>
<p><a href="#get"><strong>1.7.9.1.</strong> get</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.9.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#get"></a></p>
<h2 id="1-7-9-1-get"><a href="#get"></a>1.7.9.1. get</h2>
<p><code>terraform get</code> 命令可以用来下载以及更新根模块中使用的<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/">模块</a>。</p>
<h2 id="1-7-9-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.9.1.1. 用法</h2>
<p><code>terraform get [options]</code></p>
<p>模块被下载并安装在当前工作目录下 <code>.terraform</code> 子目录中。这个子目录不应该被提交至版本控制系统。</p>
<p><code>get</code> 命令支持以下参数：</p>
<ul>
<li><code>-update</code>：如果指定，已经被下载的模块会被检查是否有新版本，如果存在新版本则会更新</li>
<li><code>-no-color</code>：禁用输出中的文字颜色</li>
</ul>
<h2 id="graph"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">graph</a></h2>
<ul>
<li>
<p><a href="#graph"><strong>1.7.10.1.</strong> graph</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.10.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6"><strong>1.7.10.1.2.</strong> 创建图片文件</a></p>
</li>
<li>
<p><a href="#%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85graphviz"><strong>1.7.10.1.3.</strong> 如何安装GraphViz</a></p>
</li>
</ul>
<p><a href="#graph"></a></p>
<h2 id="1-7-10-1-graph"><a href="#graph"></a>1.7.10.1. graph</h2>
<p><code>terraform graph</code> 命令可以用来生成代码描述的基础设施或是执行计划的可视化图形。它的输出是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DOT_(graph_description_language">DOT 格式</a>)，可以使用 <a target="_blank" rel="noopener" href="http://www.graphviz.org/">GraphViz</a> 来生成图片，也有许多网络服务可以读取这种格式。</p>
<h2 id="1-7-10-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.10.1.1. 用法</h2>
<p><code>terraform graph [options]</code></p>
<p>默认情况下，该命令输出一个简化图，仅描述配置中资源（<code>resource</code> 和 <code>data</code> 块）的依赖顺序。</p>
<p><code>-type=...</code> 参数可以在一组具有更多细节的其他图类型中进行选择，但作为代价，它也暴露了 Terraform 语言运行时的一些实现细节。</p>
<p>参数：</p>
<ul>
<li><code>-plan=tfplan</code>：针对指定计划文件生成图。使用该参数暗示着 <code>-type=apply</code>。</li>
<li><code>-draw-cycles</code>：用彩色的边高亮图中的环，这可以帮助我们分析代码中的环错误(Terraform 禁止环状依赖)。该参数只有在通过 <code>-type=...</code> 参数指定了操作类型时有效。</li>
<li><code>-type=...</code>：生成图表的类型，默认生成只包含 <code>resource</code> 的简化图。可以是：<code>plan</code>、<code>plan-destroy</code> 或是 <code>apply</code>。</li>
</ul>
<h2 id="1-7-10-1-2-创建图片文件"><a href="#%E5%88%9B%E5%BB%BA%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6"></a>1.7.10.1.2. 创建图片文件</h2>
<p><code>terraform graph</code> 命令输出的是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DOT_(graph_description_language">DOT 格式</a>)的数据，可以轻松地使用 <a target="_blank" rel="noopener" href="http://www.graphviz.org/">GraphViz</a> 转换为图形文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform graph -<span class="built_in">type</span>=plan | dot -Tpng &gt;graph.png</span><br></pre></td></tr></table></figure>
<p>输出的图片大概是这样的：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-25/1606272727693-image.png" alt="生成的依赖图"></p>
<p>图 1.7.10/1 - 生成的依赖图</p>
<h2 id="1-7-10-1-3-如何安装GraphViz"><a href="#%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85graphviz"></a>1.7.10.1.3. 如何安装GraphViz</h2>
<p>安装GraphViz也很简单，对于Ubuntu：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install graphviz</span><br></pre></td></tr></table></figure>
<p>对于CentOS：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> dnf install graphviz</span><br></pre></td></tr></table></figure>
<p>对于Windows，也可以使用choco：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; choco install graphviz</span><br></pre></td></tr></table></figure>
<p>对于Mac用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install graphviz</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#import"><strong>1.7.11.1.</strong> import</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.11.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#provider%E9%85%8D%E7%BD%AE"><strong>1.7.11.1.2.</strong> Provider配置</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90"><strong>1.7.11.1.3.</strong> 例子</a></p>
</li>
</ul>
<p><a href="#import"></a></p>
<h2 id="1-7-11-1-import"><a href="#import"></a>1.7.11.1. import</h2>
<p><code>terraform import</code> 命令用来将已经存在的资源对象导入 Terraform。</p>
<p>我们并不总是那么幸运，能够在项目一开始就使用 Terraform 来构建和管理我们的基础设施；有时我们有一组已经运行着的基础设施资源，然后我们为它们编写了相应的 Terraform 代码，我们进行了测试，确认了这组代码描述的基础设施与当前正在使用的基础设施是等价的；但是我们仍然无法直接使用这套代码来管理现有的基础设施，因为我们缺乏了相应的状态文件。这时我们需要使用 <code>terraform import</code> 将资源对象“导入”到 Terraform 状态文件中去。</p>
<h2 id="1-7-11-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.11.1.1. 用法</h2>
<p><code>terraform import [options] ADDRESS ID</code></p>
<p><code>terraform import</code> 会根据资源 ID 找到相应资源，并将其信息导入到状态文件中 <code>ADDRESS</code> 对应的资源上。<code>ADDRESS</code> 必须符合我们在资源地址中描述的合法<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80">资源地址</a>格式，这样 <code>terraform import</code> 不但可以把资源导入到根模块中，也可以导入到子模块中。</p>
<p>ID 取决于被导入的资源对象的类型。举例来说，AWS 主机的 ID 格式类似于 <code>i-abcd1234</code>，而 AWS Route53 Zone 的 ID 类似于 <code>Z12ABC4UGMOZ2N</code>，请参考相关 Provider 文档来获取有关 ID 的详细信息。如果不确信的话，可以随便尝试任意 ID。如果 ID 不合法，你会看到一个错误信息。</p>
<p><strong>警告</strong>，Terraform设想的是每一个资源对象都仅对应一个独一无二的实际基础设施对象，通常来说如果我们完全使用 Terraform 创建并管理基础设施时这一点不是问题；但如果你是通过导入的方式把基础设施对象导入到 Terraform 里，要绝对避免将同一个对象导入到两个以及更多不同的地址上，这会导致 Terraform 产生不可预测的行为。</p>
<p>该命令有以下参数可以使用：</p>
<ul>
<li><code>-config=path</code>：包含含有导入目标的Terraform代码的文件夹路径。默认为当前工作目录。如果当前目录不包含 Terraform 代码文件，则必须通过手动输入或环境变量来配置 Provider。</li>
<li><code>-input=true</code>：是否允许提示输入 Provider 配置信息</li>
<li><code>-lock=false</code>：如果 Backend 支持，是否锁定状态文件。在其他人可能会同时修改同一工作区的配置时关闭锁是危险的。</li>
<li><code>-lock-timeout=0s</code>：重试尝试获取状态锁的间隔</li>
<li><code>-no-color</code>：如果设定该参数，则不会输出彩色信息</li>
<li><code>-parallelism=n</code>：限制 Terraform 遍历图的最大并行度，默认值为 10(又是考点)</li>
<li><code>-var 'foo=bar'</code>：通过命令行设置输入变量值，类似 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan#var"><code>plan</code> 命令中的介绍</a></li>
<li><code>-var-file=foo</code>：类似 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/14.plan#var-file"><code>plan</code> 命令中的介绍</a></li>
</ul>
<p>当代码只使用了 <code>local</code> 类型的 Backend 时，<code>terraform import</code> 同时接受以下遗留参数：</p>
<ul>
<li><code>-state=FILENAME</code>：要读取的状态文件的地址</li>
<li><code>-state-out=FILENAME</code>：指定修改后的状态文件的保存路径，如果我们设置了 <code>-state</code> 而没同时设置 <code>-state-out</code>，则 Terraform <code>-state</code> 的值写给 <code>-state-out</code>，这意味着 Terraform 如果创建新的状态快照，将直接写入源状态文件。</li>
<li><code>-backup=FILENAME</code>：生成状态备份文件的地址，默认情况下是 <code>-state-out</code> 路径加上 <code>.backup</code> 后缀名。设置为 <code>-</code> 可以关闭备份(不推荐)</li>
</ul>
<h2 id="1-7-11-1-2-Provider配置"><a href="#provider%E9%85%8D%E7%BD%AE"></a>1.7.11.1.2. Provider配置</h2>
<p>Terraform 会尝试读取要导入的资源对应的 Provider 的配置信息。如果找不到相关 Provider 的配置，那么 Terraform 会提示你输入相关的访问凭据。你也可以通过环境变量来配置访问凭据。</p>
<p>Terraform 在读取 Provider 配置时唯一的限制是不能依赖于&quot;非输入变量&quot;的输入。举例来说，Provider 配置不能依赖于数据源的输出。</p>
<p>举一个例子，如果你想要导入 AWS 资源而你有这样的一份代码文件，那么 Terraform 会使用这两个输入变量来配置 AWS Provider：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;access_key&quot; &#123;&#125;</span><br><span class="line">variable &quot;secret_key&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key = var.access_key</span><br><span class="line">  secret_key = var.secret_key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7-11-1-3-例子"><a href="#%E4%BE%8B%E5%AD%90"></a>1.7.11.1.3. 例子</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform import aws_instance.foo i-abcd1234</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform import module.foo.aws_instance.bar i-abcd1234</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform import <span class="string">&#x27;aws_instance.baz[0]&#x27;</span> i-abcd1234</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform import <span class="string">&#x27;aws_instance.baz[&quot;example&quot;]&#x27;</span> i-abcd1234</span><br></pre></td></tr></table></figure>
<p>上面这条命令如果是在PowerShell下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> terraform import <span class="string">&#x27;aws_instance.baz[\&quot;example\&quot;]&#x27;</span> i<span class="literal">-abcd1234</span></span><br></pre></td></tr></table></figure>
<p>如果是cmd：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform import aws_instance.baz[\&quot;example\&quot;] i-abcd1234</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#init"><strong>1.7.12.1.</strong> init</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.12.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><strong>1.7.12.1.2.</strong> 常用参数</a></p>
</li>
<li>
<p><a href="#%E4%BB%8E%E6%A8%A1%E5%9D%97%E6%BA%90%E6%8B%B7%E8%B4%9D%E6%A8%A1%E5%9D%97"><strong>1.7.12.1.3.</strong> 从模块源拷贝模块</a></p>
</li>
<li>
<p><a href="#backend-%E5%88%9D%E5%A7%8B%E5%8C%96"><strong>1.7.12.1.4.</strong> Backend 初始化</a></p>
</li>
<li>
<p><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%90%E6%A8%A1%E5%9D%97"><strong>1.7.12.1.5.</strong> 初始化子模块</a></p>
</li>
<li>
<p><a href="#%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85"><strong>1.7.12.1.6.</strong> 插件安装</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8C-terraform-init-%E5%91%BD%E4%BB%A4"><strong>1.7.12.1.7.</strong> 在自动化环境下运行 terraform init 命令</a></p>
</li>
<li>
<p><a href="#%E8%AE%BE%E7%BD%AE%E5%85%B6%E4%BB%96%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E5%A4%B9"><strong>1.7.12.1.8.</strong> 设置其他代码文件夹</a></p>
</li>
</ul>
<p><a href="#init"></a></p>
<h2 id="1-7-12-1-init"><a href="#init"></a>1.7.12.1. init</h2>
<p><code>terraform init</code> 命令被用来初始化一个包含 Terraform 代码的工作目录。在编写了一些 Terraform 代码或是克隆了一个 Terraform 项目后应首先执行该命令。反复执行该命令是安全的(考点)。</p>
<h2 id="1-7-12-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.12.1.1. 用法</h2>
<p><code>terraform init [options]</code></p>
<p>该命令为初始化工作目录执行了多个不同的步骤。详细说明可以见下文，总体来说用户不需要担心这些步骤。即使某些步骤可能会遭遇错误，但是该命令绝对不会删除你的基础设施资源或是状态文件。</p>
<h2 id="1-7-12-1-2-常用参数"><a href="#%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"></a>1.7.12.1.2. 常用参数</h2>
<ul>
<li><code>-input=true</code>：是否在取不到输入变量值时提示用户输入</li>
<li><code>-lock=false</code>：是否在运行时锁定状态文件</li>
<li><code>-lock-timeout=&lt;duration&gt;</code>：尝试获取状态文件锁时的超时时间，默认为 <code>0s</code>（0 秒），意为一旦发现锁已被其他进程获取立即报错</li>
<li><code>-no-color</code>：禁止输出中包含颜色</li>
<li><code>-upgrade</code>：是否升级模块代码以及插件</li>
</ul>
<h2 id="1-7-12-1-3-从模块源拷贝模块"><a href="#%E4%BB%8E%E6%A8%A1%E5%9D%97%E6%BA%90%E6%8B%B7%E8%B4%9D%E6%A8%A1%E5%9D%97"></a>1.7.12.1.3. 从模块源拷贝模块</h2>
<p>默认情况下，<code>terraform init</code> 会假设工作目录下已经包含了 Terraform 代码文件。</p>
<p>我们也可以在空文件夹内搭配 <code>-from-module=MODULE-SOURCE</code> 参数运行该命令，这样在运行任何其他初始化步骤之前，指定的模块将被复制到目标目录中。</p>
<p>这种特殊的使用方式有两种场景：</p>
<ul>
<li>我们可以用这种方法从模块源对应的版本控制系统当中签出指定版本代码并为它初始化工作目录</li>
<li>如果模块源指向的是一个样例项目，那么这种方式可以把样例代码拷贝到本地目录以便我们后续基于样例编写新的代码</li>
</ul>
<p>如果是常规使用时，建议使用版本控制系统自己的命令单独检查版本控制的配置。这样，可以在必要时将额外的标志传递给版本控制系统，并在运行 <code>terraform init</code> 之前执行其他准备步骤（例如代码生成或激活凭据）。</p>
<h2 id="1-7-12-1-4-Backend-初始化"><a href="#backend-%E5%88%9D%E5%A7%8B%E5%8C%96"></a>1.7.12.1.4. Backend 初始化</h2>
<p>在执行 <code>init</code> 时，会分析根模块代码以寻找 Backend 配置，然后使用给定的配置设定初始化 Backend 存储。</p>
<p>在已经初始化 Backend 后重复执行 <code>init</code> 命令会更新工作目录以使用新的 Backend 设置。这时我们必须设置 <code>-reconfigure</code> 或是 <code>-migrate-state</code> 来升级 Backend 配置。</p>
<p><code>-migrate-state</code> 选项会尝试将现有状态复制到新 Backend，并且根据更改的内容，可能会导致交互式提示以确认工作区状态的迁移。 设置 <code>-force-copy</code> 选项可以阻止这些提示并对迁移问题回答 <code>yes</code>。启用 <code>-force-copy</code> 还会自动启用 <code>-migrate-state</code> 选项。</p>
<p><code>-reconfigure</code> 选项会忽略任何现有配置，从而防止迁移任何现有状态。</p>
<p>要跳过后端配置，请使用 -backend=false。请注意，其他一些初始化步骤需要初始化后端，因此建议仅当先前已为特定后端初始化工作目录时才使用此标志。</p>
<p>要跳过 Backend 配置，可以设置 <code>-backend=false</code>。注意某些其他 <code>init</code> 步骤需要已经被初始化的 Backend，所以推荐只在已经初始化过 Backend 后使用该参数。</p>
<p><code>-backend-config=...</code> 参数可以用来动态指定 Backend 配置，我们在状态管理章节中介绍<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86#backend-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC">“部分配置”</a>时已经提过，在此不再赘述。</p>
<h2 id="1-7-12-1-5-初始化子模块"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%90%E6%A8%A1%E5%9D%97"></a>1.7.12.1.5. 初始化子模块</h2>
<p><code>init</code> 会搜索代码中的 <code>module</code> 块，然后通过 <code>source</code> 参数取回引用的模块代码。</p>
<p>模块安装之后重新运行 <code>init</code> 命令会继续安装那些自从上次 <code>init</code> 之后新增的模块，但不会修改已被安装的模块。设置 <code>-upgrade</code> 可以改变这种行为，将所有模块升级到最新版本的代码。</p>
<p>要跳过子模块安装步骤，可以设置 <code>-get=false</code> 参数。要注意其他一些init步骤需要模块树完整，所以建议只在成功安装过模块以后使用该参数。</p>
<h2 id="1-7-12-1-6-插件安装"><a href="#%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85"></a>1.7.12.1.6. 插件安装</h2>
<p>我们在 Provider 章节中介绍了插件安装，所以在此不再赘述，我们值介绍一下参数：</p>
<ul>
<li><code>-upgrade</code>：将之前所有已安装的插件升级到符合 <code>version</code> 约束的最新版本。</li>
<li><code>-plugin-dir=PATH</code>：跳过插件安装，<em>只</em>从<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6#%E6%98%BE%E5%BC%8F%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AE">命令行配置文件的 <code>filesystem_mirror</code></a> 指定的目录加载插件。该参数会跳过用户插件目录以及所有当前工作目录下的插件。我们推荐使用命令行参数文件来全局设置 Terraform 安装方法，<code>-plugin-dir</code> 可以作为一次性的临时方法，例如测试当前本地正在开发的 Provider 插件。</li>
<li><code>-lockfile=MODE</code> 设置依赖锁文件的模式 该参数的可选值有：</li>
<li><code>readonly</code>：禁用锁定文件更改，但根据已记录的信息验证校验和。该参数与 <code>-upgrade</code> 参数冲突。如果我们使用第三方依赖项管理工具更新锁定文件，那么控制它何时显式更改将很有用。</li>
</ul>
<h2 id="1-7-12-1-7-在自动化环境下运行-terraform-init-命令"><a href="#%E5%9C%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8C-terraform-init-%E5%91%BD%E4%BB%A4"></a>1.7.12.1.7. 在自动化环境下运行 terraform init 命令</h2>
<p>如果在团队的变更管理和部署流水线中 Terraform 扮演了关键角色，那么我们可能需要以某种自动化方式编排 Terraform 运行，以确保运行之间的一致性，并提供其他有趣的功能，例如与版本控制系统的钩子进行集成。</p>
<p>在此类环境中运行 <code>init</code> 时需要注意一些特殊问题，包括可选择在本地提供插件以避免重复重新安装。有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/8.%E6%8A%80%E5%B7%A7/10.terraform%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96">Terraform 与自动化</a>。</p>
<h2 id="1-7-12-1-8-设置其他代码文件夹"><a href="#%E8%AE%BE%E7%BD%AE%E5%85%B6%E4%BB%96%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E5%A4%B9"></a>1.7.12.1.8. 设置其他代码文件夹</h2>
<p>Terraform v0.13 及更早版本还可以设置目录路径来代替 <code>terraform apply</code> 的计划文件参数，在这种情况下，Terraform 将使用该目录作为根模块而不是当前工作目录。</p>
<p>Terraform v0.14 中仍支持该用法，但现已在 Terraform v0.15 中弃用并删除。如果我们的工作流程依赖于覆盖根模块目录，请改用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/index#%E9%80%9A%E8%BF%87--chdir-%E5%8F%82%E6%95%B0%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><code>-chdir</code> 全局选项</a>，该选项适用于所有命令，并使 Terraform 始终在给定目录中查找它通常在当前工作目录中读取或写入的所有文件。</p>
<p>如果您之前的工作流同时要求 Terraform 即使根模块目录已被修改也要将 <code>.terraform</code> 子目录写入当前工作目录，请使用 <code>TF_DATA_DIR</code> 环境变量命令 Terraform 将 <code>.terraform</code> 目录写入当前工作目录之外的其他位置。</p>
<ul>
<li>
<p><a href="#output"><strong>1.7.13.1.</strong> output</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.13.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E6%A0%B7%E4%BE%8B"><strong>1.7.13.1.2.</strong> 样例</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8C-terraform-output-%E5%91%BD%E4%BB%A4"><strong>1.7.13.1.3.</strong> 在自动化环境下运行 terraform output 命令</a></p>
</li>
</ul>
<p><a href="#output"></a></p>
<h2 id="1-7-13-1-output"><a href="#output"></a>1.7.13.1. output</h2>
<p><code>terraform output</code> 命令被用来提取状态文件中输出值的值。</p>
<h2 id="1-7-13-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.13.1.1. 用法</h2>
<p><code>terraform output [options] [NAME]</code></p>
<p>如果不添加参数，<code>output</code> 命令会展示根模块内定义的所有输出值。如果指定了 <code>NAME</code>，只会输出相关输出值。</p>
<p>可以使用以下参数：</p>
<ul>
<li><code>-json</code>：设置该参数后 Terraform 会使用 JSON 格式输出。如果指定了 <code>NAME</code>，只会输出相关输出值。该参数搭配 <code>jq</code> 使用可以构建复杂的流水线</li>
<li><code>-raw</code>：设置该参数后 Terraform 会将指定的输出值转换为字符串，并将该字符串直接打印到输出中，不带任何特殊格式。这在使用 shell 脚本时很方便，但它仅支持字符串、数字和布尔值。处理复杂的数据类型时还请使用 <code>-json</code>。</li>
<li><code>-no-color</code>：不输出颜色</li>
<li><code>-state=path</code>：状态文件的路径，默认为 <code>terraform.tfstate</code>。启用远程 Backend 时该参数无效</li>
</ul>
<p><strong>注意</strong>：设置 <code>-json</code> 或 <code>-raw</code> 参数时，Terraform 状态中的任何敏感值都将以纯文本显示。有关详细信息，请参阅状态中的<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive">敏感数据</a>。</p>
<h2 id="1-7-13-1-2-样例"><a href="#%E6%A0%B7%E4%BE%8B"></a>1.7.13.1.2. 样例</h2>
<p>假设有如下输出值代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">output &quot;instance_ips&quot; &#123;</span><br><span class="line">  value = aws_instance.web.*.public_ip</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;lb_address&quot; &#123;</span><br><span class="line">  value = aws_alb.web.public_dns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;password&quot; &#123;</span><br><span class="line">  sensitive = true</span><br><span class="line">  value = var.secret_password</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>列出所有输出值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ terraform output</span><br><span class="line">instance_ips = [</span><br><span class="line">  <span class="string">&quot;54.43.114.12&quot;</span>,</span><br><span class="line">  <span class="string">&quot;52.122.13.4&quot;</span>,</span><br><span class="line">  <span class="string">&quot;52.4.116.53&quot;</span></span><br><span class="line">]</span><br><span class="line">lb_address = <span class="string">&quot;my-app-alb-1657023003.us-east-1.elb.amazonaws.com&quot;</span></span><br><span class="line">password = &lt;sensitive&gt;</span><br></pre></td></tr></table></figure>
<p>注意password输出值定义了sensitive = true，所以它的值在输出时会被隐藏：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform output password</span><br><span class="line">password = &lt;sensitive&gt;</span><br></pre></td></tr></table></figure>
<p>要查询负载均衡的DNS地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform output lb_address</span><br><span class="line">my-app-alb-1657023003.us-east-1.elb.amazonaws.com</span><br></pre></td></tr></table></figure>
<p>查询所有主机的IP：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform output instance_ips</span><br><span class="line"><span class="built_in">test</span> = [</span><br><span class="line">    54.43.114.12,</span><br><span class="line">    52.122.13.4,</span><br><span class="line">    52.4.116.53</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>使用-json和jq查询指定主机的ip：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform output -json instance_ips | jq <span class="string">&#x27;.value[0]&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-13-1-3-在自动化环境下运行-terraform-output-命令"><a href="#%E5%9C%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8C-terraform-output-%E5%91%BD%E4%BB%A4"></a>1.7.13.1.3. 在自动化环境下运行 terraform output 命令</h2>
<p><code>terraform output</code> 命令默认以便于人类阅读的格式显示，该格式可以随着时间的推移而改变以提高易读性。</p>
<p>对于脚本编写和自动化，请使用 <code>-json</code> 生成稳定的 JSON 格式。您可以使用 JSON 命令行解析器（例如 <a target="_blank" rel="noopener" href="https://stedolan.github.io/jq/"><code>jq</code></a>）解析输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">terraform output -json instance_ips | jq -r <span class="string">&#x27;.[0]&#x27;</span></span></span><br><span class="line">54.43.114.12</span><br></pre></td></tr></table></figure>
<p>如果要在 shell 脚本中直接使用字符串值，可以转而使用 <code>-raw</code> 参数，它将直接打印字符串，没有额外的转义或空格。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">terraform output -raw lb_address</span></span><br><span class="line">my-app-alb-1657023003.us-east-1.elb.amazonaws.com</span><br></pre></td></tr></table></figure>
<p><code>-raw</code> 选项仅适用于 Terraform 可以自动转换为字符串的值。处理复杂类型的值（例如对象）时还请改用 <code>-json</code>（可以与 <code>jq</code> 结合使用）。</p>
<p>Terraform 字符串是 Unicode 字符序列而不是原始字节，因此 <code>-raw</code> 输出在包含非 ASCII 字符时将采用 UTF-8 编码。如果您需要不同的字符编码，请使用单独的命令（例如 <code>iconv</code>）对 Terraform 的输出进行转码。</p>
<ul>
<li>
<p><a href="#plan"><strong>1.7.14.1.</strong> plan</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.14.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#plan-%E6%A8%A1%E5%BC%8F"><strong>1.7.14.1.2.</strong> Plan 模式</a></p>
</li>
<li>
<p><a href="#plan-%E9%80%89%E9%A1%B9"><strong>1.7.14.1.3.</strong> Plan 选项</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F"><strong>1.7.14.1.4.</strong> 在命令行中输入变量</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D"><strong>1.7.14.1.5.</strong> 资源定位</a></p>
</li>
<li>
<p><a href="#%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9"><strong>1.7.14.1.6.</strong> 其他选项</a></p>
</li>
<li>
<p><a href="#%E6%8C%87%E5%AE%9A%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><strong>1.7.14.1.7.</strong> 指定其他配置文件目录</a></p>
</li>
<li>
<p><a href="#%E5%AE%89%E5%85%A8%E8%AD%A6%E5%91%8A"><strong>1.7.14.1.8.</strong> 安全警告</a></p>
</li>
</ul>
<p><a href="#plan"></a></p>
<h2 id="1-7-14-1-plan"><a href="#plan"></a>1.7.14.1. plan</h2>
<p><code>terraform plan</code> 命令被用来创建变更计划。Terraform 会先运行一次 <code>refresh</code>(我们后面的章节会介绍，该行为也可以被显式关闭)，然后决定要执行哪些变更使得现有状态迁移到代码描述的期待状态。</p>
<p>该命令可以方便地审查状态迁移的所有细节而不会实际更改现有资源以及状态文件。例如，在将代码提交到版本控制系统前可以先执行 <code>terraform plan</code>，确认变更行为如同预期一般。</p>
<p>如果您直接在交互式终端中使用 Terraform 并且希望执行 Terraform 所提示的变更，您也可以直接运行 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/4.apply"><code>terraform apply</code></a>。默认情况下，<code>apply</code> 命令会自动生成新计划并提示您批准它。</p>
<p>可选参数 <code>-out</code> 可以将变更计划保存在一个文件中，以便日后使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/4.apply"><code>terraform apply</code></a> 命令来执行该计划。</p>
<p>在使用版本控制和代码审查工作流程对实际基础架构进行更改的团队中，开发人员可以使用保存下来的的计划文件来验证更改的效果，然后再对提交的变更进行代码审查。但是，要慎重考虑考虑对目标系统同时进行的其他更改可能会导致配置更改的最终效果与早期保存的计划所指示的不同，因此您应该始终重新检查最终的实际执行的计划，在执行之前确保它仍然符合您的意图。</p>
<p>如果 Terraform 检测不到任何变更，那么 <code>terraform plan</code> 会提示没有任何需要执行的变更。</p>
<h2 id="1-7-14-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.14.1.1. 用法</h2>
<p><code>terraform plan [options]</code></p>
<p><code>plan</code> 命令在当前工作目录中查找根模块配置。</p>
<p>由于 <code>plan</code> 命令是 Terraform 的主要命令之一，因此它有多种不同的选项，如下部分所述。但是，大多数时候我们不需要设置这些选项，因为 Terraform 配置通常应设计为无需特殊的附加选项即可进行日常工作。</p>
<p><code>plan</code> 命令的参数选项可以分为以下三大类</p>
<ul>
<li><a href="#plan-%E6%A8%A1%E5%BC%8F">Plan 模式</a>：当我们的目标不仅仅是更改远程系统以匹配代码配置时，我们可以在某些特殊情况下使用一些特殊的替代规划模式。</li>
<li><a href="#plan-%E9%80%89%E9%A1%B9">Plan 选项</a>：除了特殊的 Plan 模式之外，我们还可以设置一些选项，以便根据特殊的需求来定制计划流程。</li>
<li><a href="#%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9">其他选项</a>：这些选项改变了规划命令本身的行为，而不是定制生成的计划的内容。</li>
</ul>
<h2 id="1-7-14-1-2-Plan-模式"><a href="#plan-%E6%A8%A1%E5%BC%8F"></a>1.7.14.1.2. Plan 模式</h2>
<p>上一节描述了 Terraform 的默认规划变更计划行为，该行为会变更远程系统以匹配我们对配置代码所做的更改。 Terraform 还有两种不同的规划模式，每种模式都会创建具有不同预期结果的计划。这些选项可用于 <code>terraform plan</code> 和 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/4.apply"><code>terraform apply</code></a>。</p>
<ul>
<li>
<p><strong>Destroy 模式</strong>：创建一个计划，其目的是销毁当前存在的所有远程对象，留下空的 Terraform 状态。这与运行 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/6.destroy"><code>terraform destroy</code></a> 相同。销毁模式对于临时的开发环境等情况非常有用，在这种情况下，一旦开发任务完成，托管对象就不再需要保留。</p>
<p>通过 <code>-destroy</code> 命令行选项启用销毁模式。</p>
</li>
<li>
<p><strong>Refresh-Only 模式</strong>：创建一个计划，其目标仅是更新 Terraform 状态和所有根模块的输出值，以匹配对 Terraform 外部远程对象所做的更改。如果您使用 Terraform 之外的工具更改了一个或多个远程对象（例如，在响应事件时），并且您现在需要使 Terraform 的记录与这些更改保持一致，那么该命令会很有帮助。</p>
<p>使用 <code>-refresh-only</code> 命令行选项启用 Refresh-Only 模式。</p>
</li>
</ul>
<p>相对而言，我们把 Terraform 在未选择任何替代模式时使用的默认规划模式的情况下的行为称为“正常模式”。由于上述的替代模式仅适用于特殊情况，因此其他一些 Terraform 文档仅讨论正常规划模式。</p>
<p>Plan 模式都是互斥的，因此启用任何非默认 Plan 模式时都会禁用“正常”计划模式，并且我们不能同时使用多种替代模式。</p>
<p><strong>注意</strong>：在 Terraform v0.15 及更早版本中，只有 <code>terraform plan</code> 命令支持 <code>-destroy</code> 选项，<code>terraform apply</code> 命令是不支持的。要在早期版本中以 Destroy 模式创建并应用计划，我们必须运行 <code>terraform destroy</code>。另外，<code>-refresh-only</code> 选项仅在 Terraform v0.15.4 及之后的版本中可用。</p>
<h2 id="1-7-14-1-3-Plan-选项"><a href="#plan-%E9%80%89%E9%A1%B9"></a>1.7.14.1.3. Plan 选项</h2>
<p>相较于 <a href="#plan-%E6%A8%A1%E5%BC%8F">Plan 模式</a>，还有一些可以用来更改规划行为的参数选项。</p>
<ul>
<li><code>-refresh=false</code>：在检查配置更改之前跳过同步 Terraform 状态与远程对象的默认行为。这可以减少远程 API 请求的数量，加快规划操作的速度。但是，设置 <code>refresh=false</code> 会导致 Terraform 忽略外部更改，这可能会导致计划不完整或不正确。您不能在 Refresh Only 计划模式中使用 <code>refresh=false</code>，因为这将导致什么都不做。</li>
<li><code>-replace=ADDRESS</code> - 命令 Terraform 在计划中替换给定地址的资源实例。当一个或多个远程对象降级时，这非常有用，并且我们可以替换成具有相同配置的对象来与不可变的基础架构模式保持一致。如果指定的资源在计划中存在“更新”操作或没有变化，则 Terraform 将使用“替换”操作。多次包含此选项可一次替换多个对象。您不能将 <code>-replace</code> 与 <code>-destroy</code> 选项一起使用，并且该功能仅从 Terraform v0.15.2 开始可用。对于早期版本，使用 <code>terraform taint</code> 来实现类似的结果。</li>
<li><code>-target=ADDRESS</code> - 命令 Terraform 只计算给定地址匹配的资源实例以及这些实例所依赖的任何对象的变更。 <strong>注意</strong>：应该仅在特殊情况下使用 <code>-target=ADDRESS</code>，例如从错误中恢复或绕过 Terraform 限制。有关更多详细信息，请参阅<a href="#%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D">资源定位</a>。</li>
<li><code>-var 'NAME=VALUE'</code> - 设置在配置的根模块中声明的单个<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.md">输入变量</a>的值。多次设置该选项可设置多个变量。有关详细信息，请参阅<a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F">在命令行中输入变量</a>。</li>
<li><code>-var-file=FILENAME</code> - 使用 <code>tfvars</code> 文件中的定义为配置的根模块中声明的潜在多个输入变量设置值。多次设置该选项可包含多个文件中的值。</li>
</ul>
<p>除了 <code>-var</code> 和 <code>-var-file</code> 选项之外，还有其他几种方法可以在根模块中设置输入变量的值。有关详细信息，请参阅为<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F#%E5%AF%B9%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC">根模块输入变量赋值</a>。</p>
<h2 id="1-7-14-1-4-在命令行中输入变量"><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F"></a>1.7.14.1.4. 在命令行中输入变量</h2>
<p>我们可以使用 <code>-var</code> 命令行选项来指定根模块中声明的输入变量的值。</p>
<p>然而，要做到这一点，需要编写一个可由您选择的 shell 和 Terraform 解析的命令，对于涉及大量引号和转义序列的表达式来说这可能会很复杂。在大多数情况下，我们建议改用 <code>-var-file</code> 选项，并将实际值写入单独的文件中，以便 Terraform 可以直接解析它们，而不是解释 shell 解析后的结果。</p>
<p><strong>警告</strong>：如果在等号之前或之后包含空格（例如 -var “length = 2”），Terraform 将报错。</p>
<p>要在 Linux 或 macOS 等系统上的 Unix 风格 shell 上使用 <code>-var</code>，我们建议将选项参数写在单引号 <code>'</code> 中，以确保 shell 按字面解释该值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan -var &#x27;name=value&#x27;</span><br></pre></td></tr></table></figure>
<p>如果我们的预期值还包含单引号，那么我们仍然需要对其进行转义，以便 shell 进行正确解释，这还需要暂时终止引号序列，以便反斜杠转义字符合法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan -var &#x27;name=va&#x27;\&#x27;&#x27;lue&#x27;</span><br></pre></td></tr></table></figure>
<p>在 Windows 上使用 Terraform 时，我们建议使用 Windows 命令提示符 (cmd.exe)。当您从 Windows 命令提示符将变量值传递给 Terraform 时，请在参数周围使用双引号 <code>&quot;</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan -var &quot;name=value&quot;</span><br></pre></td></tr></table></figure>
<p>如果我们的预期值还包含双引号，那么您需要用反斜杠转义它们：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan -var &quot;name=va\&quot;lue&quot;</span><br></pre></td></tr></table></figure>
<p>Windows 上的 PowerShell 无法正确地将文字引号传递给外部程序，因此我们不建议您在 Windows 上时将 Terraform 与 PowerShell 结合使用。请改用 Windows 命令提示符。</p>
<p>根据变量的<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/1.%E7%B1%BB%E5%9E%8B">类型约束</a>，声明变量值的语法有所不同。原始类型 <code>string</code>、<code>number</code> 和 <code>bool</code> 对应一个直接的字符串值，除非您的 shell 如上面的示例所示需要，否则不需要添加特殊的标点符号。对于所有其他类型约束，包括 <code>list</code>、<code>map</code> 和 <code>set</code> 类型以及特殊的 <code>any</code> 关键字，您必须编写一个表示该值的有效 Terraform 语言表达式，并附带必要的引用或转义字符以确保它将通过您的 shell 逐字传递到 Terraform。例如，对于 <code>list(string)</code> 类型约束：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unix-style shell</span></span><br><span class="line">terraform plan -var &#x27;name=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Windows Command Prompt (<span class="keyword">do</span> not use PowerShell on Windows)</span></span><br><span class="line">terraform plan -var &quot;name=[\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;]&quot;</span><br></pre></td></tr></table></figure>
<p>使用环境变量设置输入变量时也适用类似的约束。有关设置根模块输入变量的各种方法的更多信息，请参阅为<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F#%E5%AF%B9%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC">根模块变量赋值</a>。</p>
<h2 id="1-7-14-1-5-资源定位"><a href="#%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D"></a>1.7.14.1.5. 资源定位</h2>
<p>我们可以使用 <code>-target</code> 选项将 Terraform 的计算范围仅集中在少数资源上。我们可以使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/3.%E8%B5%84%E6%BA%90%E5%9C%B0%E5%9D%80">资源地址</a>语法来指定约束。Terraform 对代码中的资源地址的解释行为如下：</p>
<ul>
<li>如果给定地址定位了一个特定资源实例，Terraform 将单独选择该实例。对于设置了 <code>count</code> 或 <code>for_each</code> 的资源，资源实例地址必须包含实例索引部分，例如 <code>azurerm_resource_group.example[0]</code>。</li>
<li>如果给定的地址对应到一个资源整体（即表达式中不含索引部分），Terraform 将选择该资源的所有实例。对于设置了 <code>count</code> 或 <code>for_each</code> 的资源，这意味着选择当前与该资源关联的所有实例索引。对于单实例资源（没有 <code>count</code> 或 <code>for_each</code>），资源地址和资源实例地址相同，因此这种可能性不适用。</li>
<li>如果给定的地址标识整个 Module 实例，Terraform 将选择属于该 Module 实例及其所有子 Module 实例的所有资源的所有实例。</li>
</ul>
<p>一旦 Terraform 选择了我们直接定位的一个或多个资源实例，它还会扩展选择范围以包括这些选择直接或间接依赖的所有其他对象。</p>
<p>这种资源定位功能是为某些特殊情况设计的，例如从故障中恢复或绕过 Terraform 的某些限制。不建议将 <code>-target</code> 用于常规操作，因为这可能会导致未检测到的配置漂移以及对资源真实状态与配置的关系的混淆。</p>
<p>与其使用 <code>-target</code> 作为对非常庞大的配置的一小部分子集进行操作的方法，不如将大型配置分解为多个较小的配置，每个配置都可以独立应用。<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/7.%E6%95%B0%E6%8D%AE%E6%BA%90">数据源</a>可用于访问有关在其他配置中创建的资源的信息，从而允许将复杂的系统架构分解为更易于管理且可以独立更新的部分。</p>
<h2 id="1-7-14-1-6-其他选项"><a href="#%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9"></a>1.7.14.1.6. 其他选项</h2>
<p><code>terraform plan</code> 命令还有一些与规划命令的输入和输出相关的其他选项，这些配置不会影响 Terraform 将创建哪种类型的计划。这些命令不一定在 <code>terraform apply</code> 上也可用，除非该命令的文档中另有说明。</p>
<ul>
<li>
<p><code>-compact-warnings</code>：如果 Terraform 生成了一些告警信息而没有伴随的错误信息，那么以只显示消息总结的精简形式展示告警</p>
</li>
<li>
<p><code>-detailed-exitcode</code>：当命令退出时返回一个详细的返回码。如果有该参数，那么返回码将会包含更详细的含义：</p>
</li>
<li>
<p>0 = 成功的空计划(没有变更)</p>
</li>
<li>
<p>1 = 错误</p>
</li>
<li>
<p>2 = 成功的非空计划(有变更)</p>
</li>
<li>
<p><code>-generate-config-out=PATH</code> -（实验功能）如果配置中存在 <code>import</code> 块，则命令 Terraform 为尚未存在的任何导入资源生成 HCL。配置将写入 <code>PATH</code> 位置的新文件，该文件<strong>不可以</strong>存在，否则 Terraform 将报错。如果 <code>plan</code> 命令因为其他原因失败，Terraform 仍可能尝试写入配置。</p>
</li>
<li>
<p><code>-input=false</code>：在取不到值的情况下是否提示用户给定输入变量值。此参数在非交互式自动化系统中运行 Terraform 时特别有用。</p>
</li>
<li>
<p><code>-lock=false</code>：操作过程中不对状态文件上锁。如果其他人可能同一时间对同一工作区运行命令可能引发事故。</p>
</li>
<li>
<p><code>-lock-timeout=DURATION</code>：除非使用 <code>-lock=false</code> 禁用锁定，否则指示 Terraform 在返回错误之前重试获取锁定一段时间。持续时间语法是一个数字后跟一个时间单位字母，例如 <code>&quot;3s&quot;</code> 表示三秒。</p>
</li>
<li>
<p><code>-no-color</code>：关闭彩色输出。在无法解释输出色彩的终端中运行 Terraform 时请使用此参数。</p>
</li>
<li>
<p><code>-out=FILENAME</code>：将变更计划保存到指定路径下的文件中，随后我们可以使用terraform apply执行该计划</p>
<p>Terraform 将允许计划文件使用任何文件名，但典型的约定是将其命名为 <code>tfplan</code>。请<strong>不要</strong>使用 Terraform 支持的后缀名来命名文件；如果您使用 <code>.tf</code> 后缀，那么 Terraform 将尝试将该文件解释为配置源文件，这将导致后续命令出现语法错误。</p>
</li>
<li>
<p><code>-parallelism-n</code>：限制Terraform遍历图的最大并行度，默认值为 <code>10</code>。</p>
</li>
</ul>
<h2 id="1-7-14-1-7-指定其他配置文件目录"><a href="#%E6%8C%87%E5%AE%9A%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"></a>1.7.14.1.7. 指定其他配置文件目录</h2>
<p>Terraform v0.13 及更早版本接受提供目录路径的附加位置参数，在这种情况下，Terraform 将使用该目录作为根模块而不是当前工作目录。</p>
<p>该用法在 Terraform v0.14 中已弃用，并在 Terraform v0.15 中删除。如果您的工作流程需要修改根模块目录，请改用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/index#%E9%80%9A%E8%BF%87--chdir-%E5%8F%82%E6%95%B0%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><code>-chdir</code> 全局选项</a>，该选项适用于所有命令，并使 Terraform 始终在给定目录中查找它通常在当前工作目录中读取或写入的所有文件。</p>
<p>如果我们之前使用此遗留模式时同时需要 Terraform 将 <code>.terraform</code> 子目录写入当前工作目录，即使根模块目录已被覆盖，请使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/2.%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F#tf_data_dir"><code>TF_DATA_DIR</code> 环境变量</a>命令 Terraform 将 <code>.terraform</code> 目录写入其他位置，而不是当前工作目录。</p>
<h2 id="1-7-14-1-8-安全警告"><a href="#%E5%AE%89%E5%85%A8%E8%AD%A6%E5%91%8A"></a>1.7.14.1.8. 安全警告</h2>
<p>被保存的变更计划文件(使用 <code>-out</code> 参数)内部可能含有敏感信息，Terraform 本身并不会加密计划文件。如果你要移动或是保存该文件一段时间，强烈建议你自行加密该文件。</p>
<p>Terraform 未来打算增强计划文件的安全性。</p>
<ul>
<li>
<p><a href="#providers"><strong>1.7.15.1.</strong> providers</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.15.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#providers"></a></p>
<h2 id="1-7-15-1-providers"><a href="#providers"></a>1.7.15.1. providers</h2>
<p><code>terraform providers</code> 命令显示有关当前工作目录中代码的 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider#provider-%E7%9A%84%E5%A3%B0%E6%98%8E">Provider 声明</a>的信息，以帮助我们了解每个被需要的 Provider 是从何而来。</p>
<p>该命令是含有内嵌子命令，这些子命令我们会逐个解释。</p>
<h2 id="1-7-15-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.15.1.1. 用法</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform providers</span><br></pre></td></tr></table></figure>
<h2 id="mirror"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">mirror</a></h2>
<ul>
<li>
<p><a href="#terraform-providers-mirror"><strong>1.7.15.1.1.</strong> terraform providers mirror</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.15.1.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#terraform-providers-mirror"></a></p>
<h2 id="1-7-15-1-1-terraform-providers-mirror"><a href="#terraform-providers-mirror"></a>1.7.15.1.1. terraform providers mirror</h2>
<p>该子命令从 Terraform 0.13 开始引入。</p>
<p><code>terraform providers mirror</code> 命令下载当前代码所需要的 Provider 并且将其拷贝到本地文件系统的一个目录下。</p>
<p>一般情况下，<code>terraform init</code> 会在初始化当前工作目录时自动从 registry 下载所需的 Provider。有时 Terraform 工作在无法执行该操作的环境下，例如一个无法访问 registry 的局域网内。这时可以通过<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6#%E6%98%BE%E5%BC%8F%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AE">显式配置 Provider 安装方式</a>来使得在这样的环境下 Terraform 可以从本地插件镜像存储中获取插件。</p>
<p><code>terraform providers mirror</code> 命令可以自动填充准备用以作为本地插件镜像存储的目录。</p>
<h2 id="1-7-15-1-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.15.1.1.1. 用法</h2>
<p><code>terraform providers mirror [options] &lt;target-dir&gt;</code></p>
<p><code>target-dir</code> 参数是必填的。Terraform 会自动在目标目录下建立起插件镜像存储所需的文件结构，填充包含插件文件的 <code>.zip</code> 文件。</p>
<p>Terraform同时会生成一些包含了合法的<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/internals/provider-network-mirror-protocol">网络镜像协议</a>响应的 <code>.json</code> 索引文件，如果我们把填充好的文件夹上传到一个静态站点，那就能够得到一个静态的网络插件镜像存储服务。Terraform 在使用本地文件镜像存储时会忽略这些镜像文件，因为使用本地文件镜像时文件夹本身的信息更加权威。</p>
<p>该命令支持如下可选参数：</p>
<ul>
<li>
<p><code>-platform=OS_ARCH</code>：选择构建镜像的目标平台。默认情况下，Terraform 会使用当前运行 Terraform 的平台。可以多次设置该参数以构建多目标平台插件镜像</p>
<p>目标平台必须包含操作系统以及 CPU 架构。例如：<code>linux_amd64</code> 代表运行在 AMD64 或是 X86_64 CPU 之上的 Linux 操作系统。</p>
</li>
</ul>
<p>我们可以针对已构建的镜像文件夹重新运行 <code>terraform providers mirror</code> 来添加新插件。例如，可以通过设置 <code>-platform</code> 参数来添加新目标平台的插件，Terraform 会下载新平台插件同时保留原先的插件，将二者合并存储，并更新索引文件。</p>
<h2 id="schema"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">schema</a></h2>
<ul>
<li>
<p><a href="#terraform-providers-schema"><strong>1.7.15.2.1.</strong> terraform providers schema</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.15.2.1.1.</strong> 用法</a></p>
</li>
</ul>
<p><a href="#terraform-providers-schema"></a></p>
<h2 id="1-7-15-2-1-terraform-providers-schema"><a href="#terraform-providers-schema"></a>1.7.15.2.1. terraform providers schema</h2>
<p><code>terraform providers schema</code> 命令被用来打印当前代码使用的 Provider 的架构。Provider 架构包含了使用的所有 Provider 本身的参数信息，以及所提供的 <code>resource</code>、<code>data</code> 的架构信息。</p>
<h2 id="1-7-15-2-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.15.2.1.1. 用法</h2>
<p><code>terraform providers schema [options]</code></p>
<p>可选参数为：</p>
<ul>
<li><code>-json</code>：用机器可读的 JSON 格式打印架构</li>
</ul>
<p>请注意，目前 <code>-json</code> 参数是必填的，未来该命令将允许使用其他参数。</p>
<p>输出包含一个 <code>format_version</code> 键，就拿 Terraform 1.1.0 来说，其值为 <code>&quot;1.0&quot;</code>。该版本的语义是：</p>
<ul>
<li>对于向后兼容的变更或新增字段，我们将增加 minor 版本号，例如 <code>&quot;1.1&quot;</code>。这种变更会忽略所有不认识的对象属性，以保持与未来其他 minor 版本的前向兼容。</li>
<li>对于不向后兼容的变更，我们将增加 major 版本，例如 <code>&quot;2.0&quot;</code>。不同的 major 版本之间的数据无法直接传递。</li>
</ul>
<p>我们只会在 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/v1-compatibility-promises">Terraform 1.0 兼容性承诺</a>的范围内更新 major 版本。</p>
<ul>
<li>
<p><a href="#terraform-providers-lock"><strong>1.7.15.3.1.</strong> terraform providers lock</a></p>
</li>
<li>
<p><a href="#%E7%94%A8%E6%B3%95"><strong>1.7.15.3.1.1.</strong> 用法</a></p>
</li>
<li>
<p><a href="#%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87%E5%B9%B3%E5%8F%B0"><strong>1.7.15.3.1.2.</strong> 指定目标平台</a></p>
</li>
<li>
<p><a href="#%E5%86%85%E9%83%A8-providers-%E7%9A%84%E9%94%81%E6%9D%A1%E7%9B%AE"><strong>1.7.15.3.1.3.</strong> 内部 Providers 的锁条目</a></p>
</li>
</ul>
<p><a href="#terraform-providers-lock"></a></p>
<h2 id="1-7-15-3-1-terraform-providers-lock"><a href="#terraform-providers-lock"></a>1.7.15.3.1. terraform providers lock</h2>
<p><code>terraform providers lock</code> 会查询上游 registry（默认情况下），以便将 Provider 的依赖项信息写入<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/4.Terraform%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/2.%E4%BE%9D%E8%B5%96%E9%94%81%E6%96%87%E4%BB%B6.html">依赖项锁文件</a>。</p>
<p>更新依赖项锁定文件的常见方法是由 <code>terraform init</code> 命令安装 Provider 时生成，但在某些情况下，这种自动生成的方法可能不够：</p>
<ul>
<li>
<p>如果您在使用其他 Provider 程序安装方法（例如文件系统或网络镜像）的环境中运行 Terraform，则常规的 Provider 安装程序将不会访问 Provider 程序在 Registry 上的源，因此 Terraform 将无法填充所有可能的包校验和选定的 Provider 版本。</p>
<p>如果您使用 <code>terraform lock</code> 将 Provider 程序的官方版本校验和写入依赖项锁定文件中，则将来的 <code>terraform init</code> 运行将根据之前记录的官方校验和验证所选镜像中可用的软件包，从而进一步确保镜像返回的 Provider 程序的确是官方版本。</p>
</li>
<li>
<p>如果您的团队在多个不同平台上运行 Terraform（例如在 Windows 和 Linux 上），并且 Provider 的上游 Registry 无法使用最新的哈希方案提供签名的校验和，则后续在其他平台上运行 Terraform 可能会添加额外的校验和锁定文件。您可以通过使用 <code>terraform providers lock</code> 命令为您打算使用的所有平台预先填充哈希值来避免这种情况。</p>
</li>
</ul>
<p><code>terraform providers lock</code> 仅在 Terraform v0.14 或更高版本中可用。</p>
<h2 id="1-7-15-3-1-1-用法"><a href="#%E7%94%A8%E6%B3%95"></a>1.7.15.3.1.1. 用法</h2>
<p><code>terraform providers lock [options] [providers...]</code></p>
<p>在没有额外的命令行参数的情况下，<code>terraform providers lock</code> 将分析当前工作目录中的代码，以查找它所依赖的所有 Provider 程序，并且将从其源 Registry 中获取有关这些 Provider 程序的关键数据，然后更新<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/4.Terraform%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/2.%E4%BE%9D%E8%B5%96%E9%94%81%E6%96%87%E4%BB%B6.html">依赖项锁文件</a>，写入所有选定的 Provider 程序版本以及 Provider 程序开发人员的私钥签名的包校验和。</p>
<p><strong>警告</strong>：<code>terraform providers lock</code> 命令会打印有关其获取的内容以及每个包是否使用加密签名进行签名的信息，但它无法自动验证 Provider 提供者是否值得信赖以及它们是否符合您的本地系统策略或相关法规。在将更新的锁定文件提交到版本控制系统之前，请检查输出中的签名密钥信息，以确认您信任所有签名者。</p>
<p>如果您在命令行上列出一个或多个 Provider 程序源地址，则 <code>terraform providers lock</code> 将其工作仅限于这些提供程序，而其他提供程序（如果有的话）的锁定条目保持不变。</p>
<p>我们可以使用以下附加选项定制该命令的行为：</p>
<ul>
<li>
<p><code>-fs-mirror=PATH</code> - 命令 Terraform 在给定的本地文件系统镜像目录中查找提供程序包，而不是在上游注册表中。给定目录必须使用通常的文件系统镜像目录布局。</p>
</li>
<li>
<p><code>-net-mirror=URL</code> - 命令 Terraform 在给定的网络镜像服务中查找提供程序包，而不是在上游注册表中。给定的 URL 必须实现 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/internals/provider-network-mirror-protocol">Terraform Provider 网络镜像协议</a>。</p>
</li>
<li>
<p><code>-platform=OS_ARCH</code> - 设置打算用于处理此 Terraform 配置的平台。Terraform 将确保 Provider 程序均可用于指定的平台，并将在锁文件中保存足够的包校验和以至少支持指定的平台。</p>
<p>可以多次设置此选项以包含多个目标系统的校验和。</p>
<p>目标平台名称由操作系统和 CPU 架构组成。例如，linux_amd64 选择在 AMD64 或 x86_64 CPU 上运行的 Linux 操作系统。</p>
<p>我们将在后续节中讲述有关于此参数的更多详细信息。</p>
</li>
<li>
<p><code>-enable-plugin-cache</code> - 启用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html#provider-%E6%8F%92%E4%BB%B6%E7%BC%93%E5%AD%98">全局配置的插件缓存</a>的使用。这将加快锁定过程。默认情况下不启用此功能，因为插件缓存不是权威来源。由于 <code>terraform providers lock</code> 命令用于确保使用受信任的 Provider 程序版本，因此从缓存安装插件被认为是有风险的。</p>
</li>
</ul>
<h2 id="1-7-15-3-1-2-指定目标平台"><a href="#%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87%E5%B9%B3%E5%8F%B0"></a>1.7.15.3.1.2. 指定目标平台</h2>
<p>例如，在我们的团队中可能既有在 Windows 或 macOS 工作站上使用 Terraform 配置的开发人员，也有在 Linux 上运行 Terraform 配置的自动化系统。</p>
<p>在这种情况下，我们可以选择验证所有 Provider 程序是否支持所有这些平台，并通过运行 <code>terraform providers lock</code> 并指定这三个平台来预先填充锁文件所需的校验和：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">terraform providers lock \</span><br><span class="line">  -platform=windows_amd64 \ # 64-bit Windows</span><br><span class="line">  -platform=darwin_amd64 \  # 64-bit macOS</span><br><span class="line">  -platform=linux_amd64     # 64-bit Linux</span><br></pre></td></tr></table></figure>
<p>（上面的示例使用 Unix 风格的 shell 包装语法来提高可读性。如果您在 Windows 上运行该命令，则需要将所有参数放在一行上，并删除反斜杠和注释。）</p>
<h2 id="1-7-15-3-1-3-内部-Providers-的锁条目"><a href="#%E5%86%85%E9%83%A8-providers-%E7%9A%84%E9%94%81%E6%9D%A1%E7%9B%AE"></a>1.7.15.3.1.3. 内部 Providers 的锁条目</h2>
<p>所谓<em>内部 Provider 程序</em>是还没有在真正的 Terraform Provider 注册表上发布的 Provider 程序，因为它仅在特定组织内开发和使用，并通过文件系统镜像或网络镜像进行分发。</p>
<p>默认情况下，<code>terraform providers lock</code> 命令假定所有 Provider 程序都是在 Terraform Provider 程序注册表中可用，并尝试联系源注册表以访问有关提供程序包的所有细节信息。</p>
<p>要为仅在本地镜像中可用的特定 Provider 程序创建锁定条目，可以使用 <code>-fs-mirror</code> 或 <code>-net-mirror</code> 命令行选项来覆盖查询 Provider 程序的原始注册表的默认行为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">terraform providers lock \</span><br><span class="line">  -fs-mirror=/usr/local/terraform/providers</span><br><span class="line">  -platform=windows_amd64 \</span><br><span class="line">  -platform=darwin_amd64 \</span><br><span class="line">  -platform=linux_amd64 \</span><br><span class="line">  tf.example.com/ourcompany/ourplatform</span><br></pre></td></tr></table></figure>
<p>（上面的示例使用 Unix 风格的 shell 包装语法来提高可读性。如果您在 Windows 上运行该命令，则需要将所有参数放在一行上，并删除反斜杠和注释。）</p>
<p>由于上面的命令包含 Provider 程序源地址 <code>tf.example.com/ourcompany/ourplatform</code>，因此 <code>terraform providers lock</code> 将仅尝试访问该特定 Provider 程序，并将保留所有其他 Provider 程序的锁条目不变。如果我们有来自不同来源的各种不同的 Provider 程序，可以多次运行 <code>terraform providers lock</code> 并每次指定不同的 Provider 程序子集。</p>
<p><code>-fs-mirror</code> 和 <code>-net-mirror</code> 选项与 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html#%E6%98%BE%E5%BC%8F%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AE">Provider 程序安装方法配置</a>中的 <code>filesystem_mirror</code> 和 <code>network_mirror</code> 块具有相同的含义，但仅配置其中之一，以便明确您打算从何处派生包校验和信息。</p>
<p>请注意，只有原始注册表可以提供开发人员的原始加密签名所签署的官方校验和。因此，从文件系统或网络镜像创建的锁条目将仅覆盖您请求的确切平台，并且记录的校验和将是镜像报告的校验和，而不是原始注册表的官方校验和。如果要确保记录的校验和是由原始 Provider 发布者签名的校验和，请运行不带 <code>-fs-mirror</code> 或 <code>-net-mirror</code> 选项的此命令，以从原始注册表中获取所有信息。</p>
<p>如果您愿意，您可以通过内部 Provider 程序注册表发布您的内部 Provider 程序，然后该注册表将允许锁定和安装这些 Provider 程序，而无需任何特殊选项或额外的 CLI 配置。有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/internals/provider-registry-protocol">Provider 注册协议</a>。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/26/Teraform/Terraform-%E5%91%BD%E4%BB%A4%E8%A1%8C1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                            aria-label=": Terraform-模块"
                        >
                            Terraform-模块
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-23T17:43:45+08:00">
	
		    2023 年 1 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#terraform%E6%A8%A1%E5%9D%97"><strong>1.6.1.</strong> Terraform模块</a></li>
</ul>
<p><a href="#terraform%E6%A8%A1%E5%9D%97"></a></p>
<h2 id="1-6-1-Terraform模块"><a href="#terraform%E6%A8%A1%E5%9D%97"></a>1.6.1. Terraform模块</h2>
<p>到目前为止我们介绍了一些代码书写的知识，但我们创建的所有资源和数据源的代码都是我们在代码文件中编写出来的。我们有没有办法不通过复制粘贴代码从而直接使用别人编写好的 Terraform 代码来创建一组资源呢？</p>
<p>Terraform 对此给出的答案就是模块 (<a target="_blank" rel="noopener" href="https://www.terraform.io/docs/modules/index.html">Module</a>)。简单来讲模块就是包含一组 Terraform 代码的文件夹，我们之前篇章中编写的代码实际上也是在模块中。要想真正理解模块的功能，我们需要去体验一下模块的使用。</p>
<p>Terraform 模块是编写高质量 Terraform 代码，提升代码复用性的重要手段，可以说，一个成熟的生产环境应该是由数个可信成熟的模块组装而成的。我们将在本章介绍关于模块的知识。</p>
<ul>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"><strong>1.6.1.1.</strong> 创建模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><strong>1.6.1.1.1.</strong> 模块结构</a></p>
</li>
<li>
<p><a href="#%E9%81%BF%E5%85%8D%E8%BF%87%E6%B7%B1%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><strong>1.6.1.1.2.</strong> 避免过深的模块结构</a></p>
</li>
</ul>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"></a></p>
<h2 id="1-6-1-1-创建模块"><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"></a>1.6.1.1. 创建模块</h2>
<p>实际上所有包含 Terraform 代码文件的文件夹都是一个 Terraform 模块。我们如果直接在一个文件夹内执行 <code>terraform apply</code> 或者 <code>terraform plan</code> 命令，那么当前所在的文件夹就被称为根模块(root module)。我们也可以在执行 Terraform 命令时通过命令行参数指定根模块的路径。</p>
<h2 id="1-6-1-1-1-模块结构"><a href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"></a>1.6.1.1.1. 模块结构</h2>
<p>旨在被重用的模块与我们编写的根模块使用的是相同的 Terraform 代码和代码风格规范。一般来讲，在一个模块中，会有：</p>
<ul>
<li>一个 <code>README</code> 文件，用来描述模块的用途。文件名可以是 <code>README</code> 或者 <code>README.md</code>，后者应采用 Markdown 语法编写。可以考虑在 <code>README</code> 中用可视化的图形来描绘创建的基础设施资源以及它们之间的关系。<code>README</code> 中不需要描述模块的输入输出，因为工具会自动收集相关信息。如果在 <code>README</code> 中引用了外部文件或图片，请确保使用的是带有特定版本号的绝对 URL 路径以防止未来指向错误的版本</li>
<li>一个 <code>LICENSE</code> 描述模块使用的许可协议。如果你想要公开发布一个模块，最好考虑包含一个明确的许可证协议文件，许多组织不会使用没有明确许可证协议的模块</li>
<li>一个 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/terraform-aws-consul/tree/master/examples">examples 文件夹</a>用来给出一个调用样例(可选)</li>
<li>一个 <code>variables.tf</code> 文件，包含模块所有的输入变量。输入变量应该有明确的描述说明用途</li>
<li>一个 <code>outputs.tf</code> 文件，包含模块所有的输出值。输出值应该有明确的描述说明用途</li>
<li>嵌入模块文件夹，出于封装复杂性或是复用代码的目的，我们可以在 modules 子目录下建立一些嵌入模块。所有包含 README 文件的嵌入模块都可以被外部用户使用；不含 <code>README</code> 文件的模块被认为是仅在当前模块内使用的(可选)</li>
<li>一个 <code>main.tf</code>，它是模块主要的入口点。对于一个简单的模块来说，可以把所有资源都定义在里面；如果是一个比较复杂的模块，我们可以把创建的资源分布到不同的代码文件中，但引用嵌入模块的代码还是应保留在 <code>main.tf</code> 里</li>
<li>其他定义了各种基础设施对象的代码文件(可选)</li>
</ul>
<p>如果模块含有多个嵌入模块，那么应避免它们彼此之间的引用，由根模块负责组合它们。</p>
<p>由于 <code>examples/</code> 的代码经常会被拷贝到其他项目中进行修改，所有在 <code>examples/</code> 代码中引用本模块时使用的引用路径应使用外部调用者可以使用的路径，而非相对路径。</p>
<p>一个最小化模块推荐的结构是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tree minimal-module/</span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">├── outputs.tf</span><br></pre></td></tr></table></figure>
<p>一个更完整一些的模块结构可以是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ tree complete-module/</span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">├── outputs.tf</span><br><span class="line">├── ...</span><br><span class="line">├── modules/</span><br><span class="line">│   ├── nestedA/</span><br><span class="line">│   │   ├── README.md</span><br><span class="line">│   │   ├── variables.tf</span><br><span class="line">│   │   ├── main.tf</span><br><span class="line">│   │   ├── outputs.tf</span><br><span class="line">│   ├── nestedB/</span><br><span class="line">│   ├── .../</span><br><span class="line">├── examples/</span><br><span class="line">│   ├── exampleA/</span><br><span class="line">│   │   ├── main.tf</span><br><span class="line">│   ├── exampleB/</span><br><span class="line">│   ├── .../</span><br></pre></td></tr></table></figure>
<h2 id="1-6-1-1-2-避免过深的模块结构"><a href="#%E9%81%BF%E5%85%8D%E8%BF%87%E6%B7%B1%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"></a>1.6.1.1.2. 避免过深的模块结构</h2>
<p>我们刚才提到可以在 <code>modules/</code> 子目录下创建嵌入模块。Terraform 倡导&quot;扁平&quot;的模块结构，只应保持一层嵌入模块，防止在嵌入模块中继续创建嵌入模块。应将嵌入模块设计成易于组合的结构，使得在根模块中可以通过组合各个嵌入模块创建复杂的基础设施。</p>
<ul>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.</strong> 引用模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E6%BA%90"><strong>1.6.2.1.1.</strong> 模块源</a></p>
</li>
<li>
<p><a href="#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84"><strong>1.6.2.1.1.1.</strong> 本地路径</a></p>
</li>
<li>
<p><a href="#terraform-registry"><strong>1.6.2.1.1.2.</strong> Terraform Registry</a></p>
</li>
<li>
<p><a href="#github"><strong>1.6.2.1.1.3.</strong> GitHub</a></p>
</li>
<li>
<p><a href="#bitbucket"><strong>1.6.2.1.1.4.</strong> Bitbucket</a></p>
</li>
<li>
<p><a href="#%E9%80%9A%E7%94%A8-git-%E4%BB%93%E5%BA%93"><strong>1.6.2.1.1.5.</strong> 通用 Git 仓库</a></p>
</li>
<li>
<p><a href="#%E9%80%9A%E7%94%A8-mercurial-%E4%BB%93%E5%BA%93"><strong>1.6.2.1.1.6.</strong> 通用 Mercurial 仓库</a></p>
</li>
<li>
<p><a href="#http-%E5%9C%B0%E5%9D%80"><strong>1.6.2.1.1.7.</strong> HTTP 地址</a></p>
</li>
<li>
<p><a href="#s3-bucket"><strong>1.6.2.1.1.8.</strong> S3 Bucket</a></p>
</li>
<li>
<p><a href="#gcs-bucket"><strong>1.6.2.1.1.9.</strong> GCS Bucket</a></p>
</li>
<li>
<p><a href="#%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.2.</strong> 直接引用子文件夹中的模块</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.3.</strong> 使用模块</a></p>
</li>
<li>
<p><a href="#%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E5%80%BC"><strong>1.6.2.1.4.</strong> 访问模块输出值</a></p>
</li>
<li>
<p><a href="#%E5%85%B6%E4%BB%96%E7%9A%84%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.6.2.1.5.</strong> 其他的模块元参数</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F"><strong>1.6.2.1.6.</strong> 模块版本约束</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.7.</strong> 多实例模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider"><strong>1.6.2.1.8.</strong> 模块内的 Provider</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6"><strong>1.6.2.1.9.</strong> 模块内的 Provider 版本限制</a></p>
</li>
<li>
<p><a href="#%E9%9A%90%E5%BC%8F-provider-%E7%BB%A7%E6%89%BF"><strong>1.6.2.1.10.</strong> 隐式 Provider 继承</a></p>
</li>
<li>
<p><a href="#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider"><strong>1.6.2.1.11.</strong> 显式传递 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E5%9D%97"><strong>1.6.2.1.12.</strong> Provider 代理配置块</a></p>
</li>
</ul>
<p><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97"></a></p>
<h2 id="1-6-2-1-引用模块"><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97"></a>1.6.2.1. 引用模块</h2>
<p>在 Terraform 代码中引用一个模块，使用的是 <code>module</code> 块。</p>
<p>每当在代码中新增、删除或者修改一个 <code>module</code> 块之后，都要执行 <code>terraform init</code> 或是 <code>terraform get</code> 命令来获取模块代码并安装到本地磁盘上。</p>
<h2 id="1-6-2-1-1-模块源"><a href="#%E6%A8%A1%E5%9D%97%E6%BA%90"></a>1.6.2.1.1. 模块源</h2>
<p><code>module</code> 块定义了一个 <code>source</code> 参数，指定了模块的源；Terraform 目前支持如下模块源：</p>
<ul>
<li>本地路径</li>
<li>Terraform Registry</li>
<li>GitHub</li>
<li>Bitbucket</li>
<li>通用Git、Mercurial仓库</li>
<li>HTTP地址</li>
<li>S3 buckets</li>
<li>GCS buckets</li>
</ul>
<p>我们后面会一一讲解这些模块源的使用。<code>source</code> 使用的是 URL 风格的参数，但某些源支持在 <code>source</code> 参数中通过额外参数指定模块版本。</p>
<p>出于消除重复代码的目的我们可以重构我们的根模块代码，将一些拥有重复模式的代码重构为可反复调用的嵌入模块，通过本地路径来引用。</p>
<p>许多的模块源类型都支持从当前系统环境中读取认证信息，例如环境变量或系统配置文件。我们在介绍模块源的时候会介绍到这方面的信息。</p>
<p>我们建议每个模块把期待被重用的基础设施声明在各自的根模块位置上，但是直接引用其他模块的嵌入模块也是可行的。</p>
<h3 id="1-6-2-1-1-1-本地路径"><a href="#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84"></a>1.6.2.1.1.1. 本地路径</h3>
<p>使用本地路径可以使我们引用同一项目内定义的子模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;./consul&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个本地路径必须以 <code>./</code> 或者 <code>../</code> 为前缀来标明要使用的本地路径，以区别于使用 Terraform Registry 路径。</p>
<p>本地路径引用模块和其他源类型有一个区别，本地路径引用的模块不需要下载相关源代码，代码已经存在于本地相关路径的磁盘上了。</p>
<h3 id="1-6-2-1-1-2-Terraform-Registry"><a href="#terraform-registry"></a>1.6.2.1.1.2. Terraform Registry</h3>
<p>Registry 目前是 Terraform 官方力推的模块仓库方案，采用了 Terraform 定制的协议，支持版本化管理和使用模块。</p>
<p>官方提供的<a target="_blank" rel="noopener" href="https://registry.terraform.io/">公共仓库</a>保存和索引了大量公共模块，在这里可以很容易地搜索到各种官方和社区提供的高质量模块。</p>
<p>读者也可以通过 Terraform Cloud 服务维护一个私有模块仓库，或是通过实现 <a target="_blank" rel="noopener" href="https://www.terraform.io/docs/registry/api.html">Terraform 模块注册协议</a>来实现一个私有仓库。</p>
<p>公共仓库的的模块可以用 <code>&lt;NAMESPACE&gt;/&lt;NAME&gt;/&lt;PROVIDER&gt;</code> 形式的源地址来引用，在公共仓库上的模块介绍页面上都包含了确切的源地址，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;hashicorp/consul/aws&quot;</span><br><span class="line">  version = &quot;0.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于那些托管在其他仓库的模块，在源地址头部添加 <code>&lt;HOSTNAME&gt;/</code> 部分，指定私有仓库的主机名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;app.terraform.io/example-corp/k8s-cluster/azurerm&quot;</span><br><span class="line">  version = &quot;1.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用的是 SaaS 版本的 Terraform Cloud，那么托管在上面的私有仓库的主机名是 <code>app.terraform.io</code>。如果使用的是私有部署的 Terraform 企业版，那么托管在上面的私有仓库的主机名就是 Terraform 企业版服务的主机名。</p>
<p>模块仓库支持版本化。你可以在 <code>module</code> 块中指定模块的版本约束。</p>
<p>如果要引用私有仓库的模块，你需要首先通过配置命令行工具配置文件来设置访问凭证。</p>
<h3 id="1-6-2-1-1-3-GitHub"><a href="#github"></a>1.6.2.1.1.3. GitHub</h3>
<p>Terraform 发现 <code>source</code> 参数的值如果是以 <code>github.com</code> 为前缀时，会将其自动识别为一个 GitHub 源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;github.com/hashicorp/example&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子里会自动使用 HTTPS 协议克隆仓库。如果要使用 SSH 协议，那么请使用如下的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;git@github.com:hashicorp/example.git&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GitHub 源的处理与后面要介绍的通用 Git 仓库是一样的，所以他们获取 git 凭证和通过 <code>ref</code> 参数引用特定版本的方式都是一样的。如果要访问私有仓库，你需要额外配置 git 凭证。</p>
<h3 id="1-6-2-1-1-4-Bitbucket"><a href="#bitbucket"></a>1.6.2.1.1.4. Bitbucket</h3>
<p>Terraform 发现 <code>source</code> 参数的值如果是以 <code>bitbucket.org</code> 为前缀时，会将其自动识别为一个 Bitbucket 源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;bitbucket.org/hashicorp/terraform-consul-aws&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种捷径方法只针对公共仓库有效，因为 Terraform 必须访问 ButBucket API 来了解仓库使用的是 Git 还是 Mercurial 协议。</p>
<p>Terraform 根据仓库的类型来决定将它作为一个 Git 仓库还是 Mercurial 仓库来处理。后面的章节会介绍如何为访问仓库配置访问凭证以及指定要使用的版本号。</p>
<h3 id="1-6-2-1-1-5-通用-Git-仓库"><a href="#%E9%80%9A%E7%94%A8-git-%E4%BB%93%E5%BA%93"></a>1.6.2.1.1.5. 通用 Git 仓库</h3>
<p>可以通过在地址开头加上特殊的 <code>git::</code> 前缀来指定使用任意的 Git 仓库。在前缀后跟随的是一个合法的 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a">Git URL</a>。</p>
<p>使用 HTTPS 和 SSH 协议的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;git::https://example.com/vpc.git&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;storage&quot; &#123;</span><br><span class="line">  source = &quot;git::ssh://username@example.com/storage.git&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 使用 <code>git clone</code> 命令安装模块代码，所以 Terraform 会使用本地 Git 系统配置，包括访问凭证。要访问私有 Git 仓库，必须先配置相应的凭证。</p>
<p>如果使用了 SSH 协议，那么会自动使用系统配置的 SSH 证书。通常情况下我们通过这种方法访问私有仓库，因为这样可以不需要交互式提示就可以访问私有仓库。</p>
<p>如果使用 HTTP/HTTPS 协议，或是其他需要用户名、密码作为凭据，你需要配置 <a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage">Git 凭据存储</a>来选择一个合适的凭据源。</p>
<p>默认情况下，Terraform 会克隆默认分支。可以通过 <code>ref</code> 参数来指定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;git::https://example.com/vpc.git?ref=v1.2.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ref 参数会被用作 git checkout 命令的参数，可以是分支名或是 tag 名。</p>
<p>使用 SSH 协议时，我们更推荐 <code>ssh://</code> 的地址。你也可以选择 scp 风格的语法，故意忽略 <code>ssh://</code> 的部分，只留 <code>git::</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;storage&quot; &#123;</span><br><span class="line">  source = &quot;git::username@example.com:storage.git&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-1-1-6-通用-Mercurial-仓库"><a href="#%E9%80%9A%E7%94%A8-mercurial-%E4%BB%93%E5%BA%93"></a>1.6.2.1.1.6. 通用 Mercurial 仓库</h3>
<p>可以通过在地址开头加上特殊的 <code>hg::</code> 前缀来指定使用任意的 Mercurial 仓库。在前缀后跟随的是一个合法的 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/urls">Mercurial URL</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;hg::http://example.com/vpc.hg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 会通过运行 <code>hg clone</code> 命令从 Mercurial 仓库安装模块代码，所以 Terraform 会使用本地 Mercurial 系统配置，包括访问凭证。要访问私有 Mercurial 仓库，必须先配置相应的凭证。</p>
<p>如果使用了 SSH 协议，那么会自动使用系统配置的 SSH 证书。通常情况下我们通过这种方法访问私有仓库，因为这样可以不需要交互式提示就可以访问私有仓库。</p>
<p>类似 Git 源，我们可以通过 <code>ref</code> 参数指定非默认的分支或者标签来选择特定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;hg::http://example.com/vpc.hg?ref=v1.2.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-1-1-7-HTTP-地址"><a href="#http-%E5%9C%B0%E5%9D%80"></a>1.6.2.1.1.7. HTTP 地址</h3>
<p>当我们使用 HTTP 或 HTTPS 地址时，Terraform 会向指定 URL 发送一个 GET 请求，期待返回另一个源地址。这种间接的方法使得 HTTP 可以成为一个更复杂的模块源地址的指示器。</p>
<p>然后 Terraform 会再发送一个 GET 请求到之前响应的地址上，并附加一个查询参数 <code>terraform-get=1</code>，这样服务器可以选择当 Terraform 来查询时可以返回一个不一样的地址。</p>
<p>如果相应的状态码是成功的(200 范围的成功状态码)，Terraform 就会通过以下位置来获取下一个访问地址：</p>
<ul>
<li>响应头部的 <code>X-Terraform-Get</code> 值</li>
<li>如果响应内容是一个 HTML 页面，那么会检查名为 <code>terraform-get</code> 的 html meta 元素：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;terraform-get&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;github.com/hashicorp/example&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>不管用哪种方式返回的地址，Terraform 都会像本章提到的其他的源地址那样处理它。</p>
<p>如果 HTTP/HTTPS 地址需要认证凭证，可以在 HOME 文件夹下配置一个 <code>.netrc</code> 文件，详见<a target="_blank" rel="noopener" href="https://ec.haxx.se/usingcurl-netrc.html">相关文档</a></p>
<p>也有一种特殊情况，如果 Terraform 发现地址有着一个常见的存档文件的后缀名，那么 Terraform 会跳过 <code>terraform-get=1</code> 重定向的步骤，直接将响应内容作为模块代码使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;https://example.com/vpc-module.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前支持的后缀名有：</p>
<ul>
<li><code>zip</code></li>
<li><code>tar.bz2</code>和<code>tbz2</code></li>
<li><code>tar.gz</code>和<code>tgz</code></li>
<li><code>tar.xz</code>和<code>txz</code></li>
</ul>
<p>如果 HTTP 地址不以这些文件名结尾，但又的确指向模块存档文件，那么可以使用 <code>archive</code> 参数来强制按照这种行为处理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;https://example.com/vpc-module?archive=zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-1-1-8-S3-Bucket"><a href="#s3-bucket"></a>1.6.2.1.1.8. S3 Bucket</h3>
<p>你可以把模块存档保存在 AWS S3 桶里，使用 <code>s3::</code> 作为地址前缀，后面跟随一个 <a target="_blank" rel="noopener" href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro">S3 对象访问地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/vpc.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 识别到 <code>s3::</code> 前缀后会使用 AWS 风格的认证机制访问给定地址。这使得这种源地址也可以搭配其他提供了 S3 协议兼容的对象存储服务使用，只要他们的认证方式与 AWS 相同即可。</p>
<p>保存在 S3 桶内的模块存档文件格式必须与上面 HTTP 源提到的支持的格式相同，Terraform 会下载并解压缩模块代码。</p>
<p>模块安装器会从以下位置寻找AWS凭证，按照优先级顺序排列：</p>
<ul>
<li><code>AWS_ACCESS_KEY_ID</code> 和 <code>AWS_SECRET_ACCESS_KEY</code> 环境变量</li>
<li>HOME 目录下 <code>.aws/credentials</code> 文件内的默认 profile</li>
<li>如果是在 AWS EC2 主机内运行的，那么会尝试使用搭载的 IAM 主机实例配置。</li>
</ul>
<h3 id="1-6-2-1-1-9-GCS-Bucket"><a href="#gcs-bucket"></a>1.6.2.1.1.9. GCS Bucket</h3>
<p>你可以把模块存档保存在谷歌云 GCS 储桶里，使用 <code>gcs::</code> 作为地址前缀，后面跟随一个 <a target="_blank" rel="noopener" href="https://cloud.google.com/storage/docs/request-endpoints#typical">GCS 对象访问地址</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;gcs::https://www.googleapis.com/storage/v1/modules/foomodule.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块安装器会使用谷歌云 SDK 的凭据来访问 GCS。要设置凭据，你可以：</p>
<ul>
<li>通过 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量配置服务账号的密钥文件</li>
<li>如果是在谷歌云主机上运行的 Terraform，可以使用默认凭据。访问<a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/authentication">相关文档</a>获取完整信息</li>
<li>可以使用命令行 <code>gcloud auth application-default login</code> 设置</li>
</ul>
<h2 id="1-6-2-1-2-直接引用子文件夹中的模块"><a href="#%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"></a>1.6.2.1.2. 直接引用子文件夹中的模块</h2>
<p>引用版本控制系统或是对象存储服务中的模块时，模块本身可能存在于存档文件的一个子文件夹内。我们可以使用特殊的 <code>//</code> 语法来指定 Terraform 使用存档内特定路径作为模块代码所在位置，例如：</p>
<ul>
<li><code>hashicorp/consul/aws//modules/consul-cluster</code></li>
<li><code>git::https://example.com/network.git//modules/vpc</code></li>
<li><code>https://example.com/network-module.zip//modules/vpc</code></li>
<li><code>s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/network.zip//modules/vpc</code></li>
</ul>
<p>如果源地址中包含又参数，例如指定特定版本号的 <code>ref</code> 参数，那么把子文件夹路径放在参数之前：</p>
<ul>
<li><code>git::https://example.com/network.git//modules/vpc?ref=v1.2.0</code></li>
</ul>
<p>Terraform 会解压缩整个存档文件后，读取特定子文件夹。所以，对于一个存在于子文件夹中的模块来说，通过本地路径引用同一个存档内的另一个模块是安全的。</p>
<h2 id="1-6-2-1-3-使用模块"><a href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"></a>1.6.2.1.3. 使用模块</h2>
<p>我们刚才介绍了如何用 <code>source</code> 指定模块源，下面我们继续讲解如何在代码中使用一个模块。</p>
<p>我们可以把模块理解成类似函数，如同函数有输入参数表和输出值一样，我们之前介绍过 Terraform 代码有输入变量和输出值。我们在 <code>module</code> 块的块体内除了 <code>source</code> 参数，还可以对该模块的输入变量赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &quot;servers&quot; &#123;</span><br><span class="line">  source = &quot;./app-cluster&quot;</span><br><span class="line"></span><br><span class="line">  servers = 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子里，我们将会创建 <code>./app-cluster</code> 文件夹下 Terraform 声明的一系列资源，该模块的 <code>servers</code> 输入变量的值被我们设定成了5。</p>
<p>在代码中新增、删除或是修改一个某块的 <code>source</code>，都需要重新运行 <code>terraform init</code> 命令。默认情况下，该命令不会升级已安装的模块(例如 <code>source</code> 未指定版本，过去安装了旧版本模块代码，那么执行 <code>terraform init</code> 不会自动更新到新版本)；可以执行 <code>terraform init -upgrade</code> 来强制更新到最新版本模块。</p>
<h2 id="1-6-2-1-4-访问模块输出值"><a href="#%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E5%80%BC"></a>1.6.2.1.4. 访问模块输出值</h2>
<p>在模块中定义的资源和数据源都是被封装的，所以模块调用者无法直接访问它们的输出属性。然而，模块可以声明一系列输出值，来选择性地输出特定的数据供模块调用者使用。</p>
<p>举例来说，如果 <code>./app-cluster</code> 模块定义了名为 <code>instance_ids</code> 的输出值，那么模块的调用者可以像这样引用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_elb&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  instances = module.servers.instance_ids</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-2-1-5-其他的模块元参数"><a href="#%E5%85%B6%E4%BB%96%E7%9A%84%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"></a>1.6.2.1.5. 其他的模块元参数</h2>
<p>除了 <code>source</code> 以外，目前 Terraform 还支持在 <code>module</code> 块上声明其他一些可选元参数：</p>
<ul>
<li><code>version</code>：指定引用的模块版本，在后面的部分会详细介绍</li>
<li><code>count</code> 和 <code>for_each</code>：这是 Terraform 0.13 开始支持的特性，类似 <code>resource</code> 与 <code>data</code>，我们可以创建多个 <code>module</code> 实例</li>
<li><code>providers</code>：通过传入一个 <code>map</code> 我们可以指定模块中的 Provider 配置，我们将在后面详细介绍</li>
<li><code>depends_on</code>：创建整个模块和其他资源之间的显式依赖。直到依赖项创建完毕，否则声明了依赖的模块内部所有的资源及内嵌的模块资源都会被推迟处理。模块的依赖行为与资源的依赖行为相同</li>
</ul>
<p>除了上述元参数以外，<code>lifecycle</code> 参数目前还不能被用于模块，但关键字被保留以便将来实现。</p>
<h2 id="1-6-2-1-6-模块版本约束"><a href="#%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F"></a>1.6.2.1.6. 模块版本约束</h2>
<p>使用 registry 作为模块源时，可以使用 <code>version</code> 元参数约束使用的模块版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source  = &quot;hashicorp/consul/aws&quot;</span><br><span class="line">  version = &quot;0.0.5&quot;</span><br><span class="line"></span><br><span class="line">  servers = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>version</code> 元参数的格式与 Provider 版本约束的格式一致。在满足版本约束的前提下，Terraform 会使用当前已安装的最新版本的模块实例。如果当前没有满足约束的版本被安装过，那么会下载符合约束的最新的版本。</p>
<p><code>version</code> 元参数只能配合 registry 使用，<a target="_blank" rel="noopener" href="https://registry.terraform.io/">公共</a>的或者<a target="_blank" rel="noopener" href="https://www.terraform.io/docs/cloud/registry/index.html">私有</a>的模块仓库都可以。其他类型的模块源可能支持版本化，也可能不支持。本地路径模块不支持版本化。</p>
<h2 id="1-6-2-1-7-多实例模块"><a href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97"></a>1.6.2.1.7. 多实例模块</h2>
<p>可以通过在 <code>module</code> 块上声明 <code>for_each</code> 或者 <code>count</code> 来创造多实例模块。在使用上 <code>module</code> 上的 <code>for_each</code> 和 <code>count</code> 与资源、数据源块上的使用是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># my_buckets.tf</span><br><span class="line">module &quot;bucket&quot; &#123;</span><br><span class="line">  for_each = toset([&quot;assets&quot;, &quot;media&quot;])</span><br><span class="line">  source   = &quot;./publish_bucket&quot;</span><br><span class="line">  name     = &quot;$&#123;each.key&#125;_bucket&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># publish_bucket/bucket-and-cloudfront.tf</span><br><span class="line">variable &quot;name&quot; &#123;&#125; # this is the input parameter of the module</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;example&quot; &#123;</span><br><span class="line">  # Because var.name includes each.key in the calling</span><br><span class="line">  # module block, its value will be different for</span><br><span class="line">  # each instance of this module.</span><br><span class="line">  bucket = var.name</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_user&quot; &quot;deploy_user&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个位于 <code>./publish_bucket</code> 目录下的本地子模块，模块创建了一个 S3 存储桶，封装了桶的信息以及其他实现细节。</p>
<p>我们通过 <code>for_each</code> 参数声明了模块的多个实例，传入一个 <code>map</code> 或是 <code>set</code> 作为参数值。另外，因为我们使用了 <code>for_each</code>，所以在 <code>module</code> 块里可以使用 <code>each</code> 对象，例子里我们使用了 <code>each.key</code>。如果我们使用的是 <code>count</code> 参数，那么我们可以使用 <code>count.index</code>。</p>
<p>子模块里创建的资源在执行计划或UI中的名称会以 <code>module.module_name[module index]</code> 作为前缀。如果一个模块没有声明 <code>count</code> 或者 <code>for_each</code>，那么资源地址将不包含 module index。</p>
<p>在上面的例子里，<code>./publish_bucket</code> 模块包含了 <code>aws_s3_bucket.example</code> 资源，所以两个 S3 桶实例的名字分别是<code>module.bucket[&quot;assets&quot;].aws_s3_bucket.example</code> 以及 <code>module.bucket[&quot;media&quot;].aws_s3_bucket.example</code>。</p>
<h2 id="1-6-2-1-8-模块内的-Provider"><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider"></a>1.6.2.1.8. 模块内的 Provider</h2>
<p>当代码中声明了多个模块时，资源如何与 Provider 实例关联就需要特殊考虑。</p>
<p>每一个资源都必须关联一个 Provider 配置。不像 Terraform 其他的概念，Provider 配置在 Terraform 项目中是全局的，可以跨模块共享。Provider 配置声明只能放在根模块中。</p>
<p>Provider 有两种方式传递给子模块：隐式继承，或是显式通过 <code>module</code> 块的 <code>providers</code> 参数传递。</p>
<p>一个旨在被复用的模块不允许声明任何 <code>provider</code> 块，只有使用&quot;代理 Provider&quot;模式的情况除外，我们后面会介绍这种模式。</p>
<p>出于向前兼容 Terraform 0.10 及更早版本的考虑，Terraform 目前在模块代码中只用到了 Terraform 0.10 及更早版本的功能时，不会针对模块代码中声明 <code>provider</code> 块报错，但这是一个不被推荐的遗留模式。一个含有自己的 <code>provider</code> 块定义的遗留模块与 <code>for_each</code>、<code>count</code> 和 <code>depends_on</code> 等 0.13 引入的新特性是不兼容的。</p>
<p>Provider 配置被用于相关资源的所有操作，包括销毁远程资源对象以及更新状态信息等。Terraform 会在状态文件中保存针对最近用来执行所有资源变更的 Provider 配置的引用。当一个 <code>resource</code> 块被删除时，状态文件中的相关记录会被用来定位到相应的配置，因为原来包含 <code>provider</code> 参数(如果声明了的话)的 <code>resource</code> 块已经不存在了。</p>
<p>这导致了，你必须确保删除所有相关的资源配置定义以后才能删除一个 Provider 配置。如果 Terraform 发现状态文件中记录的某个资源对应的 Provider 配置已经不存在了会报错，要求你重新给出相关的 Provider 配置。</p>
<h2 id="1-6-2-1-9-模块内的-Provider-版本限制"><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6"></a>1.6.2.1.9. 模块内的 Provider 版本限制</h2>
<p>虽然 Provider 配置信息在模块间共享，每个模块还是得声明各自的模块需求，这样 Terraform 才能决定一个适用于所有模块配置的 Provider 版本。</p>
<p>为了定义这样的版本约束要求，可以在 <code>terraform</code> 块中使用 <code>required_providers</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source  = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;&gt;= 2.7.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关 Provider 的 <code>source</code> 和版本约束的信息我们已经在前文中有所记述，在此不再赘述。</p>
<h2 id="1-6-2-1-10-隐式-Provider-继承"><a href="#%E9%9A%90%E5%BC%8F-provider-%E7%BB%A7%E6%89%BF"></a>1.6.2.1.10. 隐式 Provider 继承</h2>
<p>为了方便，在一些简单的代码中，一个子模块会从调用者那里自动地继承默认的 Provider 配置。这意味着显式 <code>provider</code> 块声明仅位于根模块中，并且下游子模块可以简单地声明使用该类型 Provider 的资源，这些资源会自动关联到根模块的 Provider 配置上。</p>
<p>例如，根模块可能只含有一个 <code>provider</code> 块和一个 <code>module</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-west-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;child&quot; &#123;</span><br><span class="line">  source = &quot;./child&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子模块可以声明任意关联 <code>aws</code> 类型 Provider 的资源而无需额外声明 Provider 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_s3_bucket&quot; &quot;example&quot; &#123;</span><br><span class="line">  bucket = &quot;provider-inherit-example&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当每种类型的 Provider 都只有一个实例时我们推荐使用这种方式。</p>
<p>要注意的是，只有 Provider 配置会被子模块继承，Provider 的 <code>source</code> 或是版本约束条件则不会被继承。每一个模块都必须声明各自的 Provider 需求条件，这在使用非 HashiCorp 的 Provider 时尤其重要。</p>
<h2 id="1-6-2-1-11-显式传递-Provider"><a href="#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider"></a>1.6.2.1.11. 显式传递 Provider</h2>
<p>当不同的子模块需要不同的 Provider 实例，或者子模块需要的 Provider 实例与调用者自己使用的不同时，我们需要在 <code>module</code> 块上声明 <code>providers</code> 参数来传递子模块要使用的 Provider 实例。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># The default &quot;aws&quot; configuration is used for AWS resources in the root</span><br><span class="line"># module where no explicit provider instance is selected.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-west-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># An alternate configuration is also defined for a different</span><br><span class="line"># region, using the alias &quot;usw2&quot;.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;usw2&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># An example child module is instantiated with the alternate configuration,</span><br><span class="line"># so any AWS resources it defines will use the us-west-2 region.</span><br><span class="line">module &quot;example&quot; &#123;</span><br><span class="line">  source    = &quot;./example&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws = aws.usw2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>module</code> 块里的 <code>providers</code> 参数类似 <code>resource</code> 块里的 <code>provider</code> 参数，区别是前者接收的是一个 <code>map</code> 而不是单个 <code>string</code>，因为一个模块可能含有多个不同的 Provider。</p>
<p><code>providers</code> 的 <code>map</code> 的键就是子模块中声明的 Provider 需求中的名字，值就是在当前模块中对应的 Provider 配置的名字。</p>
<p>如果 <code>module</code> 块内声明了 <code>providers</code> 参数，那么它将重载所有默认的继承行为，所以你需要确保给定的 <code>map</code> 覆盖了子模块所需要的所有 Provider。这避免了显式赋值与隐式继承混用时带来的混乱和意外。</p>
<p>额外的 Provider 配置(使用 <code>alias</code> 参数的)将永远不会被子模块隐式继承，所以必须显式通过 <code>providers</code> 传递。比如，一个模块配置了两个 AWS 区域之间的网络打通，所以需要配置一个源区域 Provider 和目标区域 Provider。这种情况下，根模块代码看起来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;usw1&quot;</span><br><span class="line">  region = &quot;us-west-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;usw2&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;tunnel&quot; &#123;</span><br><span class="line">  source    = &quot;./tunnel&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws.src = aws.usw1</span><br><span class="line">    aws.dst = aws.usw2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子目录 <code>./tunnel</code> 必须包含像下面的例子那样声明&quot;Provider 代理&quot;，声明模块调用者必须用这些名字传递的 Provider 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias = &quot;src&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias = &quot;dst&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>./tunnel</code> 模块中的每一种资源都应该通过 <code>provider</code> 参数声明它使用的是 <code>aws.src</code> 还是 <code>aws.dst</code>。</p>
<h2 id="1-6-2-1-12-Provider-代理配置块"><a href="#provider-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E5%9D%97"></a>1.6.2.1.12. Provider 代理配置块</h2>
<p>一个 Provider 代理配置只包含 <code>alias</code> 参数，它就是一个模块间传递 Provider 配置的占位符，声明了模块期待显式传递的额外(带有 <code>alias</code> 的)Provider 配置。</p>
<p>需要注意的是，一个完全为空的 Provider 配置块也是合法的，但没有必要。只有在模块内需要带 <code>alias</code> 的 Provider 时才需要代理配置块。如果模块中只是用默认 Provider 时请不要声明代理配置块，也不要仅为了声明 Provider 版本约束而使用代理配置块。</p>
<h2 id="模块元参数"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">模块元参数</a></h2>
<ul>
<li><a href="#%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.6.3.1.</strong> 模块元参数</a></li>
</ul>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"></a></p>
<h2 id="1-6-3-1-模块元参数"><a href="#%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"></a>1.6.3.1. 模块元参数</h2>
<p>在 Terraform 0.13 之前，模块在使用上存在一些限制。例如我们通过模块来创建 EC2 主机，可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module &quot;ec2_instance&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要创建两台这样的主机怎么办？在 Terraform 0.13 之前的版本中，由于 Module 不支持元参数，所以我们只能手动拷贝模块代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">module &quot;ec2_instance_0&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance-0&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;ec2_instance_1&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance-1&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自从 Terraform 0.13 开始，模块也像资源一样，支持<code>count</code>、<code>for_each</code>、<code>depends_on</code>三种元参数。比如我们可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module &quot;ec2_instance&quot; &#123;</span><br><span class="line">  count = 2</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance-$&#123;count.index&#125;&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是 Terraform 0.13 之后在模块上声明<code>depends_on</code>，列表中也可以传入另一个模块。声明<code>depends_on</code>的模块中的所有资源的创建都会发生在被依赖的模块中所有资源创建完成之后。</p>
<ul>
<li>
<p><a href="#%E9%87%8D%E6%9E%84"><strong>1.6.4.1.</strong> 重构</a></p>
</li>
<li>
<p><a href="#moved-%E5%9D%97%E8%AF%AD%E6%B3%95"><strong>1.6.4.1.1.</strong> moved 块语法</a></p>
</li>
<li>
<p><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.6.4.1.2.</strong> 重命名一个资源</a></p>
</li>
<li>
<p><a href="#%E4%B8%BA%E8%B5%84%E6%BA%90%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"><strong>1.6.4.1.3.</strong> 为资源添加 count 或 for_each 声明</a></p>
</li>
<li>
<p><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E8%B0%83%E7%94%A8"><strong>1.6.4.1.4.</strong> 重命名对模块的调用</a></p>
</li>
<li>
<p><a href="#%E4%B8%BA%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"><strong>1.6.4.1.5.</strong> 为模块调用添加 count 或 for_each 声明</a></p>
</li>
<li>
<p><a href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%86%E5%89%B2%E6%88%90%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.6.4.1.6.</strong> 将一个模块分割成多个模块</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4-moved-%E5%9D%97"><strong>1.6.4.1.7.</strong> 删除 moved 块</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"><strong>1.6.4.1.8.</strong> 删除模块</a></p>
</li>
</ul>
<p><a href="#%E9%87%8D%E6%9E%84"></a></p>
<h2 id="1-6-4-1-重构"><a href="#%E9%87%8D%E6%9E%84"></a>1.6.4.1. 重构</h2>
<p>请注意，本节介绍的通过 <code>moved</code> 块进行模块重构的功能是从 Terraform v1.1 开始被引入的。如果要在之前的版本进行这样的操作，必须通过 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/2.mv"><code>terraform state mv</code></a> 命令来完成。</p>
<p>对于一些旨在被人复用的老模块来说，最初的模块结构和资源名称可能会逐渐变得不再合适。例如，我们可能发现将以前的一个子模块分割成两个单独的模块会更合理，这需要将现有资源的一个子集移动到新的模块中。</p>
<p>Terraform 将以前的状态与新代码进行比较，资源与每个模块或资源的唯一地址相关联。因此，默认情况下，移动或重命名对象会被 Terraform 理解为销毁旧地址的对象并在新地址创建新的对象。</p>
<p>当我们在代码中添加 <code>moved</code> 块以记录我们移动或重命名对象过去的地址时，Terraform 会将旧地址的现有对象视为现在属于新地址。</p>
<h2 id="1-6-4-1-1-moved-块语法"><a href="#moved-%E5%9D%97%E8%AF%AD%E6%B3%95"></a>1.6.4.1.1. moved 块语法</h2>
<p><code>moved</code> 块只包含 <code>from</code> 和 <code>to</code> 参数，没有名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子演示了模块先前版本中的 <code>aws_instance.a</code> 如今以 <code>aws_instance.b</code> 的名字存在。</p>
<p>在为 <code>aws_instance.b</code> 创建新的变更计划之前，Terraform 会首先检查当前状态中是否存在地址为 <code>aws_instance.a</code> 的记录。如果存在该记录，Terraform 会将之重命名为 <code>aws_instance.b</code> 然后继续创建变更计划。最终生成的变更计划中该对象就好像一开始就是以 <code>aws_instance.b</code> 的名字被创建的，防止它在执行变更时被删除。</p>
<p><code>from</code> 和 <code>to</code> 的地址使用一种特殊的地址语法，该语法允许选定模块、资源以及子模块中的资源。下面是几种不同的重构场景中所需要的地址语法：</p>
<h2 id="1-6-4-1-2-重命名一个资源"><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.6.4.1.2. 重命名一个资源</h2>
<p>考虑模块代码中这样一个资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  count = 2</span><br><span class="line"></span><br><span class="line">  # (resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次应用该代码时 Terraform 会创建 <code>aws_instance.a[0]</code> 以及 <code>aws_instance.a[1]</code>。</p>
<p>如果随后我们修改了该资源的名称，并且把旧名字记录在一个 <code>moved</code> 块里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;b&quot; &#123;</span><br><span class="line">  count = 2</span><br><span class="line"></span><br><span class="line">  # (resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当下一次应用使用了该模块的代码时，Terraform 会把所有地址为 <code>aws_instance.a</code> 的对象看作是一开始就以 <code>aws_instance.b</code> 的名字创建的：<code>aws_instance.a[0]</code> 会被看作是 <code>aws_instance.b[0]</code>，<code>aws_instance.a[1]</code> 会被看作是 <code>aws_instance.b[1]</code>。</p>
<p>新创建的模块实例中，因为从来就不存在 <code>aws_instance.a</code>，于是会忽略 <code>moved</code> 块而像通常那样直接创建 <code>aws_instance.b[0]</code> 以及 <code>aws_instance.b[1]</code>。</p>
<h2 id="1-6-4-1-3-为资源添加-count-或-for-each-声明"><a href="#%E4%B8%BA%E8%B5%84%E6%BA%90%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"></a>1.6.4.1.3. 为资源添加 count 或 for_each 声明</h2>
<p>一开始代码中有这样一个单实例资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  # (resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用该代码会使得 Terraform 创建了一个地址为 <code>aws_instance.a</code> 的资源对象。</p>
<p>随后我们想要在该资源上添加 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90#for_each"><code>for_each</code></a> 来创建多个实例。为了保持先前关联到 <code>aws_instance.a</code> 的资源对象不受影响，我们必须添加一个 <code>moved</code> 块来指定新代码中原先的对象实例所关联的键是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  instances = tomap(&#123;</span><br><span class="line">    big = &#123;</span><br><span class="line">      instance_type = &quot;m3.large&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    small = &#123;</span><br><span class="line">      instance_type = &quot;t2.medium&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  for_each = local.instances</span><br><span class="line"></span><br><span class="line">  instance_type = each.value.instance_type</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.a[&quot;small&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会防止 Terraform 在变更计划中销毁已经存在的 <code>aws_instance.a</code> 对象，并且将其看作是以 <code>aws_instance.a[&quot;small&quot;]</code> 的地址创建的。</p>
<p>当 <code>moved</code> 块的两个地址中的至少一个包含实例键时，如上例中的 <code>[&quot;small&quot;]</code>，Terraform 将这两个地址理解为引用资源的特定实例而不是整个资源。这意味着您可以使用 <code>moved</code> 在键之间切换以及在 <code>count</code>、<code>for_each</code> 之间切换时添加和删除键。</p>
<p>下面的例子演示了几种其他类似的记录了资源实例键变更的合法 <code>moved</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Both old and new configuration used &quot;for_each&quot;, but the</span><br><span class="line"># &quot;small&quot; element was renamed to &quot;tiny&quot;.</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.b[&quot;small&quot;]</span><br><span class="line">  to   = aws_instance.b[&quot;tiny&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># The old configuration used &quot;count&quot; and the new configuration</span><br><span class="line"># uses &quot;for_each&quot;, with the following mappings from</span><br><span class="line"># index to key:</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.c[0]</span><br><span class="line">  to   = aws_instance.c[&quot;small&quot;]</span><br><span class="line">&#125;</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.c[1]</span><br><span class="line">  to   = aws_instance.c[&quot;tiny&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># The old configuration used &quot;count&quot;, and the new configuration</span><br><span class="line"># uses neither &quot;count&quot; nor &quot;for_each&quot;, and you want to keep</span><br><span class="line"># only the object at index 2.</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.d[2]</span><br><span class="line">  to   = aws_instance.d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：当我们在原先没有声明 <code>count</code> 的资源上添加 <code>count</code> 时，Terraform 会自动将原先的对象移动到第 0 个位置，除非我们通过一个 <code>moved</code> 块显式声明该资源。然而，我们建议使用 <code>moved</code> 块显式声明资源的移动，使得读者在未来阅读模块的代码时能够更清楚地了解到这些变更。</p>
<h2 id="1-6-4-1-4-重命名对模块的调用"><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E8%B0%83%E7%94%A8"></a>1.6.4.1.4. 重命名对模块的调用</h2>
<p>我们可以用类似重命名资源的方式来重命名对模块的调用。假设我们开始用以下代码调用一个模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &quot;a&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当应用该代码时，Terraform 会在模块内声明的资源路径前面加上一个模块路径前缀 <code>module.a</code>。比方说，模块内的 <code>aws_instance.example</code> 的完整地址为 <code>module.a.aws_instance.example</code>。</p>
<p>如果我们随后打算修改模块名称，我们可以直接修改 <code>module</code> 块的标签，并且在一个 <code>moved</code> 块内部记录该变更：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module &quot;b&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = module.a</span><br><span class="line">  to   = module.b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当下一次应用包含该模块调用的代码时，Terraform 会将所有路径前缀为 <code>module.a</code> 的对象看作从一开始就是以 <code>module.b</code> 为前缀创建的。<code>module.a.aws_instance.example</code> 会被看作是 <code>module.b.aws_instance.example</code>。</p>
<p>该例子中的 <code>moved</code> 块中的两个地址都代表对模块的调用，而 Terraform 识别出将原模块地址中所有的资源移动到新的模块地址中。如果该模块声明时使用了 <code>count</code> 或是 <code>for_each</code>，那么该移动也将被应用于所有的实例上，不需要逐个指定。</p>
<h2 id="1-6-4-1-5-为模块调用添加-count-或-for-each-声明"><a href="#%E4%B8%BA%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"></a>1.6.4.1.5. 为模块调用添加 count 或 for_each 声明</h2>
<p>考虑一下单实例的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &quot;a&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;q</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用该段代码会导致 Terraform 创建的资源地址都拥有 <code>module.a</code> 的前缀。</p>
<p>随后如果我们可能需要再通过添加 <code>count</code> 来创建多个资源实例。为了保留先前的 <code>aws_instance.a</code> 实例不受影响，我们可以添加一个 <code>moved</code> 块来设置在新代码中该实例的对应的键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module &quot;a&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;</span><br><span class="line">  count  = 3</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = module.a</span><br><span class="line">  to   = module.a[2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码引导 Terraform 将所有 <code>module.a</code> 中的资源看作是从一开始就是以 <code>module.a[2]</code> 的前缀被创建的。结果就就是，Terraform 生成的变更计划中只会创建 <code>module.a[0]</code> 以及 <code>module.a[1]</code>。</p>
<p>当 <code>moved</code> 块的两个地址中的至少一个包含实例键时，例如上面例子中的 <code>[2]</code>那样，Terraform 会理解将这两个地址理解为对模块的特定实例的调用而非对模块所有实例的调用。这意味着我们可以使用 <code>moved</code> 块在不同键之间切换来添加或是删除键，该机制可用于 <code>count</code> 和 <code>for_each</code>，或删除模块上的这种声明。</p>
<h2 id="1-6-4-1-6-将一个模块分割成多个模块"><a href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%86%E5%89%B2%E6%88%90%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97"></a>1.6.4.1.6. 将一个模块分割成多个模块</h2>
<p>随着模块提供的功能越来越多，最终模块可能变得过大而不得不将之拆分成两个独立的模块。</p>
<p>我们看一下下面的这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;b&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;c&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将该模块分割为三个部分：</p>
<ul>
<li><code>aws_instance.a</code> 现在归属于模块 “x”。</li>
<li><code>aws_instance.b</code> 也属于模块 “x”。</li>
<li><code>aws_instance.c</code> 现在归属于模块 “y”。</li>
</ul>
<p>要在不替换绑定到旧资源地址的现有对象的情况下实现此重构，我们需要：</p>
<ol>
<li>编写模块 “x”，将属于它的两个资源拷贝过去。</li>
<li>编写模块 “y”，将属于它的一个资源拷贝过去。</li>
<li>编辑原有模块代码，删除这些资源，只包含有关迁移现有资源的非常简单的配置代码。</li>
</ol>
<p>新的模块 “x” 和 “y” 应该只包含 <code>resource</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># module &quot;x&quot;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;b&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># module &quot;y&quot;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;c&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而原有模块则被修改成只包含有向下兼容逻辑的垫片，调用两个新模块，并使用 <code>moved</code> 块定义哪些资源被移动到新模块中去了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module &quot;x&quot; &#123;</span><br><span class="line">  source = &quot;../modules/x&quot;</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;y&quot; &#123;</span><br><span class="line">  source = &quot;../modules/y&quot;</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = module.x.aws_instance.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.b</span><br><span class="line">  to   = module.x.aws_instance.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.c</span><br><span class="line">  to   = module.y.aws_instance.c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个原模块的调用者升级模块版本到这个“垫片”版本时，Terraform 会注意到这些 <code>moved</code> 块，并将那些关联到老地址的资源对象看作是从一开始就是由新模块创建的那样。</p>
<p>该模块的新用户可以选择使用这个垫片模块，或是独立调用两个新模块。我们需要通知老模块的现有用户老模块已被废弃，他们将来的开发中需要独立使用这两个新模块。</p>
<p>多模块重构的场景是不多见的，因为它违反了父模块将其子模块视为黑盒的典型规则，不知道在其中声明了哪些资源。这种妥协的前提是假设所有这三个模块都由同一个人维护并分布在一个模块包中。</p>
<p>为避免独立模块之间的耦合，Terraform 只允许声明在同一个目录下的模块间的移动。换句话讲，Terraform 不允许将资源移动到一个 <code>source</code> 地址不是<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84">本地路径</a>的模块中去。</p>
<p>Terraform 使用定义 <code>moved</code> 块的模块实例的地址的地址来解析 <code>moved</code> 块中的相对地址。例如，如果上面的原模块已经是名为 <code>module.original</code> 的子模块，则原模块中对 <code>module.x.aws_instance.a</code> 的引用在根模块中将被解析为 <code>module.original.module.x.aws_instance.a</code>。一个模块只能针对它自身或是它的子模块中的资源声明 <code>moved</code> 块。</p>
<p>如果需要引用带有 <code>count</code> 或 <code>for_each</code> 元参数的模块中的资源，则必须指定要使用的特定实例键以匹配资源配置的新位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.example</span><br><span class="line">  to   = module.new[2].aws_instance.example</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-4-1-7-删除-moved-块"><a href="#%E5%88%A0%E9%99%A4-moved-%E5%9D%97"></a>1.6.4.1.7. 删除 moved 块</h2>
<p>随着时间的推移，一些老模块可能会积累大量 <code>moved</code> 块。</p>
<p>删除 <code>moved</code> 块通常是一种破坏性变更，因为删除后所有使用旧地址引用的对象都将被删除而不是被移动。我们强烈建议保留历史上所有的 <code>moved</code> 块来保存用户从任意版本升级到当前版本的升级路径信息。</p>
<p>如果我们决定要删除 <code>moved</code> 块，需要谨慎行事。对于组织内部的私有模块来说删除 <code>moved</code> 块可能是安全的，因为我们可以确认所有用户都已经使用新版本模块代码运行过 <code>terraform apply</code> 了。</p>
<p>如果我们需要多次重命名或是移动一个对象，我们建议使用<em>串联</em>的 <code>moved</code> 块来记录完整的变更信息，新的块引用已有的块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.b</span><br><span class="line">  to   = aws_instance.c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像这样记录下移动的序列可以使 <code>aws_instance.a</code> 以及 <code>aws_instance.b</code> 两种地址的资源都得到成功更新，Terraform 会将他们视作从一开始就是以 <code>aws_instance.c</code> 的地址创建的。</p>
<h2 id="1-6-4-1-8-删除模块"><a href="#%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"></a>1.6.4.1.8. 删除模块</h2>
<p>注意：<code>removed</code> 块是在 Terraform v1.7 引入的功能。对于早期的 Terraform 版本，您可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/6.rm.html"><code>terraform state rm</code></a> 命令来处理。</p>
<p>要从 Terraform 中删除模块，只需从 Terraform 代码中删除模块调用即可。</p>
<p>默认情况下，删除模块块后，Terraform 将计划销毁由该模块中声明的所有资源。这是因为当您删除模块调用时，该模块的代码将不再包含在我们当前的 Terraform 代码中。</p>
<p>有时我们可能希望从 Terraform 代码中删除模块而不破坏它管理的实际基础设施对象。在这种情况下，资源将从 Terraform 状态中删除，但真正的基础设施对象不会被销毁。</p>
<p>要声明模块已从 Terraform 配置中删除，但不应销毁其托管对象，请从配置中删除 <code>module</code> 块并将其替换为 <code>removed</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">removed &#123;</span><br><span class="line">  from = module.example</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    destroy = false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>from</code> 参数是要删除的模块的地址，不带任何实例键（例如 <code>module.example[1]</code>）。</p>
<p><code>lifecycle</code> 块是必需的。 <code>destroy</code> 参数确定 Terraform 是否会尝试销毁模块管理的对象。 <code>false</code> 值表示 Terraform 将从状态中删除资源而不破坏它们。</p>
<ul>
<li>
<p><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A8%A1%E5%BC%8F"><strong>1.6.5.1.</strong> 设计新模块的模式</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><strong>1.6.5.1.1.</strong> 模块创建的工作流</a></p>
</li>
<li>
<p><a href="#%E5%B0%86%E9%9C%80%E6%B1%82%E8%8C%83%E5%9B%B4%E5%88%92%E5%88%86%E6%88%90%E5%90%88%E9%80%82%E7%9A%84%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.1.1.</strong> 将需求范围划分成合适的模块</a></p>
</li>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8F%AF%E8%A1%8C%E4%BA%A7%E5%93%81"><strong>1.6.5.1.1.2.</strong> 创建模块的最小可行产品</a></p>
</li>
<li>
<p><a href="#%E6%8E%A2%E7%B4%A2%E9%81%B5%E5%BE%AA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"><strong>1.6.5.1.2.</strong> 探索遵循这些原则的一个示例场景</a></p>
</li>
<li>
<p><a href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.2.1.</strong> 网络模块</a></p>
</li>
<li>
<p><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.2.2.</strong> 应用程序模块</a></p>
</li>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8F%90%E7%A4%BA"><strong>1.6.5.1.3.</strong> 创建模块的提示</a></p>
</li>
<li>
<p><a href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.3.1.</strong> 嵌套模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%8F%E4%BD%9C"><strong>1.6.5.1.4.</strong> 模块的协作</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%BF%BD%E8%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.5.</strong> 使用源代码控制系统追踪模块</a></p>
</li>
<li>
<p><a href="#%E5%BC%80%E5%8F%91%E4%B8%80%E5%A5%97%E6%A8%A1%E5%9D%97%E6%B6%88%E8%B4%B9%E5%B7%A5%E4%BD%9C%E6%B5%81"><strong>1.6.5.1.6.</strong> 开发一套模块消费工作流</a></p>
</li>
<li>
<p><a href="#%E9%98%90%E6%98%8E%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.6.1.</strong> 阐明团队应该如何使用模块</a></p>
</li>
</ul>
<p><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A8%A1%E5%BC%8F"></a></p>
<h2 id="1-6-5-1-设计新模块的模式"><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A8%A1%E5%BC%8F"></a>1.6.5.1. 设计新模块的模式</h2>
<p>Terraform 模块是独立的基础设施即代码片段，抽象了基础设施部署的底层复杂性。Terraform 用户通过使用预置的配置代码加速采用 IaC，并降低了使用门槛。所以，模块的作者应尽量遵循诸如清晰的代码结构以及 DRY(“Dont’t Repeat Yourself”)原则的代码最佳实践。</p>
<p>本篇指导讨论了模块架构的原则，用以帮助读者编写易于组合、易于分享及重用的基础设施模块。这些架构建议对使用任意版本 Terraform 的企业都有助益，某些诸如“私有模块注册表(Registry)”的模式仅在 Terraform Cloud 以及企业版中才能使用。（本文不对相关内容进行翻译）</p>
<p>本文是对 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/1.%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">Terraform 模块文档</a>的补充和扩展。</p>
<p>通过阅读文本，读者可以：</p>
<ol>
<li>学习有关 Terraform 模块创建的典型工作流程和基本原则。</li>
<li>探索遵循这些原则的示例场景。</li>
<li>学习如何通过协作改进 Terraform 模块</li>
<li>了解如何创建一套使用模块的工作流程。</li>
</ol>
<h2 id="1-6-5-1-1-模块创建的工作流"><a href="#%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"></a>1.6.5.1.1. 模块创建的工作流</h2>
<p>要创建一个新模块，第一步是寻找一个早期采纳者团队，收集他们的需求。</p>
<p>与这支早期采纳团队一起工作使我们可以通过使用输入变量以及输出值来确保模块足够灵活，从而打磨模块的功能。此外，还可以用最小的代码变更代价吸纳其他有类似需求的团队加入进来。这消除了代码重复，并缩短了交付时间。</p>
<p>完成以上任务后，需要谨记两点：</p>
<ol>
<li>将需求范围划分成合适的模块。</li>
<li>创建模块的最小可行产品(Minimum Viable Product, MVP)</li>
</ol>
<h3 id="1-6-5-1-1-1-将需求范围划分成合适的模块"><a href="#%E5%B0%86%E9%9C%80%E6%B1%82%E8%8C%83%E5%9B%B4%E5%88%92%E5%88%86%E6%88%90%E5%90%88%E9%80%82%E7%9A%84%E6%A8%A1%E5%9D%97"></a>1.6.5.1.1.1. 将需求范围划分成合适的模块</h3>
<p>创建新 Terraform 模块时最具挑战的方面之一是决定要包含哪些基础设施资源。</p>
<p>模块设计应该是有主见的，并且被设计成能很好地完成一个目标。如果一个模块的功能或目的很难解释，那么这个模块可能太复杂了。在最初确定模块的范围时，目标应当足够小且简单，易于开始编写。</p>
<p>当构建一个模块时，需要考虑以下三个方面：</p>
<ul>
<li><strong>封装</strong>：一组始终被一起部署的基础设施资源 在模块中包含更多的基础设施资源简化了终端用户部署基础设施的工作，但会使得模块的目的与需求变得更难理解。</li>
<li><strong>职责</strong>：限制模块职责的边界 如果模块中的基础设施资源由多个组来负责，使用该模块可能会意外违反职责分离原则。模块中仅包含职责边界内的一组资源可以提升基础设施资源的隔离性，并保护我们的基础设施。</li>
<li><strong>变化频率</strong>：隔离长短生命周期基础设施资源 举例来说，数据库基础设施资源相对来说较为静态，而团队可能在一天内多次部署更新应用程序服务器。在同一个模块中同时管理数据库与应用程序服务器使得保存状态数据的重要基础设施没有必要地暴露在数据丢失的风险之中。</li>
</ul>
<h3 id="1-6-5-1-1-2-创建模块的最小可行产品"><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8F%AF%E8%A1%8C%E4%BA%A7%E5%93%81"></a>1.6.5.1.1.2. 创建模块的最小可行产品</h3>
<p>如同所有类型的代码一样，模块的开发永远不会完成，永远会有新的模块需求以及变更。拥抱变化，最初的模块版本应致力于满足最小可行产品（MVP）的标准。以下是在设计最小可行产品时需要谨记的指导清单：</p>
<ul>
<li>永远致力于交付至少可以满足 80% 场景的模块</li>
<li>模块中永远不要处理边缘场景。边缘场景是很少见的。一个模块应该是一组可重用的代码。</li>
<li>在最小可行产品中避免使用条件表达式。最小可行产品应缩小范围，不应该同时完成多种任务。</li>
<li>模块应该只将最常被修改的参数公开为输入变量。一开始时，模块应该只提供最可能需要的输入变量。</li>
</ul>
<h4 id="尽可能多输出"><a href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%9A%E8%BE%93%E5%87%BA"></a>尽可能多输出</h4>
<p>在最小可行产品中输出尽可能多的信息，哪怕目前没有用户需要这些信息。这使得那些通常使用多个模块的终端用户在使用该模块时更加轻松，可以使用一个模块的输出作为下一个模块的输入。</p>
<p>请记住在模块的 <code>README</code> 文档中记录输出值的文档。</p>
<h2 id="1-6-5-1-2-探索遵循这些原则的一个示例场景"><a href="#%E6%8E%A2%E7%B4%A2%E9%81%B5%E5%BE%AA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"></a>1.6.5.1.2. 探索遵循这些原则的一个示例场景</h2>
<p>某团队想要通过 Terraform 创建一套包含 Web 层应用、App 层应用的基础设施。</p>
<p>他们想要使用一个专用的 VPC，并遵循传统的三层架构设计。他们的 Web 层应用需要一个自动伸缩组（AutoScaling Group）。他们的 App 层服务需要一个自动伸缩组，一个 S3 存储桶以及一个数据库。下面的架构图描述了期望的结果：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504165650.png" alt=""></p>
<p>该场景中，一个负责从零开始撰写 Terraform 代码的团队，负责编写一组用以配置基础设施及应用的模块。负责应用程序的团队成员将使用这些模块来配置他们需要的基础设施。</p>
<p><strong>请注意</strong>，虽然该示例使用了 AWS 命名，但所描述的模式适用于所有云平台。</p>
<p>经过对应用程序团队的需求进行审核，模块团队将该应用基础设施分割成如下模块：网络、Web、App、数据库、路由，以及安全。</p>
<p>当 Terraform 模块团队完成模块开发后，他们应该将模块导入到私有模块注册表中，并且向对应的团队成员宣传模块的使用方法。举例来说，负责网络的团队成员将会使用开发的网络模块来部署和配置相应的应用程序网络。</p>
<h3 id="1-6-5-1-2-1-网络模块"><a href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97"></a>1.6.5.1.2.1. 网络模块</h3>
<p>网络模块负责网络基础设施。它包含了网络访问控制列表（ACL）以及 NAT 网关。它也可以包含应用程序所需的 VPC、子网、对等连接以及 Direct Connect 等。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170456.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改网络资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<p>网络模块返回一组其他工作区（Workspace）以及模块可以使用的输出值。如果 VPC 的创建过程是由多个方面组成的，我们可能最终会需要将该模块进一步切割成拥有不同功能的不同模块。</p>
<h3 id="1-6-5-1-2-2-应用程序模块"><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97"></a>1.6.5.1.2.2. 应用程序模块</h3>
<p>本场景中有两个应用程序模块 —— 一个是 Web 层模块，另一个是 App 层模块。</p>
<p>Terraform 模块团队完成这两个模块的开发后，它们应被分发给对应的团队成员来部署他们的应用。随着应用程序团队的成员变得越来越熟悉 Terraform 代码，它们可以提出基础设施方面的增强建议，或是通过 Pull Request 配合他们自己的应用代码发布提交对基础设施的变更请求。</p>
<h4 id="Web-模块"><a href="#web-%E6%A8%A1%E5%9D%97"></a>Web 模块</h4>
<p>Web 模块创建和管理运行 Web 应用程序所需的基础设施。它包含了负载均衡器和自动伸缩组，同时也可以包含应用程序中使用的 EC2 虚拟机实例、S3 存储桶、安全组，以及日志系统。该模块接收一个通过 Packer 预构建的包含最新 Web 层应用发布版本代码的虚拟机镜像的 AMI ID 作为输入。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170534.png" alt=""></p>
<p>该模块包含这些资源是因为它们是<strong>高度封装</strong>的，并且它们<strong>变化频率较高</strong>。</p>
<ol>
<li>此模块中的资源高度内聚，并且与 Web 应用程序紧密相关（例如，此模块需要一个包含最新 Web 层应用程序代码版本的 AMI）。结果就是它们被编制进同一个模块，这样 Web 应用团队的成员们就可以轻松地部署它们。</li>
<li>该模块的资源变更频率较高（每次发布更新版本都需要更新对应基础设施资源）。通过将它们组合在单独的模块中，我们降低了将其他模块的资源暴露在没有必要的数据丢失的风险中的可能性。</li>
</ol>
<h4 id="App-模块"><a href="#app-%E6%A8%A1%E5%9D%97"></a>App 模块</h4>
<p>App 模块创建和管理运行 App 层应用所需的基础设施。它包含了负载均衡器和自动伸缩组，同时也包含了应用程序中使用的 EC2 虚拟机实例、S3 存储桶、安全组，以及日志系统。该模块接收一个通过 Packer 预构建的包含最新 App 层应用发布版本代码的虚拟机镜像的 AMI ID 作为输入。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170602.png" alt=""></p>
<p>该模块包含这些资源是因为它们是<strong>高度封装</strong>的，并且它们<strong>变化频率较高</strong>。</p>
<ol>
<li>此模块中的资源高度内聚，并且与 App 应用程序紧密相关。结果就是它们被编制进同一个模块，这样 App 层应用团队的成员们就可以轻松地部署它们。</li>
<li>该模块的资源变更频率较高（每次发布更新版本都需要更新对应基础设施资源）。通过将它们组合在单独的模块中，我们降低了将其他模块的资源暴露在没有必要的数据丢失的风险中的可能性。</li>
</ol>
<h4 id="数据库模块"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97"></a>数据库模块</h4>
<p>数据库模块创建并管理了运行数据库所需的基础设施资源。它包含了应用程序所需的 RDS 实例，也包含了所有关联的存储、备份以及日志资源。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170632.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改数据库资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<h4 id="路由模块"><a href="#%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97"></a>路由模块</h4>
<p>路由模块创建并管理网络路由所需的基础设施资源。它包含了公共托管区域（Hosted Zone）、Route 53 以及路由表，也可以包含私有托管区域。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170657.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改路由资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<h4 id="安全模块"><a href="#%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97"></a>安全模块</h4>
<p>安全模块创建并管理所有安全所需的基础设施资源。它包含一组 IAM 资源，也可以包含安全组（Security Group）及多因素认证（MFA）。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170717.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改 IAM 或是安全资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<h2 id="1-6-5-1-3-创建模块的提示"><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8F%90%E7%A4%BA"></a>1.6.5.1.3. 创建模块的提示</h2>
<p>除了范围界定之外，我们在创建模块时还应牢记以下几点：</p>
<h3 id="1-6-5-1-3-1-嵌套模块"><a href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%9D%97"></a>1.6.5.1.3.1. 嵌套模块</h3>
<p>嵌套模块是指在当前模块中对另一个模块的引用。嵌套模块可以是外部的，也可以是当前工作空间内的。使用嵌套模块是一项强大的功能；然而我们必须谨慎实践以避免引入错误。</p>
<p>对于所有类型的嵌套模块，请考虑以下事项：</p>
<ul>
<li>嵌套模块可以加速开发速度，但可能会引发未知以及意料之外的结果。请在文档中清晰地记录输入变量、模块行为以及输出值。</li>
<li>通常来说，不要让主模块的嵌套深度超过两层。常用且简单的工具模块，例如专门用来定义 Tag 的模块，则不受此限制制约。</li>
<li>嵌套模块必须包含必要的用来创建指定的资源配置的输入参数以及输出值。</li>
<li>输入参数以及输出值的命名应遵循一致的命名约定，以使得模块可以更容易地被分享，以及将一个模块的的输出值作为另一个模块的输入参数。</li>
<li>嵌套模块可能会导致代码冗余。必须同时在父模块与嵌套模块中声明输入参数和输出值。</li>
</ul>
<h4 id="嵌套的外部模块"><a href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9D%97"></a>嵌套的外部模块</h4>
<p>当我们需要使用那些定义了被多个应用程序堆栈、应用程序和团队复用的标准化资源的通用模块时，嵌套的外部模块会很有用。外部模块通被集中管理和版本化控制，以使得消费者在使用新版本之前可以对其进行验证。当我们依赖或希望使用位于外部的子模块时，请注意以下几点：</p>
<ul>
<li>外部模块必须被独立维护，并可供任何需要调用它的模块使用。使用模块注册表可以确保这一点。</li>
<li>根据模块注册要求，嵌套模块将拥有自己的版本控制代码仓库，独立于调用模块进行版本控制。</li>
<li>对嵌套模块的变更可能会影响调用模块，即使调用模块的调用代码及版本没有发生变化，这会破坏调用代码的信任。</li>
<li>对调用模块如何使用外部模块在文档中进行记录，使得模块行为以及调用关系可以被轻松理解。</li>
<li>对外部模块的变更应该是向后兼容的。如果向后兼容是不可能的，则应清楚地记录需要对任何调用模块进行的更改，并将之分发给所有模块使用者以避免意外。</li>
</ul>
<h4 id="嵌套的嵌入模块"><a href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9D%97"></a>嵌套的嵌入模块</h4>
<p>在当前工作空间中嵌入一个模块使得我们能够清晰地分离模块的逻辑组件，或是创建可在调用模块执行期间多次调用的可重用代码块。在下面的例子中，<code>ec2-instance</code> 是一个嵌入模块，根模块的 <code>main.tf</code> 引用了该模块：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root-module-directory</span><br><span class="line">├── README.md</span><br><span class="line">├── main.tf</span><br><span class="line">└── ec2-instances</span><br><span class="line">    └── main.tf</span><br></pre></td></tr></table></figure>
<p>如果我们需要或者倾向于使用嵌入模块，需要考虑以下几点：</p>
<ul>
<li>在“根模块”中添加嵌入模块意味着子模块与根模块被放在一起进行版本控制。</li>
<li>任何影响两个模块间兼容性的变更都会被快速发现，因为它们必须被一同测试和发布。</li>
<li>（嵌入的）子模块不能被代码树之外的其他模块调用，所以可能会增加重复的代码。举例来说，如果嵌入的 <code>ec2-instance</code> 模块是用来创建一台被用在多个地方的标准化的计算实例，该模块<strong>无法</strong>以这种形式被分享。</li>
</ul>
<h4 id="标签化模块名并记录在文档中"><a href="#%E6%A0%87%E7%AD%BE%E5%8C%96%E6%A8%A1%E5%9D%97%E5%90%8D%E5%B9%B6%E8%AE%B0%E5%BD%95%E5%9C%A8%E6%96%87%E6%A1%A3%E4%B8%AD"></a>标签化模块名并记录在文档中</h4>
<p>为我们的模块创建并遵循一个命名约定将使得模块易于理解与使用。这将促进模块的采用和贡献。以下是一个用以提升模块元素一致性的建议列表：</p>
<ul>
<li>使用一个对人类来说一致且易于理解的模块命名约定。举例来说：</li>
</ul>
<table>
<thead>
<tr>
<th>terraform</th>
<th>cloud provider</th>
<th>function</th>
<th>full name</th>
</tr>
</thead>
<tbody>
<tr>
<td>terraform</td>
<td>aws</td>
<td>consul cluster</td>
<td><code>terraform-aws-consul_cluser</code></td>
</tr>
<tr>
<td>terraform</td>
<td>aws</td>
<td>security module</td>
<td><code>terraform-aws-security</code></td>
</tr>
<tr>
<td>terraform</td>
<td>azure</td>
<td>database</td>
<td><code>terraform-azure-database</code></td>
</tr>
</tbody>
</table>
<ul>
<li>使用人类可以理解的输入变量命名约定。模块是编写一次并多次使用的代码，因此请完整命名所有内容以提升可读性，并在编写代码时在文档中进行记录。</li>
<li>对所有模块进行文档记录。确保文档中包含有：
<ul>
<li>必填的输入变量：这些输入变量应该是经过深思熟虑后的选择。如果这些输入变量值未定义，模块运行将失败。只在必要时为这些输入变量设置默认值。例如 <code>var.vpc_id</code> 永远不应该有默认值，因为每次使用模块时值都会不同。</li>
<li>可选的输入变量：这些输入变量应该有一个合理的，适用于大多数场景的默认值，同时又可以根据需求进行调整。公告输入变量的默认值。例如 <code>var.elb_idle_timeout</code> 会有一个合理的默认值，但调用者也可以根据需求修改它的值。</li>
<li>输出值：列出模块的所有输出值，并将重要的输出和信息性的输出包装在对用户友好的输出模板中。</li>
</ul>
</li>
</ul>
<h4 id="定义并使用一个一致的模块结构"><a href="#%E5%AE%9A%E4%B9%89%E5%B9%B6%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E4%B8%80%E8%87%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"></a>定义并使用一个一致的模块结构</h4>
<p>虽然模块结构是一个品味问题，我们应当将模块的结构记录在文档中，并且在我们的所有模块之间保持统一的结构。为了要维持模块结构的一致：</p>
<ul>
<li>定义一组模块必须包含的 <code>.tf</code> 文件，定义它们应包含哪些内容</li>
<li>为模块定义一个 <code>.gitignore</code>(或类似作用的)文件</li>
<li>创建供样例代码所使用的输入变量值的标准方式（例如一个 <code>terraform.tfvars.example</code> 文件）</li>
<li>使用具有固定子目录的一致的目录结构，即使它们可能是空的</li>
<li>所有模块目录都必须包含一个 <code>README</code> 文件详细记述目录存在的目的以及如何使用其中的文件</li>
</ul>
<h2 id="1-6-5-1-4-模块的协作"><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%8F%E4%BD%9C"></a>1.6.5.1.4. 模块的协作</h2>
<p>随着团队模块的开发工作，简化我们的协作。</p>
<ol>
<li>为每个模块创建路线图</li>
<li>从用户处收集需求信息，并按受欢迎程度进行优先级排序。
<ul>
<li>不使用模块的最常见原因是“它不符合我的要求”。收集这些需求并将它们添加到路线图或对用户的工作流程提出建议。</li>
<li>检查每一项需求以确认它引用的用例是否正确。</li>
<li>公布和维护需求列表。分享该列表并让用户参与列表管理过程。</li>
<li>不要为边缘用例排期。</li>
</ul>
</li>
<li>将每一个决策记录进文档。</li>
<li>在公司内部采用开源社区原则。一些用户希望尽可能高效地使用这些模块，而另一些用户则希望帮助创建这些模块。
<ul>
<li>创建一个社区</li>
<li>维护一份清晰和公开的贡献指引</li>
<li>最终，我们将允许可信的社区成员获得某些模块的所有权</li>
</ul>
</li>
</ol>
<h2 id="1-6-5-1-5-使用源代码控制系统追踪模块"><a href="#%E4%BD%BF%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%BF%BD%E8%B8%AA%E6%A8%A1%E5%9D%97"></a>1.6.5.1.5. 使用源代码控制系统追踪模块</h2>
<p>一个 Terraform 模块应遵守所有良好的代码实践：</p>
<ul>
<li>将模块置于源代码控制中以管理版本发布、协作、变更的审计跟踪。</li>
<li>为所有 <code>main</code> 分支的发布版本建立版本标签，记录文档（最起码在 <code>CHANGELOG</code> 及 <code>README</code> 中记录）。</li>
<li>对 <code>main</code> 分支的所有变更进行代码审查</li>
<li>鼓励模块的用户通过版本标签引用模块</li>
<li>为每一个模块指派一位负责人</li>
<li>一个代码仓库只负责一个模块
<ul>
<li>这对于模块的幂等性和作为库的功能至关重要。</li>
<li>我们应该对模块打上版本标签或是版本化控制。打上版本标签或是版本化的模块应该是不可变的。</li>
<li>发布到私有模块注册表的模块必须要有版本标签。</li>
</ul>
</li>
</ul>
<h2 id="1-6-5-1-6-开发一套模块消费工作流"><a href="#%E5%BC%80%E5%8F%91%E4%B8%80%E5%A5%97%E6%A8%A1%E5%9D%97%E6%B6%88%E8%B4%B9%E5%B7%A5%E4%BD%9C%E6%B5%81"></a>1.6.5.1.6. 开发一套模块消费工作流</h2>
<p>定义和宣传一套消费者团队使用模块时应遵循的可重复工作流程。这个工作流程，就像模块本身一样，应该考虑到用户的需求。</p>
<h3 id="1-6-5-1-6-1-阐明团队应该如何使用模块"><a href="#%E9%98%90%E6%98%8E%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"></a>1.6.5.1.6.1. 阐明团队应该如何使用模块</h3>
<ul>
<li><strong>分散的安全性</strong>：如果每个模块都在自己的存储库中进行版本控制，则可以使用存储库 RBAC 来管理谁拥有写访问权限，从而允许相关团队管理相关的基础设施（例如网络团队拥有对网络模块的写访问权限）。</li>
<li><strong>培育代码社区</strong>：鉴于上述建议，模块开发的最佳实践是允许对存储在私有模块存储库中的模块的所有模块存储库提出 Pull Request。这促进了组织内的代码社区，保持模块内容的相关性和最大的灵活性，并有助于保持模块注册表的长期有效性。</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/21/Teraform/Terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"
                            aria-label=": Terraform 文件与目录"
                        >
                            Terraform 文件与目录
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-21T17:43:45+08:00">
	
		    2023 年 1 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Terraform-文件与目录"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">Terraform 文件与目录</a></h2>
<ul>
<li>
<p><a href="#terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95"><strong>1.5.1.</strong> Terraform 文件与目录</a></p>
</li>
<li>
<p><a href="#%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81"><strong>1.5.1.1.</strong> 文本编码</a></p>
</li>
<li>
<p><a href="#%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E6%A8%A1%E5%9D%97"><strong>1.5.1.2.</strong> 文件夹与模块</a></p>
</li>
<li>
<p><a href="#%E6%A0%B9%E6%A8%A1%E5%9D%97"><strong>1.5.1.3.</strong> 根模块</a></p>
</li>
</ul>
<p><a href="#terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95"></a></p>
<h2 id="1-5-1-Terraform-文件与目录"><a href="#terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95"></a>1.5.1. Terraform 文件与目录</h2>
<p>Terraform 语言的代码存储在文件扩展名为 <code>.tf</code> 的纯文本文件中。该语言还有一种基于 JSON 的变体，以 <code>.tf.json</code> 文件扩展名命名（本书精力所限将不涉及这方面的内容）。 包含 Terraform 代码的文件通常称为配置文件。</p>
<h2 id="1-5-1-1-文本编码"><a href="#%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81"></a>1.5.1.1. 文本编码</h2>
<p>配置文件必须始终使用 UTF-8 编码，并且按照惯例通常使用 Unix 样式行结束符 (LF)，而不是 Windows 样式行结束符 (CRLF)，尽管两者都被接受。</p>
<h2 id="1-5-1-2-文件夹与模块"><a href="#%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E6%A8%A1%E5%9D%97"></a>1.5.1.2. 文件夹与模块</h2>
<p>同一个文件夹中一起保存的一组 <code>.tf</code> 以及 <code>.tf.json</code> 文件组成一个<em>模块</em>。</p>
<p>Terraform 模块仅由直接隶属于该目录的配置文件组成；子目录被视为完全独立的模块，并且不会自动包含在配置中。</p>
<p>Terraform 执行模块中的所有配置文件，最终将整个模块视为单个代码文件。将各个块分成不同的文件纯粹是为了方便读者和维护者，对模块的行为没有影响。</p>
<p>Terraform 模块可以使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html">模块调用</a>将其他模块显式包含到配置中。这些子模块可以来自本地目录（嵌套在父模块的目录中，或磁盘上的任意其他位置），也可以来自 <a target="_blank" rel="noopener" href="https://registry.terraform.io/">Terraform 注册表</a>等外部源。</p>
<h2 id="1-5-1-3-根模块"><a href="#%E6%A0%B9%E6%A8%A1%E5%9D%97"></a>1.5.1.3. 根模块</h2>
<p>Terraform 始终在单一的根模块的上下文中运行。完整的 Terraform 配置由根模块和子模块树组成（其中包括根模块调用的模块、以及由这些模块调用的任何模块等）。</p>
<ul>
<li>
<p>在 Terraform 命令行 中，根模块是执行 Terraform 命令的工作目录。 （我们可以使用命令行参数来指定不同于当前工作目录的根模块，但实际上这种情况很少见。）</p>
</li>
<li>
<p>在 HCP Terraform 和 Terraform Enterprise 中，工作区的根模块默认为配置目录的顶层（通过版本控制存储库或直接上传提供），但工作区设置可以指定要使用的子目录。</p>
</li>
<li>
<p><a href="#%E9%87%8D%E8%BD%BDoverride-%E6%96%87%E4%BB%B6"><strong>1.5.1.1.</strong> 重载(Override) 文件</a></p>
</li>
<li>
<p><a href="#%E7%A4%BA%E4%BE%8B"><strong>1.5.1.1.1.</strong> 示例</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6%E8%A7%84%E5%88%99"><strong>1.5.1.1.2.</strong> 合并规则</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-resource-%E5%92%8C-data-%E5%9D%97"><strong>1.5.1.1.2.1.</strong> 合并 resource 和 data 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-variable-%E5%9D%97"><strong>1.5.1.1.2.2.</strong> 合并 variable 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-output-%E5%9D%97"><strong>1.5.1.1.2.3.</strong> 合并 output 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-locals-%E5%9D%97"><strong>1.5.1.1.2.4.</strong> 合并 locals 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-terraform-%E5%9D%97"><strong>1.5.1.1.2.5.</strong> 合并 terraform 块</a></p>
</li>
</ul>
<p><a href="#%E9%87%8D%E8%BD%BDoverride-%E6%96%87%E4%BB%B6"></a></p>
<h2 id="1-5-1-1-重载-Override-文件"><a href="#%E9%87%8D%E8%BD%BDoverride-%E6%96%87%E4%BB%B6"></a>1.5.1.1. 重载(Override) 文件</h2>
<p>Terraform 通常会加载目录中的所有 <code>.tf</code> 和 <code>.tf.json</code> 文件，并假设每个文件中配置的对象是不同的。如果两个文件尝试定义同一对象，Terraform 将返回错误。</p>
<p>在某些极少数情况下，能够很方便地重载某一文件中声明配置的对象的指定部分。例如，可以使用 JSON 语法以编程方式生成的文件部分重载那些使用 HCL 语法人工编辑的 Terraform 配置文件。</p>
<p>对于这些不常见的场景，Terraform 对名称以 <code>_override.tf</code> 或 <code>_override.tf.json</code> 结尾的配置文件进行特殊处理。这种特殊处理也适用于字面名称为 <code>override.tf</code> 或 <code>override.tf.json</code> 的文件。</p>
<p>Terraform 最初在加载配置时跳过这些重载文件，然后依次处理每个文件（按字典顺序）。对于重载文件中定义的每个顶级块，Terraform 尝试查找与该块对应的已定义对象，然后将重载块的内容合并到现有对象中。</p>
<p>请确保仅在特殊情况下使用重载文件。过度使用重载文件会损害可读性，因为仅查看原始文件的读者无法在不查阅所有重载文件的情况下轻松地认识到这些文件的某些部分已被重载。使用重载文件时，请在原文件中对重载文件修改的每一个块添加注释警告。</p>
<h2 id="1-5-1-1-1-示例"><a href="#%E7%A4%BA%E4%BE%8B"></a>1.5.1.1.1. 示例</h2>
<p>假设我们有一个名为 <code>example.tf</code> 的文件中包含如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  ami           = &quot;ami-408c7f28&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，创建名为 <code>override.tf</code> 的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami = &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 会将后者合并到前者中，其行为就好比我们一开始就写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  ami           = &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-1-1-2-合并规则"><a href="#%E5%90%88%E5%B9%B6%E8%A7%84%E5%88%99"></a>1.5.1.1.2. 合并规则</h2>
<p>不同的块类型所对应的合并行为略有不同，某些块内的一些特殊结构以特殊方式合并。</p>
<p>适用于大多数情况的一般规则是：</p>
<ul>
<li>重载文件中的顶级块与具有相同<em>块头</em>的普通配置文件中的块合并。<em>块头</em>是块类型及其后面的所有标签。</li>
<li>顶级块中的属性值将被替换为重载块中的同名属性值。</li>
<li>顶级块中的内嵌块全部都会被重载块中相同类型的块替换。任何未出现在重载块中的块类型仍保留在原始块中。</li>
<li>内嵌块的内容不会合并。</li>
<li>合并后的块仍必须符合所有适用于该类型块的验证规则。</li>
</ul>
<p>如果多个重载文件定义相同的顶级块，则重载效果会叠加，后面的块优先于前面的块。重载首先按文件名（按字典顺序）然后按每个文件中的位置进行处理。</p>
<p>以下部分描述了适用于某些顶级块类型中的特定参数的特殊合并行为。</p>
<h3 id="1-5-1-1-2-1-合并-resource-和-data-块"><a href="#%E5%90%88%E5%B9%B6-resource-%E5%92%8C-data-%E5%9D%97"></a>1.5.1.1.2.1. 合并 resource 和 data 块</h3>
<p>在 <code>resource</code> 块内，所有 <code>lifecycle</code> 块的内容都会按参数进行合并。例如，如果重载块仅设置了 <code>create_before_destroy</code> 参数，则原始块中 <code>ignore_changes</code> 参数会被保留。</p>
<p>如果重载 <code>resource</code> 块包含一个或多个 <code>provisioner</code> 块，则原始块中的所有 <code>provisioner</code> 块都将被忽略。</p>
<p>如果重载 <code>resource</code> 块包含 <code>connection</code> 块，则它完全取代原始块中存在的所有 <code>connection</code> 块。</p>
<p>不允许在重载块中声明 <code>depends_on</code> 元参数，那将会返回错误。</p>
<h3 id="1-5-1-1-2-2-合并-variable-块"><a href="#%E5%90%88%E5%B9%B6-variable-%E5%9D%97"></a>1.5.1.1.2.2. 合并 variable 块</h3>
<p><code>variable</code> 块内的参数按照上述的标准方式合并，但由于 <code>type</code> 和 <code>default</code> 参数之间存在相互作用，有一些特殊规则。</p>
<p>如果原始块定义了 <code>default</code> 值并且重载块更改了变量的 <code>type</code>，Terraform 会尝试将默认值转换为重载的类型，如果无法进行这样的转换，则会产生错误。</p>
<p>相反，如果原始块定义 <code>type</code> 并且重载块更改 <code>default</code> 值，则重载的默认值必须与原始块定义的类型兼容。</p>
<h3 id="1-5-1-1-2-3-合并-output-块"><a href="#%E5%90%88%E5%B9%B6-output-%E5%9D%97"></a>1.5.1.1.2.3. 合并 output 块</h3>
<p>不允许在重载块中声明 <code>depends_on</code> 元参数，那将会返回错误。</p>
<h3 id="1-5-1-1-2-4-合并-locals-块"><a href="#%E5%90%88%E5%B9%B6-locals-%E5%9D%97"></a>1.5.1.1.2.4. 合并 locals 块</h3>
<p>每个 <code>locals</code> 块定义了键值对。重载是在逐个值进行的，不论它们定义在哪个 <code>locals</code> 块中。</p>
<h3 id="1-5-1-1-2-5-合并-terraform-块"><a href="#%E5%90%88%E5%B9%B6-terraform-%E5%9D%97"></a>1.5.1.1.2.5. 合并 terraform 块</h3>
<p><code>terraform</code> 块内的配置在合并时会有不同的规则。</p>
<p>如果设置了 <code>required_providers</code> 参数，则其值将以 Provider 的尺度进行合并，这允许重载块调整单个 Provider 的约束，而不影响其他 Provider 的约束。</p>
<p>在 <code>required_version</code> 和 <code>required_providers</code> 设置中，所有重载的约束都会彻底替换原始块中同一组件的约束。如果原始块和重载块都设置了 <code>required_version</code>，则原始块中的约束将被彻底忽略。</p>
<p>重载文件中定义 Backend（<code>cloud</code>或 <code>backend</code>）的块始终优先于原始配置中定义 Backend 的块。也就是说，如果在原始配置中设置了 <code>cloud</code> 块，并在重载文件中设置了 <code>backend</code> 块，则 Terraform 将在合并时使用重载文件中指定的 <code>backend</code> 块。同样，如果在原始配置中设置了 <code>backend</code> 块，并且在重载文件中设置了 <code>cloud</code> 块，则 Terraform 将在合并时使用重载文件中指定的 <code>cloud</code> 块。</p>
<ul>
<li>
<p><a href="#%E4%BE%9D%E8%B5%96%E9%94%81dependency-lock%E6%96%87%E4%BB%B6"><strong>1.5.2.1.</strong> 依赖锁(Dependency Lock)文件</a></p>
</li>
<li>
<p><a href="#%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE"><strong>1.5.2.1.1.</strong> 锁文件的位置</a></p>
</li>
<li>
<p><a href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A1%8C%E4%B8%BA"><strong>1.5.2.1.2.</strong> 安装依赖的行为</a></p>
</li>
<li>
<p><a href="#%E9%AA%8C%E8%AF%81%E6%A0%A1%E9%AA%8C%E5%92%8C"><strong>1.5.2.1.2.1.</strong> 验证校验和</a></p>
</li>
<li>
<p><a href="#%E7%90%86%E8%A7%A3%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E6%9B%B4"><strong>1.5.2.1.3.</strong> 理解锁文件的变更</a></p>
</li>
<li>
<p><a href="#%E6%96%B0-provider-%E7%9A%84%E4%BE%9D%E8%B5%96"><strong>1.5.2.1.3.1.</strong> 新 Provider 的依赖</a></p>
</li>
<li>
<p><a href="#%E7%8E%B0%E5%AD%98-provider-%E7%9A%84%E6%96%B0%E7%89%88%E6%9C%AC"><strong>1.5.2.1.3.2.</strong> 现存 Provider 的新版本</a></p>
</li>
<li>
<p><a href="#%E6%96%B0-provider-%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%A0%A1%E9%AA%8C%E5%92%8C"><strong>1.5.2.1.3.3.</strong> 新 Provider 程序包校验和</a></p>
</li>
<li>
<p><a href="#%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84-provider"><strong>1.5.2.1.3.4.</strong> 那些不再被使用的 Provider</a></p>
</li>
</ul>
<p><a href="#%E4%BE%9D%E8%B5%96%E9%94%81dependency-lock%E6%96%87%E4%BB%B6"></a></p>
<h2 id="1-5-2-1-依赖锁-Dependency-Lock-文件"><a href="#%E4%BE%9D%E8%B5%96%E9%94%81dependency-lock%E6%96%87%E4%BB%B6"></a>1.5.2.1. 依赖锁(Dependency Lock)文件</h2>
<p><strong>注意</strong>：该功能是自 Terraform 0.14 起引入的一项功能。 Terraform 的更早期版本不跟踪依赖项，因此本节与这些早期版本无关。</p>
<p>Terraform 配置文件中可以引用来自其自身代码库之外的两种不同类型的外部依赖项：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html">Providers</a>，它们是 Terraform 的插件，用以与各种外部系统交互。</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/">模块</a>，允许将一组 Terraform 配置（用 Terraform 语言编写）拆分为可重用的抽象组件。</li>
</ul>
<p>这两种类型的依赖都可以独立于 Terraform 本身以及依赖于它们的代码进行发布和更新。因此，Terraform 必须确定这些依赖项的哪些版本可能与当前配置兼容以及当前选择使用哪些版本。</p>
<p>配置本身内的版本约束决定了哪些版本的依赖项可能与当前配置兼容，但在为每个依赖项选定的特定版本后，Terraform 会记住它在依赖锁文件中所做的决定，以便它可以（默认情况下）在将来再次做出相同的决定。</p>
<p>目前，依赖锁文件<strong>仅追踪</strong> Provider 的依赖项。 Terraform 不会保存远程模块的版本选择，因此 Terraform 将始终选择满足指定版本约束的最新可用模块版本。我们可以使用精确的版本约束来确保 Terraform 始终选择相同版本的模块。</p>
<h2 id="1-5-2-1-1-锁文件的位置"><a href="#%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE"></a>1.5.2.1.1. 锁文件的位置</h2>
<p>依赖锁文件是记录的是整个配置的依赖，而不是配置代码中使用每个单独的模块的依赖。因此，Terraform 在运行 Terraform 时的当前工作目录中创建该文件，并假设该文件存在于此，同时该目录也包含了配置根模块的 <code>.tf</code> 文件的。</p>
<p>依赖锁文件的名字始终是 <code>.terraform.lock.hcl</code>，此名称旨在表示它是 Terraform 缓存在工作目录的 <code>.terraform</code> 子目录中的各种项目的锁定文件。</p>
<p>每次运行 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/12.init.html"><code>terraform init</code> 命令</a>时，Terraform 都会自动创建或更新依赖项锁定文件。我们应该将此文件包含在版本控制存储库中，以便我们可以在代码审查过程中对那些外部依赖项的更改进行审查，就像对配置本身的更改进行审查一样。</p>
<p>依赖锁定文件使用与 Terraform 语言相同的语法，但依赖锁定文件本身并不是 Terraform 语言配置文件。它以后缀 <code>.hcl</code> 而不是 <code>.tf</code> 命名，以显示这种差异。</p>
<h2 id="1-5-2-1-2-安装依赖的行为"><a href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A1%8C%E4%B8%BA"></a>1.5.2.1.2. 安装依赖的行为</h2>
<p>当 <code>terraform init</code> 正在安装配置所需的所有 Provider 程序时，Terraform 会同时参考配置中的版本约束以及锁定文件中记录的版本选择。</p>
<p>如果某个 Provider 程序没有在锁文件中找到对应的记录，Terraform 将选择与给定版本约束匹配的最新可用版本，然后更新锁定文件以保存该选择。</p>
<p>如果某个 Provider 程序已在锁文件中保存了一个版本选择记录，Terraform 将始终重新选择该版本进行安装，即使有更新的版本可用。我们可以通过在运行 <code>terraform init</code> 时添加 <code>-upgrade</code> 选项来重载该行为，在这种情况下，Terraform 将忽略现有选择并再次选择与版本约束匹配的最新可用版本。</p>
<p>如果某次 <code>terraform init</code> 调用对锁文件进行了更改，Terraform 会在其输出中提到这一点：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Terraform has made some changes to the provider dependency selections recorded</span><br><span class="line">in the .terraform.lock.hcl file. Review those changes and commit them to your</span><br><span class="line">version control system if they represent changes you intended to make.</span><br></pre></td></tr></table></figure>
<p>当我们看到这样的消息时，我们可以使用版本控制系统来<a href="#%E7%90%86%E8%A7%A3%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E6%9B%B4">查看 Terraform 提到的那些在文件中的变更</a>，如果变更的确是我们有意为之的，那我们可以将这些变更发送至团队的常规代码审核流程进行审查。</p>
<h3 id="1-5-2-1-2-1-验证校验和"><a href="#%E9%AA%8C%E8%AF%81%E6%A0%A1%E9%AA%8C%E5%92%8C"></a>1.5.2.1.2.1. 验证校验和</h3>
<p>Terraform 还将验证它安装的每个包是否与之前在锁定文件中记录的校验和至少一个相匹配（如果有），如果没有校验和匹配，则返回错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error: Failed to install provider</span><br><span class="line"></span><br><span class="line">Error while installing hashicorp/azurerm v2.1.0: the current package for</span><br><span class="line">registry.terraform.io/hashicorp/azurerm 2.1.0 doesn&#x27;t match any of the</span><br><span class="line">checksums previously recorded in the dependency lock file.</span><br></pre></td></tr></table></figure>
<p>此校验和验证采用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Trust_on_first_use">“<em>初次使用时信任</em>”</a>原则。当我们第一次添加新的 Provider 程序时，我们可以通过各种方式或相关法规要求的所有方法对其进行验证，然后确信如果未来运行 <code>terraform init</code> 时，在安装相同 Provider 程序时遇到不匹配的包时 Terraform 会返回错误。</p>
<p>“初次使用时”模型有两个特殊考虑因素：</p>
<ul>
<li>如果我们从源注册表安装 Provider 程序时，该 Provider 程序提供了使用加密签名算法签名的校验和，那么只要有一个校验和匹配，Terraform 就会将所有已签名的校验和视为有效。因此，锁文件将包含该 Provider 所适用的所有平台的所有不同包的校验和。</li>
</ul>
<p>在这种情况下，<code>terraform init</code> 的输出将包括对校验和进行签名的密钥的指纹，以及像这样的信息 <code>(signed by a HashiCorp partner, key ID DC9FC6B1FCE47986)</code>。在提交包含签名校验和的锁文件之前，最好先确认我们能够信任给该密钥的持有者，或者检索并验证指定 Provider 版本的所有可用包的集合。</p>
<ul>
<li>如果我们首次安装 Provider 时使用的是替代安装方法（例如文件系统或网络镜像），Terraform 将无法验证除运行 <code>terraform init</code> 的平台之外的其他所有平台的校验和，因此它不会记录其他平台的校验和，导致该配置将无法在任何其他平台上使用。</li>
</ul>
<p>为了避免此问题，您可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/15.providers/3.lock.html"><code>terraform providers lock</code> 命令</a>在锁文件中预先记录各种不同平台的校验和，这样我们将来可以调用 <code>terraform init</code> 命令来验证我们选择的镜像中可用的包是否与该 Provider 源注册表提供的官方包相匹配。</p>
<h2 id="1-5-2-1-3-理解锁文件的变更"><a href="#%E7%90%86%E8%A7%A3%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E6%9B%B4"></a>1.5.2.1.3. 理解锁文件的变更</h2>
<p>由于依赖锁文件主要由 Terraform 本身自动维护，而不是手动更新，因此我们的版本控制系统可能会向我们显示该文件已更改。</p>
<p>Terraform 可能会对我们的锁文件进行几种不同类型的变更，我们可能需要了解这些更改才能查看建议的变更。以下各节将描述这些常见变更。</p>
<h3 id="1-5-2-1-3-1-新-Provider-的依赖"><a href="#%E6%96%B0-provider-%E7%9A%84%E4%BE%9D%E8%B5%96"></a>1.5.2.1.3.1. 新 Provider 的依赖</h3>
<p>如果我们向配置中任意模块的 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html#provider-%E7%9A%84%E5%A3%B0%E6%98%8E">Provider 的声明</a>配置节中添加新条目，或者添加了包含新 Provider 程序依赖项的外部模块，<code>terraform init</code> 将通过选择满足配置中所有版本约束的最新版本的 Provider 程序，并将这条决策保存为依赖锁文件中的一个新的 Provider 程序块。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- .terraform.lock.hcl 2020-10-07 16:12:07.539570634 -0700</span></span><br><span class="line"><span class="comment">+++ .terraform.lock.hcl 2020-10-07 16:12:15.267487237 -0700</span></span><br><span class="line"><span class="meta">@@ -6,6 +6,26 @@</span></span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+provider &quot;registry.terraform.io/hashicorp/azurerm&quot; &#123;</span></span><br><span class="line"><span class="addition">+  version     = &quot;2.30.0&quot;</span></span><br><span class="line"><span class="addition">+  constraints = &quot;~&gt; 2.12&quot;</span></span><br><span class="line"><span class="addition">+  hashes = [</span></span><br><span class="line"><span class="addition">+    &quot;h1:FJwsuowaG5CIdZ0WQyFZH9r6kIJeRKts9+GcRsTz1+Y=&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;h1:c/ntSXrDYM1mUir2KufijYebPcwKqS9CRGd3duDSGfY=&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;h1:yre4Ph76g9H84MbuhZ2z5MuldjSA4FsrX6538O7PCcY=&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:04f0a50bb2ba92f3bea6f0a9e549ace5a4c13ef0cbb6975494cac0ef7d4acb43&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:2082e12548ebcdd6fd73580e83f626ed4ed13f8cdfd51205d8696ffe54f30734&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:246bcc449e9a92679fb30f3c0a77f05513886565e2dcc66b16c4486f51533064&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:24de3930625ac9014594d79bfa42d600eca65e9022b9668b54bfd0d924e21d14&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:2a22893a576ff6f268d9bf81cf4a56406f7ba79f77826f6df51ee787f6d2840a&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:2b27485e19c2aaa9f15f29c4cff46154a9720647610171e30fc6c18ddc42ec28&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:435f24ce1fb2b63f7f02aa3c84ac29c5757cd29ec4d297ed0618423387fe7bd4&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:7d99725923de5240ff8b34b5510569aa4ebdc0bdb27b7bac2aa911a8037a3893&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:7e3b5d0af3b7411dd9dc65ec9ab6caee8c191aee0fa7f20fc4f51716e67f50c0&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:da0af4552bef5a29b88f6a0718253f3bf71ce471c959816eb7602b0dadb469ca&quot;,</span></span><br><span class="line"><span class="addition">+  ]</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> provider &quot;registry.terraform.io/newrelic/newrelic&quot; &#123;</span><br><span class="line">   version     = &quot;2.1.2&quot;</span><br><span class="line">   constraints = &quot;~&gt; 2.1.1&quot;</span><br></pre></td></tr></table></figure>
<p>新的锁文件条目记录了几条信息：</p>
<ul>
<li><code>version</code>：Terraform 根据配置中的版本约束所选择的版本。</li>
<li><code>constraints</code>：Terraform 在进行此选择时所遵守的所有的版本约束。 （Terraform 实际上并不使用此信息来做出安装决策，而是保存该信息以帮助向人类读者解释之前的决策是如何做出的。）</li>
<li><code>hashes</code>：给定 Provider 程序在不同平台上有效的安装包所对应的一组校验和。这些哈希值的含义在下面的<a href="#%E6%96%B0-provider-%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%A0%A1%E9%AA%8C%E5%92%8C">新 Provider 程序包校验和</a>中有进一步的解释。</li>
</ul>
<h3 id="1-5-2-1-3-2-现存-Provider-的新版本"><a href="#%E7%8E%B0%E5%AD%98-provider-%E7%9A%84%E6%96%B0%E7%89%88%E6%9C%AC"></a>1.5.2.1.3.2. 现存 Provider 的新版本</h3>
<p>如果我们运行 <code>terraform init -upgrade</code> 来命令 Terraform 在遵守配置的版本约束匹配的前提下将 Provider 升级到更新的版本，那么 Terraform 可能会为 Provider 程序选择较新的版本并更新其现有的 Provider 程序块，以体现该变更。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- .terraform.lock.hcl 2020-10-07 16:44:25.819579509 -0700</span></span><br><span class="line"><span class="comment">+++ .terraform.lock.hcl 2020-10-07 16:43:42.785665945 -0700</span></span><br><span class="line"><span class="meta">@@ -7,22 +7,22 @@</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> provider &quot;registry.terraform.io/hashicorp/azurerm&quot; &#123;</span><br><span class="line"><span class="deletion">-  version     = &quot;2.1.0&quot;</span></span><br><span class="line"><span class="deletion">-  constraints = &quot;~&gt; 2.1.0&quot;</span></span><br><span class="line"><span class="addition">+  version     = &quot;2.0.0&quot;</span></span><br><span class="line"><span class="addition">+  constraints = &quot;2.0.0&quot;</span></span><br><span class="line">   hashes      = [</span><br><span class="line"><span class="deletion">-    &quot;h1:EOJImaEaVThWasdqnJjfYc6/P8N/MRAq1J7avx5ZbV4=&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:0015b491cf9151235e57e35ea6b89381098e61bd923f56dffc86026d58748880&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:4c5682ba1e0fc7e2e602d3f103af1638f868c31fe80cc1a884a97f6dad6e1c11&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:57bac885b108c91ade4a41590062309c832c9ab6bf6a68046161636fcaef1499&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:5810d48f574c0e363c969b3f45276369c8f0a35b34d6202fdfceb7b85b3ac597&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:5c6e37a44462b8662cf9bdd29ce30523712a45c27c5d4711738705be0785db41&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:64548940a3387aa3a752e709ee9eb9982fa820fe60eb60e5f212cc1d2c58549e&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:7f46749163da17330bbb5293dc825333c86304baa0a7c6256650ac536b4567c8&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:8f8970f2df75ac43ffdd112055ee069d8bd1030f7eb4367cc4cf494a1fa802c3&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:9ad693d00dc5d7d455d06faba70e716bce727c6706f7293288e87fd7956b8fe0&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:b6e3cb55e6aec62b47edd0d2bd5e14bd6a2bcfdac65930a6e9e819934734c57b&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:d6a3f3b9b05c28ecf3919e9e7afa185805a6d7442fc4b3eedba749c2731d1f0e&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:d81fb624a357c57c7ea457ce543d865b39b12f26c2edd58a2f7cd43326c91010&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;h1:bigGXBoRbp7dv79bEEn+aaju8575qEXHQ57XHVPJeB8=&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:09c603c8904ca4a5bc19e82335afbc2837dcc4bee81e395f9daccef2f2cba1c8&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:194a919d4836d6c6d4ce598d0c66cce00ddc0d0b5c40d01bb32789964d818b42&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:1f269627df4e266c4e0ef9ee2486534caa3c8bea91a201feda4bca525005aa0a&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:2bae3071bd5f8e553355c4b3a547d6efe1774a828142b762e9a4e85f79be7f63&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:6c98dfa5c3468e8d02e2b3af7c4a8a14a5d469ce5a642909643b413a17ca338b&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:7af78f61666fd45fbf428161c061ea2623162d601b79dc71d6a5158756853ffa&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:883c2df86ae9ba2a5c167cf5c2c7deca0239171a224d6d335f0fd6dd9c283830&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:a2028379078577d8ff5ecfca6e8a8b25a25ffb1686de0ee52a7fe8011783488b&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:abe6ef399552fd3861a454a839cd978c1d15735658fdc00f9054435aff0f4620&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:c30b1bf14077913c3cdf34979b1434dbb1353cb5995eb3956b191c50538b64a9&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:ca64ae2ad9793e5631e3b0b9327f7cb22cb5d8e9de57be7d85821791b1d5a375&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:fffe56904a38109bb8d613b02808a177c3ddfac19f03b3aac799281fea38f475&quot;,</span></span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>选择新的 Provider 程序版本的对锁文件进行的修改主要是更改了 <code>provider</code> 块中 <code>version</code> 的值。如果升级伴随着对配置文件中声明的版本约束的变更，Terraform 还将在 <code>constraints</code> 中记录该变更。</p>
<p>由于每个版本都有自己的一组分发包，因此切换到新版本也往往会替换 <code>hashes</code> 中的所有值，以体现新版本包的校验和。</p>
<h3 id="1-5-2-1-3-3-新-Provider-程序包校验和"><a href="#%E6%96%B0-provider-%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%A0%A1%E9%AA%8C%E5%92%8C"></a>1.5.2.1.3.3. 新 Provider 程序包校验和</h3>
<p>我们可能在 <code>provider</code> 块中看到的一个很细微的变化是添加了以前未记录的新校验和，即使 <code>provider</code> 块中的所有其他内容都没有更改：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- .terraform.lock.hcl 2020-10-07 17:24:23.397892140 -0700</span></span><br><span class="line"><span class="comment">+++ .terraform.lock.hcl 2020-10-07 17:24:57.423130253 -0700</span></span><br><span class="line"><span class="meta">@@ -10,6 +10,7 @@</span></span><br><span class="line">   version     = &quot;2.1.0&quot;</span><br><span class="line">   constraints = &quot;~&gt; 2.1.0&quot;</span><br><span class="line">   hashes = [</span><br><span class="line"><span class="addition">+    &quot;h1:1xvaS5D8B8t6J6XmXxX8spo97tAzjhacjedFX1B47Fk=&quot;,</span></span><br><span class="line">     &quot;h1:EOJImaEaVThWasdqnJjfYc6/P8N/MRAq1J7avx5ZbV4=&quot;,</span><br><span class="line">     &quot;zh:0015b491cf9151235e57e35ea6b89381098e61bd923f56dffc86026d58748880&quot;,</span><br><span class="line">     &quot;zh:4c5682ba1e0fc7e2e602d3f103af1638f868c31fe80cc1a884a97f6dad6e1c11&quot;,</span><br></pre></td></tr></table></figure>
<p>在 <code>hashes</code> 中添加的新的校验和代表 Terraform 在不同哈希方案之间逐渐过渡。这些值上的 <code>h1:</code> 和 <code>zh:</code> 前缀代表不同的哈希方案，每个方案都代表使用不同的算法计算校验和。如果现有方案存在某种局限性或者新方案提供了一些相当明显的收益，有时我们可能会引入新的哈希方案。</p>
<p>目前支持两种哈希方案：</p>
<ul>
<li><code>zh:</code>: 代表“zip hash”，这是一种遗留哈希格式，是 Terraform Provider 程序注册表协议的一部分，因此用于直接从源注册表安装的 Provider 程序。</li>
</ul>
<p>此哈希方案捕记录下注册表中索引的每个官方 <code>.zip</code> 包的 SHA256 哈希值。这是验证从注册表安装的官方发布包的有效方案，但它无法验证来自<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html#provider-%E7%9A%84%E5%AE%89%E8%A3%85">其他 Provider 程序安装方法</a>的包，例如文件系统中指向解压后的安装包的镜像。</p>
<ul>
<li><code>h1:</code>: 代表“hash schema 1”，它是当前首选的哈希方案。</li>
</ul>
<p>Hash Schema 1 也是 SHA256 哈希，但它是根据提供 Provider 安装包内包含的内容计算得出的，而不是根据其包含的 <code>.zip</code> 文件的内容计算得出的。因此，该方案的优点是可以针对官方 <code>.zip</code> 文件、具有相同内容的解压目录或包含相同文件但可能具有不同元数据或压缩方案的重新压缩 <code>.zip</code> 文件计算出相同的校验和。</p>
<p>由于 <code>zh:</code> 方案的局限性，Terraform 将在计算出相应的 <code>h1:</code> 校验和时适时添加它们，这就是导致在上面所示的示例更改中添加第二个 <code>h1:</code> 校验和的原因。</p>
<p>Terraform 只会在安装包与已有哈希值之一相匹配时，才会把新计算出的哈希值添加到锁文件中。在上面的示例中，Terraform 在与生成原始 <code>h1:</code> 校验和的平台不同的平台安装了 <code>hashcorp/azurerm</code> 包，但能够匹配到之前记录的 <code>zh:</code> 校验和的其中之一，确认 <code>zh:</code> 校验和匹配后，Terraform 保存相应的 <code>h1:</code> 校验和，以便逐步从旧方案迁移到新方案。</p>
<p>首次安装某个 Provider 程序时（没有已有的 <code>provider</code> 块），Terraform 将使用 Provider 插件开发人员的加密签名（通常涵盖所有可用包）所涵盖适用于所有受支持平台上的该 Provider 程序版本校验集合来预先填充 <code>hashes</code>。但是，由于 Provider 程序注册表协议仍然使用 <code>zh:</code> 方案，因此初始集将主要包含使用该方案的哈希值，然后当我们在不同平台上安装软件包时，Terraform 将适时升级该哈希值。</p>
<p>如果我们希望避免在新目标平台上使用配置时不断添加新的 <code>h1:</code> 哈希值，或者如果因为我们是从镜像安装的 Provider 程序，因此无法提供官方签名的校验和，您可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/15.providers/3.lock.html"><code>terraform providers lock</code></a> 命令要求 Terraform 预填充一组选定平台的哈希值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terraform providers lock \</span><br><span class="line">  -platform=linux_arm64 \</span><br><span class="line">  -platform=linux_amd64 \</span><br><span class="line">  -platform=darwin_amd64 \</span><br><span class="line">  -platform=windows_amd64</span><br></pre></td></tr></table></figure>
<p>上述命令将下载并验证所有四个给定平台上所有我们指定的 Provider 程序的官方软件包，然后在锁文件中记录每个软件包的 <code>zh:</code> 和 <code>h1:</code> 校验和，从而避免 Terraform 在之后只能得到 <code>h1:</code> 校验和这种情况。有关此命令的更多信息，请参阅 <code>terraform providers lock</code> 命令。</p>
<h3 id="1-5-2-1-3-4-那些不再被使用的-Provider"><a href="#%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84-provider"></a>1.5.2.1.3.4. 那些不再被使用的 Provider</h3>
<p>为了确定是否仍然存在对某个 Provider 程序的依赖，Terraform 使用两个事实来源：配置代码和状态。如果我们从配置和状态中删除对某个 Provider 程序的最后一个依赖项，则 <code>terraform init</code> 将从锁文件中删除该 Provider 的现存记录。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- .terraform.lock.hcl 2020-10-07 16:12:07.539570634 -0700</span></span><br><span class="line"><span class="comment">+++ .terraform.lock.hcl 2020-10-07 16:12:15.267487237 -0700</span></span><br><span class="line"><span class="meta">@@ -6,26 +6,6 @@</span></span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-provider &quot;registry.terraform.io/hashicorp/azurerm&quot; &#123;</span></span><br><span class="line"><span class="deletion">-  version     = &quot;2.30.0&quot;</span></span><br><span class="line"><span class="deletion">-  constraints = &quot;~&gt; 2.12&quot;</span></span><br><span class="line"><span class="deletion">-  hashes = [</span></span><br><span class="line"><span class="deletion">-    &quot;h1:FJwsuowaG5CIdZ0WQyFZH9r6kIJeRKts9+GcRsTz1+Y=&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;h1:c/ntSXrDYM1mUir2KufijYebPcwKqS9CRGd3duDSGfY=&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;h1:yre4Ph76g9H84MbuhZ2z5MuldjSA4FsrX6538O7PCcY=&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:04f0a50bb2ba92f3bea6f0a9e549ace5a4c13ef0cbb6975494cac0ef7d4acb43&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:2082e12548ebcdd6fd73580e83f626ed4ed13f8cdfd51205d8696ffe54f30734&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:246bcc449e9a92679fb30f3c0a77f05513886565e2dcc66b16c4486f51533064&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:24de3930625ac9014594d79bfa42d600eca65e9022b9668b54bfd0d924e21d14&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:2a22893a576ff6f268d9bf81cf4a56406f7ba79f77826f6df51ee787f6d2840a&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:2b27485e19c2aaa9f15f29c4cff46154a9720647610171e30fc6c18ddc42ec28&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:435f24ce1fb2b63f7f02aa3c84ac29c5757cd29ec4d297ed0618423387fe7bd4&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:7d99725923de5240ff8b34b5510569aa4ebdc0bdb27b7bac2aa911a8037a3893&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:7e3b5d0af3b7411dd9dc65ec9ab6caee8c191aee0fa7f20fc4f51716e67f50c0&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:da0af4552bef5a29b88f6a0718253f3bf71ce471c959816eb7602b0dadb469ca&quot;,</span></span><br><span class="line"><span class="deletion">-  ]</span></span><br><span class="line"><span class="deletion">-&#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"> provider &quot;registry.terraform.io/newrelic/newrelic&quot; &#123;</span><br><span class="line">   version     = &quot;2.1.2&quot;</span><br><span class="line">   constraints = &quot;~&gt; 2.1.1&quot;</span><br></pre></td></tr></table></figure>
<p>如果我们稍后为同一 Provider 程序添加新的引用并再次运行 <code>terraform init</code>，Terraform 会将其视为全新的 Provider 程序，因此不一定会选择之前选择的相同版本，并且无法验证校验和是否保持不变。</p>
<p><strong>注意</strong>：在 Terraform v1.0 及更早版本中，<code>terraform init</code> 不会自动从锁文件中删除现在不需要的 Provider 程序，而只是忽略它们。如果您之前使用早期版本的 Terraform 时删除了提供 Provider 依赖项，然后升级到 Terraform v1.1 或更高版本，那么您可能会看到错误“missing or corrupted provider plugins”，指向过时的锁文件条目。如果是这样，请使用新的 Terraform 版本运行 <code>terraform init</code> 以整理那些不需要的条目，然后重试之前的操作。</p>
<ul>
<li>
<p><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6"><strong>1.5.3.1.</strong> 测试文件</a></p>
</li>
<li>
<p><a href="#%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><strong>1.5.3.1.1.</strong> 文件扩展名</a></p>
</li>
<li>
<p><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE"><strong>1.5.3.1.2.</strong> 测试文件的位置</a></p>
</li>
</ul>
<p><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6"></a></p>
<h2 id="1-5-3-1-测试文件"><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6"></a>1.5.3.1. 测试文件</h2>
<p>某些的 Terraform 命令（例如 <code>test</code>、<code>init</code> 和 <code>validate</code>）会针对配置代码加载 Terraform 测试文件。</p>
<p>测试文件包含 Terraform 测试执行的代码。有关 Terraform 测试命令的更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/23.test.html">命令：<code>test</code></a>。有关语法和 Terraform 测试文件语言的更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/">测试</a>。</p>
<h2 id="1-5-3-1-1-文件扩展名"><a href="#%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"></a>1.5.3.1.1. 文件扩展名</h2>
<p>测试文件的扩展名是 <code>.tftest.hcl</code> 以及 <code>.tftest.json</code>。</p>
<h2 id="1-5-3-1-2-测试文件的位置"><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE"></a>1.5.3.1.2. 测试文件的位置</h2>
<p>Terraform 加载根模块目录中的所有测试文件。</p>
<p>Terraform 还会加载测试目录中的测试文件。我们可以通过在那些会加载测试文件的命令后添加 <code>-test-directory</code> 参数来修改测试目录的位置。默认测试目录是根模块目录下的 <code>tests</code> 目录。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/21/Teraform/Terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/19/Teraform/Terraform-%E4%BB%A3%E7%A0%81/"
                            aria-label=": Terraform-代码-类型"
                        >
                            Terraform-代码-类型
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-19T17:43:45+08:00">
	
		    2023 年 1 月 19 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#%E7%B1%BB%E5%9E%8B"><strong>1.4.1.1.</strong> 类型</a></p>
</li>
<li>
<p><a href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><strong>1.4.1.1.1.</strong> 原始类型</a></p>
</li>
<li>
<p><a href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"><strong>1.4.1.1.2.</strong> 复杂类型</a></p>
</li>
<li>
<p><a href="#any"><strong>1.4.1.1.3.</strong> any</a></p>
</li>
<li>
<p><a href="#null"><strong>1.4.1.1.4.</strong> null</a></p>
</li>
<li>
<p><a href="#object-%E7%9A%84-optional-%E6%88%90%E5%91%98"><strong>1.4.1.1.5.</strong> object 的 optional 成员</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B8%A6%E6%9C%89-optional-%E5%B1%9E%E6%80%A7%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84"><strong>1.4.1.1.5.1.</strong> 例子：带有 optional 属性和默认值的内嵌结构</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7"><strong>1.4.1.1.5.2.</strong> 例子：有条件地设置一个默认属性</a></p>
</li>
</ul>
<p><a href="#%E7%B1%BB%E5%9E%8B"></a></p>
<h2 id="1-4-1-1-类型"><a href="#%E7%B1%BB%E5%9E%8B"></a>1.4.1.1. 类型</h2>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/8.%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>的结果是一个值。所有的值都有一个类型，这个类型决定了这个值可以在哪里使用以及可以对它应用哪些转换。</p>
<p>Terraform 的某些类型之间存在隐式类型转换规则，如果无法隐式转换类型，那么不同类型数据间的赋值将会报错。</p>
<p>Terraform 类型分为原始类型、复杂类型，以及 <code>null</code>。</p>
<h2 id="1-4-1-1-1-原始类型"><a href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"></a>1.4.1.1.1. 原始类型</h2>
<p>原始类型分三类：<code>string</code>、<code>number</code>、<code>bool</code>。</p>
<ul>
<li><code>string</code> 代表一组 Unicode 字符串，例如：<code>&quot;hello&quot;</code>。</li>
<li><code>number</code> 代表数字，可以为整数，也可以为小数。</li>
<li><code>bool</code> 代表布尔值，要么为 <code>true</code>，要么为 <code>false</code>。<code>bool</code> 值可以被用做逻辑判断。</li>
</ul>
<p><code>number</code> 和 <code>bool</code> 都可以和 <code>string</code> 进行隐式转换，当我们把 <code>number</code> 或 <code>bool</code> 类型的值赋给 <code>string</code> 类型的值，或是反过来时，Terraform 会自动替我们转换类型，其中：</p>
<ul>
<li><code>true</code> 值会被转换为 <code>&quot;true&quot;</code>，反之亦然</li>
<li><code>false</code> 值会被转换为 <code>&quot;false&quot;</code>，反之亦然</li>
<li><code>15</code> 会被转换为 <code>&quot;15&quot;</code>，<code>3.1415</code> 会被转换为 <code>&quot;3.1415&quot;</code>，反之亦然</li>
</ul>
<h2 id="1-4-1-1-2-复杂类型"><a href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"></a>1.4.1.1.2. 复杂类型</h2>
<p>复杂类型是一组值所组成的符合类型，有两类复杂类型。</p>
<p>一种是集合类型。一个集合包含了一组同一类型的值。集合内元素的类型成为元素类型。一个集合变量在构造时必须确定集合类型。集合内所有元素的类型必须相同。</p>
<p>Terraform 支持三种集合：</p>
<ul>
<li>
<p><code>list(...)</code>：列表是一组值的连续集合，可以用下标访问内部元素，下标从 <code>0</code> 开始。例如名为 <code>l</code> 的 <code>list</code>，<code>l[0]</code> 就是第一个元素。<code>list</code> 类型的声明可以是 <code>list(number)</code>、<code>list(string)</code>、<code>list(bool)</code>等，括号中的类型即为元素类型。</p>
</li>
<li>
<p><code>map(...)</code>：字典类型(或者叫映射类型)，代表一组键唯一的键值对，键类型必须是 <code>string</code>，值类型任意。<code>map(number)</code> 代表键为 <code>string</code> 类型而值为 <code>number</code> 类型，其余类推。<code>map</code> 值有两种声明方式，一种是类似 <code>&#123;&quot;foo&quot;: &quot;bar&quot;, &quot;bar&quot;: &quot;baz&quot;&#125;</code>，另一种是 <code>&#123;foo=&quot;bar&quot;, bar=&quot;baz&quot;&#125;</code>。键可以不用双引号，但如果键是以数字开头则例外。多对键值对之间要用逗号分隔，也可以用换行符分隔。推荐使用 <code>=</code> 号(Terraform 代码规范中规定按等号对齐，使用等号会使得代码在格式化后更加美观)</p>
</li>
<li>
<p><code>set(...)</code>：集合类型，代表一组不重复的值。</p>
</li>
</ul>
<p>以上集合类型都支持通配类型缩写，例如 <code>list</code> 等价于 <code>list(any)</code>，<code>map</code> 等价于 <code>map(any)</code>，<code>set</code> 等价于 <code>set(any)</code>。<code>any</code> 代表支持任意的元素类型，前提是所有元素都是一个类型。例如，将 <code>list(number)</code> 赋给 <code>list(any)</code> 是合法的，<code>list(string)</code> 赋给 <code>list(any)</code> 也是合法的，但是 <code>list</code> 内部所有的元素必须是同一种类型的。</p>
<p>第二种复杂类型是结构化类型。一个结构化类型允许多个不同类型的值组成一个类型。结构化类型需要提供一个 <code>schema</code> 结构信息作为参数来指明元素的结构。</p>
<p>Terraform 支持两种结构化类型：</p>
<ul>
<li><code>object(...)</code>：对象是指一组由具有名称和类型的属性所构成的符合类型，它的 schema 信息由 <code>&#123; \&lt;KEY\&gt;=\&lt;TYPE\&gt;, \&lt;KEY\&gt;=\&lt;TYPE\&gt;,...&#125;</code> 的形式描述，例如 <code>object(&#123;age=number, name=string&#125;)</code>，代表由名为 <code>&quot;age“</code> 类型为<code>number</code>，以及名为 <code>&quot;name&quot;</code> 类型为 <code>string</code> 两个属性组成的对象。赋给 <code>object</code> 类型的合法值必须含有所有属性值，但是可以拥有多余的属性(多余的属性在赋值时会被抛弃)。例如对于 <code>object(&#123;age=number,name=string&#125;)</code> 来说，<code>&#123; age=18 &#125;</code> 是一个非法值，而 <code>&#123; age=18, name=&quot;john&quot;, gender=&quot;male&quot; &#125;</code> 是一个合法值，但赋值时 <code>gender</code> 会被抛弃</li>
<li><code>tuple(...)</code>：元组类似 <code>list</code>，也是一组值的连续集合，但每个元素都有独立的类型。元组同 <code>list</code> 一样，也可以用下标访问内部元素，下标从 <code>0</code> 开始。元组 schema 用 <code>[\&lt;TYPE\&gt;, \&lt;TYPE\&gt;, ...]</code> 的形式描述。元组的元素数量必须与 schema 声明的类型数量相等，并且每个元素的类型必须与元组 schema 相应位置的类型相等。例如，<code>tuple([string, number, bool])</code> 类型的一个合法值可以是 <code>[&quot;a&quot;, 15, true]</code></li>
</ul>
<p>复杂类型也支持隐式类型转换。</p>
<p>Terraform 会尝试转换相似的类型，转换规则有：</p>
<ul>
<li><code>object</code> 和 <code>map</code>：如果一个 <code>map</code> 的键集合含有 <code>object</code> 规定的所有属性，那么 <code>map</code> 可以被转换为 <code>object</code>，<code>map</code> 里多余的键值对会被抛弃。由 <code>map</code> -&gt; <code>object</code> -&gt; <code>map</code> 的转换可能会丢失数据。</li>
<li><code>tuple</code> 和 <code>list</code>：当一个 <code>list</code> 元素的数量正好等于一个 <code>tuple</code> 声明的长度时，<code>list</code> 可以被转换为 <code>tuple</code>。例如：值为 <code>[&quot;18&quot;, &quot;true&quot;, &quot;john&quot;]</code> 的 <code>list</code> 转换为 <code>tuple([number,bool, string])</code> 的结果为 <code>[18, true, &quot;john&quot;]</code></li>
<li><code>set</code> 和 <code>tuple</code>：当一个 <code>list</code> 或是 <code>tuple</code> 被转换为一个 <code>set</code>，那么重复的值将被丢弃，并且值原有的顺序也将丢失。如果一个 <code>set</code> 被转换到 <code>list</code> 或是 <code>tuple</code>，那么元素将按照以下顺序排列：如果 <code>set</code> 的元素是 <code>string</code>，那么将按照字段顺序排列；其他类型的元素不承诺任何特定的排列顺序。</li>
</ul>
<p>复杂类型转换时，元素类型将在可能的情况下发生隐式转换，类似上述 <code>list</code> 到 <code>tuple</code> 转换举的例子。</p>
<p>如果类型不匹配，Terraform 会报错，例如我们试图把<code>object(&#123;name = [&quot;Kristy&quot;, &quot;Claudia&quot;, &quot;Mary Anne&quot;, &quot;Stacey&quot;], age = 12&#125;)</code>转换到 <code>map(string)</code> 类型，这是不合法的，因为 <code>name</code> 的值为 <code>list</code>，无法转换为 <code>string</code>。</p>
<h2 id="1-4-1-1-3-any"><a href="#any"></a>1.4.1.1.3. any</h2>
<p><code>any</code> 是 Terraform 中非常特殊的一种类型约束，它本身并非一个类型，而只是一个占位符。每当一个值被赋予一个由 <code>any</code> 约束的复杂类型时，Terraform 会尝试计算出一个最精确的类型来取代 <code>any</code>。</p>
<p>例如我们把 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code> 赋给 <code>list(any)</code>，它在 Terraform 中实际的物理类型首先被编译成 <code>tuple([string, string, string])</code>，然后 Terraform 认为 <code>tuple</code> 和 <code>list</code> 相似，所以会尝试将它转换为 <code>list(string)</code>。然后 Terraform 发现 <code>list(string)</code> 符合 <code>list(any)</code> 的约束，所以会用 <code>string</code> 取代 <code>any</code>，于是赋值后最终的类型是 <code>list(string)</code>。</p>
<p>由于即使是 <code>list(any)</code>，所有元素的类型也必须是一样的，所以某些类型转换到 <code>list(any)</code> 时会对元素进行隐式类型转换。例如将 <code>[&quot;a&quot;, 1, &quot;b&quot;]</code> 赋给 <code>list(any)</code>，Terraform 发现 <code>1</code> 可以转换到 <code>&quot;1&quot;</code>，所以最终的值是 <code>[&quot;a&quot;, &quot;1&quot;, &quot;b&quot;]</code>，最终的类型会是 <code>list(string)</code>。再比如我们想把 <code>[&quot;a&quot;, \[\], &quot;b&quot;]</code> 转换成 <code>list(any)</code>，由于 Terraform 无法找到一个一个合适的目标类型使得所有元素都能成功隐式转换过去，所以 Terraform 会报错，要求所有元素都必须是同一个类型的。</p>
<p>声明类型时如果不想有任何的约束，那么可以用 <code>any</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;no_type_constraint&quot; &#123;</span><br><span class="line">  type = any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，Terraform 可以将任何类型的数据赋予它。</p>
<h2 id="1-4-1-1-4-null"><a href="#null"></a>1.4.1.1.4. null</h2>
<p>存在一种特殊值是无类型的，那就是 <code>null</code>。<code>null</code> 代表数据缺失。如果我们把一个参数设置为 <code>null</code>，Terraform 会认为你忘记为它赋值。如果该参数有默认值，那么 Terraform 会使用默认值；如果没有又恰巧该参数是必填字短，Terraform 会报错。<code>null</code> 在条件表达式中非常有用，你可以在某项条件不满足时跳过对某参数的赋值。</p>
<h2 id="1-4-1-1-5-object-的-optional-成员"><a href="#object-%E7%9A%84-optional-%E6%88%90%E5%91%98"></a>1.4.1.1.5. object 的 optional 成员</h2>
<p>自 Terraform 1.3 开始，我们可以在 <code>object</code> 类型定义中使用 <code>optional</code> 修饰属性。</p>
<p>在 1.3 之前，如果一个 <code>variable</code> 的类型为 <code>object</code>，那么使用时必须传入一个结构完全相符的对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;an_object&quot; &#123;</span><br><span class="line">  type = object(&#123;</span><br><span class="line">    a = string</span><br><span class="line">    b = string</span><br><span class="line">    c = number</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想传入一个对象给 <code>var.an_object</code>，但不准备给 <code>b</code> 和 <code>c</code> 赋值，我们必须这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a = &quot;a&quot;</span><br><span class="line">  b = null</span><br><span class="line">  c = null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入的对象必须完全匹配类型定义的结构，哪怕我们不想对某些属性赋值。这使得我们如果想要定义一些比较复杂，属性比较多的 <code>object</code> 类型时会给用户在使用上造成一些麻烦。</p>
<p>Terraform 1.3 允许我们为一个属性添加 <code>optional</code> 声明，还是用上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;with_optional_attribute&quot; &#123;</span><br><span class="line">  type = object(&#123;</span><br><span class="line">    a = string                # a required attribute</span><br><span class="line">    b = optional(string)      # an optional attribute</span><br><span class="line">    c = optional(number, 127) # an optional attribute with default value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们将 <code>b</code> 声明为 <code>optional</code>，如果传入的对象没有 <code>b</code>，则会使用 <code>null</code> 作为值；<code>c</code> 不但声明为 <code>optional</code> 的，还添加了 <code>127</code> 作为默认值，传入的对象如果没有 <code>c</code>，那么会使用 <code>127</code> 作为它的值。</p>
<p><code>optional</code> 修饰符有这样两个参数：</p>
<ul>
<li>类型：（必填）第一个参数标明了属性的类型</li>
<li>默认值：（选填）第二个参数定义了 Terraform 在对象中没有定义该属性值时使用的默认值。默认值必须与类型参数兼容。如果没有指定默认值，Terraform 会使用 <code>null</code> 作为默认值。</li>
</ul>
<p>一个包含非 <code>null</code> 默认值的 <code>optional</code> 属性在模块内使用时可以确保不会读到 <code>null</code> 值。当用户没有设置该属性，或是显式将其设置为 <code>null</code> 时，Terraform 会使用默认值，所以模块内无需再次判断该属性是否为 <code>null</code>。</p>
<p>Terraform 采用自上而下的顺序来设置对象的默认值，也就是说，Terraform 会先应用 <code>optional</code> 修饰符中的指定的默认值，然后再为其中可能存在的内嵌对象设置默认值。</p>
<h3 id="1-4-1-1-5-1-例子：带有-optional-属性和默认值的内嵌结构"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B8%A6%E6%9C%89-optional-%E5%B1%9E%E6%80%A7%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84"></a>1.4.1.1.5.1. 例子：带有 optional 属性和默认值的内嵌结构</h3>
<p>下面的例子演示了一个输入变量，用来描述一个存储了静态网站内容的存储桶。该变量的类型包含了一系列的 <code>optional</code> 属性，包括 <code>website</code>，不但其自身是 <code>optional</code> 的，其内部包含了数个 <code>optional</code> 的属性以及默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;buckets&quot; &#123;</span><br><span class="line">  type = list(object(&#123;</span><br><span class="line">    name    = string</span><br><span class="line">    enabled = optional(bool, true)</span><br><span class="line">    website = optional(object(&#123;</span><br><span class="line">      index_document = optional(string, &quot;index.html&quot;)</span><br><span class="line">      error_document = optional(string, &quot;error.html&quot;)</span><br><span class="line">      routing_rules  = optional(string)</span><br><span class="line">    &#125;), &#123;&#125;)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下给出一个样例 <code>terraform.tfvars</code> 文件，为 <code>var.buckets</code> 定义了三个存储桶：</p>
<ul>
<li><code>production</code> 配置了一条重定向的路由规则</li>
<li><code>archived</code> 使用了默认配置，但被关闭了</li>
<li><code>docs</code> 使用文本文件取代了索引页和错误页</li>
</ul>
<p><code>production</code> 桶没有指定索引页和错误页，<code>archived</code> 桶完全忽略了网站配置。Terraform 会使用 <code>bucket</code> 类型约束中指定的默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">buckets = [</span><br><span class="line">  &#123;</span><br><span class="line">    name = &quot;production&quot;</span><br><span class="line">    website = &#123;</span><br><span class="line">      routing_rules = &lt;&lt;-EOT</span><br><span class="line">      [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;Condition&quot; = &#123; &quot;KeyPrefixEquals&quot;: &quot;img/&quot; &#125;,</span><br><span class="line">          &quot;Redirect&quot;  = &#123; &quot;ReplaceKeyPrefixWith&quot;: &quot;images/&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">      EOT</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name = &quot;archived&quot;</span><br><span class="line">    enabled = false</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name = &quot;docs&quot;</span><br><span class="line">    website = &#123;</span><br><span class="line">      index_document = &quot;index.txt&quot;</span><br><span class="line">      error_document = &quot;error.txt&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>该配置会产生如下的 <code>variable</code> 值：</p>
<ul>
<li>对 <code>production</code> 和 <code>docs</code> 桶，Terraform 会将 <code>enabled</code> 设置为 <code>true</code>。Terraform 会同时使用默认值配置 <code>website</code>，然后使用 <code>docs</code> 中指定的值来覆盖默认值。</li>
<li>对 <code>archived</code> 和 <code>docs</code> 桶，Terraform 会将 <code>routing_rules</code> 设置为 <code>null</code>。当 Terraform 没有读取到 <code>optional</code> 的属性，并且属性上没有设置默认值时，Terraform 会将这些属性设置为 <code>null</code>。</li>
<li>对于 <code>archived</code> 桶，Terraform 会将 <code>website</code> 属性设置为 <code>buckets</code> 类型约束中定义的默认值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">tolist([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;enabled&quot; = true</span><br><span class="line">    &quot;name&quot; = &quot;production&quot;</span><br><span class="line">    &quot;website&quot; = &#123;</span><br><span class="line">      &quot;error_document&quot; = &quot;error.html&quot;</span><br><span class="line">      &quot;index_document&quot; = &quot;index.html&quot;</span><br><span class="line">      &quot;routing_rules&quot; = &lt;&lt;-EOT</span><br><span class="line">      [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;Condition&quot; = &#123; &quot;KeyPrefixEquals&quot;: &quot;img/&quot; &#125;,</span><br><span class="line">          &quot;Redirect&quot;  = &#123; &quot;ReplaceKeyPrefixWith&quot;: &quot;images/&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">      EOT</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;enabled&quot; = false</span><br><span class="line">    &quot;name&quot; = &quot;archived&quot;</span><br><span class="line">    &quot;website&quot; = &#123;</span><br><span class="line">      &quot;error_document&quot; = &quot;error.html&quot;</span><br><span class="line">      &quot;index_document&quot; = &quot;index.html&quot;</span><br><span class="line">      &quot;routing_rules&quot; = tostring(null)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;enabled&quot; = true</span><br><span class="line">    &quot;name&quot; = &quot;docs&quot;</span><br><span class="line">    &quot;website&quot; = &#123;</span><br><span class="line">      &quot;error_document&quot; = &quot;error.txt&quot;</span><br><span class="line">      &quot;index_document&quot; = &quot;index.txt&quot;</span><br><span class="line">      &quot;routing_rules&quot; = tostring(null)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h3 id="1-4-1-1-5-2-例子：有条件地设置一个默认属性"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7"></a>1.4.1.1.5.2. 例子：有条件地设置一个默认属性</h3>
<p>有时我们需要根据其他数据的值来动态决定是否要为一个 <code>optional</code> 参数设置值。在这种场景下，发起调用的 <code>module</code> 块可以使用条件表达式搭配 <code>null</code> 来动态地决定是否设置该参数。</p>
<p>还是上一个例子中的 <code>variable &quot;buckets&quot;</code> 的例子，使用下面演示的例子可以根据新输入参数 <code>var.legacy_filenames</code> 的值来有条件地覆盖 <code>website</code> 对象中 <code>index_document</code> 以及 <code>error_document</code> 的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;legacy_filenames&quot; &#123;</span><br><span class="line">  type     = bool</span><br><span class="line">  default  = false</span><br><span class="line">  nullable = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;buckets&quot; &#123;</span><br><span class="line">  source = &quot;./modules/buckets&quot;</span><br><span class="line"></span><br><span class="line">  buckets = [</span><br><span class="line">    &#123;</span><br><span class="line">      name = &quot;maybe_legacy&quot;</span><br><span class="line">      website = &#123;</span><br><span class="line">        error_document = var.legacy_filenames ? &quot;ERROR.HTM&quot; : null</span><br><span class="line">        index_document = var.legacy_filenames ? &quot;INDEX.HTM&quot; : null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>var.legacy_filenames</code> 设置为 <code>true</code> 时，调用会覆盖 <code>document</code> 的文件名。当它的值为 <code>false</code> 时，调用不会指定这两个文件名，这样就会使得模块使用定义的默认值。</p>
<ul>
<li>
<p><a href="#%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95"><strong>1.4.2.1.</strong> 配置语法</a></p>
</li>
<li>
<p><a href="#%E5%8F%82%E6%95%B0"><strong>1.4.2.1.1.</strong> 参数</a></p>
</li>
<li>
<p><a href="#%E5%9D%97"><strong>1.4.2.1.2.</strong> 块</a></p>
</li>
<li>
<p><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88identifiers%EF%BC%89"><strong>1.4.2.1.3.</strong> 标识符（Identifiers）</a></p>
</li>
<li>
<p><a href="#%E6%B3%A8%E9%87%8A"><strong>1.4.2.1.4.</strong> 注释</a></p>
</li>
<li>
<p><a href="#%E7%BC%96%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%8D%A2%E8%A1%8C"><strong>1.4.2.1.5.</strong> 编码以及换行</a></p>
</li>
</ul>
<p><a href="#%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95"></a></p>
<h2 id="1-4-2-1-配置语法"><a href="#%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95"></a>1.4.2.1. 配置语法</h2>
<p>这里讲的仍然是 HCL 的语法，但我们只讲一些关键语法。如果读者有兴趣了解完整信息可以访问 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/hcl/blob/hcl2/hclsyntax/spec.md">HCL 语法规约</a></p>
<p>HCL 的语法由两个关键元素构成：参数(Argument)与块(Block)</p>
<h2 id="1-4-2-1-1-参数"><a href="#%E5%8F%82%E6%95%B0"></a>1.4.2.1.1. 参数</h2>
<p>HCL 中的参数就是将一个值赋给一个特定的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image_id = &quot;abc123&quot;</span><br></pre></td></tr></table></figure>
<p>等号前的标识符就是参数名，等号后的表达式就是参数值。参数赋值时 Terraform 会检查类型是否匹配。参数名是确定的，参数值可以是确定的字面量硬编码，也可以是一组表达式，用以通过其他的值加以计算得出结果值。</p>
<h2 id="1-4-2-1-2-块"><a href="#%E5%9D%97"></a>1.4.2.1.2. 块</h2>
<p>一个块是包含一组其他内容（参数和块）的容器，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami = &quot;abc123&quot;</span><br><span class="line"></span><br><span class="line">  network_interface &#123;</span><br><span class="line">    # ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个块有一个类型(上面的例子里类型就是 <code>resource</code>)。每个块类型都定义了类型关键字后面要跟多少标签，例如 <code>resource</code> 块规定了后面要跟两个标签 —— 在例子里就是 <code>aws_instance</code> 和 <code>example</code>。一个块类型可以规定任意多个标签，也可以没有标签，比如内嵌的 <code>network_interface</code> 块。</p>
<p>在块类型及其后续标签之后，就是块体。块体必须被包含在一对花括号中间。在块体中可以进一步定义各种参数和其他的块。</p>
<p>Terraform 规范定义了有限个顶级块类型，也就是可以游离于任何其他块独立定义在配置文件中的块。大部分的 Terraform 功能(例如 <code>resource</code>, <code>variable</code>, <code>output</code>, <code>data</code>等)都是顶级块。</p>
<h2 id="1-4-2-1-3-标识符（Identifiers）"><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88identifiers%EF%BC%89"></a>1.4.2.1.3. 标识符（Identifiers）</h2>
<p>参数名、块类型名以及其他 Terraform 规范中定义的结构的名称，例如 <code>resource</code>、<code>variable</code> 等，都是标识符。</p>
<p>合法的标识符可以包含字母、数字、下划线(<code>_</code>)以及连字符(<code>-</code>)。标识符首字母不可以为数字。</p>
<p>要了解完整的标识符规范，请访问 <a target="_blank" rel="noopener" href="http://unicode.org/reports/tr31/">Unicode 标识符语法</a>。</p>
<h2 id="1-4-2-1-4-注释"><a href="#%E6%B3%A8%E9%87%8A"></a>1.4.2.1.4. 注释</h2>
<p>Terraform支持三种注释：</p>
<ul>
<li><code>#</code> 单行注释，其后的内容为注释</li>
<li><code>//</code> 单行注释，其后的内容为注释</li>
<li><code>/*</code> 和 <code>*/</code>，多行注释，可以注释多行</li>
</ul>
<p>默认情况下单行注释优先使用 <code>#</code>。自动化格式整理工具会自动把 <code>//</code> 替换成 <code>#</code>。</p>
<h2 id="1-4-2-1-5-编码以及换行"><a href="#%E7%BC%96%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%8D%A2%E8%A1%8C"></a>1.4.2.1.5. 编码以及换行</h2>
<p>Terraform 配置文件必须始终使用 UTF-8 编码。分隔符必须使用 ASCII 符号，其他标识符、注释以及字符串字面量均可使用非 ASCII 字符。</p>
<p>Terraform 兼容 Unix 风格的换行符（LF）以及 Windows 风格的换行符（CRLF），但是理想状态下应使用 Unix 风格换行符。</p>
<ul>
<li>
<p><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F"><strong>1.4.3.1.</strong> 输入变量</a></p>
</li>
<li>
<p><a href="#%E7%B1%BB%E5%9E%8B-type"><strong>1.4.3.1.1.</strong> 类型 (type)</a></p>
</li>
<li>
<p><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC-default"><strong>1.4.3.1.2.</strong> 默认值 (default)</a></p>
</li>
<li>
<p><a href="#%E6%8F%8F%E8%BF%B0-description"><strong>1.4.3.1.3.</strong> 描述 (description)</a></p>
</li>
<li>
<p><a href="#%E6%96%AD%E8%A8%80-validation"><strong>1.4.3.1.4.</strong> 断言 (validation)</a></p>
</li>
<li>
<p><a href="#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%EF%BC%88ephemeral%EF%BC%89"><strong>1.4.3.1.5.</strong> 临时输入变量（ephemeral）</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"><strong>1.4.3.1.6.</strong> 在命令行输出中隐藏值 (sensitive)</a></p>
</li>
<li>
<p><a href="#terraform-%E5%8F%AF%E8%83%BD%E6%9A%B4%E9%9C%B2%E6%95%8F%E6%84%9F%E5%8F%98%E9%87%8F%E7%9A%84%E6%83%85%E5%86%B5"><strong>1.4.3.1.6.1.</strong> Terraform 可能暴露敏感变量的情况</a></p>
</li>
<li>
<p><a href="#%E7%A6%81%E6%AD%A2%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E4%B8%BA%E7%A9%BA-nullable"><strong>1.4.3.1.7.</strong> 禁止输入变量为空 (nullable)</a></p>
</li>
<li>
<p><a href="#%E5%AF%B9%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><strong>1.4.3.1.8.</strong> 对输入变量赋值</a></p>
</li>
<li>
<p><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><strong>1.4.3.1.8.1.</strong> 命令行参数</a></p>
</li>
<li>
<p><a href="#%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6"><strong>1.4.3.1.8.2.</strong> 参数文件</a></p>
</li>
<li>
<p><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><strong>1.4.3.1.8.3.</strong> 环境变量</a></p>
</li>
<li>
<p><a href="#%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2%E4%BC%A0%E5%80%BC"><strong>1.4.3.1.8.4.</strong> 交互界面传值</a></p>
</li>
<li>
<p><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%BC%98%E5%85%88%E7%BA%A7"><strong>1.4.3.1.9.</strong> 输入变量赋值优先级</a></p>
</li>
<li>
<p><a href="#terraform-%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E5%80%BC"><strong>1.4.3.1.9.1.</strong> Terraform 测试中的输入变量值</a></p>
</li>
<li>
<p><a href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%80%BC"><strong>1.4.3.1.10.</strong> 复杂类型传值</a></p>
</li>
</ul>
<p><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F"></a></p>
<h2 id="1-4-3-1-输入变量"><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F"></a>1.4.3.1. 输入变量</h2>
<p>在前面的例子中，我们在代码中都是使用字面量硬编码的，如果我们想要在创建、修改基础设施时动态传入一些值呢？比如说在代码中定义 Provider 时用变量替代硬编码的访问密钥，或是由创建基础设施的用户来决定创建什么样尺寸的主机？我们需要的是输入变量。</p>
<p>如果我们把一组 Terraform 代码想像成一个函数，那么输入变量就是函数的入参。输入变量用 <code>variable</code> 块进行定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;image_id&quot; &#123;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;availability_zone_names&quot; &#123;</span><br><span class="line">  type    = list(string)</span><br><span class="line">  default = [&quot;us-west-1a&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;docker_ports&quot; &#123;</span><br><span class="line">  type = list(object(&#123;</span><br><span class="line">    internal = number</span><br><span class="line">    external = number</span><br><span class="line">    protocol = string</span><br><span class="line">  &#125;))</span><br><span class="line">  default = [</span><br><span class="line">    &#123;</span><br><span class="line">      internal = 8300</span><br><span class="line">      external = 8300</span><br><span class="line">      protocol = &quot;tcp&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是合法的输入参数定义。紧跟 <code>variable</code> 关键字的就是变量名。在一个 Terraform 模块(同一个文件夹中的所有 Terraform 代码文件，不包含子文件夹)中变量名必须是唯一的。我们在代码中可以通过<code>var.&lt;NAME&gt;</code>的方式引用变量的值。有一组关键字<strong>不可以</strong>被用作输入变量的名字：</p>
<ul>
<li><code>source</code></li>
<li><code>version</code></li>
<li><code>providers</code></li>
<li><code>count</code></li>
<li><code>for_each</code></li>
<li><code>lifecycle</code></li>
<li><code>depends_on</code></li>
<li><code>locals</code></li>
</ul>
<p>输入变量只能在声明该变量的目录下的代码中使用。</p>
<p>输入变量块中可以定义一些属性。</p>
<h2 id="1-4-3-1-1-类型-type"><a href="#%E7%B1%BB%E5%9E%8B-type"></a>1.4.3.1.1. 类型 (type)</h2>
<p>可以在输入变量块中通过 <code>type</code> 定义类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;name&quot; &#123;</span><br><span class="line">    type = string</span><br><span class="line">&#125;</span><br><span class="line">variable &quot;ports&quot; &#123;</span><br><span class="line">    type = list(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了类型的输入变量只能被赋予符合类型约束的值。</p>
<h2 id="1-4-3-1-2-默认值-default"><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC-default"></a>1.4.3.1.2. 默认值 (default)</h2>
<p>默认值定义了当 Terraform 无法获得一个输入变量得到值的时候会使用的默认值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;name&quot; &#123;</span><br><span class="line">    type    = string</span><br><span class="line">    default = &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Terraform 无法通过其他途径获得name的值时，<code>var.name</code> 的值为 <code>&quot;John Doe&quot;</code>。</p>
<h2 id="1-4-3-1-3-描述-description"><a href="#%E6%8F%8F%E8%BF%B0-description"></a>1.4.3.1.3. 描述 (description)</h2>
<p>可以在输入变量中定义一个描述，简单地向调用者描述该变量的意义和用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;image_id&quot; &#123;</span><br><span class="line">  type        = string</span><br><span class="line">  description = &quot;The id of the machine image (AMI) to use for the server.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在执行 <code>terraform plan</code> 或是 <code>terraform apply</code> 时 Terraform 不知道某个输入变量的值，Terraform 会在命令行界面上提示我们为输入变量设置一个值。例如上面的输入变量代码，执行 <code>terraform apply</code> 时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply</span><br><span class="line">var.image_id</span><br><span class="line">  The <span class="built_in">id</span> of the machine image (AMI) to use <span class="keyword">for</span> the server.</span><br><span class="line"></span><br><span class="line">  Enter a value:</span><br></pre></td></tr></table></figure>
<p>为了使得代码的使用者能够准确理解输入变量的意义和用法，我们应该站在代码使用者而非代码维护者的角度编写输入变量的描述。<strong>描述并不是注释！</strong></p>
<h2 id="1-4-3-1-4-断言-validation"><a href="#%E6%96%AD%E8%A8%80-validation"></a>1.4.3.1.4. 断言 (validation)</h2>
<p>输入变量的断言是 Terraform 0.13.0 开始引入的新功能，在过去，Terraform 只能用类型约束确保输入参数的类型是正确的，曾经有不少人试图通过奇技淫巧来实现更加复杂的变量校验断言。如今 Terraform 终于正式添加了相关的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;image_id&quot; &#123;</span><br><span class="line">  type        = string</span><br><span class="line">  description = &quot;The id of the machine image (AMI) to use for the server.&quot;</span><br><span class="line"></span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = length(var.image_id) &gt; 4 &amp;&amp; substr(var.image_id, 0, 4) == &quot;ami-&quot;</span><br><span class="line">    error_message = &quot;The image_id value must be a valid AMI id, starting with \&quot;ami-\&quot;.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>condition</code> 参数是一个 <code>bool</code> 类型的参数，我们可以用一个表达式来定义如何界定输入变量是合法的。当 <code>condition</code> 为 <code>true</code> 时输入变量合法，反之不合法。<code>condition</code> 表达式中只能通过 <code>var.\&lt;NAME\&gt;</code> 引用当前定义的变量，并且它的计算不能产生错误。</p>
<p>假如表达式的计算产生一个错误是输入变量验证的一种判定手段，那么可以使用 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/functions/can"><code>can</code> 函数</a>来判定表达式的执行是否抛错。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;image_id&quot; &#123;</span><br><span class="line">  type        = string</span><br><span class="line">  description = &quot;The id of the machine image (AMI) to use for the server.&quot;</span><br><span class="line"></span><br><span class="line">  validation &#123;</span><br><span class="line">    # regex(...) fails if it cannot find a match</span><br><span class="line">    condition     = can(regex(&quot;^ami-&quot;, var.image_id))</span><br><span class="line">    error_message = &quot;The image_id value must be a valid AMI id, starting with \&quot;ami-\&quot;.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，如果输入的 <code>image_id</code> 不符合正则表达式的要求，那么 <code>regex</code> 函数调用会抛出一个错误，这个错误会被 <code>can</code> 函数捕获，输出 <code>false</code>。</p>
<p><code>condition</code> 表达式如果为 <code>false</code>，Terraform 会返回 <code>error_message</code> 中定义的错误信息。<code>error_message</code> 应该完整描述输入变量校验失败的原因，以及输入变量的合法约束条件。</p>
<h2 id="1-4-3-1-5-临时输入变量（ephemeral）"><a href="#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%EF%BC%88ephemeral%EF%BC%89"></a>1.4.3.1.5. 临时输入变量（ephemeral）</h2>
<p><strong>注意</strong>：临时输入变量是 Terraform v1.10 开始引入的功能</p>
<p>将变量设置为 <code>ephemeral</code> 的结果是，该输入值在运行时可用，但 Terraform 不会在状态和计划文件中记录这种临时值。将输入变量标记为 <code>ephemeral</code> 变量对于仅需要暂时存在的数据非常有用，例如短生命周期的令牌或会话标识符。</p>
<p>要将输入变量标记为临时变量，只通过将 <code>ephemeral</code> 参数设置为 <code>true</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;session_token&quot; &#123;</span><br><span class="line">  type      = string</span><br><span class="line">  ephemeral = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>临时变量在当前 Terraform 运行期间可用，并且 Terraform 不会将它们存储在状态或计划文件中。因此，与 <a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"><code>sensitive</code> 输入</a>不同，Terraform 确保临时值在当前 Terraform 运行结束后无法读取。</p>
<p>您只能在特定上下文中引用临时变量，否则 Terraform 会返回错误。以下是引用临时变量的有效上下文：</p>
<ul>
<li>另一个临时变量</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/5.%E5%B1%80%E9%83%A8%E5%80%BC.html#%E4%B8%B4%E6%97%B6%E5%B1%80%E9%83%A8%E5%80%BC"><code>local</code> 表达式</a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/4.%E8%BE%93%E5%87%BA%E5%80%BC.html#%E4%B8%B4%E6%97%B6%E5%80%BCephemeral-%E9%81%BF%E5%85%8D%E5%B0%86%E5%80%BC%E5%AD%98%E5%82%A8%E5%88%B0%E7%8A%B6%E6%80%81%E6%88%96%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E4%B8%AD">临时输出值</a></li>
</ul>
<h2 id="1-4-3-1-6-在命令行输出中隐藏值-sensitive"><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"></a>1.4.3.1.6. 在命令行输出中隐藏值 (sensitive)</h2>
<p>该功能于 Terraform v0.14.0 开始引入。</p>
<p>将变量设置为 <code>sensitive</code> 可以防止我们在配置文件中使用变量时 Terraform 在 <code>plan</code> 和 <code>apply</code> 命令的输出中展示与变量相关的值。</p>
<p>Terraform <strong>仍然会</strong>将敏感数据记录在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">状态文件</a>中，任何可以访问状态文件的人都<strong>可以</strong>读取到明文的敏感数据值。</p>
<p>声明一个变量包含敏感数据值需要将 <code>sensitive</code> 参数设置为 <code>true</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;user_information&quot; &#123;</span><br><span class="line">  type = object(&#123;</span><br><span class="line">    name    = string</span><br><span class="line">    address = string</span><br><span class="line">  &#125;)</span><br><span class="line">  sensitive = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;some_resource&quot; &quot;a&quot; &#123;</span><br><span class="line">  name    = var.user_information.name</span><br><span class="line">  address = var.user_information.address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何使用了敏感变量的表达式都将被视为敏感的，因此在上面的示例中，<code>resource “some_resource” “a”</code>的两个参数也将在计划输出中被隐藏：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">some_resource.a will be created</span></span><br><span class="line">  + resource &quot;some_resource&quot; &quot;a&quot; &#123;</span><br><span class="line">      + name    = (sensitive)</span><br><span class="line">      + address = (sensitive)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure>
<p>在某些情况下，我们会在嵌套块中使用敏感变量，Terraform 可能会将整个块视为敏感的。这发生在那些包含有要求值是唯一的内嵌块的资源中，公开这种内嵌块的部分内容可能会暗示兄弟块的内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">some_resource.a will be updated in-place</span></span><br><span class="line"> ~ resource &quot;some_resource&quot; &quot;a&quot; &#123;</span><br><span class="line">     ~ nested_block &#123;</span><br><span class="line">         # At least one attribute in this block is (or was) sensitive,</span><br><span class="line">         # so its contents will not be displayed.</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Provider 还可以将资源属性声明为敏感属性，这将导致 Terraform 将其从常规输出中隐藏。</p>
<p>如果打算使用敏感值作为输出值的一部分，Terraform 将要求您将输出值本身标记为敏感值，以确认确实打算将其导出。</p>
<h3 id="1-4-3-1-6-1-Terraform-可能暴露敏感变量的情况"><a href="#terraform-%E5%8F%AF%E8%83%BD%E6%9A%B4%E9%9C%B2%E6%95%8F%E6%84%9F%E5%8F%98%E9%87%8F%E7%9A%84%E6%83%85%E5%86%B5"></a>1.4.3.1.6.1. Terraform 可能暴露敏感变量的情况</h3>
<p><code>sensitive</code> 变量是一个以配置文件为中心的概念，值被不加混淆地发送给 Provider。如果该值被包含在错误消息中，则 Provider 报错时可能会暴露该值。例如，即使 <code>&quot;foo&quot;</code> 是敏感值，Provider 也可能返回以下错误：<code>&quot;Invalid value 'foo' for field&quot;</code></p>
<p>如果将资源属性用作、或是作为 Provider 定义的资源 ID 的一部分，则 <code>apply</code> 将公开该值。在下面的示例中，前缀属性已设置为 <code>sensitive</code> 变量，但随后该值（<code>&quot;jae&quot;</code>）作为资源 ID 的一部分公开：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">random_pet.animal will be created</span></span><br><span class="line">  + resource &quot;random_pet&quot; &quot;animal&quot; &#123;</span><br><span class="line">      + id        = (known after apply)</span><br><span class="line">      + length    = 2</span><br><span class="line">      + prefix    = (sensitive)</span><br><span class="line">      + separator = &quot;-&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">random_pet.animal: Creating...</span><br><span class="line">random_pet.animal: Creation complete after 0s [id=jae-known-mongoose]</span><br></pre></td></tr></table></figure>
<h2 id="1-4-3-1-7-禁止输入变量为空-nullable"><a href="#%E7%A6%81%E6%AD%A2%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E4%B8%BA%E7%A9%BA-nullable"></a>1.4.3.1.7. 禁止输入变量为空 (nullable)</h2>
<p>该功能自 Terraform v1.1.0 开始被引入</p>
<p>输入变量的 <code>nullable</code> 参数控制模块调用者是否可以将 <code>null</code> 赋值给变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;example&quot; &#123;</span><br><span class="line">  type     = string</span><br><span class="line">  nullable = false </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nullable</code> 的默认值为 <code>true</code>。当 <code>nullable</code> 为 <code>true</code> 时，<code>null</code> 是变量的有效值，并且模块代码必须始终考虑变量值为 <code>null</code> 的可能性。将 <code>null</code> 作为模块输入参数传递将覆盖输入变量上定义的默认值。</p>
<p>将 <code>nullable</code> 设置为 <code>false</code> 可确保变量值在模块内永远不会为空。如果 <code>nullable</code> 为 <code>false</code> 并且输入变量定义有默认值，则当模块输入参数为 <code>null</code> 时，Terraform 将使用默认值。</p>
<p><code>nullable</code> 参数仅控制变量的直接值可能为 <code>null</code> 的情况。对于集合或对象类型的变量，例如列表或对象，调用者仍然可以在集合元素或属性中使用 <code>null</code>，只要集合或对象本身不为 <code>null</code>。</p>
<h2 id="1-4-3-1-8-对输入变量赋值"><a href="#%E5%AF%B9%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"></a>1.4.3.1.8. 对输入变量赋值</h2>
<h3 id="1-4-3-1-8-1-命令行参数"><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"></a>1.4.3.1.8.1. 命令行参数</h3>
<p>对输入变量赋值有几种途径，一种是在调用 <code>terraform plan</code> 或是 <code>terraform apply</code> 命令时以参数的形式传入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply -var=<span class="string">&quot;image_id=ami-abc123&quot;</span></span><br><span class="line">$ terraform apply -var=<span class="string">&#x27;image_id_list=[&quot;ami-abc123&quot;,&quot;ami-def456&quot;]&#x27;</span></span><br><span class="line">$ terraform plan -var=<span class="string">&#x27;image_id_map=&#123;&quot;us-east-1&quot;:&quot;ami-abc123&quot;,&quot;us-east-2&quot;:&quot;ami-def456&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以在一条命令中使用多个 <code>-var</code> 参数。</p>
<h3 id="1-4-3-1-8-2-参数文件"><a href="#%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6"></a>1.4.3.1.8.2. 参数文件</h3>
<p>第二种方法是使用参数文件。参数文件的后缀名可以是 <code>.tfvars</code> 或是 <code>.tfvars.json</code>。<code>.tfvars</code> 文件使用 HCL 语法，<code>.tfvars.json</code> 使用 JSON 语法。</p>
<p>以 <code>.tfvars</code> 为例，参数文件中用 HCL 代码对需要赋值的参数进行赋值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image_id = &quot;ami-abc123&quot;</span><br><span class="line">availability_zone_names = [</span><br><span class="line">  &quot;us-east-1a&quot;,</span><br><span class="line">  &quot;us-west-1c&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>后缀名为 <code>.tfvars.json</code> 的文件用一个 JSON 对象来对输入变量赋值，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;image_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ami-abc123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;availability_zone_names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;us-west-1a&quot;</span><span class="punctuation">,</span> <span class="string">&quot;us-west-1c&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>调用 terraform 命令时，通过 <code>-var-file</code> 参数指定要用的参数文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -var-file=<span class="string">&quot;testing.tfvars&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -var-file=<span class="string">&quot;testing.tfvars.json&quot;</span></span><br></pre></td></tr></table></figure>
<p>有两种情况，你<strong>无需</strong>指定参数文件：</p>
<ul>
<li>当前模块内有名为 <code>terraform.tfvars</code> 或是 <code>terraform.tfvars.json</code> 的文件</li>
<li>当前模块内有一个或多个后缀名为 <code>.auto.tfvars</code> 或是 <code>.auto.tfvars.json</code> 的文件</li>
</ul>
<p>Terraform 会自动使用这两种自动参数文件对输入参数赋值。</p>
<h3 id="1-4-3-1-8-3-环境变量"><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"></a>1.4.3.1.8.3. 环境变量</h3>
<p>可以通过设置名为 <code>TF_VAR_&lt;NAME&gt;</code> 的环境变量为输入变量赋值，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TF_VAR_image_id=ami-abc123</span><br><span class="line">$ terraform plan</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在环境变量名大小写敏感的操作系统上，Terraform 要求环境变量中的 <code>&lt;NAME&gt;</code> 与 Terraform 代码中定义的输入变量名大小写完全一致。</p>
<p>环境变量传值非常适合在自动化流水线中使用，尤其适合用来传递敏感数据，类似密码、访问密钥等。</p>
<h3 id="1-4-3-1-8-4-交互界面传值"><a href="#%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2%E4%BC%A0%E5%80%BC"></a>1.4.3.1.8.4. 交互界面传值</h3>
<p>在前面介绍断言的例子中我们看到过，当我们从命令行界面执行 terraform 操作，Terraform 无法通过其他途径获取一个输入变量的值，而该变量也没有定义默认值时，Terraform 会进行最后的尝试，在交互界面上要求我们给出变量值。</p>
<h2 id="1-4-3-1-9-输入变量赋值优先级"><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%BC%98%E5%85%88%E7%BA%A7"></a>1.4.3.1.9. 输入变量赋值优先级</h2>
<p>当上述的赋值方式同时存在时，同一个变量可能会被赋值多次。Terraform 会使用新值覆盖旧值。</p>
<p>Terraform 加载变量值的顺序是：</p>
<ol>
<li>环境变量</li>
<li><code>terraform.tfvars</code> 文件(如果存在的话)</li>
<li><code>terraform.tfvars.json</code> 文件(如果存在的话)</li>
<li>所有的 <code>.auto.tfvars</code> 或者 <code>.auto.tfvars.json</code> 文件，以字母顺序排序处理</li>
<li>通过 <code>-var</code> 或是 <code>-var-file</code> 命令行参数传递的输入变量，按照在命令行参数中定义的顺序加载</li>
</ol>
<p>假如以上方式均未能成功对变量赋值，那么 Terraform 会尝试使用默认值；对于没有定义默认值的变量，Terraform 会采用交互界面方式要求用户输入一个。对于某些 Terraform 命令，如果执行时带有 <code>-input=false</code> 参数禁用了交互界面传值方式，那么就会报错。</p>
<p><strong>重要提示</strong>：在 Terraform 0.12 及更高版本中，类型为 <code>map</code> 或 <code>object</code> 的输入变量的读取行为与其他变量相同：后找到的值会覆盖之前的值。这与 Terraform 的早期版本不同，早期版本会合并 <code>map</code>，而不是覆盖它们。</p>
<h3 id="1-4-3-1-9-1-Terraform-测试中的输入变量值"><a href="#terraform-%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E5%80%BC"></a>1.4.3.1.9.1. Terraform 测试中的输入变量值</h3>
<p>在 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test">Terraform 测试文件</a>中，您可以在 <code>variable</code> 块中指定变量值，这些 <code>variable</code> 块可以嵌套在 <code>run</code> 块中，也可以直接在文件中定义。</p>
<p>以这种方式定义的变量在测试执行期间优先于所有其他机制，其中在 <code>run</code> 块中定义的变量优先于在文件中定义的变量。</p>
<h2 id="1-4-3-1-10-复杂类型传值"><a href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%80%BC"></a>1.4.3.1.10. 复杂类型传值</h2>
<p>通过参数文件传值时，可以直接使用 HCL 或是 JSON 语法对复杂类型传值，例如 <code>list</code> 或 <code>map</code>。</p>
<p>对于某些场景下必须使用 <code>-var</code> 命令行参数，或是环境变量传值时，可以用单引号引用 HCL 语法的字面量来定义复杂类型，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TF_VAR_availability_zone_names=<span class="string">&#x27;[&quot;us-west-1b&quot;,&quot;us-west-1d&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于采用这种方法需要手工处理引号的转义，所以这种方法比较容易出错，复杂类型的传值建议尽量通过参数文件。</p>
<ul>
<li>
<p><a href="#%E8%BE%93%E5%87%BA%E5%80%BC"><strong>1.4.4.1.</strong> 输出值</a></p>
</li>
<li>
<p><a href="#%E8%BE%93%E5%87%BA%E5%80%BC%E7%9A%84%E5%A3%B0%E6%98%8E"><strong>1.4.4.1.1.</strong> 输出值的声明</a></p>
</li>
<li>
<p><a href="#%E6%8F%8F%E8%BF%B0-description"><strong>1.4.4.1.1.1.</strong> 描述 description</a></p>
</li>
<li>
<p><a href="#%E4%B8%B4%E6%97%B6%E5%80%BC%EF%BC%88ephemeral%EF%BC%89%E2%80%94%E2%80%94-%E9%81%BF%E5%85%8D%E5%B0%86%E5%80%BC%E5%AD%98%E5%82%A8%E5%88%B0%E7%8A%B6%E6%80%81%E6%88%96%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E4%B8%AD"><strong>1.4.4.1.1.2.</strong> 临时值（ephemeral）—— 避免将值存储到状态或计划文件中</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"><strong>1.4.4.1.1.3.</strong> 在命令行输出中隐藏值 sensitive</a></p>
</li>
<li>
<p><a href="#dependson"><strong>1.4.4.1.1.4.</strong> depends_on</a></p>
</li>
<li>
<p><a href="#%E6%96%AD%E8%A8%80-precondition"><strong>1.4.4.1.1.5.</strong> 断言 precondition</a></p>
</li>
</ul>
<p><a href="#%E8%BE%93%E5%87%BA%E5%80%BC"></a></p>
<h2 id="1-4-4-1-输出值"><a href="#%E8%BE%93%E5%87%BA%E5%80%BC"></a>1.4.4.1. 输出值</h2>
<p>我们在介绍输入变量时提到过，如果我们把一组 Terraform 代码想像成一个函数，那么输入变量就是函数的入参；函数可以有入参，也可以有返回值，同样的，Terraform 代码也可以有返回值，这就是输出值。</p>
<p>大部分语言的的函数只支持无返回值或是单返回值，但是 Terraform 支持多返回值。在当前模块 apply 一段 Terraform 代码，运行成功后命令行会输出代码中定义的返回值。另外我们也可以通过 <code>terraform output</code> 命令来输出当前模块对应的状态文件中的返回值。</p>
<h2 id="1-4-4-1-1-输出值的声明"><a href="#%E8%BE%93%E5%87%BA%E5%80%BC%E7%9A%84%E5%A3%B0%E6%98%8E"></a>1.4.4.1.1. 输出值的声明</h2>
<p>输出值的声明使用输出块，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output &quot;instance_ip_addr&quot; &#123;</span><br><span class="line">  value = aws_instance.server.private_ip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>output</code> 关键字后紧跟的就是输出值的名称。在当前模块内的所有输出值的名字都必须是唯一的。<code>output</code> 块内的 <code>value</code> 参数即为输出值，它可以像是上面的例子里那样某个 resource 的输出属性，也可以是任意合法的表达式。</p>
<p>输出值只有在执行 <code>terraform apply</code> 后才会被计算，光是执行 <code>terraform plan</code> 并不会计算输出值。</p>
<p>Terraform 代码中无法引用本目录下定义的输出值。</p>
<p><code>output</code> 块还有一些可选的属性：</p>
<h3 id="1-4-4-1-1-1-描述-description"><a href="#%E6%8F%8F%E8%BF%B0-description"></a>1.4.4.1.1.1. 描述 description</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output &quot;instance_ip_addr&quot; &#123;</span><br><span class="line">  value       = aws_instance.server.private_ip</span><br><span class="line">  description = &quot;The private IP address of the main server instance.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与输入变量的<code>description</code>类似，我们不再赘述。</p>
<h3 id="1-4-4-1-1-2-临时值（ephemeral）——-避免将值存储到状态或计划文件中"><a href="#%E4%B8%B4%E6%97%B6%E5%80%BC%EF%BC%88ephemeral%EF%BC%89%E2%80%94%E2%80%94-%E9%81%BF%E5%85%8D%E5%B0%86%E5%80%BC%E5%AD%98%E5%82%A8%E5%88%B0%E7%8A%B6%E6%80%81%E6%88%96%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E4%B8%AD"></a>1.4.4.1.1.2. 临时值（ephemeral）—— 避免将值存储到状态或计划文件中</h3>
<p><strong>注意</strong>：临时输出值是 Terraform v1.10 开始引入的功能</p>
<p>我们可以在子模块中将 <code>output</code> 标记为 <code>ephemeral</code>，以在模块之间传递临时值，同时避免将这些值保留到状态或计划文件中。这对于管理我们不想存储在 Terraform 状态文件中的凭据、令牌或其他临时资源非常有用。</p>
<p>我们可以通过将 <code>ephemeral</code> 属性设置为 <code>true</code> 将子模块中的输出标记为临时输出值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># modules/db/main.tf</span><br><span class="line"></span><br><span class="line">output &quot;secret_id&quot; &#123;</span><br><span class="line">  value       = aws_secretsmanager_secret.secret_id</span><br><span class="line">  description = &quot;Temporary secret ID for accessing database in AWS.&quot;</span><br><span class="line">  ephemeral   = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 可以在 <code>plan</code> 和 <code>apply</code> 操作期间访问 <code>output</code> 块的值。在 <code>plan</code> 或 <code>apply</code> 操作结束时，Terraform 不会保存任何临时输出的值。</p>
<p>我们只能在特定上下文中引用临时输出，否则 Terraform 会返回错误。以下是引用临时输出的有效上下文：</p>
<ul>
<li>另一个临时输出值</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8Fephemeral">临时输入变量</a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/12.Ephemeral%E8%B5%84%E6%BA%90.html">临时资源</a></li>
</ul>
<p><strong>注意</strong>：我们不可以在根模块中将 <code>output</code> 声明为 <code>ephemeral</code>。</p>
<h3 id="1-4-4-1-1-3-在命令行输出中隐藏值-sensitive"><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"></a>1.4.4.1.1.3. 在命令行输出中隐藏值 sensitive</h3>
<p>一个输出值可以标记 <code>sensitive</code> 为 <code>true</code>，表示该输出值含有敏感信息。被标记 <code>sensitive</code> 的输出值只是在执行 <code>terraform apply</code> 命令成功后会打印 <code>&quot;&lt;sensitive&gt;&quot;</code> 以取代真实的输出值，执行 <code>terraform output</code> 时也会输出<code>&quot;&lt;sensitive&gt;&quot;</code>，但仍然可以通过执行 <code>terraform output -json</code> 看到实际的敏感值。</p>
<p>需要注意的是，标记为 <code>sensitive</code> 输出值仍然会被记录在状态文件中，任何有权限读取状态文件的人仍然可以读取到敏感数据。</p>
<h3 id="1-4-4-1-1-4-depends-on"><a href="#dependson"></a>1.4.4.1.1.4. depends_on</h3>
<p>关于 <code>depends_on</code> 的内容将在 resource 章节里详细介绍，所以这里我们只是粗略地介绍一下。</p>
<p>Terraform 会解析代码所定义的各种 <code>data</code>、<code>resource</code>，以及他们之间的依赖关系，例如，创建虚拟机时用的 <code>image_id</code> 参数是通过 <code>data</code> 查询而来的，那么虚拟机实例就依赖于这个镜像的 <code>data</code>，Terraform 会首先创建 <code>data</code>，得到查询结果后，再创建虚拟机 <code>resource</code>。一般来说，<code>data</code>、<code>resource</code> 之间的创建顺序是由 Terraform 自动计算的，不需要代码的编写者显式指定。但有时有些依赖关系无法通过分析代码得出，这时我们可以在代码中通过 <code>depends_on</code> 显式声明依赖关系。</p>
<p>一般 <code>output</code> 很少会需要显式依赖某些资源，但有一些特殊场景，例如某些资源的属性必须在另外一些资源被创建后才能被读取，这种情况下我们可以通过 <code>depends_on</code> 来显式声明依赖关系。</p>
<p><code>depends_on</code> 的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">output &quot;instance_ip_addr&quot; &#123;</span><br><span class="line">  value       = aws_instance.server.private_ip</span><br><span class="line">  description = &quot;The private IP address of the main server instance.&quot;</span><br><span class="line"></span><br><span class="line">  depends_on = [</span><br><span class="line">    # Security group rule must be created before this IP address could</span><br><span class="line">    # actually be used, otherwise the services will be unreachable.</span><br><span class="line">    aws_security_group_rule.local_access,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不鼓励针对 <code>output</code> 定义<code>depends_on</code>，只能作为最后的手段加以应用。如果不得不针对 <code>output</code> 定义<code>depends_on</code>，请务必通过注释说明原因，方便后人进行维护。</p>
<h3 id="1-4-4-1-1-5-断言-precondition"><a href="#%E6%96%AD%E8%A8%80-precondition"></a>1.4.4.1.1.5. 断言 precondition</h3>
<p><code>output</code> 块从 Terraform v1.2.0 开始也可以包含一个 <code>precondition</code> 块。</p>
<p><code>output</code> 块上的 <code>precondition</code> 对应于 <code>variable</code> 块中的 <code>validation</code> 块。<code>validation</code> 块检查输入变量值是否符合模块的要求，<code>precondition</code> 则确保模块的输出值满足某种要求。我们可以通过 <code>precondition</code> 来防止 Terraform 把一个不合法的输入值写入状态文件。我们可以在合适的场景下通过 <code>precondition</code> 来保护上一次 <code>apply</code> 留下的合法的输出值。</p>
<p>Terraform 在计算输出值的 <code>value</code> 表达式之前执行 <code>precondition</code> 检查，这可以防止 <code>value</code> 表达式中的潜在错误被激发。</p>
<ul>
<li>
<p><a href="#%E5%B1%80%E9%83%A8%E5%80%BC"><strong>1.4.5.1.</strong> 局部值</a></p>
</li>
<li>
<p><a href="#%E4%B8%B4%E6%97%B6%EF%BC%88ephemeral%EF%BC%89%E5%B1%80%E9%83%A8%E5%80%BC"><strong>1.4.5.1.1.</strong> 临时（Ephemeral）局部值</a></p>
</li>
</ul>
<p><a href="#%E5%B1%80%E9%83%A8%E5%80%BC"></a></p>
<h2 id="1-4-5-1-局部值"><a href="#%E5%B1%80%E9%83%A8%E5%80%BC"></a>1.4.5.1. 局部值</h2>
<p>有时我们会需要用一个比较复杂的表达式计算某一个值，并且反复使用之，这时我们把这个复杂表达式赋予一个局部值，然后反复引用该局部值。如果说输入变量相当于函数的入参，输出值相当于函数的返回值，那么局部值就相当于函数内定义的局部变量。</p>
<p>局部值通过 <code>locals</code> 块定义，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  service_name = &quot;forum&quot;</span><br><span class="line">  owner        = &quot;Community Team&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 <code>locals</code> 块可以定义多个局部值，也可以定义任意多个 <code>locals</code> 块。赋给局部值的可以是更复杂的表达式，也可以是其他 <code>data</code>、<code>resource</code> 的输出、输入变量，甚至是其他的局部值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  # Ids for multiple sets of EC2 instances, merged together</span><br><span class="line">  instance_ids = concat(aws_instance.blue.*.id, aws_instance.green.*.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  # Common tags to be assigned to all resources</span><br><span class="line">  common_tags = &#123;</span><br><span class="line">    Service = local.service_name</span><br><span class="line">    Owner   = local.owner</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用局部值的表达式是 <code>local.&lt;NAME&gt;</code> (注意，虽然局部值定义在 <code>locals</code> 块内，但引用是务必使用 <code>local</code> 而不是 <code>locals</code>)，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  tags = local.common_tags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部值只能在同一模块内的代码中引用。</p>
<p>局部值可以帮助我们避免重复复杂的表达式，提升代码的可读性，但如果过度使用也有可能增加代码的复杂度，使得代码的维护者更难理解所使用的表达式和值。适度使用局部值，仅用于反复引用同一复杂表达式的场景，未来当我们需要修改该表达式时局部值将使得修改变得相当轻松。</p>
<h2 id="1-4-5-1-1-临时（Ephemeral）局部值"><a href="#%E4%B8%B4%E6%97%B6%EF%BC%88ephemeral%EF%BC%89%E5%B1%80%E9%83%A8%E5%80%BC"></a>1.4.5.1.1. 临时（Ephemeral）局部值</h2>
<p><strong>注意</strong>：临时局部值是 Terraform v1.10 开始引入的功能</p>
<p>如果局部值的表达式中引用了临时值，则本地值会隐式地变为临时值。例如，您可以创建引用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8Fephemeral">临时输入变量</a> <code>service_token</code> 的局部值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;service_name&quot; &#123;</span><br><span class="line">  type    = string</span><br><span class="line">  default = &quot;forum&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;environment&quot; &#123;</span><br><span class="line">  type    = string</span><br><span class="line">  default = &quot;dev&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;service_token&quot; &#123;</span><br><span class="line">  type      = string</span><br><span class="line">  ephemeral = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  service_tag   = &quot;$&#123;var.service_name&#125;-$&#123;var.environment&#125;&quot;</span><br><span class="line">  session_token = &quot;$&#123;var.service_name&#125;:$&#123;var.service_token&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式 <code>local.session_token</code> 的值隐式地成为了临时值，因为它依赖于临时输入变量 <code>var.service_token</code>。</p>
<ul>
<li>
<p><a href="#%E8%B5%84%E6%BA%90"><strong>1.4.6.1.</strong> 资源</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E8%AF%AD%E6%B3%95"><strong>1.4.6.1.1.</strong> 资源语法</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B"><strong>1.4.6.1.2.</strong> 资源类型</a></p>
</li>
<li>
<p><a href="#providers"><strong>1.4.6.1.2.1.</strong> Providers</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E5%8F%82%E6%95%B0"><strong>1.4.6.1.2.2.</strong> 资源参数</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E6%A1%A3"><strong>1.4.6.1.2.3.</strong> 资源类型的文档</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E8%A1%8C%E4%B8%BA"><strong>1.4.6.1.3.</strong> 资源的行为</a></p>
</li>
<li>
<p><a href="#%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E8%BE%93%E5%87%BA%E5%B1%9E%E6%80%A7"><strong>1.4.6.1.4.</strong> 访问资源输出属性</a></p>
</li>
<li>
<p><a href="#%E6%95%8F%E6%84%9F%E7%9A%84%E8%B5%84%E6%BA%90%E5%B1%9E%E6%80%A7"><strong>1.4.6.1.4.1.</strong> 敏感的资源属性</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><strong>1.4.6.1.5.</strong> 资源的依赖关系</a></p>
</li>
<li>
<p><a href="#%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.4.6.1.6.</strong> 元参数</a></p>
</li>
<li>
<p><a href="#dependson"><strong>1.4.6.1.6.1.</strong> depends_on</a></p>
</li>
<li>
<p><a href="#count"><strong>1.4.6.1.6.2.</strong> count</a></p>
</li>
<li>
<p><a href="#foreach"><strong>1.4.6.1.6.3.</strong> for_each</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8-foreach-%E5%92%8C-count-%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9"><strong>1.4.6.1.6.4.</strong> 在 for_each 和 count 之间选择</a></p>
</li>
<li>
<p><a href="#provider"><strong>1.4.6.1.6.5.</strong> provider</a></p>
</li>
<li>
<p><a href="#lifecycle"><strong>1.4.6.1.6.6.</strong> lifecycle</a></p>
</li>
<li>
<p><a href="#precondition-%E4%B8%8E-postcondition"><strong>1.4.6.1.6.7.</strong> Precondition 与 Postcondition</a></p>
</li>
<li>
<p><a href="#provisioner-%E5%92%8C-connection"><strong>1.4.6.1.6.8.</strong> provisioner 和 connection</a></p>
</li>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8"><strong>1.4.6.1.7.</strong> 创建时预置器</a></p>
</li>
<li>
<p><a href="#%E9%94%80%E6%AF%81%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8"><strong>1.4.6.1.8.</strong> 销毁时预置器</a></p>
</li>
<li>
<p><a href="#%E9%A2%84%E7%BD%AE%E5%99%A8%E5%A4%B1%E8%B4%A5%E8%A1%8C%E4%B8%BA"><strong>1.4.6.1.9.</strong> 预置器失败行为</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90"><strong>1.4.6.1.10.</strong> 删除资源</a></p>
</li>
<li>
<p><a href="#%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90"><strong>1.4.6.1.11.</strong> 本地资源</a></p>
</li>
<li>
<p><a href="#%E6%93%8D%E4%BD%9C%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE"><strong>1.4.6.1.12.</strong> 操作超时设置</a></p>
</li>
</ul>
<p><a href="#%E8%B5%84%E6%BA%90"></a></p>
<h2 id="1-4-6-1-资源"><a href="#%E8%B5%84%E6%BA%90"></a>1.4.6.1. 资源</h2>
<p>资源是 Terraform 最重要的组成部分，而本节亦是本教程最重要的一节。资源通过 <code>resource</code> 块来定义，一个 <code>resource</code> 可以定义一个或多个基础设施资源对象，例如 VPC、虚拟机，或是 DNS 记录、Consul 的键值对数据等。</p>
<h2 id="1-4-6-1-1-资源语法"><a href="#%E8%B5%84%E6%BA%90%E8%AF%AD%E6%B3%95"></a>1.4.6.1.1. 资源语法</h2>
<p>资源通过 <code>resource</code> 块定义，我们首先讲解通过 <code>resource</code> 块定义单个资源对象的场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_vpc&quot; &quot;main&quot; &#123;</span><br><span class="line">  cidr_block = var.base_cidr_block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;BLOCK TYPE&gt; &quot;&lt;BLOCK LABEL&gt;&quot; &quot;&lt;BLOCK LABEL&gt;&quot; &#123;</span><br><span class="line">  # Block body</span><br><span class="line">  &lt;IDENTIFIER&gt; = &lt;EXPRESSION&gt; # Argument</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>块</strong> 是其他内容的容器，通常代表某种对象的配置，比如资源。块有一个块类型，可以有零个或多个标签，有一个包含任意数量的参数和嵌套块的块体。Terraform 的大部分功能都是由配置文件中的顶级块控制的。</li>
<li><strong>参数</strong> 为一个名称赋值。它们出现在块内。</li>
<li><strong>表达式</strong> 表示一个值，可以是字面量，也可以是引用和组合其他值。它们出现在参数的值中，或者在其他表达式中。</li>
</ul>
<p>Terraform 是一种声明式语言，描述的是一个期望的资源状态，而不是达到期望状态所需要的步骤。块的顺序和它们所在的文件通常不重要；Terraform 只在确定操作顺序时考虑资源之间的隐式和显式关系。</p>
<p>在下面的例子里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧跟 <code>resource</code> 关键字的是资源类型，在上面的例子里就是 <code>aws_instance</code>。后面是资源的 Local Name，例子里就是 <code>web</code>。Local Name 可以在同一模块内的代码里被用来引用该资源，但类型加 Local Name 的组合在当前模块内必须是唯一的，不同类型的两个资源 Local Name 可以相同。随后的花括号内的内容就是块体，创建资源所用到的各种参数的值就在块体内定义。例子中我们定义了虚拟机所使用的镜像 id 以及虚拟机的尺寸。</p>
<p>请注意：资源名称必须以字母或下划线开头，只能包含字母、数字、下划线(<code>_</code>)和连字符(<code>-</code>)。</p>
<h2 id="1-4-6-1-2-资源类型"><a href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B"></a>1.4.6.1.2. 资源类型</h2>
<p>每个资源都与一个<em>资源类型</em>相关联，<em>资源类型</em>决定了它管理的基础设施对象的类型，以及资源支持的参数和其他属性。</p>
<h3 id="1-4-6-1-2-1-Providers"><a href="#providers"></a>1.4.6.1.2.1. Providers</h3>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html">Provider</a> 是 Terraform 用以提供一组资源类型的插件。每个资源类型都是由一个 Provider 实现的。Provider 提供了管理单个云或本地基础设施平台的资源。Provider 与 Terraform 分开发布，但 Terraform 可以在初始化工作目录时自动安装大多数 Provider。</p>
<p>要管理资源，Terraform 模块必须指定所需的 Provider。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html#provider-%E7%9A%84%E5%A3%B0%E6%98%8E">Provider 的声明</a>。</p>
<p>大部分 Provider 需要一些配置来访问远程 API，这些配置是在根模块中配置的。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html#provider-%E7%9A%84%E9%85%8D%E7%BD%AE">Provider 配置</a>。</p>
<p>根据一个 <code>resource</code> 块的类型名，Terraform 通常可以确定使用哪个 Provider。按照约定，资源类型名以其 Provider 的首选 Local Name 开头。当使用一个 Provider 的多个配置或非首选的本地 Provider 名称时，你必须使用 <a href="#provider">provider 元参数</a> 来手动选择一个 Provider 配置。</p>
<h3 id="1-4-6-1-2-2-资源参数"><a href="#%E8%B5%84%E6%BA%90%E5%8F%82%E6%95%B0"></a>1.4.6.1.2.2. 资源参数</h3>
<p>不同资源定义了不同的可赋值的属性，官方文档将之称为参数(Argument)，有些参数是必填的，有些参数是可选的。使用某项资源前可以通过阅读相关文档了解参数列表以及他们的含义、赋值的约束条件。</p>
<p>参数值可以是简单的字面量，也可以是一个复杂的表达式。</p>
<h3 id="1-4-6-1-2-3-资源类型的文档"><a href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E6%A1%A3"></a>1.4.6.1.2.3. 资源类型的文档</h3>
<p>每一个 Terraform Provider 都有自己的文档，用以描述它所支持的资源类型种类，以及每种资源类型所支持的属性列表。</p>
<p>大部分公共的 Provider 都是通过 <a target="_blank" rel="noopener" href="https://registry.terraform.io/browse/providers">Terraform Registry</a> 连带文档一起发布的。当我们在 Terraform Registry 站点上浏览一个 Provider 的页面时，我们可以点击 “Documentation” 链接来浏览相关文档。Provider 的文档都是版本化的，我们可以选择特定版本的 Provider 文档。</p>
<p>需要注意的是，Provider 文档曾经是直接托管在 <a target="_blank" rel="noopener" href="http://terraform.io">terraform.io</a> 站点上的，也就是 Terraform 核心主站的一部分，有些 Provider 的文档目前依然托管在那里，但目前 Terraform Registry 才是所有公共 Provider 文档的主站。</p>
<h2 id="1-4-6-1-3-资源的行为"><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E8%A1%8C%E4%B8%BA"></a>1.4.6.1.3. 资源的行为</h2>
<p>一个 <code>resource</code> 块声明了作者想要创建的一个确切的基础设施对象，并且设定了各项属性的值。如果我们正在编写一个新的 Terraform 代码文件，那么代码所定义的资源仅仅只在代码中存在，并没有与之对应的实际的基础设施资源存在。</p>
<p>对一组 Terraform 代码执行 <code>terraform apply</code> 可以创建、更新或者销毁实际的基础设施对象，Terraform 会制定并执行变更计划，以使得实际的基础设施符合代码的定义。</p>
<p>每当 Terraform 按照一个 <code>resource</code> 块创建了一个新的基础设施对象，这个实际的对象的 id 会被保存进 Terraform 状态中，使得将来 Terraform 可以根据变更计划对它进行更新或是销毁操作。如果一个 <code>resource</code> 块描述的资源在状态文件中已有记录，那么 Terraform 会比对记录的状态与代码描述的状态，如果有必要，Terraform 会制定变更计划以使得资源状态能够符合代码的描述。</p>
<p>这种行为适用于所有资源而无关其类型。创建、更新、销毁一个资源的细节会根据资源类型而不同，但是这个行为规则却是普适的。</p>
<h2 id="1-4-6-1-4-访问资源输出属性"><a href="#%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E8%BE%93%E5%87%BA%E5%B1%9E%E6%80%A7"></a>1.4.6.1.4. 访问资源输出属性</h2>
<p>资源不但可以通过参数传值，成功创建的资源还对外输出一些通过调用 API 才能获得的只读数据，经常包含了一些我们在实际创建一个资源之前无法获知的数据，比如云主机的 id 等，官方文档将之称为属性(Attribute)。我们可以在同一模块内的代码中引用资源的属性来创建其他资源或是表达式。在表达式中引用资源属性的语法是<code>&lt;RESOURCE TYPE&gt;.&lt;NAME&gt;.&lt;ATTRIBUTE&gt;</code>。</p>
<p>要获取一个资源类型输出的属性列表，我们可以查阅对应的 Provider 文档，一般在文档中会专门记录资源的输出属性列表。</p>
<h3 id="1-4-6-1-4-1-敏感的资源属性"><a href="#%E6%95%8F%E6%84%9F%E7%9A%84%E8%B5%84%E6%BA%90%E5%B1%9E%E6%80%A7"></a>1.4.6.1.4.1. 敏感的资源属性</h3>
<p>在为资源类型定义架构时，Provider 开发着可以将某些属性标记为 <code>sensitive</code>，在这种情况下，Terraform 将在展示涉及该属性的计划时显示占位符标记<code>(sensitive)</code> 而不是实际值。</p>
<p>标记为 <code>sensitive</code> 的 Provider 属性的行为类似于声明为 <code>sensitive</code> 的输入变量，Terraform 将隐藏计划中的值，还将隐藏从该值派生出的任何其他敏感值。但是，该行为存在一些限制，如 Terraform 可能暴露敏感变量。</p>
<p>如果使用资源属性中的敏感值作为输出值的一部分，Terraform 将要求将输出值本身标记为 <code>sensitive</code>，以确认确实打算将其导出。</p>
<p>Terraform 仍会在状态中记录敏感值，因此任何可以访问状态数据的人都可以以明文形式访问敏感值。</p>
<p>注意：Terraform 从 v0.15 开始将从敏感资源属性派生的值视为敏感值本身。早期版本的 Terraform 将隐藏敏感资源属性的直接值，但不会自动隐藏从敏感资源属性派生的其他值。</p>
<h2 id="1-4-6-1-5-资源的依赖关系"><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"></a>1.4.6.1.5. 资源的依赖关系</h2>
<p>我们在介绍输出值的<code>depends_on</code>的时候已经简单介绍过了依赖关系。一般来说在 Terraform 代码定义的资源之间不会有特定的依赖关系，Terraform 可以并行地对多个无依赖关系的资源执行变更，默认情况下这个并行度是 10。</p>
<p>然而，创建某些资源所需要的信息依赖于另一个资源创建后输出的属性，又或者必须在某些资源成功创建后才可以被创建，这时资源之间就存在依赖关系。</p>
<p>大部分资源间的依赖关系可以被 Terraform 自动处理，Terraform 会分析 <code>resource</code> 块内的表达式，根据表达式的引用链来确定资源之间的引用，进而计算出资源在创建、更新、销毁时的执行顺序。大部分情况下，我们不需要显式指定资源之间的依赖关系。</p>
<p>然而，有时候某些依赖关系是无法从代码中推导出来的。例如，Terraform 必须要创建一个访问控制权限资源，以及另一个需要该权限才能成功创建的资源。后者的创建依赖于前者的成功创建，然而这种依赖在代码中没有表现为数据引用关联，这种情况下，我们需要用 <code>depends_on</code> 来显式声明这种依赖关系。</p>
<h2 id="1-4-6-1-6-元参数"><a href="#%E5%85%83%E5%8F%82%E6%95%B0"></a>1.4.6.1.6. 元参数</h2>
<p><code>resource</code> 块支持几种元参数声明，这些元参数可以被声明在所有类型的 <code>resource</code> 块内，它们将会改变资源的行为：</p>
<ul>
<li><code>depends_on</code>：显式声明依赖关系</li>
<li><code>count</code>：创建多个资源实例</li>
<li><code>for_each</code>：迭代集合，为集合中每一个元素创建一个对应的资源实例</li>
<li><code>provider</code>：指定非默认 Provider 实例</li>
<li><code>lifecycle</code>：自定义资源的生命周期行为</li>
<li><code>provisioner</code> 和 <code>connection</code>：在资源创建后执行一些额外的操作</li>
</ul>
<p>下面我们将逐一讲解他们的用法。</p>
<h3 id="1-4-6-1-6-1-depends-on"><a href="#dependson"></a>1.4.6.1.6.1. depends_on</h3>
<p>使用 <code>depends_on</code> 可以显式声明资源之间哪些 Terraform 无法自动推导出的隐含的依赖关系。只有当资源间确实存在依赖关系，但是彼此间又没有数据引用的场景下才有必要使用 <code>depends_on</code>。</p>
<p>使用 <code>depends_on</code> 的例子是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_role&quot; &quot;example&quot; &#123;</span><br><span class="line">  name = &quot;example&quot;</span><br><span class="line"></span><br><span class="line">  # assume_role_policy is omitted for brevity in this example. See the</span><br><span class="line">  # documentation for aws_iam_role for a complete example.</span><br><span class="line">  assume_role_policy = &quot;...&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_instance_profile&quot; &quot;example&quot; &#123;</span><br><span class="line">  # Because this expression refers to the role, Terraform can infer</span><br><span class="line">  # automatically that the role must be created first.</span><br><span class="line">  role = aws_iam_role.example.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_role_policy&quot; &quot;example&quot; &#123;</span><br><span class="line">  name   = &quot;example&quot;</span><br><span class="line">  role   = aws_iam_role.example.name</span><br><span class="line">  policy = jsonencode(&#123;</span><br><span class="line">    &quot;Statement&quot; = [&#123;</span><br><span class="line">      # This policy allows software running on the EC2 instance to</span><br><span class="line">      # access the S3 API.</span><br><span class="line">      &quot;Action&quot; = &quot;s3:*&quot;,</span><br><span class="line">      &quot;Effect&quot; = &quot;Allow&quot;,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  # Terraform can infer from this that the instance profile must</span><br><span class="line">  # be created before the EC2 instance.</span><br><span class="line">  iam_instance_profile = aws_iam_instance_profile.example</span><br><span class="line"></span><br><span class="line">  # However, if software running in this EC2 instance needs access</span><br><span class="line">  # to the S3 API in order to boot properly, there is also a &quot;hidden&quot;</span><br><span class="line">  # dependency on the aws_iam_role_policy that Terraform cannot</span><br><span class="line">  # automatically infer, so it must be declared explicitly:</span><br><span class="line">  depends_on = [</span><br><span class="line">    aws_iam_role_policy.example,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来分段解释一下这个场景，首先我们声明了一个 AWS IAM 角色，将角色绑定在一个主机实例配置文件上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_role&quot; &quot;example&quot; &#123;</span><br><span class="line">  name = &quot;example&quot;</span><br><span class="line"></span><br><span class="line">  # assume_role_policy is omitted for brevity in this example. See the</span><br><span class="line">  # documentation for aws_iam_role for a complete example.</span><br><span class="line">  assume_role_policy = &quot;...&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_instance_profile&quot; &quot;example&quot; &#123;</span><br><span class="line">  # Because this expression refers to the role, Terraform can infer</span><br><span class="line">  # automatically that the role must be created first.</span><br><span class="line">  role = aws_iam_role.example.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟机的声明代码中的这个赋值使得 Terraform 能够判断出虚拟机依赖于主机实例配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  # Terraform can infer from this that the instance profile must</span><br><span class="line">  # be created before the EC2 instance.</span><br><span class="line">  iam_instance_profile = aws_iam_instance_profile.example</span><br></pre></td></tr></table></figure>
<p>至此，Terraform 规划出的创建顺序是 IAM 角色 -&gt; 主机实例配置文件 -&gt; 主机实例。但是我们又为这个 IAM 角色添加了对 S3 存储服务的完全控制权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_role_policy&quot; &quot;example&quot; &#123;</span><br><span class="line">  name   = &quot;example&quot;</span><br><span class="line">  role   = aws_iam_role.example.name</span><br><span class="line">  policy = jsonencode(&#123;</span><br><span class="line">    &quot;Statement&quot; = [&#123;</span><br><span class="line">      # This policy allows software running on the EC2 instance to</span><br><span class="line">      # access the S3 API.</span><br><span class="line">      &quot;Action&quot; = &quot;s3:*&quot;,</span><br><span class="line">      &quot;Effect&quot; = &quot;Allow&quot;,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，虚拟机实例由于绑定了主机实例配置文件，从而在运行时拥有了一个 IAM 角色，而这个 IAM 角色又被赋予了 S3 的权限。但是虚拟机实例的声明代码中并没有引用 S3 权限的任何输出属性，这将导致 Terraform 无法理解他们之间存在依赖关系，进而可能会并行地创建两者，如果虚拟机实例被先创建了出来，内部的程序开始运行时，它所需要的 S3 权限却还没有创建完成，那么就将导致程序运行错误。为了确保虚拟机创建时 S3 权限一定已经存在，我们可以用 <code>depends_on</code> 显式声明它们的依赖关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># However, if software running in this EC2 instance needs access</span><br><span class="line">  # to the S3 API in order to boot properly, there is also a &quot;hidden&quot;</span><br><span class="line">  # dependency on the aws_iam_role_policy that Terraform cannot</span><br><span class="line">  # automatically infer, so it must be declared explicitly:</span><br><span class="line">  depends_on = [</span><br><span class="line">    aws_iam_role_policy.example,</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p><code>depends_on</code> 的赋值必须是包含同一模块内声明的其他资源名称的列表，不允许包含其他表达式，例如不允许使用其他资源的输出属性，这是因为 Terraform 必须在计算资源间关系之前就能理解列表中的值，为了能够安全地完成表达式计算，所以限制只能使用资源实例的名称。</p>
<p><code>depends_on</code> 只能作为最后的手段使用，如果我们使用 <code>depends_on</code>，我们应该用注释记录我们使用它的原因，以便今后代码的维护者能够理解隐藏的依赖关系。</p>
<h3 id="1-4-6-1-6-2-count"><a href="#count"></a>1.4.6.1.6.2. count</h3>
<p>一般来说，一个 resource 块定义了一个对应的实际基础设施资源对象。但是有时候我们希望创建多个相似的对象，比如创建一组虚拟机。Terraform 提供了两种方法实现这个目标：<code>count</code> 与 <code>for_each</code>。</p>
<p><code>count</code> 参数可以是任意自然数，Terraform 会创建 <code>count</code> 个资源实例，每一个实例都对应了一个独立的基础设施对象，并且在执行 Terraform 代码时，这些对象是被分别创建、更新或者销毁的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;server&quot; &#123;</span><br><span class="line">  count = 4 # create four similar EC2 instances</span><br><span class="line"></span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;Server $&#123;count.index&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在 <code>resource</code> 块中的表达式里使用 <code>count</code> 对象来获取当前的 <code>count</code> 索引号。<code>count</code> 对象只有一个属性：</p>
<ul>
<li><code>count.index</code>：代表当前对象对应的 <code>count</code> 下标索引(从 <code>0</code> 开始)</li>
</ul>
<p>如果一个 <code>resource</code> 块定义了 <code>count</code> 参数，那么 Terraform 会把这种多资源实例对象与没有 <code>count</code> 参数的单实例资源对象区别开：</p>
<ul>
<li>访问单资源实例对象：<code>&lt;TYPE&gt;.&lt;NAME&gt;</code>(例如：<code>aws_instance.server</code>)</li>
<li>访问多资源实例对象：<code>&lt;TYPE&gt;.&lt;NAME&gt;[&lt;INDEX&gt;]</code> (例如：<code>aws_instance.server[0]</code>，<code>aws_instance.server[1]</code>)</li>
</ul>
<p>声明了 <code>count</code> 或 <code>for_each</code> 的资源必须使用下标索引或者键来访问。</p>
<p><code>count</code> 参数可以是任意自然数，然而与 <code>resource</code> 的其他参数不同，<code>count</code> 的值在 Terraform 进行任何远程资源操作(实际的增删改查)之前必须是已知的，这也就意味着赋予 <code>count</code> 参数的表达式不可以引用任何其他资源的输出属性(例如由其他资源对象创建时返回的一个唯一的 ID)。</p>
<h3 id="1-4-6-1-6-3-for-each"><a href="#foreach"></a>1.4.6.1.6.3. for_each</h3>
<p><code>for_each</code> 是 Terraform 0.12.6 开始引入的新特性。一个 <code>resource</code> 块不允许同时声明 <code>count</code> 与 <code>for_each</code>。<code>for_each</code> 参数可以是一个 <code>map</code> 或是一个 <code>set(string)</code>，Terraform 会为集合中每一个元素都创建一个独立的基础设施资源对象，和 <code>count</code> 一样，每一个基础设施资源对象在执行 Terraform 代码时都是独立创建、修改、销毁的。</p>
<p>使用 <code>map</code> 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_resource_group&quot; &quot;rg&quot; &#123;</span><br><span class="line">  for_each = &#123;</span><br><span class="line">    a_group = &quot;eastus&quot;</span><br><span class="line">    another_group = &quot;westus2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  name     = each.key</span><br><span class="line">  location = each.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>set(string)</code> 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_user&quot; &quot;the-accounts&quot; &#123;</span><br><span class="line">  for_each = toset( [&quot;Todd&quot;, &quot;James&quot;, &quot;Alice&quot;, &quot;Dottie&quot;] )</span><br><span class="line">  name     = each.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在声明了 <code>for_each</code> 参数的 <code>resource</code> 块内使用 <code>each</code> 对象来访问当前的迭代器对象：</p>
<ul>
<li><code>each.key</code>：<code>map</code> 的键，或是 <code>set</code> 中的值</li>
<li><code>each.value</code>：<code>map</code> 的值，或是 <code>set</code> 中的值</li>
</ul>
<p>如果 <code>for_each</code> 的值是一个 <code>set</code>，那么 <code>each.key</code> 和 <code>each.value</code> 是相等的。</p>
<p>使用 <code>for_each</code> 时，<code>map</code> 的所有键、<code>set</code> 的所有 <code>string</code> 值都必须是已知的，也就是状态文件中已有记录的值。所以有时候我们可能需要在执行 <code>terraform apply</code> 时添加 <code>-target</code> 参数，实现分步创建。另外，<code>for_each</code> 所使用的键集合不能够包含或依赖非纯函数，也就是反复执行会返回不同返回值的函数，例如 <code>uuid</code>、<code>bcrypt</code>、<code>timestamp</code> 等。</p>
<p>当一个 <code>resource</code> 声明了 <code>for_each</code> 时，Terraform 会把这种多资源实例对象与没有 <code>count</code> 参数的单资源实例对象区别开：</p>
<ul>
<li>访问单资源实例对象：<code>&lt;TYPE&gt;.&lt;NAME&gt;</code>(例如：<code>aws_instance.server</code>)</li>
<li>访问多资源实例对象：<code>&lt;TYPE&gt;.&lt;NAME&gt;[&lt;KE&gt;]</code> (例如：<code>aws_instance.server[&quot;ap-northeast-1&quot;]</code>，<code>aws_instance.server[&quot;ap-northeast-2&quot;]</code>)</li>
</ul>
<p>声明了<code>count</code>或 <code>for_each</code> 的资源必须使用下标索引或者键来访问。</p>
<p>由于 Terraform 没有用以声明 <code>set</code> 的字面量，所以我们有时需要使用 <code>toset</code> 函数把 <code>list(string)</code> 转换为 <code>set(string)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  subnet_ids = toset([</span><br><span class="line">    &quot;subnet-abcdef&quot;,</span><br><span class="line">    &quot;subnet-012345&quot;,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;server&quot; &#123;</span><br><span class="line">  for_each = local.subnet_ids</span><br><span class="line"></span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  subnet_id     = each.key # note: each.key and each.value are the same for a set</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;Server $&#123;each.key&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们用 <code>toset</code> 把一个 <code>list(string)</code> 转换成了 <code>set(string)</code>，然后赋予 <code>for_each</code>。在转换过程中，<code>list</code> 中所有重复的元素会被抛弃，只剩下不重复的元素，例如 <code>toset([&quot;b&quot;, &quot;a&quot;, &quot;b&quot;])</code> 的结果只有<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>，并且 <code>set</code> 的元素没有特定顺序。</p>
<p>如果我们要把一个输入变量赋予 <code>for_each</code>，我们可以直接定义变量的类型约束来避免显式调用 <code>toset</code> 转换类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;subnet_ids&quot; &#123;</span><br><span class="line">  type = set(string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;server&quot; &#123;</span><br><span class="line">  for_each = var.subnet_ids</span><br><span class="line"></span><br><span class="line">  # (and the other arguments as above)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-6-1-6-4-在-for-each-和-count-之间选择"><a href="#%E5%9C%A8-foreach-%E5%92%8C-count-%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9"></a>1.4.6.1.6.4. 在 for_each 和 count 之间选择</h3>
<p>如果创建的资源实例彼此之间几乎完全一致，那么 <code>count</code> 比较合适。如果彼此之间的参数差异无法直接从 <code>count</code> 的下标派生，那么使用 <code>for_each</code> 会更加安全。</p>
<p>在 Terraform 引入 <code>for_each</code> 之前，我们经常使用 <code>count.index</code> 搭配 <code>length</code> 函数和 <code>list</code> 来创建多个资源实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;subnet_ids&quot; &#123;</span><br><span class="line">  type = list(string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;server&quot; &#123;</span><br><span class="line">  # Create one instance for each subnet</span><br><span class="line">  count = length(var.subnet_ids)</span><br><span class="line"></span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  subnet_id     = var.subnet_ids[count.index]</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;Server $&#123;count.index&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现方法是脆弱的，因为资源仍然是以他们的下标而不是实际的字符串值来区分的。如果我们从 <code>subnet_ids</code> 列表的中间移除了一个元素，那么从该位置起后续所有的 <code>aws_instance</code> 都会发现它们的 <code>subnet_id</code> 发生了变化，结果就是所有后续的 <code>aws_instance</code> 都需要更新。这种场景下如果使用 <code>for_each</code> 就更为妥当，如果使用 <code>for_each</code>，那么只有被移除的 <code>subnet_id</code> 对应的 <code>aws_instance</code> 会被销毁。</p>
<h3 id="1-4-6-1-6-5-provider"><a href="#provider"></a>1.4.6.1.6.5. provider</h3>
<p>关于 <code>provider</code> 的定义我们在前面介绍 Provider 的章节已经提到过了，如果我们声明了同一类型 Provider 的多个实例，那么我们在创建资源时可以通过指定 <code>provider</code> 参数选择要使用的 Provider 实例。如果没有指定 <code>provider</code> 参数，那么 Terraform 默认使用资源类型名中第一个单词所对应的 Provider 实例，例如 <code>google_compute_instance</code> 的默认 Provider 实例就是 <code>google</code>，<code>aws_instance</code> 的默认 Provider 就是 <code>aws</code>。</p>
<p>指定 <code>provider</code> 参数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># default configuration</span><br><span class="line">provider &quot;google&quot; &#123;</span><br><span class="line">  region = &quot;us-central1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># alternate configuration, whose alias is &quot;europe&quot;</span><br><span class="line">provider &quot;google&quot; &#123;</span><br><span class="line">  alias  = &quot;europe&quot;</span><br><span class="line">  region = &quot;europe-west1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;google_compute_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # This &quot;provider&quot; meta-argument selects the google provider</span><br><span class="line">  # configuration whose alias is &quot;europe&quot;, rather than the</span><br><span class="line">  # default configuration.</span><br><span class="line">  provider = google.europe</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>provider</code>参数期待的赋值是<code>&lt;PROVIDER&gt;</code>或是<code>&lt;PROVIDER&gt;.&lt;ALIAS&gt;</code>，不需要双引号。因为在Terraform开始计算依赖路径图时，provider关系必须是已知的，所以除了这两种以外的表达式是不被接受的。</p>
<h3 id="1-4-6-1-6-6-lifecycle"><a href="#lifecycle"></a>1.4.6.1.6.6. lifecycle</h3>
<p>通常一个资源对象的生命周期在前面<a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E8%A1%8C%E4%B8%BA">“资源的行为”</a>一节中已经描述了，但是我们可以用 <code>lifecycle</code> 块来定一个不一样的行为方式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_resource_group&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    create_before_destroy = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lifecycle</code> 块和它的内容都属于元参数，可以被声明于任意类型的资源块内部。Terraform 支持如下几种 <code>lifecycle</code>：</p>
<ul>
<li><code>create_before_destroy</code> (<code>bool</code>)：默认情况下，当 Terraform 需要修改一个由于服务端 API 限制导致无法直接升级的资源时，Terraform 会删除现有资源对象，然后用新的配置参数创建一个新的资源对象取代之。<code>create_before_destroy</code> 参数可以修改这个行为，使得 Terraform 首先创建新对象，只有在新对象成功创建并取代老对象后再销毁老对象。这并不是默认的行为，因为许多基础设施资源需要有一个唯一的名字或是别的什么标识属性，在新老对象并存时也要符合这种约束。有些资源类型有特别的参数可以为每个对象名称添加一个随机的前缀以防止冲突。Terraform 不能默认采用这种行为，所以在使用 <code>create_before_destroy</code> 前你必须了解每一种资源类型在这方面的约束。</li>
<li><code>prevent_destroy</code> (<code>bool</code>)：这个参数是一个保险措施，只要它被设置为 <code>true</code> 时，Terraform 会拒绝执行任何可能会销毁该基础设施资源的变更计划。这个参数可以预防意外删除关键资源，例如错误地执行了 <code>terraform destroy</code>，或者是意外修改了资源的某个参数，导致 Terraform 决定删除并重建新的资源实例。在 <code>resource</code> 块内声明了 <code>prevent_destroy = true</code> 会导致无法执行 <code>terraform destroy</code>，所以对它的使用要节制。需要注意的是，该措施无法防止我们删除 <code>resource</code> 块后 Terraform 删除相关资源，因为对应的 <code>prevent_destroy = true</code> 声明也被一并删除了。</li>
<li><code>ignore_changes</code> (<code>list(string)</code>)：默认情况下，Terraform 检测到代码描述的配置与真实基础设施对象之间有任何差异时都会计算一个变更计划来更新基础设施对象，使之符合代码描述的状态。在一些非常罕见的场景下，实际的基础设施对象会被 Terraform 之外的流程所修改，这就会使得 Terraform 不停地尝试修改基础设施对象以弥合和代码之间的差异。这种情况下，我们可以通过设定 <code>ignore_changes</code> 来指示 Terraform 忽略某些属性的变更。<code>ignore_changes</code> 的值定义了一组在创建时需要按照代码定义的值来创建，但在更新时不需要考虑值的变化的属性名，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    ignore_changes = [</span><br><span class="line">      # Ignore changes to tags, e.g. because a management agent</span><br><span class="line">      # updates these based on some ruleset managed elsewhere.</span><br><span class="line">      tags,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以忽略 <code>map</code> 中特定的元素，例如 <code>tags[&quot;Name&quot;]</code>，但是要注意的是，如果你是想忽略 <code>map</code> 中特定元素的变更，那么你必须首先确保 <code>map</code> 中含有这个元素。如果一开始 <code>map</code> 中并没有这个键，而后外部系统添加了这个键，那么 Terraform 还是会把它当成一次变更来处理。比较好的方法是你在代码中先为这个键创建一个占位元素来确保这个键已经存在，这样在外部系统修改了键对应的值以后 Terraform 会忽略这个变更。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    # Initial value for Name is overridden by our automatic scheduled</span><br><span class="line">    # re-tagging process; changes to this are ignored by ignore_changes</span><br><span class="line">    # below.</span><br><span class="line">    Name = &quot;placeholder&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    ignore_changes = [</span><br><span class="line">      tags[&quot;Name&quot;],</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用一个 <code>list(string)</code>，也可以使用关键字 <code>all</code> ，这时 Terraform 会忽略资源一切属性的变更，这样 Terraform 只会创建或销毁一个对象，但绝不会尝试更新一个对象。你只能在 <code>ignore_changes</code> 里忽略所属的 <code>resource</code> 的属性，<code>ignore_changes</code> 不可以赋予它自身或是其他任何元参数。</p>
<ul>
<li><code>replace_triggered_by</code> (包含资源引用的列表)：强制 Terraform 在引用的资源或是资源属性发生变更时替换声明该块的父资源，值为一个包含了托管资源、实例或是实例属性引用表达式的列表。当声明该块的资源声明了 <code>count</code> 或是 <code>for_each</code> 时，我们可以在表达式中使用 <code>count.index</code> 或是 <code>each.key</code> 来指定引用实例的序号。</li>
</ul>
<p><code>replace_triggered_by</code> 可以在以下几种场景中使用：</p>
<ul>
<li>如果表达式指向多实例的资源声明（例如声明了 <code>count</code> 或是 <code>for_each</code> 的资源），那么这组资源中任意实例发生变更或被替换时都将引发声明 <code>replace_triggered_by</code> 的资源被替换</li>
<li>如果表达式指向单个资源实例，那么该实例发生变更或被替换时将引发声明 <code>replace_triggered_by</code> 的资源被替换</li>
<li>如果表达式指向单个资源实例的单个属性，那么该属性值的任何变化都将引发声明 <code>replace_triggered_by</code> 的资源被替换</li>
</ul>
<p>我们在 <code>replace_triggered_by</code> 中只能引用托管资源。这允许我们在不引发强制替换的前提下修改这些表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_appautoscaling_target&quot; &quot;ecs_target&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    replace_triggered_by = [</span><br><span class="line">      # Replace `aws_appautoscaling_target` each time this instance of </span><br><span class="line">      # the `aws_ecs_service` is replaced.</span><br><span class="line">      aws_ecs_service.svc.id</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lifecycle</code> 配置影响了 Terraform 如何构建并遍历依赖图。作为结果，<code>lifecycle</code> 内赋值仅支持字面量，因为它的计算过程发生在 Terraform 计算的极早期。这就是说，例如 <code>prevent_destroy</code>、<code>create_before_destroy</code> 的值只能是 <code>true</code> 或者 <code>false</code>，<code>ignore_changes</code>、<code>replace_triggered_by</code> 的列表内只能是硬编码的属性名。</p>
<h3 id="1-4-6-1-6-7-Precondition-与-Postcondition"><a href="#precondition-%E4%B8%8E-postcondition"></a>1.4.6.1.6.7. Precondition 与 Postcondition</h3>
<p>请注意，Precondition 与 Postcondition 是从 Terraform v1.2.0 开始被引入的功能。</p>
<p>在 <code>lifecycle</code> 块中声明 <code>precondition</code> 与 <code>postcondition</code> 块可以为资源、数据源以及输出值创建自定义的验证规则。</p>
<p>Terraform 在计算一个对象之前会首先检查该对象关联的 <code>precondition</code>，并且在对象计算完成后执行 <code>postcondition</code> 检查。Terraform 会尽可能早地执行自定义检查，但如果表达式中包含了只有在 <code>apply</code> 阶段才能知晓的值，那么该检查也将被推迟执行。</p>
<p>每一个 <code>precondition</code> 与 <code>postcondition</code> 块都需要一个 <code>condition</code> 参数。该参数是一个表达式，在满足条件时返回 <code>true</code>，否则返回 <code>false</code>。该表达式可以引用同一模块内的任意其他对象，只要这种引用不会产生环依赖。在 <code>postcondition</code> 表达式中也可以使用 <code>self</code> 对象引用声明 <code>postcondition</code> 的资源实例的属性。</p>
<p>如果 <code>condition</code> 表达式计算结果为 <code>false</code>，Terraform 会生成一条错误信息，包含了 <code>error_message</code> 表达式的内容。如果我们声明了多条 <code>precondition</code> 或 <code>postcondition</code>，Terraform 会返回所有失败条件对应的错误信息。</p>
<p>下面的例子演示了通过 <code>postcondition</code> 检测调用者是否不小心传入了错误的 AMI 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data &quot;aws_ami&quot; &quot;example&quot; &#123;</span><br><span class="line">  id = var.aws_ami_id</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    # The AMI ID must refer to an existing AMI that has the tag &quot;nomad-server&quot;.</span><br><span class="line">    postcondition &#123;</span><br><span class="line">      condition     = self.tags[&quot;Component&quot;] == &quot;nomad-server&quot;</span><br><span class="line">      error_message = &quot;tags[\&quot;Component\&quot;] must be \&quot;nomad-server\&quot;.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>resource</code> 或 <code>data</code> 块中的 <code>lifecycle</code> 块可以同时包含 <code>precondition</code> 与 <code>postcondition</code> 块。</p>
<ul>
<li>Terraform 会在计算完 <code>count</code> 和 <code>for_each</code> 元参数后执行 <code>precondition</code> 块。这使得 Terraform 可以对每一个实例独立进行检查，并允许在表达式中使用 <code>each.key</code>、<code>count.index</code> 等。Terraform 还会在计算资源的参数表达式之前执行 <code>precondition</code> 检查。<code>precondition</code> 可以用来防止参数表达式计算中的错误被激发。</li>
<li>Terraform 在计算和执行对一个托管资源的变更之后执行 <code>postcondition</code> 检查，或是在完成数据源读取后执行它关联的 <code>postcondition</code> 检查。<code>postcondition</code> 失败会阻止其他依赖于此失败资源的其他资源的变更。</li>
</ul>
<p>在大多数情况下，我们不建议在同一配置文件中同时包含表示同一个对象的 <code>data</code> 块和 <code>resource</code> 块。这样做会使得 Terraform 无法理解 <code>data</code> 块的结果会被 <code>resource</code> 块的变更所影响。然而，当我们需要检查一个 <code>resource</code> 块的结果，恰巧该结果又没有被资源直接输出时，我们可以使用 <code>data</code> 块并在块中直接使用 <code>postcondition</code> 来检查该对象。这等于告诉 Terraform 该 <code>data</code> 块是用来检查其他什么地方定义的对象的，从而允许 Terraform 以正确的顺序执行操作。</p>
<h3 id="1-4-6-1-6-8-provisioner-和-connection"><a href="#provisioner-%E5%92%8C-connection"></a>1.4.6.1.6.8. provisioner 和 connection</h3>
<p>某些基础设施对象需要在创建后执行特定的操作才能正式工作。比如说，主机实例必须在上传了配置或是由配置管理工具初始化之后才能正常工作。</p>
<p>像这样创建后执行的操作可以使用预置器(Provisioner)。预置器是由 Terraform 所提供的另一组插件，每种预置器可以在资源对象创建后执行不同类型的操作。</p>
<p>使用预置器需要节制，因为他们采取的操作并非 Terraform 声明式的风格，所以 Terraform 无法对他们执行的变更进行建模和保存。</p>
<p>预置器也可以声明为资源销毁前执行，但会有一些限制。</p>
<p>作为元参数，<code>provisioner</code> 和 <code>connection</code> 可以声明在任意类型的 <code>resource</code> 块内。</p>
<p>举一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  provisioner &quot;file&quot; &#123;</span><br><span class="line">  source       = &quot;conf/myapp.conf&quot;</span><br><span class="line">  destination  = &quot;/etc/myapp.conf&quot;</span><br><span class="line"></span><br><span class="line">    connection &#123;</span><br><span class="line">      type     = &quot;ssh&quot;</span><br><span class="line">      user     = &quot;root&quot;</span><br><span class="line">      password = var.root_password</span><br><span class="line">      host     = self.public_ip</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 <code>aws_instance</code> 中定义了类型为 <code>file</code> 的预置器，该预置器可以本机文件或文件夹拷贝到目标机器的指定路径下。我们在预置器内部定义了<code>connection</code>块，类型是<code>ssh</code>。我们对<code>connection</code>的<code>host</code>赋值<code>self.public_ip</code>，在这里<code>self</code>代表预置器所在的母块，也就是<code>aws_instance.web</code>，所以<code>self.public_ip</code>代表着<code>aws_instance.web.public_ip</code>，也就是创建出来的主机的公网ip。</p>
<p><code>file</code> 类型预置器支持 <code>ssh</code> 和 <code>winrm</code> 两种类型的 <code>connection</code>。</p>
<p>预置器根据运行的时机分为两种类型，创建时预置器以及销毁时预置器。</p>
<h2 id="1-4-6-1-7-创建时预置器"><a href="#%E5%88%9B%E5%BB%BA%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8"></a>1.4.6.1.7. 创建时预置器</h2>
<p>默认情况下，创建时资源对象会运行预置器，在对象更新、销毁时则不会运行。预置器的默认行为是为了引导一个系统。</p>
<p>如果创建时预置器失败了，那么资源对象会被标记污点(我们将在介绍 <code>terraform taint</code> 命令时详细介绍)。一个被标记污点的资源在下次执行 <code>terraform apply</code> 命令时会被销毁并重建。Terraform 的这种设计是因为当预置器运行失败时标志着资源处于半就绪的状态。由于 Terraform 无法衡量预置器的行为，所以唯一能够完全确保资源被正确初始化的方式就是删除重建。</p>
<p>我们可以通过设置 <code>on_failure</code> 参数来改变这种行为。</p>
<h2 id="1-4-6-1-8-销毁时预置器"><a href="#%E9%94%80%E6%AF%81%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8"></a>1.4.6.1.8. 销毁时预置器</h2>
<p>如果我们设置预置器的 <code>when</code> 参数为 <code>destroy</code>，那么预置器会在资源被销毁时执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    when    = destroy</span><br><span class="line">    command = &quot;echo &#x27;Destroy-time provisioner&#x27;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁时预置器在资源被实际销毁前运行。如果运行失败，Terraform 会报错，并在下次运行 <code>terraform apply</code> 操作时重新执行预置器。在这种情况下，需要仔细关注销毁时预置器以使之能够安全地反复执行。</p>
<p>注意：销毁时预置器不会在 <code>resource</code> 块配置了 <code>create_before_destroy = true</code> 时运行。</p>
<p>销毁时预置器只有在存在于代码中的情况下才会在销毁时被执行。如果一个 <code>resource</code> 块连带内部的销毁时预置器块一起被从代码中删除，那么被删除的预置器在资源被销毁时<strong>不会</strong>被执行。要解决这个问题，我们需要使用多个步骤来绕过这个限制：</p>
<ul>
<li>修改资源声明代码，添加 <code>count = 0</code> 参数</li>
<li>执行 <code>terraform apply</code>，运行删除时预置器，然后删除资源实例</li>
<li>删除 <code>resource</code> 块</li>
<li>重新执行 <code>terraform apply</code>，此时应该不会有任何变更需要执行</li>
</ul>
<p>该限制在未来将会得到解决，但目前来说我们必须节制使用销毁时预置器。</p>
<p>注意：一个被标记污点的 <code>resource</code> 块内的销毁时预置器不会被执行。这包括了因为创建时预置器失败或是手动使用 <code>terraform taint</code> 命令标记污点的资源。</p>
<h2 id="1-4-6-1-9-预置器失败行为"><a href="#%E9%A2%84%E7%BD%AE%E5%99%A8%E5%A4%B1%E8%B4%A5%E8%A1%8C%E4%B8%BA"></a>1.4.6.1.9. 预置器失败行为</h2>
<p>默认情况下，预置器运行失败会导致<code>terraform apply</code>执行失败。可以通过设置<code>on_failure</code>参数来改变这一行为。可以设置的值为：</p>
<ul>
<li><code>continue</code>：忽视错误，继续执行创建或是销毁</li>
<li><code>fail</code>：报错并终止执行变更(这是默认行为)。如果这是一个创建时预置器，则在对应资源对象上标记污点</li>
</ul>
<p>样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    command    = &quot;echo The server&#x27;s IP address is $&#123;self.private_ip&#125;&quot;</span><br><span class="line">    on_failure = continue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-6-1-10-删除资源"><a href="#%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90"></a>1.4.6.1.10. 删除资源</h2>
<p>注意：<code>removed</code> 块是在 Terraform v1.7 引入的功能。对于早期的 Terraform 版本，您可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/6.rm.html"><code>terraform state rm</code></a> 命令来处理。</p>
<p>要从 Terraform 中删除资源，只需从 Terraform 代码中删除 <code>resource</code> 块即可。</p>
<p>默认情况下，删除 <code>resource</code> 块后，Terraform 将计划销毁该资源管理的所有实际基础设施对象。</p>
<p>有时，我们可能希望从 Terraform 配置中删除资源，而不破坏它管理的实际基础设施对象。在这种情况下，资源将从 Terraform 状态中删除，但真正的基础设施对象不会被破坏。</p>
<p>要声明资源已从 Terraform 配置中删除，但不应销毁其托管对象，请从配置中删除 <code>resource</code> 块并将其替换为 <code>removed</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">removed &#123;</span><br><span class="line">  from = aws_instance.example</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    destroy = false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>from</code> 参数是您要删除的资源的地址，没有任何实例键（例如 <code>aws_instance.example[1]</code>）。</p>
<p><code>lifecycle</code> 块是必需的。 <code>destroy</code> 参数确定 Terraform 是否会尝试销毁资源管理的对象。 <code>false</code> 值表示 Terraform 将从状态中删除资源而不销毁实际的远程资源。</p>
<p><code>removed</code> 块还可以包含<a href="#%E9%94%80%E6%AF%81%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8">销毁时预置器</a>，以便即使 <code>resource</code> 块已被删除，预制器也可以保留在代码中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">removed &#123;</span><br><span class="line">  from = aws_instance.example</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    destroy = true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    when    = destroy</span><br><span class="line">    command = &quot;echo &#x27;Instance $&#123;self.id&#125; has been destroyed.&#x27;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通的销毁时预置器中的引用规则相同，仅允许使用 <code>count.index</code>、<code>each.key</code> 和 <code>self</code>。预置器必须指定 <code>when = destroy</code>，并且 <code>removed</code> 块必须声明 <code>destroy = true</code> 才能执行预置器。</p>
<h2 id="1-4-6-1-11-本地资源"><a href="#%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90"></a>1.4.6.1.11. 本地资源</h2>
<p>虽然大部分资源类型都对应的是通过远程基础设施 API 控制的一个资源对象，但也有一些资源对象他们只存在于 Terraform 进程自身内部，用来计算生成某些结果，并将这些结果保存在状态中以备日后使用。</p>
<p>比如说，我们可以用 <code>tls_private_key</code> 生成公私钥，用 <code>tls_self_signed_cert</code> 生成自签名证书，或者是用 <code>random_id</code> 生成随机 id。虽不像其他“真实”基础设施对象那般重要，但这些本地资源也可以成为连接其他资源有用的黏合剂。</p>
<p>本地资源的行为与其他类型资源是一致的，但是他们的结果数据仅存在于 Terraform 状态文件中。“销毁”这种资源只是将结果数据从状态中删除。</p>
<h2 id="1-4-6-1-12-操作超时设置"><a href="#%E6%93%8D%E4%BD%9C%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE"></a>1.4.6.1.12. 操作超时设置</h2>
<p>有些资源类型提供了特殊的 <code>timeouts</code> 内嵌块参数，它允许我们配置我们允许操作持续多长时间，超时将被认定为失败。比如说，<code>aws_db_instance</code> 资源允许我们分别为 <code>create</code>，<code>update</code>，<code>delete</code> 操作设置超时时间。</p>
<p>超时完全由资源对应的 Provider 来处理，但支持超时设置的 Provider 一般都遵循相同的传统，那就是由一个名为 <code>timeouts</code> 的内嵌块参数定义超时设置，<code>timeouts</code> 块内可以分别设置不同操作的超时时间。超时时间由 <code>string</code> 描述，比如 <code>&quot;60m&quot;</code> 代表 60 分钟，<code>&quot;10s&quot;</code> 代表 10 秒，<code>&quot;2h&quot;</code> 代表 2 小时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_db_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  timeouts &#123;</span><br><span class="line">    create = &quot;60m&quot;</span><br><span class="line">    delete = &quot;2h&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可配置超时的操作类别由每种支持超时设定的资源类型自行决定。大部分资源类型不支持设置超时。使用超时前请先查阅相关文档。</p>
<ul>
<li>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.7.1.</strong> 数据源</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.7.1.1.</strong> 使用数据源</a></p>
</li>
<li>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%82%E6%95%B0"><strong>1.4.7.1.2.</strong> 数据源参数</a></p>
</li>
<li>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E8%A1%8C%E4%B8%BA"><strong>1.4.7.1.3.</strong> 数据源行为</a></p>
</li>
<li>
<p><a href="#%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.7.1.4.</strong> 本地数据源</a></p>
</li>
<li>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><strong>1.4.7.1.5.</strong> 数据源的依赖关系</a></p>
</li>
<li>
<p><a href="#precondition-%E4%B8%8E-postcondition"><strong>1.4.7.1.6.</strong> Precondition 与 Postcondition</a></p>
</li>
<li>
<p><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><strong>1.4.7.1.7.</strong> 生命周期</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E4%BE%8B"><strong>1.4.7.1.8.</strong> 多数据源实例</a></p>
</li>
<li>
<p><a href="#%E6%8C%87%E5%AE%9A%E7%89%B9%E5%AE%9A-provider-%E5%AE%9E%E4%BE%8B"><strong>1.4.7.1.9.</strong> 指定特定 Provider 实例</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90"><strong>1.4.7.1.10.</strong> 例子</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.7.1.11.</strong> 引用数据源</a></p>
</li>
</ul>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90"></a></p>
<h2 id="1-4-7-1-数据源"><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.7.1. 数据源</h2>
<p>数据源允许查询或计算一些数据以供其他地方使用。使用数据源可以使得 Terraform 代码使用在 Terraform 管理范围之外的一些信息，或者是读取其他 Terraform 代码保存的状态。</p>
<p>每一种 Provider 都可以在定义一些资源类型的同时定义一些数据源。</p>
<h2 id="1-4-7-1-1-使用数据源"><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.7.1.1. 使用数据源</h2>
<p>数据源通过一种特殊的资源访问：<code>data</code> 资源。数据源通过 <code>data</code> 块声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data &quot;aws_ami&quot; &quot;example&quot; &#123;</span><br><span class="line">  most_recent = true</span><br><span class="line"></span><br><span class="line">  owners = [&quot;self&quot;]</span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name   = &quot;app-server&quot;</span><br><span class="line">    Tested = &quot;true&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 <code>data</code> 块请求 Terraform 从一个指定的数据源 <code>aws_ami</code> 读取指定数据并且把结果输出到 Local Name 为 <code>example</code> 的实例中。我们可以在同一模块内的代码中通过数据源名称来引用数据源，但无法从模块外部直接访问数据源。</p>
<p>同资源类似，一个数据源类型以及它的名称一同构成了该数据源的标识符，所以数据源类型加名称的组合在同一模块内必须是唯一的。</p>
<p>在 <code>data</code> 块体(<code>&#123;</code> 与 <code>&#125;</code> 中间的内容)是传给数据源的查询条件。查询条件参数的种类取决于数据源的类型，在上述例子中，<code>most_recent</code>、<code>owners</code> 和 <code>tags</code> 都是定义查询 <code>aws_ami</code> 数据源时使用的查询条件。</p>
<p>与数据源这种特殊资源不同的是，我们在上一节介绍的主要资源(使用 <code>resource</code> 块定义的)是一种“托管资源”。这两种资源都可以接收参数并对外输出属性，但托管资源会触发 Terraform 对基础设施对象进行增删改操作，而数据源只会触发读取操作。简单来说，我们一般说的“资源”就是特指托管资源。</p>
<h2 id="1-4-7-1-2-数据源参数"><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%82%E6%95%B0"></a>1.4.7.1.2. 数据源参数</h2>
<p>每一种数据源资源都关联到一种外部数据源，数据源类型决定了它接收的查询参数以及输出的数据。每一种数据源类型都属于一个 Provider。大部分 <code>data</code> 块内的数据源参数都是由对应的数据源类型定义的，这些参数的赋值可以使用完整的 Terraform 表达式能力或其他 Terraform 语言的功能。</p>
<p>然而类似资源，Terraform 也为所有类型的数据源定义了一些元参数。这些元参数的限制和功能我们将在后续节当中叙述。</p>
<h2 id="1-4-7-1-3-数据源行为"><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E8%A1%8C%E4%B8%BA"></a>1.4.7.1.3. 数据源行为</h2>
<p>如果数据源的查询参数涉及到的表达式只引用了字面量或是在执行 <code>terraform plan</code> 时就已知的数据(比如输入变量)，那么数据源会在执行 Terraform 的 “refersh” 阶段时被读取，然后 Terraform 会构建变更计划。这保证了在制定变更计划时 Terraform 可以使用这些数据源的返回数据。</p>
<p>如果查询参数的表达式引用了那些只有执行部分执行变更计划以后才能知晓的数据，比如另一个还未被创建的托管资源的输出，那么数据源的读取操作会被推迟到 “apply” 阶段。以下几种情况下 Terraform 会推迟数据源的读取：</p>
<ul>
<li>给定的参数中至少有一个是一个托管资源的属性或是其他值，Terraform 在执行步骤之前无法预测。</li>
<li><code>data</code> 块内的查询参数引用了一个还未被创建的托管资源的输出。</li>
<li><code>data</code> 块内声明的 <code>precondition</code> 或 <code>postcondition</code> 直接或间接地依赖了一个在当前计划中有变更的托管资源。</li>
</ul>
<p>任何引用该数据源输出的表达式的值在执行到数据源被读取完之前都是未知的。</p>
<h2 id="1-4-7-1-4-本地数据源"><a href="#%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.7.1.4. 本地数据源</h2>
<p>虽然绝大多数数据源都对应了一个通过远程基础设施 API 访问的外部数据源，但是也有一些特殊的数据源仅存在于 Terraform 进程内部，计算并对外输出一些数据。</p>
<p>比如说，本地数据源有 <code>template_file</code>、<code>local_file</code>、<code>aws_iam_policy_document</code> 等。</p>
<p>本地数据源的行为与其他数据源完全一致，但他们输出的结果数据只是临时存在于 Terraform 运行时，每次计算一个新的变更计划时这些值都会被重新计算。</p>
<h2 id="1-4-7-1-5-数据源的依赖关系"><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"></a>1.4.7.1.5. 数据源的依赖关系</h2>
<p>数据源有着与资源一样的依赖机制，我们也可以在 <code>data</code> 块内设置 <code>depends_on</code> 元参数来显式声明依赖关系，在此不再赘述。</p>
<p>注意：在 Terraform 0.12 及更早版本中，由于 <code>data</code> 会将尚不知晓值的读取推迟到 Apply 阶段，因此将 <code>dependent_on</code> 与 <code>data</code> 一起使用将强制将数据的读取推迟到 Apply 阶段，因此，使用 <code>depends_on</code> 的 <code>data</code> 数据源配置永远无法收敛。由于这种行为，我们不建议对 <code>data</code> 使用 <code>depends_on</code>。</p>
<h2 id="1-4-7-1-6-Precondition-与-Postcondition"><a href="#precondition-%E4%B8%8E-postcondition"></a>1.4.7.1.6. Precondition 与 Postcondition</h2>
<p>您可以使用 <code>precondition</code> 和 <code>postcondition</code> 块来指定有关 <code>data</code> 如何运行的假设和验证。以下实力创建一个 <code>postcondition</code> 来检查 AMI 是否具有正确的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data &quot;aws_ami&quot; &quot;example&quot; &#123;</span><br><span class="line">  id = var.aws_ami_id</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    # The AMI ID must refer to an existing AMI that has the tag &quot;nomad-server&quot;.</span><br><span class="line">    postcondition &#123;</span><br><span class="line">      condition     = self.tags[&quot;Component&quot;] == &quot;nomad-server&quot;</span><br><span class="line">      error_message = &quot;tags[\&quot;Component\&quot;] must be \&quot;nomad-server\&quot;.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义条件检查可以声明对数据的假设，帮助未来的维护人员了解代码的设计和意图。它们还可以更早地在上下文中返回有关错误的有用信息，帮助使用者更轻松地诊断其配置中的问题。</p>
<h2 id="1-4-7-1-7-生命周期"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"></a>1.4.7.1.7. 生命周期</h2>
<p>同资源<strong>不一样</strong>，数据源目前的 <code>lifecycle</code> 块中只支持 <code>precondition</code> 和 <code>postcondition</code> 块。</p>
<h2 id="1-4-7-1-8-多数据源实例"><a href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E4%BE%8B"></a>1.4.7.1.8. 多数据源实例</h2>
<p>与资源一样，数据源也可以通过设置 <code>count</code>、<code>for_each</code> 元参数来创建一组多个数据源实例，并且 Terraform 也会把每个数据源实例单独创建并读取相应的外部数据，对 <code>count.index</code> 与 <code>each</code> 的使用也是一样的，在 <code>count</code> 与 <code>for_each</code> 之间选择的原则也是一样的。</p>
<h2 id="1-4-7-1-9-指定特定-Provider-实例"><a href="#%E6%8C%87%E5%AE%9A%E7%89%B9%E5%AE%9A-provider-%E5%AE%9E%E4%BE%8B"></a>1.4.7.1.9. 指定特定 Provider 实例</h2>
<p>同资源一样，数据源也可以通过 <code>provider</code> 元参数指定使用特定 Provider 实例，在此不再赘述。</p>
<h2 id="1-4-7-1-10-例子"><a href="#%E4%BE%8B%E5%AD%90"></a>1.4.7.1.10. 例子</h2>
<p>一个数据源定义例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Find the latest available AMI that is tagged with Component = web</span><br><span class="line">data &quot;aws_ami&quot; &quot;web&quot; &#123;</span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;state&quot;</span><br><span class="line">    values = [&quot;available&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;tag:Component&quot;</span><br><span class="line">    values = [&quot;web&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  most_recent = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-7-1-11-引用数据源"><a href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.7.1.11. 引用数据源</h2>
<p>引用数据源数据的语法是<code>data.&lt;TYPE&gt;.&lt;NAME&gt;.&lt;ATTRIBUTE&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = data.aws_ami.web.id</span><br><span class="line">  instance_type = &quot;t1.micro&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>1.4.8.1.</strong> 表达式</a></p>
</li>
<li>
<p><a href="#%E4%B8%8B%E6%A0%87%E5%92%8C%E5%B1%9E%E6%80%A7"><strong>1.4.8.1.1.</strong> 下标和属性</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E5%91%BD%E5%90%8D%E5%80%BC"><strong>1.4.8.1.2.</strong> 引用命名值</a></p>
</li>
<li>
<p><a href="#%E5%B1%80%E9%83%A8%E5%91%BD%E5%90%8D%E5%80%BC"><strong>1.4.8.1.3.</strong> 局部命名值</a></p>
</li>
<li>
<p><a href="#%E5%91%BD%E5%90%8D%E5%80%BC%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><strong>1.4.8.1.4.</strong> 命名值的依赖关系</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90%E8%BE%93%E5%87%BA%E5%B1%9E%E6%80%A7"><strong>1.4.8.1.5.</strong> 引用资源输出属性</a></p>
</li>
<li>
<p><a href="#%E5%B0%9A%E4%B8%8D%E7%9F%A5%E6%99%93%E7%9A%84%E5%80%BC"><strong>1.4.8.1.6.</strong> 尚不知晓的值</a></p>
</li>
<li>
<p><a href="#%E7%AE%97%E6%95%B0%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.</strong> 算数和逻辑操作符</a></p>
</li>
<li>
<p><a href="#%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.1.</strong> 算数操作符</a></p>
</li>
<li>
<p><a href="#%E7%9B%B8%E7%AD%89%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.2.</strong> 相等性操作符</a></p>
</li>
<li>
<p><a href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.3.</strong> 比较操作符</a></p>
</li>
<li>
<p><a href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.4.</strong> 逻辑操作符</a></p>
</li>
<li>
<p><a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>1.4.8.1.8.</strong> 条件表达式</a></p>
</li>
<li>
<p><a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><strong>1.4.8.1.9.</strong> 函数调用</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E5%BC%80%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82"><strong>1.4.8.1.9.1.</strong> 展开函数入参</a></p>
</li>
<li>
<p><a href="#for-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>1.4.8.1.10.</strong> for 表达式</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8Fsplat-expression"><strong>1.4.8.1.11.</strong> 展开表达式(Splat Expression)</a></p>
</li>
<li>
<p><a href="#%E9%81%97%E7%95%99%E7%9A%84%E6%97%A7%E6%9C%89%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>1.4.8.1.11.1.</strong> 遗留的旧有展开表达式</a></p>
</li>
<li>
<p><a href="#dynamic-%E5%9D%97"><strong>1.4.8.1.12.</strong> dynamic 块</a></p>
</li>
<li>
<p><a href="#dynamic-%E5%9D%97%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><strong>1.4.8.1.12.1.</strong> dynamic 块的最佳实践</a></p>
</li>
<li>
<p><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><strong>1.4.8.1.13.</strong> 字符串字面量</a></p>
</li>
<li>
<p><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%89%88"><strong>1.4.8.1.14.</strong> 字符串模版</a></p>
</li>
<li>
<p><a href="#%E6%8F%92%E5%80%BCinterpolation"><strong>1.4.8.1.14.1.</strong> 插值(Interpolation)</a></p>
</li>
<li>
<p><a href="#%E5%91%BD%E4%BB%A4directive"><strong>1.4.8.1.14.2.</strong> 命令(Directive)</a></p>
</li>
<li>
<p><a href="#terraform-%E6%8F%92%E5%80%BC"><strong>1.4.8.1.15.</strong> Terraform 插值</a></p>
</li>
</ul>
<p><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a></p>
<h2 id="1-4-8-1-表达式"><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a>1.4.8.1. 表达式</h2>
<p>表达式用来在配置文件中进行一些计算。最简单的表达式就是字面量，比如 <code>&quot;hello&quot;</code>，或者 <code>5</code>。<code>Terraform</code> 也支持一些更加复杂的表达式，比如引用其他 <code>resource</code> 的输出值、数学计算、布尔条件计算，以及一些内建的函数。</p>
<p>Terraform 配置中很多地方都可以使用表达式，但某些特定的场景下限制了可以使用的表达式的类型，例如只准使用特定数据类型的字面量，或是禁止使用 <code>resource</code> 的输出值。</p>
<p>您可以通过运行 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/5.console"><code>terraform console</code> 命令</a>，从 Terraform 表达式控制台测试 Terraform 表达式的行为。</p>
<p>我们在类型章节中已经基本介绍了类型以及类型相关的字面量，下面我们来介绍一些其他的表达式。</p>
<h2 id="1-4-8-1-1-下标和属性"><a href="#%E4%B8%8B%E6%A0%87%E5%92%8C%E5%B1%9E%E6%80%A7"></a>1.4.8.1.1. 下标和属性</h2>
<p><code>list</code> 和 <code>tuple</code> 可以通过下标访问成员，例如 <code>local.list[3]</code>、<code>var.tuple[2]</code>。<code>map</code> 和 <code>object</code> 可以通过属性访问成员，例如 <code>local.object.attrname</code>、<code>local.map.keyname</code>。由于 <code>map</code> 的键是用户定义的，可能无法成为合法的 Terraform 标识符，所以访问 <code>map</code> 成员时我们推荐使用方括号：<code>local.map[&quot;keyname&quot;]</code>。</p>
<h2 id="1-4-8-1-2-引用命名值"><a href="#%E5%BC%95%E7%94%A8%E5%91%BD%E5%90%8D%E5%80%BC"></a>1.4.8.1.2. 引用命名值</h2>
<p>Terraform 中定义了多种命名值，表达式中的每一个命名值都关联到一个具体的值，我们可以用单一命名值作为一个表达式，或是组合多个命名值来计算出一个新值。</p>
<p>命名值有如下种类：</p>
<ul>
<li><code>&lt;RESOURCE TYPE&gt;.&lt;NAME&gt;</code>：表示一个资源对象。凡是不符合后面列出的命名值模式的表达式都会被 Terraform 解释为一个托管资源。如果资源声明了 <code>count</code> 元参数，那么该表达式表示的是一个对象实例的 <code>list</code>。如果资源声明了 <code>for_each</code> 元参数，那么该表达式表示的是一个对象实例的 <code>map</code>。</li>
<li><code>var.&lt;NAME&gt;</code>：表示一个输入变量</li>
<li><code>local.&lt;NAME&gt;</code>：表示一个局部值</li>
<li><code>module.&lt;MODULE_NAME&gt;.&lt;OUTPUT_NAME&gt;</code>：表示一个模块的一个输出值</li>
<li><code>data.&lt;DATA_TYPE&gt;.&lt;NAME&gt;</code>：表示一个数据源实例。如果数据源声明了 <code>count</code> 元参数，那么该表达式表示的是一个数据源实例 <code>list</code>。如果数据源声明了 <code>for_each</code> 元参数，那么该表达式表示的是一个数据源实例 <code>map</code>。</li>
<li><code>path.module</code>：表示当前模块在文件系统中的路径</li>
<li><code>path.root</code>：表示根模块(调用 Terraform 命令行执行的代码文件所在的模块)在文件系统中的路径</li>
<li><code>path.cwd</code>：表示当前工作目录的路径。一般来说该路径等同于 <code>path.root</code>，但在调用 Terraform 命令行时如果指定了代码路径，那么二者将会不同。</li>
<li><code>terraform.workspace</code>：当前使用的 Workspace (我们在状态管理的<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html#%E7%8A%B6%E6%80%81%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AD%98%E5%82%A8">&quot;状态的隔离存储&quot;</a>中介绍过)</li>
</ul>
<p>虽然这些命名表达式可以使用 <code>.&lt;NAME&gt;</code> 号来访问对象的各种属性，但实际上他们实际类型并不是我们在类型章节里提到过的 <code>object</code>。两者的区别在于，<code>object</code> 同时支持使用 <code>.&lt;NAME&gt;</code> 或者 <code>[&quot;&lt;NAME&gt;&quot;]</code> 两种方式访问对象成员属性，而上述命名表达式仅支持 <code>.&lt;NAME&gt;</code>。</p>
<h2 id="1-4-8-1-3-局部命名值"><a href="#%E5%B1%80%E9%83%A8%E5%91%BD%E5%90%8D%E5%80%BC"></a>1.4.8.1.3. 局部命名值</h2>
<p>在某些特定表达式或上下文当中，有一些特殊的命名值可以被使用，他们是局部命名值。几种比较常见的局部命名值有：</p>
<ul>
<li><code>count.index</code>：表达当前 <code>count</code> 下标序号</li>
<li><code>each.key</code>：表达当前 <code>for_each</code> 迭代器实例</li>
<li><code>self</code>：在预置器中指代声明预置器的资源</li>
</ul>
<h2 id="1-4-8-1-4-命名值的依赖关系"><a href="#%E5%91%BD%E5%90%8D%E5%80%BC%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"></a>1.4.8.1.4. 命名值的依赖关系</h2>
<p>构建资源或是模块时经常会使用含有命名值的表达式赋值，Terraform 会分析这些表达式并自动计算出对象之间的依赖关系。</p>
<h2 id="1-4-8-1-5-引用资源输出属性"><a href="#%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90%E8%BE%93%E5%87%BA%E5%B1%9E%E6%80%A7"></a>1.4.8.1.5. 引用资源输出属性</h2>
<p>最常见的引用类型就是引用一个 <code>resource</code> 或 <code>data</code> 块定义的对象的输出属性。由于这些资源与数据源对象结构可能非常复杂，所以对它们的输出属性的引用表达式也可能非常复杂。</p>
<p>比如下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-abc123&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  ebs_block_device &#123;</span><br><span class="line">    device_name = &quot;sda2&quot;</span><br><span class="line">    volume_size = 16</span><br><span class="line">  &#125;</span><br><span class="line">  ebs_block_device &#123;</span><br><span class="line">    device_name = &quot;sda3&quot;</span><br><span class="line">    volume_size = 20</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>aws_instance</code> 文档列出了该类型所支持的所有输入参数和内嵌块，以及对外输出的属性列表。所有这些不同的资源类型 Schema 都可以在引用中使用，如下所示：</p>
<ul>
<li><code>ami</code> 参数可以在可以在其他地方用 <code>aws_instance.example.ami</code> 表达式来引用</li>
<li><code>id</code> 属性可以用 <code>aws_instance.example.id</code> 的表达式来引用</li>
<li>内嵌的 <code>ebs_block_device</code> 参数可以通过后面会介绍的<a href="#%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8Fsplat-expression">展开表达式(splat expression)</a>来访问，比如我们获取所有的 <code>ebs_block_device</code> 的 <code>device_name</code> 列表：<code>aws_instance.example.ebs_block_device[*].device_name</code></li>
<li>在 <code>aws_instance</code> 类型里的内嵌块并没有任何输出属性，但如果 <code>ebs_block_device</code> 添加了一个名为 <code>&quot;id&quot;</code> 的输出属性，那么可以用 <code>aws_instance.example.ebs_block_device[*].id</code> 表达式来访问含有所有 <code>id</code> 的列表</li>
<li>有时多个内嵌块会各自包含一个逻辑键来区分彼此，类似用资源名访问资源，我们也可以用内嵌块的名字来访问特定内嵌块。假如 <code>aws_instance</code> 类型有一个假想的内嵌块类型 <code>device</code> 并规定 <code>device</code> 可以赋予这样的一个逻辑键，那么代码看起来就会是这样的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">device &quot;foo&quot; &#123;</span><br><span class="line">  size = 2</span><br><span class="line">&#125;</span><br><span class="line">device &quot;bar&quot; &#123;</span><br><span class="line">  size = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用键来访问特定块的数据，例如：<code>aws_instance.example.device[&quot;foo&quot;].size</code></p>
<p>要获取一个 <code>device</code> 名称到 <code>device</code> 大小的映射，可以使用 <code>for</code> 表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;for k, device in aws_instance.example.device : k =&gt; device.size&#125;</span><br></pre></td></tr></table></figure>
<p>当一个资源声明了 <code>count</code> 参数，那么资源本身就成了一个资源对象列表而非单个资源。这种情况下要访问资源输出属性，要么使用展开表达式，要么使用下标索引：</p>
<ul>
<li><code>aws_instance.example[*].id</code>：返回所有 instance 的 <code>id</code> 列表</li>
<li><code>aws_instance.example[0].id</code>：返回第一个 instance的 <code>id</code></li>
</ul>
<p>当一个资源声明了 <code>for_each</code> 参数，那么资源本身就成了一个资源对象字典而非单个资源。这种情况下要访问资源的输出属性，要么使用特定键，要么使用 <code>for</code> 表达式：</p>
<ul>
<li><code>aws_instance.example[&quot;a&quot;].id</code>：返回 <code>&quot;a&quot;</code> 对应的实例的 <code>id</code></li>
<li><code>[for value in aws_instance.example: value.id]</code>：返回所有 instance 的 <code>id</code></li>
</ul>
<p>注意不像使用 <code>count</code>，使用 <code>for_each</code> 的资源集合不能直接使用展开表达式，展开表达式只能适用于列表。你可以把字典转换成列表后再使用展开表达式：</p>
<ul>
<li><code>values(aws_instance.example)[*].id</code></li>
</ul>
<h2 id="1-4-8-1-6-尚不知晓的值"><a href="#%E5%B0%9A%E4%B8%8D%E7%9F%A5%E6%99%93%E7%9A%84%E5%80%BC"></a>1.4.8.1.6. 尚不知晓的值</h2>
<p>当 Terraform 在计算变更计划时，有些资源输出属性无法立即求值，因为他们的值取决于远程API的返回值。比如说，有一个远程对象可以在创建时返回一个生成的唯一 <code>id</code>，Terraform 无法在创建它之前就预知这个值。</p>
<p>为了允许在计算变更阶段就能计算含有这种值的表达式，Terraform 使用了一个特殊的&quot;尚不知晓(unknown value)&quot;占位符来代替这些结果。大部分时候你不需要特意理会它们，因为 Terraform 语言会自动处理这些尚不知晓的值，比如说使两个尚不知晓的值相加得到的会是一个尚不知晓的值。</p>
<p>然而，有些情况下表达式中含有尚不知晓的值会有明显的影响：</p>
<ul>
<li><code>count</code> 元参数不可以为尚不知晓，因为变更计划必须明确地知晓到底要维护多少个目标实例</li>
<li>如果尚不知晓的值被用于数据源，那么数据源在计算变更计划阶段就无法读取，它会被推迟到执行阶段读取。这种情况下，在计划阶段该数据源的一切输出均为尚不知晓</li>
<li>如果声明 <code>module</code> 块时传递给模块输入变量的表达式使用了尚不知晓值，那么在模块代码中任何使用了该输入变量值的表达式的值都将是尚不知晓</li>
<li>如果模块输出值表达式中含有尚不知晓值，任何使用该模块输出值的表达式都将是尚不知晓</li>
<li>Terraform 会尝试验证尚不知晓值的数据类型是否合法，但仍然有可能无法正确检查数据类型，导致执行阶段发生错误</li>
</ul>
<p>尚不知晓值在执行 <code>terraform plan</code> 时会被输出为 “(not yet known)”。</p>
<h2 id="1-4-8-1-7-算数和逻辑操作符"><a href="#%E7%AE%97%E6%95%B0%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7. 算数和逻辑操作符</h2>
<p>一个操作符是一种用以转换或合并一个或多个表达式的表达式。操作符要么是把两个值计算为第三个值，也就是二元操作符；要么是把一个值转换成另一个值，也就是一元操作符。</p>
<p>二元操作符位于两个表达式的中间，类似 <code>1+2</code>。一元操作符位于一个表达式的前面，类似 <code>!true</code>。</p>
<p>Terraform 的 HCL 语言支持一组算数和逻辑操作符，它们的功能类似于 JavaScript 或 Ruby 里的操作符功能。</p>
<p>当一个表达式中含有多个操作符时，它们的优先级顺序为：</p>
<ol>
<li><code>!</code>，<code>-</code> (负号)</li>
<li><code>*</code>，<code>/</code>，<code>%</code></li>
<li><code>+</code>，<code>-</code> (减号)</li>
<li><code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li>
<li><code>==</code>，<code>!=</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
</ol>
<p>可以使用小括号覆盖默认优先级。如果没有小括号，高优先级操作符会被先计算，例如 <code>1+2*3</code> 会被解释成 <code>1+(2*3)</code> 而不是 <code>(1+2)*3</code>。</p>
<p>不同的操作符可以按它们之间相似的行为被归纳为几组，每一组操作符都期待被给予特定类型的值。Terraform 会在类型不符时尝试进行隐式类型转换，如果失败则会抛错。</p>
<h3 id="1-4-8-1-7-1-算数操作符"><a href="#%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7.1. 算数操作符</h3>
<ul>
<li><code>a + b</code>：返回 <code>a</code> 与 <code>b</code> 的和</li>
<li><code>a - b</code>：返回 <code>a</code> 与 <code>b</code> 的差</li>
<li><code>a * b</code>：返回 <code>a</code> 与 <code>b</code> 的积</li>
<li><code>a / b</code>：返回 <code>a</code> 与 <code>b</code> 的商</li>
<li><code>a % b</code>：返回 <code>a</code> 与 <code>b</code> 的模。该操作符一般仅在 <code>a</code> 与 <code>b</code> 是整数时有效</li>
<li><code>-a</code>：返回 <code>a</code> 与 <code>-1</code> 的商</li>
</ul>
<h3 id="1-4-8-1-7-2-相等性操作符"><a href="#%E7%9B%B8%E7%AD%89%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7.2. 相等性操作符</h3>
<ul>
<li><code>a == b</code>：如果 <code>a</code> 与 <code>b</code> 类型与值都相等返回 <code>true</code>，否则返回 <code>false</code></li>
<li><code>a != b</code>：与 <code>==</code> 相反</li>
</ul>
<h3 id="1-4-8-1-7-3-比较操作符"><a href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7.3. 比较操作符</h3>
<ul>
<li><code>a &lt; b</code>：如果 <code>a</code> 比 <code>b</code> 小则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>a &gt; b</code>：如果 <code>a</code> 比 <code>b</code> 大则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>a &lt;= b</code>：如果 <code>a</code> 比 <code>b</code> 小或者相等则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>a &gt;= b</code>：如果 <code>a</code> 比 <code>b</code> 大或者相等则为 <code>true</code>，否则为 <code>false</code></li>
</ul>
<h3 id="1-4-8-1-7-4-逻辑操作符"><a href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7.4. 逻辑操作符</h3>
<ul>
<li><code>a || b</code>：<code>a</code> 或 <code>b</code> 中有至少一个为 <code>true</code> 则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>a &amp;&amp; b</code>：<code>a</code> 与比都为 <code>true</code> 则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>!a</code>：如果 <code>a</code> 为 <code>true</code> 则为 <code>false</code>，如果 <code>a</code> 为 <code>false</code> 则为 <code>true</code></li>
</ul>
<h2 id="1-4-8-1-8-条件表达式"><a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a>1.4.8.1.8. 条件表达式</h2>
<p>条件表达式是判断一个布尔表达式的结果以便于在后续两个值当中选择一个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? true_val : false_val</span><br></pre></td></tr></table></figure>
<p>如果 <code>condition</code> 表达式为 <code>true</code>，那么结果是 <code>true_value</code>，反之则为 <code>false_value</code>。</p>
<p>一个常见的条件表达式用法是使用默认值替代非法值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var.a != &quot;&quot; ? var.a : &quot;default-a&quot;</span><br></pre></td></tr></table></figure>
<p>(注：以上表达式目前推荐写为：<code>coalesce(var.a, &quot;default-a&quot;)</code>)</p>
<p>如果输入变量 <code>a</code> 的值是空字符串，那么结果会是 <code>default-a</code>，否则返回输入变量 <code>a</code> 的值。</p>
<p>条件表达式的判断条件可以使用上述的任意操作符。供选择的两个值也可以是任意类型，但它们的类型必须相同，这样 Terraform 才能判断条件表达式的输出类型。</p>
<h2 id="1-4-8-1-9-函数调用"><a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"></a>1.4.8.1.9. 函数调用</h2>
<p>Terraform 支持在计算表达式时使用一些内建函数，函数调用表达式类似操作符，通用语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FUNCTION NAME&gt;(&lt;ARGUMENT 1&gt;, &lt;ARGUMENT 2&gt;)</span><br></pre></td></tr></table></figure>
<p>函数名标明了要调用的函数。每一个函数都定义了数量不等、类型不一的入参以及不同类型的返回值。</p>
<p>有些函数定义了不定长的入参表，例如，<code>min</code> 函数可以接收任意多个数值类型入参，返回其中最小的数值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min(55, 3453, 2)</span><br></pre></td></tr></table></figure>
<h3 id="1-4-8-1-9-1-展开函数入参"><a href="#%E5%B1%95%E5%BC%80%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82"></a>1.4.8.1.9.1. 展开函数入参</h3>
<p>如果想要把列表或元组的元素作为参数传递给函数，那么我们可以使用展开符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min([55, 2453, 2]...)</span><br></pre></td></tr></table></figure>
<p>展开符使用的是三个独立的 <code>.</code> 号组成的 <code>...</code>，不是 Unicode 中的省略号 <code>…</code>。展开符是一种只能用在函数调用场景下的特殊语法。</p>
<p>有关完整的内建函数我们可能会在今后撰写相应的章节介绍。</p>
<h2 id="1-4-8-1-10-for-表达式"><a href="#for-%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a>1.4.8.1.10. for 表达式</h2>
<p><code>for</code> 表达式是将一种复杂类型映射成另一种复杂类型的表达式。输入类型值中的每一个元素都会被映射为一个或零个结果。</p>
<p>举例来说，如果 <code>var.list</code> 是一个字符串列表，那么下面的表达式将会把列表元素全部转为大写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for s in var.list : upper(s)]</span><br></pre></td></tr></table></figure>
<p>在这里 <code>for</code> 表达式迭代了 <code>var.list</code> 中每一个元素(就是 <code>s</code>)，然后计算了 <code>upper(s)</code>，最后构建了一个包含了所有 <code>upper(s)</code> 结果的新元组，元组内元素顺序与源列表相同。</p>
<p><code>for</code> 表达式周围的括号类型决定了输出值的类型。上面的例子里我们使用了方括号，所以输出类型是元组。如果使用的是花括号，那么输出类型是对象，<code>for</code> 表达式内部冒号后面应该使用以 <code>=&gt;</code> 符号分隔的表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;for s in var.list : s =&gt; upper(s)&#125;</span><br></pre></td></tr></table></figure>
<p>该表达式返回一个对象，对象的成员属性名称就是源列表中的元素，值就是对应的大写值。</p>
<p>一个 <code>for</code> 表达式还可以包含一个可选的 <code>if</code> 子句用以过滤结果，这可能会减少返回的元素数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for s in var.list : upper(s) if s != &quot;&quot;]</span><br></pre></td></tr></table></figure>
<p>被 <code>for</code> 迭代的也可以是对象或者字典，这样的话迭代器就会被表示为两个临时变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for k, v in var.map : length(k) + length(v)]</span><br></pre></td></tr></table></figure>
<p>最后，如果返回类型是对象(使用花括号)那么表达式中可以使用 <code>...</code> 符号实现 group by：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;for s in var.list : substr(s, 0, 1) =&gt; s... if s != &quot;&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-8-1-11-展开表达式-Splat-Expression"><a href="#%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8Fsplat-expression"></a>1.4.8.1.11. 展开表达式(Splat Expression)</h2>
<p>展开表达式提供了一种类似 <code>for</code> 表达式的简洁表达方式。比如说 <code>var.list</code> 包含一组对象，每个对象有一个属性 <code>id</code>，那么读取所有 <code>id</code> 的 <code>for</code> 表达式会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for o in var.list : o.id]</span><br></pre></td></tr></table></figure>
<p>与之等价的展开表达式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var.list[*].id</span><br></pre></td></tr></table></figure>
<p>这个特殊的 <code>[*]</code> 符号迭代了列表中每一个元素，然后返回了它们在 <code>.</code> 号右边的属性值。</p>
<p>展开表达式只能被用于列表(所以使用 <code>for_each</code> 参数的资源不能使用展开表达式，因为它的类型是字典)。然而，如果一个展开表达式被用于一个既不是列表又不是元组的值，那么这个值会被自动包装成一个单元素的列表然后被处理。</p>
<p>比如说，<code>var.single_object[*].id</code> 等价于 <code>[var.single_object][*].id</code>。大部分场景下这种行为没有什么意义，但在访问一个不确定是否会定义 <code>count</code> 参数的资源时，这种行为很有帮助，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws_instance.example[*].id</span><br></pre></td></tr></table></figure>
<p>上面的表达式不论 <code>aws_instance.example</code> 定义了 <code>count</code> 与否都会返回实例的 <code>id</code> 列表，这样如果我们以后为 <code>aws_instance.example</code> 添加了 <code>count</code> 参数我们也不需要修改这个表达式。</p>
<h3 id="1-4-8-1-11-1-遗留的旧有展开表达式"><a href="#%E9%81%97%E7%95%99%E7%9A%84%E6%97%A7%E6%9C%89%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a>1.4.8.1.11.1. 遗留的旧有展开表达式</h3>
<p>曾经存在另一种旧的展开表达式语法，它是一种比较弱化的展开表达式，现在应该尽量避免使用。</p>
<p>这种旧的展开表达式使用 <code>.*</code> 而不是 <code>[*]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var.list.*.interfaces[0].name</span><br></pre></td></tr></table></figure>
<p>要特别注意该表达式与现有的展开表达式结果不同，它的行为等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for o in var.list : o.interfaces][0].name</span><br></pre></td></tr></table></figure>
<p>而现有 <code>[*]</code> 展开表达式的行为等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for o in var.list : o.interfaces[0].name]</span><br></pre></td></tr></table></figure>
<p>注意两者右方括号的位置。</p>
<h2 id="1-4-8-1-12-dynamic-块"><a href="#dynamic-%E5%9D%97"></a>1.4.8.1.12. dynamic 块</h2>
<p>在顶级块，例如 <code>resource</code> 块当中，一般只能以类似 <code>name = expression</code> 的形式进行一对一的赋值。大部分情况下这已经够用了，但某些资源类型包含了可重复的内嵌块，无法使用表达式循环赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource  &quot;aws_elastic_beanstalk_environment&quot; &quot;tfenvtest&quot; &#123;</span><br><span class="line">  name = &quot;tf-test-name&quot; # can use expressions here</span><br><span class="line"></span><br><span class="line">  setting &#123;</span><br><span class="line">    # but the &quot;setting&quot; block is always a literal block</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以用 <code>dynamic</code> 块来动态构建重复的 <code>setting</code> 这样的内嵌块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_elastic_beanstalk_environment&quot; &quot;tfenvtest&quot; &#123;</span><br><span class="line">  name                = &quot;tf-test-name&quot;</span><br><span class="line">  application         = &quot;$&#123;aws_elastic_beanstalk_application.tftest.name&#125;&quot;</span><br><span class="line">  solution_stack_name = &quot;64bit Amazon Linux 2018.03 v2.11.4 running Go 1.12.6&quot;</span><br><span class="line"></span><br><span class="line">  dynamic &quot;setting&quot; &#123;</span><br><span class="line">    for_each = var.settings</span><br><span class="line">    content &#123;</span><br><span class="line">      namespace = setting.value[&quot;namespace&quot;]</span><br><span class="line">      name = setting.value[&quot;name&quot;]</span><br><span class="line">      value = setting.value[&quot;value&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dynamic</code> 可以在 <code>resource</code>、<code>data</code>、<code>provider</code> 和 <code>provisioner</code> 块内使用。一个 <code>dynamic</code> 块类似于 <code>for</code> 表达式，只不过它产生的是内嵌块。它可以迭代一个复杂类型数据然后为每一个元素生成相应的内嵌块。在上面的例子里：</p>
<ul>
<li><code>dynamic</code> 的标签(也就是 <code>&quot;setting&quot;</code>)确定了我们要生成的内嵌块种类</li>
<li><code>for_each</code> 参数提供了需要迭代的复杂类型值</li>
<li><code>iterator</code> 参数(可选)设置了用以表示当前迭代元素的临时变量名。如果没有设置 <code>iterator</code>，那么临时变量名默认就是 <code>dynamic</code> 块的标签(也就是 <code>setting</code>)</li>
<li><code>labels</code> 参数(可选)是一个表示块标签的有序列表，用以按次序生成一组内嵌块。有 <code>labels</code> 参数的表达式里可以使用临时的 <code>iterator</code> 变量</li>
<li>内嵌的 <code>content</code> 块定义了要生成的内嵌块的块体。你可以在 <code>content</code> 块内部使用临时的 <code>iterator</code> 变量</li>
</ul>
<p>由于 <code>for_each</code> 参数可以是集合或者结构化类型，所以你可以使用 <code>for</code> 表达式或是展开表达式来转换一个现有集合的类型。</p>
<p><code>iterator</code> 变量(上面的例子里就是 <code>setting</code>)有两个属性：</p>
<ul>
<li><code>key</code>：迭代容器如果是 <code>map</code>，那么就是当前元素的键；迭代容器如果是 <code>list</code>，那么就是当前元素在 <code>list</code> 中的下标序号；如果是由 <code>for_each</code> 表达式产出的 <code>set</code>，那么 <code>key</code> 和 <code>value</code> 是一样的，这时我们不应该使用 <code>key</code>。</li>
<li><code>value</code>：当前元素的值</li>
</ul>
<p>一个 <code>dynamic</code> 块只能生成属于当前块定义过的内嵌块参数。无法生成诸如 <code>lifecycle</code>、<code>provisioner</code> 这样的元参数，因为 Terraform 必须在确保对这些元参数求值的计算是成功的。</p>
<p><code>for_each</code> 的值必须是不为空的 <code>map</code> 或者 <code>set</code>。如果你需要根据内嵌数据结构或者多个数据结构的元素组合来声明资源实例集合，你可以使用 Terraform 表达式和函数来生成合适的值。</p>
<h3 id="1-4-8-1-12-1-dynamic-块的最佳实践"><a href="#dynamic-%E5%9D%97%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"></a>1.4.8.1.12.1. dynamic 块的最佳实践</h3>
<p>过度使用 <code>dynamic</code> 块会导致代码难以阅读以及维护，所以我们建议只在需要构造可重用的模块代码时使用 <code>dynamic</code> 块。尽可能手写内嵌块。</p>
<h2 id="1-4-8-1-13-字符串字面量"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"></a>1.4.8.1.13. 字符串字面量</h2>
<p>Terraform 有两种不同的字符串字面量。最通用的就是用一对双引号包裹的字符，比如 <code>&quot;hello&quot;</code>。在双引号之间，反斜杠 <code>\</code> 被用来进行转义。Terraform 支持的转义符有：</p>
<table>
<thead>
<tr>
<th>Sequence</th>
<th>Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号 (不会截断字符串)</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠</td>
</tr>
<tr>
<td><code>\uNNNN</code></td>
<td>普通字符映射平面的Unicode字符(NNNN代表四位16进制数)</td>
</tr>
<tr>
<td><code>\UNNNNNNNN</code></td>
<td>补充字符映射平面的Unicode字符(NNNNNNNN代表八位16进制数)</td>
</tr>
</tbody>
</table>
<p>另一种字符串表达式被称为 “heredoc” 风格，是受 Unix Shell 语言启发。它可以使用自定义的分隔符更加清晰地表达多行字符串：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;EOT</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code> 标记后面直到行尾组成的标识符开启了字符串，然后 Terraform 会把剩下的行都添加进字符串，直到遇到与标识符完全相等的字符串为止。在上面的例子里，<code>EOT</code> 就是标识符。任何字符都可以用作标识符，但传统上标识符一般以 <code>EO</code> 开头。上面例子里的 <code>EOT</code> 代表&quot;文本的结束(end of text)&quot;。</p>
<p>上面例子里的 heredoc 风格字符串要求内容必须对齐行头，这在块内声明时看起来会比较奇怪：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">block &#123;</span><br><span class="line">  value = &lt;&lt;EOT</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">EOT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了改进可读性，Terraform 也支持<em><strong>缩进的</strong></em> heredoc，只要把 <code>&lt;&lt;</code> 改成 <code>&lt;&lt;-</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">block &#123;</span><br><span class="line">  value = &lt;&lt;-EOT</span><br><span class="line">  hello</span><br><span class="line">    world</span><br><span class="line">  EOT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子里，Terraform 会以最靠近行头的行作为基准来调整行头缩进，得到的字符串是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">  world</span><br></pre></td></tr></table></figure>
<p>heredoc 中的反斜杠不会被解释成转义，而只会是简单的反斜杠。</p>
<p>双引号和 heredoc 两种字符串都支持字符串模版，模版的形式是 <code>$&#123;...&#125;</code> 以及 <code>%&#123;...&#125;</code>。如果想要表达 <code>$&#123;</code> 或者 <code>%&#123;</code> 的字面量，那么可以重复第一个字符：<code>$$&#123;</code> 和 <code>%%&#123;</code> 。</p>
<h2 id="1-4-8-1-14-字符串模版"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%89%88"></a>1.4.8.1.14. 字符串模版</h2>
<p>字符串模版允许我们在字符串中嵌入表达式，或是通过其他值动态构造字符串。</p>
<h3 id="1-4-8-1-14-1-插值-Interpolation"><a href="#%E6%8F%92%E5%80%BCinterpolation"></a>1.4.8.1.14.1. 插值(Interpolation)</h3>
<p>一个 <code>$&#123;...&#125;</code> 序列被称为插值，插值计算花括号之间的表达式的值，有必要的话将之转换为字符串，然后插入字符串模版，形成最终的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello, $&#123;var.name&#125;!&quot;</span><br></pre></td></tr></table></figure>
<p>上面的例子里，输入变量 <code>var.name</code> 的值被访问后插入了字符串模版，产生了最终的结果，比如：<code>&quot;Hello, Juan!&quot;</code></p>
<h3 id="1-4-8-1-14-2-命令-Directive"><a href="#%E5%91%BD%E4%BB%A4directive"></a>1.4.8.1.14.2. 命令(Directive)</h3>
<p>一个 <code>%&#123;...&#125;</code> 序列被称为命令，命令可以是一个布尔表达式或者是对集合的迭代，类似条件表达式以及 <code>for</code> 表达式。有两种命令：</p>
<ul>
<li><code>if \&lt;BOOL\&gt;</code> / <code>else</code> /<code>endif</code> 命令根据布尔表达式的结果在两个模版中选择一个：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello, %&#123; if var.name != &quot;&quot; &#125;$&#123;var.name&#125;%&#123; else &#125;unnamed%&#123; endif &#125;!&quot;</span><br></pre></td></tr></table></figure>
<p><code>else</code> 部分可以省略，这样如果布尔表达结果为false那么就会插入空字符串。</p>
<ul>
<li><code>for \&lt;NAME\&gt; in \&lt;COLLECTION\&gt;</code> / <code>endfor</code> 命令迭代一个结构化对象或者集合，用每一个元素渲染模版，然后把它们拼接起来：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;EOT</span><br><span class="line">%&#123; for ip in aws_instance.example.*.private_ip &#125;</span><br><span class="line">server $&#123;ip&#125;</span><br><span class="line">%&#123; endfor &#125;</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>
<p><code>for</code> 关键字后紧跟的名字被用作代表迭代器元素的临时变量，可以用来在内嵌模版中使用。</p>
<p>为了在不添加额外空格和换行的前提下提升可读性，所有的模版序列都可以在首尾添加 <code>~</code> 符号。如果有 <code>~</code> 符号，那么模版序列会去除字符串左右的空白(空格以及换行)。如果 <code>~</code> 出现在头部，那么会去除字符串左侧的空白；如果出现在尾部，那么会去除字符串右边的空白：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;EOT</span><br><span class="line">%&#123; for ip in aws_instance.example.*.private_ip ~&#125;</span><br><span class="line">server $&#123;ip&#125;</span><br><span class="line">%&#123; endfor ~&#125;</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>
<p>上面的例子里，命令符后面的换行符被忽略了，但是 <code>server $&#123;ip&#125;</code> 后面的换行符被保留了，这确保了每一个元素生成一行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server 10.1.16.154</span><br><span class="line">server 10.1.16.1</span><br><span class="line">server 10.1.16.34</span><br></pre></td></tr></table></figure>
<p>当使用模版命令时，我们推荐使用 heredoc 风格字符串，用多行模版提升可读性。双引号字符串内最好只使用插值。</p>
<h2 id="1-4-8-1-15-Terraform-插值"><a href="#terraform-%E6%8F%92%E5%80%BC"></a>1.4.8.1.15. Terraform 插值</h2>
<p>Terraform 曾经只支持在表达式中使用插值，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = var.image_id</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种语法是在 Terraform 0.12 后才被支持的。在 Terraform 0.11 及更早的版本中，这段代码只能被写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = &quot;$&#123;var.image_id&#125;&quot;</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 0.12 保持了向前兼容，所以现在这样的代码也仍然是合法的。读者们也许会在一些 Terraform 代码和文档中继续看到这样的写法，但请尽量避免继续这样书写纯插值字符串，而是直接使用表达式。</p>
<ul>
<li>
<p><a href="#%E9%87%8D%E8%BD%BD%E6%96%87%E4%BB%B6"><strong>1.4.9.1.</strong> 重载文件</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90"><strong>1.4.9.1.1.</strong> 例子</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6%E8%A1%8C%E4%B8%BA"><strong>1.4.9.1.2.</strong> 合并行为</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-resource-%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%90%88%E5%B9%B6-data-%E5%9D%97"><strong>1.4.9.1.2.1.</strong> 合并 resource 块以及合并 data 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-variable-%E5%9D%97"><strong>1.4.9.1.2.2.</strong> 合并 variable 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-output-%E5%9D%97"><strong>1.4.9.1.2.3.</strong> 合并 output 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-locals-%E5%9D%97"><strong>1.4.9.1.2.4.</strong> 合并 locals 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-terraform-%E5%9D%97"><strong>1.4.9.1.2.5.</strong> 合并 terraform 块</a></p>
</li>
</ul>
<p><a href="#%E9%87%8D%E8%BD%BD%E6%96%87%E4%BB%B6"></a></p>
<h2 id="1-4-9-1-重载文件"><a href="#%E9%87%8D%E8%BD%BD%E6%96%87%E4%BB%B6"></a>1.4.9.1. 重载文件</h2>
<p>一般来说 Terraform 会加载模块内所有的 <code>.tf</code> 和 <code>.tf.json</code> 文件，并要求文件内定义了一组无重复的对象。如果两个文件尝试定义同一个对象，那么 Terraform 会报错。</p>
<p>在某些少见场景中，能够用单独的文件重载已有对象配置的特定部分将会十分有用。比如说，由工程师编写的配置文件能够在运行时被程序生成的 JSON 文件部分重载。</p>
<p>为支持这些少见场景，Terraform 会对后缀名为 <code>override.tf</code> 和 <code>override.tf.json</code> 的代码文件进行特殊处理。对于名为 <code>override.tf</code> 和 <code>override.tf.json</code> 的代码文件也会进行相同的特殊处理。</p>
<p>Terraform 一开始加载代码文件时会跳过这些重载文件，然后才会按照字典序一个一个处理重载文件。对重载文件中定义的所有顶级块(<code>resource</code>、<code>data</code>等)，Terraform 会尝试找到对应的已有对象并且将重载内容合并进已有对象。</p>
<p>重载文件只应使用于特殊场景，过度使用会使得读者在阅读原始代码文件时被迫还要阅读所有的重载文件才能理解对象配置，从而降低了代码的可读性。使用重载文件时，请在原始文件被重载的部分添加相应注释，提醒未来的读者哪些部分会被重载文件修改。</p>
<h2 id="1-4-9-1-1-例子"><a href="#%E4%BE%8B%E5%AD%90"></a>1.4.9.1.1. 例子</h2>
<p>如果我们有一个名为 <code>example.tf</code> 的代码文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  ami           = &quot;ami-408c7f28&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们创建一个名为 <code>override.tf</code> 的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami = &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 随后会合并两者，实际的配置会是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  ami           = &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-9-1-2-合并行为"><a href="#%E5%90%88%E5%B9%B6%E8%A1%8C%E4%B8%BA"></a>1.4.9.1.2. 合并行为</h2>
<p>不同的块类型有着些微不同的合并行为，某些特定块内的特殊构造会以特殊形式被合并。</p>
<p>一般来说：</p>
<ul>
<li>重载文件内的顶级块会和普通文件内同类型同名的顶级块合并</li>
<li>重载文件内的顶级块配置册参数会覆盖普通文件内对应块内的同名参数</li>
<li>重载块内的内嵌块会<strong>取代</strong>普通文件内对应块内的<strong>所有</strong>同类型内嵌块。所有重载块内没有定义的内嵌块在普通文件内保持不变</li>
<li>内嵌块的内容<strong>不会</strong>进行合并</li>
<li>合并后的块仍然需要符合对应块类型的所有验证规则</li>
</ul>
<p>如果有多个重载文件定义了同一个顶级块，那么重载效果是叠加的，后加载的重载块会在先前加载的重载块生效的基础上合并。重载操作首先按照文件名的字典序其次是在重载文件中的位置决定执行顺序。</p>
<p>有一些针对特定顶级块类型的特殊合并行为规则，我们将重载文件中定义的块称为重载块，重载块在普通文件中对应的块称为源块：</p>
<h3 id="1-4-9-1-2-1-合并-resource-块以及合并-data-块"><a href="#%E5%90%88%E5%B9%B6-resource-%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%90%88%E5%B9%B6-data-%E5%9D%97"></a>1.4.9.1.2.1. 合并 resource 块以及合并 data 块</h3>
<p>在 <code>resource</code> 块内，所有 <code>lifecycle</code> 块的内容会按照参数逐条合并。比如说，一个重载块只定义了 <code>create_before_destroy</code> 参数而源块定义了 <code>ignore_changes</code>，那么 <code>create_before_destroy</code> 被合并的同时 <code>igonore_changes</code> 将会被保留。</p>
<p>如果重载的 <code>resource</code> 块包含了一个或多个 <code>provisioner</code>，那么源块内所有的 <code>provisioner</code> 会被忽略。</p>
<p>如果重载的 <code>resource</code> 块内包含了一个 <code>connection</code> 块，那么它将会完全覆盖所有源块内定义的 <code>connection</code> 块</p>
<p>不允许在重载块内定义 <code>depends_on</code> 参数，那将会引发一个错误。</p>
<h3 id="1-4-9-1-2-2-合并-variable-块"><a href="#%E5%90%88%E5%B9%B6-variable-%E5%9D%97"></a>1.4.9.1.2.2. 合并 variable 块</h3>
<p><code>variable</code> 块内参数的合并遵循上述的标准流程，但对于 <code>type</code> 和 <code>default</code> 参数的处理会有一些特殊的考虑。</p>
<p>如果源块定义了 <code>default</code> 值而重载块修改了变量的 <code>type</code>，Terraform 会尝试将 <code>default</code> 值转换成新类型，如果转换失败则会报错。</p>
<p>同样的，如果源块定义了 <code>type</code> 参数而重载块修改了 <code>default</code> 值，那么新的 <code>default</code> 值必须能够被转换成原先的类型。</p>
<h3 id="1-4-9-1-2-3-合并-output-块"><a href="#%E5%90%88%E5%B9%B6-output-%E5%9D%97"></a>1.4.9.1.2.3. 合并 output 块</h3>
<p>不允许在重载块内定义 <code>depends_on</code> 参数，这会引发一个错误。</p>
<h3 id="1-4-9-1-2-4-合并-locals-块"><a href="#%E5%90%88%E5%B9%B6-locals-%E5%9D%97"></a>1.4.9.1.2.4. 合并 locals 块</h3>
<p>所有的 <code>locals</code> 块都定义了一个或多个命名值。针对 <code>locals</code> 的合并会是按照命名值的名字逐条执行的，不论命名值是在哪个 <code>locals</code> 块内被定义的。</p>
<h3 id="1-4-9-1-2-5-合并-terraform-块"><a href="#%E5%90%88%E5%B9%B6-terraform-%E5%9D%97"></a>1.4.9.1.2.5. 合并 terraform 块</h3>
<p>如果重载块定义了 <code>required_providers</code> 参数，那么它的值会被逐条合并，这就允许重载块在不影响其他Provider的情况下调整单个 Provider 的版本约束。</p>
<p>重载块内的 <code>requeired_version</code> 和 <code>required_providers</code> 里的配置完全覆盖源块内的相应配置。如果源块和重载块都定义了 <code>required_version</code>，那么源块的配置会被完全忽略。</p>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83"><strong>1.4.10.1.</strong> 代码风格规范</a></li>
</ul>
<p><a href="#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83"></a></p>
<h2 id="1-4-10-1-代码风格规范"><a href="#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83"></a>1.4.10.1. 代码风格规范</h2>
<p>Terraform 推荐以下代码规范：</p>
<ul>
<li>使用两个空格缩进</li>
<li>同一缩进层级的多个赋值语句以等号对齐：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ami           = &quot;abc123&quot;</span><br><span class="line">instance_type = &quot;t2.micro&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>当块体内同时有参数赋值以及内嵌块时，请先编写参数赋值，然后是内嵌块。参数与内嵌块之间空一行分隔</li>
<li>对于同时包含参数赋值以及元参数赋值的块，请先编写元参数赋值语句，然后是参数赋值语句，之间空一行分隔。元参数块请置于块体的最后，空一行分隔：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  count = 2 # meta-argument first</span><br><span class="line"></span><br><span class="line">  ami           = &quot;abc123&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  network_interface &#123;</span><br><span class="line">    # ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lifecycle &#123; # meta-argument block last</span><br><span class="line">    create_before_destroy = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>顶层块之间应空一行分隔。内嵌块之间也应该空一行分隔，除非是相同类型的内嵌块(比如 <code>resource</code> 块内部多个 <code>provisioner</code> 块)</p>
</li>
<li>
<p>同类型块之间尽量避免插入其他类型块，除非不同类型块共同组成了一个有语义的家族(比方说，<code>aws_instnace</code> 资源内的 <code>root_block_device</code>、<code>ebs_block_device</code>、<code>ephemeral_block_device</code> 内嵌块共同构成了描述 AWS 块存储的块家族，所以他们可以被混合编写)。</p>
</li>
<li>
<p><a href="#checks"><strong>1.4.11.1.</strong> Checks</a></p>
</li>
<li>
<p><a href="#%E8%AF%AD%E6%B3%95"><strong>1.4.11.1.1.</strong> 语法</a></p>
</li>
<li>
<p><a href="#%E6%9C%89%E9%99%90%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.11.1.1.1.</strong> 有限作用范围的数据源</a></p>
</li>
<li>
<p><a href="#%E6%96%AD%E8%A8%80"><strong>1.4.11.1.1.2.</strong> 断言</a></p>
</li>
<li>
<p><a href="#check-%E5%9D%97%E7%9A%84%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.4.11.1.1.3.</strong> check 块的元参数</a></p>
</li>
<li>
<p><a href="#%E6%98%AF%E4%BD%BF%E7%94%A8-check-%E5%9D%97%E8%BF%98%E6%98%AF%E5%85%B6%E4%BB%96%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E6%A3%80%E6%9F%A5"><strong>1.4.11.1.2.</strong> 是使用 check 块还是其他自定义条件检查</a></p>
</li>
<li>
<p><a href="#%E8%BE%93%E5%87%BA%E5%80%BC%E4%B8%8E%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0"><strong>1.4.11.1.2.1.</strong> 输出值与输入参数</a></p>
</li>
<li>
<p><a href="#resource-%E5%9D%97%E7%9A%84-precondition-%E4%B8%8E-postcondition"><strong>1.4.11.1.2.2.</strong> resource 块的 precondition 与 postcondition</a></p>
</li>
</ul>
<p><a href="#checks"></a></p>
<h2 id="1-4-11-1-Checks"><a href="#checks"></a>1.4.11.1. Checks</h2>
<p><code>check</code> 块是 Terraform 1.5 开始引入的新功能。</p>
<p>过去我们可以在 <code>resource</code> 块里的 <code>lifecycle</code> 块中验证基础设施的状态。<code>check</code> 块填补了在 Terraform <code>apply</code> 后验证基础设施状态这一功能中的一块空白。</p>
<p><code>check</code> 块允许我们定义在每次 <code>plan</code> 以及 <code>apply</code> 操作后执行的自定义的验证。<code>check</code> 块定义的验证逻辑是作为 <code>plan</code> 和 <code>apply</code> 操作的最后一步执行的。</p>
<h2 id="1-4-11-1-1-语法"><a href="#%E8%AF%AD%E6%B3%95"></a>1.4.11.1.1. 语法</h2>
<p>你可以定义一个包含本地名称的 <code>check</code> 块，其中可以定义一个 <a href="#%E6%9C%89%E9%99%90%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90">有限作用范围的 <code>data</code> 块</a>，以及至少一个的<a href="#%E6%96%AD%E8%A8%80">断言</a>。</p>
<p>下面的例子演示了加载 Terraform 官网并验证 HTTP 返回状态码为 <code>200</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">check &quot;health_check&quot; &#123;</span><br><span class="line">  data &quot;http&quot; &quot;terraform_io&quot; &#123;</span><br><span class="line">    url = &quot;https://www.terraform.io&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition = data.http.terraform_io.status_code == 200</span><br><span class="line">    error_message = &quot;$&#123;data.http.terraform_io.url&#125; returned an unhealthy status code&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-11-1-1-1-有限作用范围的数据源"><a href="#%E6%9C%89%E9%99%90%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.11.1.1.1. 有限作用范围的数据源</h3>
<p>我们可以在 <code>check</code> 块使用任意 Provider 提供的任意数据源作为一个有限作用范围的数据源。</p>
<p>一个 <code>check</code> 块可以配一个可选的内嵌（也叫有限作用范围）数据源。该 <code>data</code> 块和普通的 <code>data</code> 块行为类似，但你不能在定义它的 <code>check</code> 块以外引用它。另外，如果一个有限作用范围的数据源运行时触发了任意错误，这些错误将被标记为警告，不会阻止 Terraform 继续执行操作。</p>
<p>你可以使用有限作用范围的数据源在 <code>resource</code> 的 <code>lifecycle</code> 外验证相关基础设施片段的状态。在上面的例子里，如果 <code>terraform_io</code> 数据源在加载时发生错误，那么我们将会收到一个警告而不是中断执行的错误。</p>
<h4 id="元参数"><a href="#%E5%85%83%E5%8F%82%E6%95%B0"></a>元参数</h4>
<p>有限作用域的数据源支持 <code>depends_on</code> 和 <code>provider</code> <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#%E5%85%83%E5%8F%82%E6%95%B0">元参数</a>，但不支持 <code>count</code> 或 <code>for_each</code> 元参数。</p>
<p><code>depends_on</code></p>
<p><code>depends_on</code> 元参数配合有限作用域数据源可以提供非常强大的能力。</p>
<p>假设上述例子中的 Terraform 网站是我们即将用同一目录下的 Terraform 代码部署的，在第一次创建 Plan 时因为网站还没有被创建，所以验证会失败，Terraform 总是会在一开始显示一条让人分心的警告信息。</p>
<p>我们可以给该内嵌数据源添加 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#depends_on"><code>depends_on</code></a> 来确保该数据源依赖于某项组成基础设施的必要资源，例如负载均衡器。这样对该数据源的检查结果将保持 <code>known after apply</code> 直到依赖项创建完成。该策略避免了在配置阶段产生无意义的警告信息，直到在 <code>plan</code> 和 <code>apply</code> 操作的合适阶段执行检查。</p>
<p>该策略的一个问题是如果有限作用域数据源所依赖的资源发生了变化，那么 <code>check</code> 块将返回 <code>known after apply</code> 直到 Terraform 完成了对被依赖资源的更新。在某些情况下，这种行为将会引发一些问题。</p>
<p>我们推荐只有在内嵌数据源依赖于某项资源，但又没有显式的引用其数据时使用 <code>depends_on</code> 元参数。</p>
<h3 id="1-4-11-1-1-2-断言"><a href="#%E6%96%AD%E8%A8%80"></a>1.4.11.1.1.2. 断言</h3>
<p>我们在 <code>check</code> 块中使用 <code>assert</code> 块定义自定义的断言条件。每个 <code>check</code> 块必须声明至少一个或更多的 <code>assert</code> 块。每个 <code>assert</code> 块都包含了一个 <code>condition</code> 属性与一个 <code>error_message</code> 属性。</p>
<p>与其他自定义检查（<code>variable</code> 中的 <code>validation</code> 以及 <code>lifecycle</code> 中的 <code>precondition</code> 和 <code>postcondition</code>）不同，<code>assert</code> 的断言不会影响 Terraform 执行操作。失败的断言将以警告信息的形式输出而不会中断后续的操作。这与其他诸如 <code>postcondition</code> 这样的自定义检查形成了对比，因为它们的检查失败会立即终止后续的 <code>plan</code> 以及 <code>apply</code> 操作，返回错误信息。</p>
<p><code>assert</code> 块中的断言条件表达式可以引用同一 <code>check</code> 块里的内嵌数据源数据，以及同一模块中的任意输入参数、资源、数据源、模块的输出值。</p>
<h3 id="1-4-11-1-1-3-check-块的元参数"><a href="#check-%E5%9D%97%E7%9A%84%E5%85%83%E5%8F%82%E6%95%B0"></a>1.4.11.1.1.3. check 块的元参数</h3>
<p><code>check</code> 块目前不支持元参数。Terraform 团队目前正在<a target="_blank" rel="noopener" href="https://github.com/hashicorp/terraform/issues/new/choose">收集</a>有关这一功能的反馈。</p>
<h2 id="1-4-11-1-2-是使用-check-块还是其他自定义条件检查"><a href="#%E6%98%AF%E4%BD%BF%E7%94%A8-check-%E5%9D%97%E8%BF%98%E6%98%AF%E5%85%B6%E4%BB%96%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E6%A3%80%E6%9F%A5"></a>1.4.11.1.2. 是使用 check 块还是其他自定义条件检查</h2>
<p><code>check</code> 块提供了 Terraform 中最灵活的验证功能。我们可以在其中引用输出值、输入参数、资源以及数据源的值。我们的确可以使用 <code>check</code> 块取代所有其他的自定义条件检查，但这并不意味着我们应该要这么做。</p>
<p><code>check</code> 与其他检查最大的区别在于 <code>check</code> 块不会中断 Terraform 的执行。我们需要将这种非阻塞性的行为特点计入考量来决定采取何种检查。</p>
<h3 id="1-4-11-1-2-1-输出值与输入参数"><a href="#%E8%BE%93%E5%87%BA%E5%80%BC%E4%B8%8E%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0"></a>1.4.11.1.2.1. 输出值与输入参数</h3>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/4.%E8%BE%93%E5%87%BA%E5%80%BC.html#%E6%96%AD%E8%A8%80-precondition">输出值的 <code>precondition</code></a> 以及 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E6%96%AD%E8%A8%80-validation">输入变量的 <code>validation</code></a>都可以对输入输出值进行断言。</p>
<p>这些检查是用来阻止 Terraform 在数据有问题时继续执行的。</p>
<p>举例来说，如果输入参数的值是无效的那么任由 Terraform 执行整个配置文件并没有什么意义，这种情况下，<code>check</code> 块只会输出有关无效输入参数的警告，不会打断 Terraform 的执行，而 <code>validation</code> 块则会警告输入参数值非法，并终止 Terraform 执行 <code>plan</code> 或 <code>apply</code> 操作。</p>
<h3 id="1-4-11-1-2-2-resource-块的-precondition-与-postcondition"><a href="#resource-%E5%9D%97%E7%9A%84-precondition-%E4%B8%8E-postcondition"></a>1.4.11.1.2.2. resource 块的 precondition 与 postcondition</h3>
<p><code>check</code> 块与 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#precondition-%E4%B8%8E-postcondition"><code>precondition</code> 和 <code>postcondition</code></a> 的区别更加微妙。</p>
<p><code>precondition</code> 是自定义条件检查中最特殊的，因为它们是在资源的变更被计算或应用之前执行的检查。决定使用 <code>precondition</code> 还是 <code>postcondition</code> 的考量也适用于选择是使用 <code>precondition</code> 还是 <code>check</code> 块。</p>
<p>我们可以在 <code>postcondition</code> 与 <code>check</code> 块之间互换来验证资源和数据源。例如，我们可以把上述例子中的 <code>check</code> 块改写成 <code>postcondition</code>，以下的 <code>postcondition</code> 块将会验证对 Terraform 网站的请求是否返回了状态码 <code>200</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data &quot;http&quot; &quot;terraform_io&quot; &#123;</span><br><span class="line">  url = &quot;https://www.terraform.io&quot;</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    postcondition &#123;</span><br><span class="line">        condition = self.status_code == 200</span><br><span class="line">        error_message = &quot;$&#123;self.url&#125; returned an unhealthy status code&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>check</code> 和 <code>postcondition</code> 块都在 <code>plan</code> 或 <code>apply</code> 操作中验证了 Terraform 网站是否返回 <code>200</code> 状态码，它们的区别是发生错误时的行为。</p>
<p>如果是 <code>postcondition</code> 失败，那么将无法继续执行。Terraform 会阻止任意后续的 <code>plan</code> 或 <code>apply</code> 操作。</p>
<p>我们推荐使用 <code>check</code> 块来验证基础设施的整体状态，仅在希望确保单一资源状态符合预期时使用 <code>postcondition</code>。</p>
<ul>
<li>
<p><a href="#ephemeral-%E8%B5%84%E6%BA%90"><strong>1.4.12.1.</strong> Ephemeral 资源</a></p>
</li>
<li>
<p><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><strong>1.4.12.1.1.</strong> 生命周期</a></p>
</li>
<li>
<p><a href="#%E4%BE%9D%E8%B5%96%E5%9B%BE"><strong>1.4.12.1.2.</strong> 依赖图</a></p>
</li>
<li>
<p><a href="#%E4%B8%B4%E6%97%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%A3%B0%E6%98%8E"><strong>1.4.12.1.3.</strong> 临时资源的声明</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E4%B8%B4%E6%97%B6%E8%B5%84%E6%BA%90"><strong>1.4.12.1.4.</strong> 引用临时资源</a></p>
</li>
<li>
<p><a href="#%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.4.12.1.5.</strong> 元参数</a></p>
</li>
<li>
<p><a href="#%E7%A4%BA%E4%BE%8B"><strong>1.4.12.1.6.</strong> 示例</a></p>
</li>
</ul>
<p><a href="#ephemeral-%E8%B5%84%E6%BA%90"></a></p>
<h2 id="1-4-12-1-Ephemeral-资源"><a href="#ephemeral-%E8%B5%84%E6%BA%90"></a>1.4.12.1. Ephemeral 资源</h2>
<p>临时（Ephemeral）资源是本质上是临时的（Temporary） Terraform 资源。临时资源具有独特的生命周期，Terraform 不会将它们存储在其状态文件中。每个 <code>ephemeral</code> 块描述一个或多个临时资源，例如临时密码或与另一个系统的连接。</p>
<p><code>ephemeral</code> 块的声明包含了临时资源的类型以及本地名，就像 <code>resource</code> 块那样。 Terraform 使用临时资源的名称来引用同一模块中的该资源，但临时资源的名称在该模块的范围之外没有任何意义。</p>
<h2 id="1-4-12-1-1-生命周期"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"></a>1.4.12.1.1. 生命周期</h2>
<p><code>ephemeral</code> 的生命周期与 <code>resource</code> 和 <code>data</code> 不同。当 Terraform 创建临时资源时，它会执行以下步骤：</p>
<ol>
<li>如果 Terraform 需要访问临时资源的结果，它将“打开”该临时资源。例如，如果 Terraform “打开”一个包含了 Vault 机密的临时资源，则 Vault 的 Provider 将获取租约并返回一个机密。</li>
<li>如果 Terraform 需要访问临时资源的时间比远程系统为机密设置的过期时间还长，Terraform 会要求 Provider 定期续约。例如，如果 Terraform 对包含了 Vault 机密的临时资源续约，则 Vault Provider 程序将调用 Vault 的租约续约 API 来延长到期时间。</li>
<li>一旦 Terraform 不再需要临时资源，Terraform 就会将其关闭。这种情况发生在依赖于某个临时资源的 Provider 完成当前 Terraform 运行阶段的所有工作之后。例如，关闭 Vault 机密临时资源意味着 Vault Provider 明确吊销租约，从而使得 Vault 立即撤销相关凭证。</li>
</ol>
<p>Terraform 对于给定配置中的每个临时资源实例都遵循这些生命周期步骤。</p>
<h2 id="1-4-12-1-2-依赖图"><a href="#%E4%BE%9D%E8%B5%96%E5%9B%BE"></a>1.4.12.1.2. 依赖图</h2>
<p>临时资源对应了 Terraform 依赖关系图中的节点，其交互方式与 <code>resource</code> 和 <code>data</code> 类似。例如，当 <code>resource</code> 或 <code>data</code> 依赖于临时资源的属性时，Terraform 首先自动配置临时资源。</p>
<h2 id="1-4-12-1-3-临时资源的声明"><a href="#%E4%B8%B4%E6%97%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%A3%B0%E6%98%8E"></a>1.4.12.1.3. 临时资源的声明</h2>
<p><code>ephemeral</code> 块中的绝大多数参数是由您正在定义的临时资源类型所决定的。与 <code>resource</code> 和 <code>data</code> 一样，<a target="_blank" rel="noopener" href="https://registry.terraform.io/browse/providers">Terraform 注册表</a>中的每个 Provider 程序都包含其支持的临时资源（如果有）的文档。临时资源类型的文档列出了可用的参数以及应如何配置的格式。</p>
<p>临时资源由两部分组成：</p>
<ul>
<li>属性</li>
<li>元参数</li>
</ul>
<p><code>ephemeral</code> 块的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ephemeral &quot;&lt;resource_type&gt;&quot; &quot;&lt;resource_name&gt;&quot; &#123;</span><br><span class="line">  &lt;attributes&gt;</span><br><span class="line">  &lt;meta-arguments&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-12-1-4-引用临时资源"><a href="#%E5%BC%95%E7%94%A8%E4%B8%B4%E6%97%B6%E8%B5%84%E6%BA%90"></a>1.4.12.1.4. 引用临时资源</h2>
<p>只允许在特定的临时上下文中引用临时资源，否则 Terraform 会返回错误。以下是可以引用临时资源的上下文：</p>
<ul>
<li>另一个临时资源</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/5.%E5%B1%80%E9%83%A8%E5%80%BC.html#%E4%B8%B4%E6%97%B6ephemeral%E5%B1%80%E9%83%A8%E5%80%BC">局部值</a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F-ephemeral">临时输入变量</a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/4.%E8%BE%93%E5%87%BA%E5%80%BC.html#%E4%B8%B4%E6%97%B6%E5%80%BCephemeral-%E9%81%BF%E5%85%8D%E5%B0%86%E5%80%BC%E5%AD%98%E5%82%A8%E5%88%B0%E7%8A%B6%E6%80%81%E6%88%96%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E4%B8%AD">临时输出值</a></li>
<li>在 <code>provider</code> 块中配置 Provider</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#provisioner-%E5%92%8C-connection"><code>provisioner</code></a> 与 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#provisioner-%E5%92%8C-connection"><code>connection</code></a> 块</li>
</ul>
<h2 id="1-4-12-1-5-元参数"><a href="#%E5%85%83%E5%8F%82%E6%95%B0"></a>1.4.12.1.5. 元参数</h2>
<p>我们可以将在临时资源块内声明以下元参数，来更改这些资源的行为。以下元参数对于资源、数据源和临时资源的工作方式相同：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#depends_on"><code>depends_on</code></a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#count"><code>count</code></a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#for_each"><code>for_each</code></a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#provider"><code>provider</code></a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#lifecycle"><code>lifecycle</code></a></li>
</ul>
<p>临时资源不支持 <code>provisioner</code> 元参数。</p>
<h2 id="1-4-12-1-6-示例"><a href="#%E7%A4%BA%E4%BE%8B"></a>1.4.12.1.6. 示例</h2>
<p>以下示例使用临时资源的凭据配置 <code>postgresql</code> Provider 程序。由于这些凭据由临时资源管理，因此 Terraform 不会将它们存储在状态或计划文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ephemeral &quot;aws_secretsmanager_secret_version&quot; &quot;db_master&quot; &#123;</span><br><span class="line">  secret_id = data.aws_db_instance.example.master_user_secret[0].secret_arn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  credentials = jsondecode(ephemeral.aws_secretsmanager_secret_version.db_master.secret_string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;postgresql&quot; &#123;</span><br><span class="line">  host     = data.aws_db_instance.example.address</span><br><span class="line">  port     = data.aws_db_instance.example.port</span><br><span class="line">  username = local.credentials[&quot;username&quot;]</span><br><span class="line">  password = local.credentials[&quot;password&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/19/Teraform/Terraform-%E4%BB%A3%E7%A0%81/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/18/Teraform/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"
                            aria-label=": Terraform-基础概念-状态管理"
                        >
                            Terraform-基础概念-状态管理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-18T17:43:45+08:00">
	
		    2023 年 1 月 18 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><strong>1.3.2.1.</strong> Terraform 基础概念——状态管理</a></p>
</li>
<li>
<p><a href="#%E5%88%9D%E6%8E%A2%E7%8A%B6%E6%80%81%E6%96%87%E4%BB%B6"><strong>1.3.2.1.1.</strong> 初探状态文件</a></p>
</li>
<li>
<p><a href="#%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%89%E5%85%A8%E8%AD%A6%E7%A4%BA%E2%80%94%E2%80%94-tfstate-%E6%98%AF%E6%98%8E%E6%96%87%E7%9A%84"><strong>1.3.2.1.2.</strong> 极其重要的安全警示—— tfstate 是明文的</a></p>
</li>
<li>
<p><a href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-tfstate-%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94-backend"><strong>1.3.2.1.3.</strong> 生产环境的 tfstate 管理方案—— Backend</a></p>
</li>
<li>
<p><a href="#consul%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85"><strong>1.3.2.1.4.</strong> Consul简介以及安装</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8-backend"><strong>1.3.2.1.5.</strong> 使用 Backend</a></p>
</li>
<li>
<p><a href="#%E8%A7%82%E5%AF%9F%E9%94%81%E6%96%87%E4%BB%B6"><strong>1.3.2.1.6.</strong> 观察锁文件</a></p>
</li>
<li>
<p><a href="#backend-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC"><strong>1.3.2.1.7.</strong> Backend 配置的动态赋值</a></p>
</li>
<li>
<p><a href="#backend-%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><strong>1.3.2.1.8.</strong> Backend 的权限控制以及版本控制</a></p>
</li>
<li>
<p><a href="#%E7%8A%B6%E6%80%81%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AD%98%E5%82%A8"><strong>1.3.2.1.9.</strong> 状态的隔离存储</a></p>
</li>
<li>
<p><a href="#%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9A%94%E7%A6%BB"><strong>1.3.2.1.10.</strong> 该使用哪种隔离</a></p>
</li>
</ul>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"></a></p>
<h2 id="1-3-2-1-Terraform-基础概念——状态管理"><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"></a>1.3.2.1. Terraform 基础概念——状态管理</h2>
<p>我们在第一章的末尾提过，当我们成功地执行了一次 <code>terraform apply</code>，创建了期望的基础设施以后，我们如果再次执行 <code>terraform apply</code>，生成的新的执行计划将不会包含任何变更，Terraform 会记住当前基础设施的状态，并将之与代码所描述的期望状态进行比对。第二次 apply 时，因为当前状态已经与代码描述的状态一致了，所以会生成一个空的执行计划。</p>
<h2 id="1-3-2-1-1-初探状态文件"><a href="#%E5%88%9D%E6%8E%A2%E7%8A%B6%E6%80%81%E6%96%87%E4%BB%B6"></a>1.3.2.1.1. 初探状态文件</h2>
<p>在这里，Terraform 引入了一个独特的概念——状态管理，这是 Ansible 等配置管理工具或是自研工具调用 SDK 操作基础设施的方案所没有的。简单来说，Terraform 将每次执行基础设施变更操作时的状态信息保存在一个状态文件中，默认情况下会保存在当前工作目录下的 <code>terraform.tfstate</code> 文件里。例如我们之前在使用 LocalStack 模拟环境的代码中声明一个 <code>data</code> 和一个 <code>resource</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_ami&quot; &quot;ubuntu&quot; &#123;</span><br><span class="line">  most_recent = true</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;name&quot;</span><br><span class="line">    values = [&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;virtualization-type&quot;</span><br><span class="line">    values = [&quot;hvm&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  owners = [&quot;099720109477&quot;] # Canonical</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = data.aws_ami.ubuntu.id</span><br><span class="line">  instance_type = &quot;t3.micro&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;HelloWorld&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>terraform apply</code> 后，我们可以看到 <code>terraform.tfstate</code> 的内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;terraform_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.7.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;serial&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lineage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;159018e2-63f4-2dfa-ce0d-873a37a1e0a7&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;resources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aws_ami&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;provider[\&quot;registry.terraform.io/hashicorp/aws\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;instances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;schema_version&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x86_64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;arn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:ec2:us-east-1::image/ami-1e749f67&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;block_device_mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;device_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/sda1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ebs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;delete_on_termination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;encrypted&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;iops&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;snapshot_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;snap-15bd5527&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;throughput&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;volume_size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;15&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;volume_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standard&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;no_device&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;virtual_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;boot_mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;creation_date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-02-20T13:52:42.000Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;deprecation_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Canonical, Ubuntu, 14.04 LTS, amd64 trusty image build on 2017-07-27&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ena_support&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;executable_users&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                  <span class="string">&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;virtualization-type&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                  <span class="string">&quot;hvm&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hypervisor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xen&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ami-1e749f67&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;image_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ami-1e749f67&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;image_location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amazon/getting-started&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;image_owner_alias&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amazon&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;image_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;machine&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;imds_support&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;include_deprecated&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;kernel_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;None&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;most_recent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name_regex&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;owner_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;099720109477&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;owners&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;099720109477&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;platform_details&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;product_codes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ramdisk_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ari-1a2b3c4d&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;root_device_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/sda1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;root_device_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ebs&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;root_snapshot_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;snap-15bd5527&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;sriov_net_support&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;available&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;state_reason&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UNSET&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UNSET&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;timeouts&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tpm_support&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;usage_operation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;virtualization_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hvm&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;sensitive_attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;managed&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aws_instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;web&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;provider[\&quot;registry.terraform.io/hashicorp/aws\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;instances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;schema_version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;ami&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ami-1e749f67&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;arn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:ec2:us-east-1::instance/i-288a34165ed2ad2f7&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;associate_public_ip_address&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;availability_zone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;us-east-1a&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;capacity_reservation_specification&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cpu_core_count&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cpu_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cpu_threads_per_core&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;credit_specification&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;disable_api_stop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;disable_api_termination&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ebs_block_device&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ebs_optimized&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;enclave_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ephemeral_block_device&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;get_password_data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hibernation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;host_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;host_resource_group_arn&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;iam_instance_profile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;i-288a34165ed2ad2f7&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_initiated_shutdown_behavior&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stop&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_lifecycle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_market_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;running&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t3.micro&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ipv6_address_count&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ipv6_addresses&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;key_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;launch_template&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;maintenance_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;metadata_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;monitoring&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;network_interface&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;outpost_arn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;password_data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;placement_group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;placement_partition_number&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;primary_network_interface_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eni-68899bf6&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_dns&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ip-10-13-239-41.ec2.internal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_dns_name_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.13.239.41&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_dns&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ec2-54-214-132-221.compute-1.amazonaws.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;54.214.132.221&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;root_block_device&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;delete_on_termination&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;device_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/sda1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;encrypted&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;iops&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kms_key_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;throughput&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volume_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vol-6dde834f&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volume_size&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volume_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gp2&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;secondary_private_ips&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;security_groups&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;source_dest_check&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;spot_instance_request_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;subnet_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;subnet-dbb4c2f9&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tenancy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;timeouts&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user_data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user_data_base64&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user_data_replace_on_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;volume_tags&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;vpc_security_group_ids&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;sensitive_attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6MTIwMDAwMDAwMDAwMCwidXBkYXRlIjo2MDAwMDAwMDAwMDB9LCJzY2hlbWFfdmVyc2lvbiI6IjEifQ==&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;data.aws_ami.ubuntu&quot;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;check_results&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，查询到的 <code>data</code> 以及创建的 <code>resource</code> 信息都被以 json 格式保存在 <code>tfstate</code> 文件里。</p>
<p>我们前面已经说过，由于 <code>tfstate</code> 文件的存在，我们在 <code>terraform apply</code> 之后立即再次 apply 是不会执行任何变更的，那么如果我们删除了这个 <code>tfstate</code> 文件，然后再执行 apply 会发生什么呢？Terraform 读取不到 <code>tfstate</code> 文件，会认为这是我们第一次创建这组资源，所以它会再一次创建代码中描述的所有资源。更加麻烦的是，由于我们前一次创建的资源所对应的状态信息被我们删除了，所以我们再也无法通过执行 <code>terraform destroy</code> 来销毁和回收这些资源，实际上产生了资源泄漏。所以妥善保存这个状态文件是非常重要的。</p>
<p>另外，如果我们对 Terraform 的代码进行了一些修改，导致生成的执行计划将会改变状态，那么在实际执行变更之前，Terraform 会复制一份当前的 <code>tfstate</code> 文件到同路径下的 <code>terraform.tfstate.backup</code> 中，以防止由于各种意外导致的 <code>tfstate</code> 损毁。</p>
<p>在 Terraform 发展的极早期，HashiCorp 曾经尝试过无状态文件的方案，也就是在执行 Terraform 变更计划时，给所有涉及到的资源都打上特定的 tag，在下次执行变更时，先通过 tag 读取相关资源来重建状态信息。但因为并不是所有资源都支持打 tag，也不是所有公有云都支持多 tag，所以 Terraform 最终决定用状态文件方案。</p>
<p>还有一点，HashiCorp 官方从未公开过 <code>tfstate</code> 的格式，也就是说，HashiCorp 保留随时修改 <code>tfstate</code> 格式的权力。所以不要试图手动或是用自研代码去修改 <code>tfstate</code>，Terraform 命令行工具提供了相关的指令(我们后续会介绍到)，请确保只通过命令行的指令操作状态文件。</p>
<h2 id="1-3-2-1-2-极其重要的安全警示——-tfstate-是明文的"><a href="#%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%89%E5%85%A8%E8%AD%A6%E7%A4%BA%E2%80%94%E2%80%94-tfstate-%E6%98%AF%E6%98%8E%E6%96%87%E7%9A%84"></a>1.3.2.1.2. 极其重要的安全警示—— tfstate 是明文的</h2>
<p>关于 Terraform 状态，还有极其重要的事，所有考虑在生产环境使用 Terraform 的人都必须格外小心并再三警惕：Terraform 的状态文件是明文的，这就意味着代码中所使用的一切机密信息都将以明文的形式保存在状态文件里。例如我们创建一个私钥文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;tls_private_key&quot; &quot;example&quot; &#123;</span><br><span class="line">  algorithm = &quot;RSA&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行了<code>terraform apply</code>后我们观察 <code>tfstate</code> 文件中相关段落：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;terraform_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.7.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;serial&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lineage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dec42d6b-d61f-30b3-0b83-d5d8881c29ea&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;resources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;managed&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tls_private_key&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;example&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;provider[\&quot;registry.terraform.io/hashicorp/tls\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;instances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;schema_version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;algorithm&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RSA&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ecdsa_curve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;P224&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d47d1465586d25322bb8ca16029fe4fb2ec001e0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_key_openssh&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-----BEGIN OPENSSH PRIVATE KEY-----\nb3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABFwAAAAdz\nc2gtcnNhAAAAAwEAAQAAAQEAsdD9sJ/L5m8cRB19V20HA9BIqZwnT3id5JoMNUuW\nYn4sJTWHa/JHkQ5akrWH50aIdzQrQneIZXJyx1OMlqKbVxAc2+u/8qd2m2GrsWKZ\neqQcpNT7v76QowDcvdggad3Tezn3XU/eBukVj9i+lnN1ofyQzVEQAdvW8TpRdUL5\nb/bIsz1RzGWzUrWD8XTFLf2RuvvzhgBViuuWI0ns3WQMpa6Dcu+nWfGLCl26Wlph\nNmoUAv8wCay7KoynG58pJW+uqYA7lTx4tNMLhIW7rM4roYbXctkCi03PcW3x25O8\nyKSzYIi5xH7CQ7ggwXzcx4r06NXkaE9/LHuBSFJcIMvH8QAAA7jnMVXy5zFV8gAA\nAAdzc2gtcnNhAAABAQCx0P2wn8vmbxxEHX1XbQcD0EipnCdPeJ3kmgw1S5Zifiwl\nNYdr8keRDlqStYfnRoh3NCtCd4hlcnLHU4yWoptXEBzb67/yp3abYauxYpl6pByk\n1Pu/vpCjANy92CBp3dN7OfddT94G6RWP2L6Wc3Wh/JDNURAB29bxOlF1Qvlv9siz\nPVHMZbNStYPxdMUt/ZG6+/OGAFWK65YjSezdZAylroNy76dZ8YsKXbpaWmE2ahQC\n/zAJrLsqjKcbnyklb66pgDuVPHi00wuEhbusziuhhtdy2QKLTc9xbfHbk7zIpLNg\niLnEfsJDuCDBfNzHivTo1eRoT38se4FIUlwgy8fxAAAAAwEAAQAAAQEAleLv5ZFd\nY9mm/vfIrwg1UI6ioW4CaOfoWElOHyKfGlj2x0qu41wv3WM3D9G7REVdRPYRvQ5b\nSABIJiMUL+nTfXkUioDXpShqPyH+gyD09L8fcgYiS4fMDcrtR43GDNcyq/25uMtZ\nAYQ6a62tQc8Dik8GlDtPffGc5mxdO7X/4tLAObBPqO+lvGX2K/2hV2ql/a4fBVXR\nOMPc9A0eva2exifZyFo9vT9CCcW4iNY2BHY2hXAPI1gFpBnmnY2twFof4EvX6tfZ\nGjt20QCqTi41P8Obrfqi108zRAKtjJFeezNY+diVvxZaCDb/7ceFbFUrXq9u2UVD\nExn9joOLTJTEwQAAAIEAgOQ/mjRousgSenXW2nE2aq0m7oKQzhsF/8k5UPj6mym1\nvwUyC2gglTIOGVkUpj91L/Fh2nCuX5BLyzzIee0twRvT1Kj11BU6UoElStpR/JEC\n7trKWJrBddphBWHAuVcU5AQQPwI/9sg27q/9y16WTIQAJzx8GwGcDbgZj8/LbB4A\nAACBAMpVcX+2smqt8T9mbwU7e7ZaCQM0c3/7F2S2Z26Zl16k+8WPr6+CyJd3d2s2\nQkrmqVKJzDqPYidU0EmaNOrqytvUTUDK9KJgKsJuNC9ZbODqTCMA03ntr+hVcfdt\nd9F5fxyBJSrzpAhUQKadHs8jtAa1ENAhPmwKzvcJ51Gp4R3ZAAAAgQDg+s4nk926\njuLQGlweOi2HY6eeMQF8MOnXEhM8P7ErdRR73ql7GlhBNoGzuI6YTaqjLXBGNetj\nm4iziPLapbqBXSeia3y1JU71e1M+J342CxQwZRKTI9G/AB2AzspB4VfjAT9ZYJM1\nSFH7cDTejcrkfWko8TqyRLwtTPDa7Xlz2QAAAAAB\n-----END OPENSSH PRIVATE KEY-----\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_key_pem&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEAsdD9sJ/L5m8cRB19V20HA9BIqZwnT3id5JoMNUuWYn4sJTWH\na/JHkQ5akrWH50aIdzQrQneIZXJyx1OMlqKbVxAc2+u/8qd2m2GrsWKZeqQcpNT7\nv76QowDcvdggad3Tezn3XU/eBukVj9i+lnN1ofyQzVEQAdvW8TpRdUL5b/bIsz1R\nzGWzUrWD8XTFLf2RuvvzhgBViuuWI0ns3WQMpa6Dcu+nWfGLCl26WlphNmoUAv8w\nCay7KoynG58pJW+uqYA7lTx4tNMLhIW7rM4roYbXctkCi03PcW3x25O8yKSzYIi5\nxH7CQ7ggwXzcx4r06NXkaE9/LHuBSFJcIMvH8QIDAQABAoIBAQCV4u/lkV1j2ab+\n98ivCDVQjqKhbgJo5+hYSU4fIp8aWPbHSq7jXC/dYzcP0btERV1E9hG9DltIAEgm\nIxQv6dN9eRSKgNelKGo/If6DIPT0vx9yBiJLh8wNyu1HjcYM1zKr/bm4y1kBhDpr\nra1BzwOKTwaUO0998ZzmbF07tf/i0sA5sE+o76W8ZfYr/aFXaqX9rh8FVdE4w9z0\nDR69rZ7GJ9nIWj29P0IJxbiI1jYEdjaFcA8jWAWkGeadja3AWh/gS9fq19kaO3bR\nAKpOLjU/w5ut+qLXTzNEAq2MkV57M1j52JW/FloINv/tx4VsVSter27ZRUMTGf2O\ng4tMlMTBAoGBAMpVcX+2smqt8T9mbwU7e7ZaCQM0c3/7F2S2Z26Zl16k+8WPr6+C\nyJd3d2s2QkrmqVKJzDqPYidU0EmaNOrqytvUTUDK9KJgKsJuNC9ZbODqTCMA03nt\nr+hVcfdtd9F5fxyBJSrzpAhUQKadHs8jtAa1ENAhPmwKzvcJ51Gp4R3ZAoGBAOD6\nzieT3bqO4tAaXB46LYdjp54xAXww6dcSEzw/sSt1FHveqXsaWEE2gbO4jphNqqMt\ncEY162ObiLOI8tqluoFdJ6JrfLUlTvV7Uz4nfjYLFDBlEpMj0b8AHYDOykHhV+MB\nP1lgkzVIUftwNN6NyuR9aSjxOrJEvC1M8NrteXPZAoGAIQf/5nSh/e51ov8LAtSq\nJqPeMsq+TFdmg0eP7Stf3dCbVa5WZRW5v5h+Q19xRR8Q52udjrXXtUoQUuO83dkE\n0wx+rCQ1+cgvUtyA4nX741/8m/5Hh/E4tXo1h8o0NFtcV//xXGi4D7AJeenOnMxc\nWHf4zbGPqj29efEA9YEBQkkCgYABhG+DgNHMAk6xTJw2b/oCob9tp7L03XeWRb7v\ndxaAzodW1oeaFvFlbzKsvZ/okw2FkDbjolV2FIR1gYTxyJBbcv9jbwomRpwjt7M2\nBhopzyVRtjzL1UAC48NPLRXcH+Lx2v5MYgRcJaK36WfR4G7v35CoAAh/T0tdmtk9\nAMEC8QKBgQCA5D+aNGi6yBJ6ddbacTZqrSbugpDOGwX/yTlQ+PqbKbW/BTILaCCV\nMg4ZWRSmP3Uv8WHacK5fkEvLPMh57S3BG9PUqPXUFTpSgSVK2lH8kQLu2spYmsF1\n2mEFYcC5VxTkBBA/Aj/2yDbur/3LXpZMhAAnPHwbAZwNuBmPz8tsHg==\n-----END RSA PRIVATE KEY-----\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_key_pem_pkcs8&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCx0P2wn8vmbxxE\nHX1XbQcD0EipnCdPeJ3kmgw1S5ZifiwlNYdr8keRDlqStYfnRoh3NCtCd4hlcnLH\nU4yWoptXEBzb67/yp3abYauxYpl6pByk1Pu/vpCjANy92CBp3dN7OfddT94G6RWP\n2L6Wc3Wh/JDNURAB29bxOlF1Qvlv9sizPVHMZbNStYPxdMUt/ZG6+/OGAFWK65Yj\nSezdZAylroNy76dZ8YsKXbpaWmE2ahQC/zAJrLsqjKcbnyklb66pgDuVPHi00wuE\nhbusziuhhtdy2QKLTc9xbfHbk7zIpLNgiLnEfsJDuCDBfNzHivTo1eRoT38se4FI\nUlwgy8fxAgMBAAECggEBAJXi7+WRXWPZpv73yK8INVCOoqFuAmjn6FhJTh8inxpY\n9sdKruNcL91jNw/Ru0RFXUT2Eb0OW0gASCYjFC/p0315FIqA16Uoaj8h/oMg9PS/\nH3IGIkuHzA3K7UeNxgzXMqv9ubjLWQGEOmutrUHPA4pPBpQ7T33xnOZsXTu1/+LS\nwDmwT6jvpbxl9iv9oVdqpf2uHwVV0TjD3PQNHr2tnsYn2chaPb0/QgnFuIjWNgR2\nNoVwDyNYBaQZ5p2NrcBaH+BL1+rX2Ro7dtEAqk4uNT/Dm636otdPM0QCrYyRXnsz\nWPnYlb8WWgg2/+3HhWxVK16vbtlFQxMZ/Y6Di0yUxMECgYEAylVxf7ayaq3xP2Zv\nBTt7tloJAzRzf/sXZLZnbpmXXqT7xY+vr4LIl3d3azZCSuapUonMOo9iJ1TQSZo0\n6urK29RNQMr0omAqwm40L1ls4OpMIwDTee2v6FVx92130Xl/HIElKvOkCFRApp0e\nzyO0BrUQ0CE+bArO9wnnUanhHdkCgYEA4PrOJ5Pduo7i0BpcHjoth2OnnjEBfDDp\n1xITPD+xK3UUe96pexpYQTaBs7iOmE2qoy1wRjXrY5uIs4jy2qW6gV0nomt8tSVO\n9XtTPid+NgsUMGUSkyPRvwAdgM7KQeFX4wE/WWCTNUhR+3A03o3K5H1pKPE6skS8\nLUzw2u15c9kCgYAhB//mdKH97nWi/wsC1Komo94yyr5MV2aDR4/tK1/d0JtVrlZl\nFbm/mH5DX3FFHxDna52Otde1ShBS47zd2QTTDH6sJDX5yC9S3IDidfvjX/yb/keH\n8Ti1ejWHyjQ0W1xX//FcaLgPsAl56c6czFxYd/jNsY+qPb158QD1gQFCSQKBgAGE\nb4OA0cwCTrFMnDZv+gKhv22nsvTdd5ZFvu93FoDOh1bWh5oW8WVvMqy9n+iTDYWQ\nNuOiVXYUhHWBhPHIkFty/2NvCiZGnCO3szYGGinPJVG2PMvVQALjw08tFdwf4vHa\n/kxiBFwlorfpZ9Hgbu/fkKgACH9PS12a2T0AwQLxAoGBAIDkP5o0aLrIEnp11tpx\nNmqtJu6CkM4bBf/JOVD4+psptb8FMgtoIJUyDhlZFKY/dS/xYdpwrl+QS8s8yHnt\nLcEb09So9dQVOlKBJUraUfyRAu7ayliawXXaYQVhwLlXFOQEED8CP/bINu6v/cte\nlkyEACc8fBsBnA24GY/Py2we\n-----END PRIVATE KEY-----\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_key_fingerprint_md5&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a9:cc:2d:0f:66:b9:a9:89:94:f1:da:8f:93:df:63:d5&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_key_fingerprint_sha256&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SHA256:ias4wauIC4J/zd/cVoXT6UUSUZLQXaxdpJfkGAfRDz0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_key_openssh&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCx0P2wn8vmbxxEHX1XbQcD0EipnCdPeJ3kmgw1S5ZifiwlNYdr8keRDlqStYfnRoh3NCtCd4hlcnLHU4yWoptXEBzb67/yp3abYauxYpl6pByk1Pu/vpCjANy92CBp3dN7OfddT94G6RWP2L6Wc3Wh/JDNURAB29bxOlF1Qvlv9sizPVHMZbNStYPxdMUt/ZG6+/OGAFWK65YjSezdZAylroNy76dZ8YsKXbpaWmE2ahQC/zAJrLsqjKcbnyklb66pgDuVPHi00wuEhbusziuhhtdy2QKLTc9xbfHbk7zIpLNgiLnEfsJDuCDBfNzHivTo1eRoT38se4FIUlwgy8fx\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_key_pem&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsdD9sJ/L5m8cRB19V20H\nA9BIqZwnT3id5JoMNUuWYn4sJTWHa/JHkQ5akrWH50aIdzQrQneIZXJyx1OMlqKb\nVxAc2+u/8qd2m2GrsWKZeqQcpNT7v76QowDcvdggad3Tezn3XU/eBukVj9i+lnN1\nofyQzVEQAdvW8TpRdUL5b/bIsz1RzGWzUrWD8XTFLf2RuvvzhgBViuuWI0ns3WQM\npa6Dcu+nWfGLCl26WlphNmoUAv8wCay7KoynG58pJW+uqYA7lTx4tNMLhIW7rM4r\noYbXctkCi03PcW3x25O8yKSzYIi5xH7CQ7ggwXzcx4r06NXkaE9/LHuBSFJcIMvH\n8QIDAQAB\n-----END PUBLIC KEY-----\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rsa_bits&quot;</span><span class="punctuation">:</span> <span class="number">2048</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;sensitive_attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;check_results&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到不应该被第三方知晓的 <code>private_key_openssh</code>、<code>private_key_pem</code> 和 <code>private_key_pem_pkcs8</code> 是以明文形式被写在 <code>tfstate</code> 文件里的。这是 Terraform 从设计之初就确定的，并且在可见的未来不会有改善。不论你是在代码中明文硬编码，还是使用参数(variable，我们之后的章节会介绍)，亦或是妙想天开地使用函数在运行时从外界读取，都无法改变这个结果。</p>
<p>解决之道有两种，一种是使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/essential-vault/">Vault</a> 或是 <a target="_blank" rel="noopener" href="https://aws.amazon.com/secrets-manager/">AWS Secret Manager</a> 这样的动态机密管理工具生成临时有效的动态机密(比如有效期只有 5 分钟，即使被他人读取到，机密也早已失效)；另一种就是我们下面将要介绍的 —— Terraform Backend。</p>
<h2 id="1-3-2-1-3-生产环境的-tfstate-管理方案——-Backend"><a href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-tfstate-%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94-backend"></a>1.3.2.1.3. 生产环境的 tfstate 管理方案—— Backend</h2>
<p>到目前为止我们的 <code>tfstate</code> 文件是保存在当前工作目录下的本地文件，假设我们的计算机损坏了，导致文件丢失，那么 <code>tfstate</code> 文件所对应的资源都将无法管理，而产生资源泄漏。</p>
<p>另外如果我们是一个团队在使用 Terraform 管理一组资源，团队成员之间要如何共享这个状态文件？能不能把 <code>tfstate</code> 文件签入源代码管理工具进行保存？</p>
<p>把 <code>tfstate</code> 文件签入管代码管理工具是非常错误的，这就好比把数据库签入了源代码管理工具，如果两个人同时签出了同一份 <code>tfstate</code>，并且对代码做了不同的修改，又同时 apply 了，这时想要把 <code>tfstate</code> 签入源码管理系统可能会遭遇到无法解决的冲突。况且如果代码仓库是公开的，那么保存在 State 中的明文机密就会泄露。</p>
<p>为了解决状态文件的存储和共享问题，Terraform 引入了远程状态存储机制，也就是 Backend。Backend 是一种抽象的远程存储接口，如同 Provider 一样，Backend 也支持多种不同的远程存储服务：</p>
<ul>
<li><code>local</code></li>
<li><code>remote</code></li>
<li><code>azurerm</code></li>
<li><code>consul</code></li>
<li><code>cos</code></li>
<li><code>gcs</code></li>
<li><code>http</code></li>
<li><code>kubernetes</code></li>
<li><code>oss</code></li>
<li><code>pg</code></li>
<li><code>s3</code></li>
</ul>
<p><strong>注意</strong>：在 Terraform 1.1.0 之前的版本中，Backend 分为<em>标准</em>和<em>增强</em>两种。<em>增强</em>是一种特殊的 <code>remote</code> Backend，它既可以存储状态，也可以执行 Terraform 操作。但是这种分类已被移除。请参考<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/cli/cloud">使用 Terraform Cloud</a> 了解关于存储状态、执行远程操作以及直接从 Terraform 调用 Terraform Cloud 的详细信息。</p>
<p>状态锁是指，当针对一个 <code>tfstate</code> 进行变更操作时，可以针对该状态文件添加一把全局锁，确保同一时间只能有一个变更被执行。不同的 Backend 对状态锁的支持不尽相同，实现状态锁的机制也不尽相同，例如 <code>consul</code> Backend就通过一个 <code>.lock</code> 节点来充当锁，一个 <code>.lockinfo</code> 节点来描述锁对应的会话信息，<code>tfstate</code> 文件被保存在 Backend 定义的路径节点内；<code>s3</code> Backend 则需要用户传入一个 Dynamodb 表来存放锁信息，而 <code>tfstate</code> 文件被存储在 S3 存储桶里，等等等等。读者可以根据实际情况，挑选自己合适的 Backend。接下来我将以 <code>consul</code> 为范例为读者演示 Backend 机制。</p>
<h2 id="1-3-2-1-4-Consul简介以及安装"><a href="#consul%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85"></a>1.3.2.1.4. Consul简介以及安装</h2>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/">Consul</a> 是 HashiCorp 推出的一个开源工具，主要用来解决服务发现、配置中心以及 Service Mesh 等问题；Consul 本身也提供了类似 ZooKeeper、Etcd 这样的分布式键值存储服务，具有基于 Gossip 协议的最终一致性，所以可以被用来充当 Terraform Backend 存储。</p>
<p>安装 Consul 十分简单，如果你是 Ubuntu 用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O- https://apt.releases.hashicorp.com/gpg | <span class="built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com <span class="subst">$(lsb_release -cs)</span> main&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/hashicorp.list</span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install consul</span><br></pre></td></tr></table></figure>
<p>对于CentOS用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils</span><br><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo</span><br><span class="line"><span class="built_in">sudo</span> yum -y install consul</span><br></pre></td></tr></table></figure>
<p>对于Macos用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap hashicorp/tap</span><br><span class="line">brew install hashicorp/tap/consul</span><br></pre></td></tr></table></figure>
<p>对于 Windows 用户，如果按照前文安装 Terraform 教程已经配置了 Chocolatey 的话：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install consul</span><br></pre></td></tr></table></figure>
<p>安装完成后的验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ consul</span><br><span class="line">Usage: consul [--version] [--<span class="built_in">help</span>] &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Available commands are:</span><br><span class="line">    acl             Interact with Consul<span class="string">&#x27;s ACLs</span></span><br><span class="line"><span class="string">    agent           Runs a Consul agent</span></span><br><span class="line"><span class="string">    catalog         Interact with the catalog</span></span><br><span class="line"><span class="string">    config          Interact with Consul&#x27;</span>s Centralized Configurations</span><br><span class="line">    connect         Interact with Consul Connect</span><br><span class="line">    debug           Records a debugging archive <span class="keyword">for</span> operators</span><br><span class="line">    event           Fire a new event</span><br><span class="line">    <span class="built_in">exec</span>            Executes a <span class="built_in">command</span> on Consul nodes</span><br><span class="line">    force-leave     Forces a member of the cluster to enter the <span class="string">&quot;left&quot;</span> state</span><br><span class="line">    info            Provides debugging information <span class="keyword">for</span> operators.</span><br><span class="line">    intention       Interact with Connect service intentions</span><br><span class="line">    <span class="built_in">join</span>            Tell Consul agent to <span class="built_in">join</span> cluster</span><br><span class="line">    keygen          Generates a new encryption key</span><br><span class="line">    keyring         Manages gossip layer encryption keys</span><br><span class="line">    kv              Interact with the key-value store</span><br><span class="line">    leave           Gracefully leaves the Consul cluster and shuts down</span><br><span class="line">    lock            Execute a <span class="built_in">command</span> holding a lock</span><br><span class="line">    login           Login to Consul using an auth method</span><br><span class="line">    <span class="built_in">logout</span>          Destroy a Consul token created with login</span><br><span class="line">    maint           Controls node or service maintenance mode</span><br><span class="line">    members         Lists the members of a Consul cluster</span><br><span class="line">    monitor         Stream logs from a Consul agent</span><br><span class="line">    operator        Provides cluster-level tools <span class="keyword">for</span> Consul operators</span><br><span class="line">    peering         Create and manage peering connections between Consul clusters</span><br><span class="line">    reload          Triggers the agent to reload configuration files</span><br><span class="line">    resource        Interact with Consul<span class="string">&#x27;s resources</span></span><br><span class="line"><span class="string">    rtt             Estimates network round trip time between nodes</span></span><br><span class="line"><span class="string">    services        Interact with services</span></span><br><span class="line"><span class="string">    snapshot        Saves, restores and inspects snapshots of Consul server state</span></span><br><span class="line"><span class="string">    tls             Builtin helpers for creating CAs and certificates</span></span><br><span class="line"><span class="string">    troubleshoot    CLI tools for troubleshooting Consul service mesh</span></span><br><span class="line"><span class="string">    validate        Validate config files/directories</span></span><br><span class="line"><span class="string">    version         Prints the Consul version</span></span><br><span class="line"><span class="string">    watch           Watch for changes in Consul</span></span><br></pre></td></tr></table></figure>
<p>安装完 Consul 后，我们可以启动一个测试版 Consul 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul agent -dev</span><br></pre></td></tr></table></figure>
<p>Consul 会在本机 <code>8500</code> 端口开放 Http 终结点，我们可以通过浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8500/">http://localhost:8500</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220224455.png" alt="Consul的GUI界面"></p>
<p>图 1.3.2/1 - Consul的GUI界面</p>
<h2 id="1-3-2-1-5-使用-Backend"><a href="#%E4%BD%BF%E7%94%A8-backend"></a>1.3.2.1.5. 使用 Backend</h2>
<p>我们还是利用 LocalStack 来执行一段简单的 Terraform 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backend &quot;consul&quot; &#123;</span><br><span class="line">    address = &quot;localhost:8500&quot;</span><br><span class="line">    scheme  = &quot;http&quot;</span><br><span class="line">    path    = &quot;localstack-aws&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    docdb          = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_ami&quot; &quot;ubuntu&quot; &#123;</span><br><span class="line">  most_recent = true</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;name&quot;</span><br><span class="line">    values = [&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;virtualization-type&quot;</span><br><span class="line">    values = [&quot;hvm&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  owners = [&quot;099720109477&quot;] # Canonical</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = data.aws_ami.ubuntu.id</span><br><span class="line">  instance_type = &quot;t3.micro&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;HelloWorld&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>terraform</code> 节中，我们添加了 <code>backend</code> 配置节，指定使用 <code>localhost:8500</code> 为地址(也就是我们刚才启动的测试版 Consul 服务)，指定使用 http 协议访问该地址，指定 <code>tfstate</code> 文件存放在 Consul 键值存储服务的 <code>localstack-aws</code> 路径下。</p>
<p>当我们执行完 <code>terraform apply</code> 后，我们访问 <a target="_blank" rel="noopener" href="http://localhost:8500/ui/dc1/kv">http://localhost:8500/ui/dc1/kv</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220230042.png" alt="Consul 中可以看到名为  的键"></p>
<p>图 1.3.2/2 - Consul 中可以看到名为 `localstack-aws` 的键</p>
<p>可以看到 <code>localstack-aws</code>，点击进入：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220230136.png" alt="键的内容"></p>
<p>图 1.3.2/3 - 键的内容</p>
<p>可以看到，原本保存在工作目录下的 <code>tfstate</code> 文件的内容，被保存在了 Consul 的名为 <code>localstack-aws</code> 的键下。</p>
<p>让我们执行 <code>terraform destroy</code> 后，重新访问 <a target="_blank" rel="noopener" href="http://localhost:8500/ui/dc1/kv">http://localhost:8500/ui/dc1/kv</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220230312.png" alt="键依然存在"></p>
<p>图 1.3.2/4 - 键依然存在</p>
<p>可以看到，<code>localstack-aws</code> 这个键仍然存在。让我们点击进去：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220230350.png" alt="内容已被清空"></p>
<p>图 1.3.2/5 - 内容已被清空</p>
<p>可以看到，它的内容为空，代表基础设施已经被成功销毁。</p>
<h2 id="1-3-2-1-6-观察锁文件"><a href="#%E8%A7%82%E5%AF%9F%E9%94%81%E6%96%87%E4%BB%B6"></a>1.3.2.1.6. 观察锁文件</h2>
<p>那么在这个过程里，锁究竟在哪里？我们如何能够体验到锁的存在？让我们对代码进行一点修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backend &quot;consul&quot; &#123;</span><br><span class="line">    address = &quot;localhost:8500&quot;</span><br><span class="line">    scheme  = &quot;http&quot;</span><br><span class="line">    path    = &quot;localstack-aws&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    docdb          = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_ami&quot; &quot;ubuntu&quot; &#123;</span><br><span class="line">  most_recent = true</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;name&quot;</span><br><span class="line">    values = [&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;virtualization-type&quot;</span><br><span class="line">    values = [&quot;hvm&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  owners = [&quot;099720109477&quot;] # Canonical</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = data.aws_ami.ubuntu.id</span><br><span class="line">  instance_type = &quot;t3.micro&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;HelloWorld&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    command = &quot;sleep 1000&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次的变化是我们在 <code>aws_instance</code> 的定义上添加了一个 <code>local-exec</code> 类型的 Provisioner。Provisioner 我们在后续的章节中会专门叙述，在这里读者只需要理解，Terraform 进程在成功创建了该资源后，会在执行 Terraform 命令行的机器上执行一条命令：<code>sleep 1000</code>，这个时间足以将 Terraform 进程阻塞足够长的时间，以便让我们观察锁信息了。如果读者正在使用 Windows，可以把 <code>provisioner</code> 改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">  command = &quot;Start-Sleep -s 1000&quot;</span><br><span class="line">  interpreter = [&quot;PowerShell&quot;, &quot;-Command&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们执行<code>terraform apply</code>，这一次 apply 将会被 sleep 阻塞，而不会成功完成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">data.aws_ami.ubuntu: Reading...</span><br><span class="line">data.aws_ami.ubuntu: Read complete after 1s [<span class="built_in">id</span>=ami-1e749f67]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following  </span><br><span class="line">symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># aws_instance.web will be created</span></span><br><span class="line">  + resource <span class="string">&quot;aws_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      + ami                                  = <span class="string">&quot;ami-1e749f67&quot;</span></span><br><span class="line">      + arn                                  = (known after apply)</span><br><span class="line">      + associate_public_ip_address          = (known after apply)</span><br><span class="line">      + availability_zone                    = (known after apply)</span><br><span class="line">      + cpu_core_count                       = (known after apply)</span><br><span class="line">      + cpu_threads_per_core                 = (known after apply)</span><br><span class="line">      + disable_api_stop                     = (known after apply)</span><br><span class="line">      + disable_api_termination              = (known after apply)</span><br><span class="line">      + ebs_optimized                        = (known after apply)</span><br><span class="line">      + get_password_data                    = <span class="literal">false</span></span><br><span class="line">      + host_id                              = (known after apply)</span><br><span class="line">      + host_resource_group_arn              = (known after apply)</span><br><span class="line">      + iam_instance_profile                 = (known after apply)</span><br><span class="line">      + <span class="built_in">id</span>                                   = (known after apply)</span><br><span class="line">      + instance_initiated_shutdown_behavior = (known after apply)</span><br><span class="line">      + instance_lifecycle                   = (known after apply)</span><br><span class="line">      + instance_state                       = (known after apply)</span><br><span class="line">      + instance_type                        = <span class="string">&quot;t3.micro&quot;</span></span><br><span class="line">      + ipv6_address_count                   = (known after apply)</span><br><span class="line">      + ipv6_addresses                       = (known after apply)</span><br><span class="line">      + key_name                             = (known after apply)</span><br><span class="line">      + monitoring                           = (known after apply)</span><br><span class="line">      + outpost_arn                          = (known after apply)</span><br><span class="line">      + password_data                        = (known after apply)</span><br><span class="line">      + placement_group                      = (known after apply)</span><br><span class="line">      + placement_partition_number           = (known after apply)</span><br><span class="line">      + primary_network_interface_id         = (known after apply)</span><br><span class="line">      + private_dns                          = (known after apply)</span><br><span class="line">      + private_ip                           = (known after apply)</span><br><span class="line">      + public_dns                           = (known after apply)</span><br><span class="line">      + public_ip                            = (known after apply)</span><br><span class="line">      + secondary_private_ips                = (known after apply)</span><br><span class="line">      + security_groups                      = (known after apply)</span><br><span class="line">      + source_dest_check                    = <span class="literal">true</span></span><br><span class="line">      + spot_instance_request_id             = (known after apply)</span><br><span class="line">      + subnet_id                            = (known after apply)</span><br><span class="line">      + tags                                 = &#123;</span><br><span class="line">          + <span class="string">&quot;Name&quot;</span> = <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      + tags_all                             = &#123;</span><br><span class="line">          + <span class="string">&quot;Name&quot;</span> = <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      + tenancy                              = (known after apply)</span><br><span class="line">      + user_data                            = (known after apply)</span><br><span class="line">      + user_data_base64                     = (known after apply)</span><br><span class="line">      + user_data_replace_on_change          = <span class="literal">false</span></span><br><span class="line">      + vpc_security_group_ids               = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line">aws_instance.web: Creating...</span><br><span class="line">aws_instance.web: Still creating... [10s elapsed]</span><br><span class="line">aws_instance.web: Provisioning with <span class="string">&#x27;local-exec&#x27;</span>...</span><br><span class="line">aws_instance.web (local-exec): Executing: [<span class="string">&quot;PowerShell&quot;</span> <span class="string">&quot;-Command&quot;</span> <span class="string">&quot;Start-Sleep -s 1000&quot;</span>]</span><br><span class="line">aws_instance.web: Still creating... [20s elapsed]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>让我们重新访问 <a target="_blank" rel="noopener" href="http://localhost:8500/ui/dc1/kv">http://localhost:8500/ui/dc1/kv</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225100309.png" alt="多了一个同名的文件夹"></p>
<p>图 1.3.2/6 - 多了一个同名的文件夹</p>
<p>这一次情况发生了变化，我们看到除了<code>localstack-aws</code>这个键之外，还多了一个同名的文件夹。让我们点击进入文件夹：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225100354.png" alt="localstack-aws 文件夹内部"></p>
<p>图 1.3.2/7 - localstack-aws 文件夹内部</p>
<p>在这里我们成功观测到了 <code>.lock</code> 和 <code>.lockinfo</code> 文件。让我们点击 <code>.lock</code> 看看：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225180803.png" alt=" 内容"></p>
<p>图 1.3.2/8 - `.lock` 内容</p>
<p>Consul UI提醒我们，该键值对目前正被锁定，而它的内容是空的。让我们查看 <code>.lockinfo</code> 的内容：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225180852.png" alt=" 内容"></p>
<p>图 1.3.2/9 - `.lockinfo` 内容</p>
<p><code>.lockinfo</code> 里记录了锁 <code>ID</code>、我们执行的操作，以及其他的一些信息。</p>
<p>让我们另起一个新的命令行窗口，在同一个工作目录下尝试另一次执行 <code>terraform apply</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply</span><br><span class="line">Acquiring state lock. This may take a few moments...</span><br><span class="line">╷</span><br><span class="line">│ Error: Error acquiring the state lock</span><br><span class="line">│ </span><br><span class="line">│ Error message: Lock Info:</span><br><span class="line">│   ID:        11c859fd-d3e5-4eab-46d6-586b73133430</span><br><span class="line">│   Path:      localstack-aws</span><br><span class="line">│   Operation: OperationTypeApply</span><br><span class="line">│   Who:       ***</span><br><span class="line">│   Version:   1.7.3</span><br><span class="line">│   Created:   2024-02-25 02:00:21.3700184 +0000 UTC</span><br><span class="line">│   Info:      consul session: 11c859fd-d3e5-4eab-46d6-586b73133430</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">│ Terraform acquires a state lock to protect the state from being written</span><br><span class="line">│ by multiple <span class="built_in">users</span> at the same <span class="keyword">time</span>. Please resolve the issue above and try</span><br><span class="line">│ again. For most commands, you can <span class="built_in">disable</span> locking with the <span class="string">&quot;-lock=false&quot;</span></span><br><span class="line">│ flag, but this is not recommended.</span><br><span class="line">╵</span><br></pre></td></tr></table></figure>
<p>可以看到，同时另一个人试图对同一个 <code>tfstate</code> 执行变更的尝试失败了，因为它无法顺利获取到锁。</p>
<p>让我们用 <code>ctrl-c</code> 终止原先被阻塞的 <code>terraform apply</code> 的执行，然后用 <code>terraform force-unlock 11c859fd-d3e5-4eab-46d6-586b73133430</code> 解锁：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ terraform force-unlock 11c859fd-d3e5-4eab-46d6-586b73133430</span><br><span class="line">Do you really want to force-unlock?</span><br><span class="line">  Terraform will remove the lock on the remote state.</span><br><span class="line">  This will allow <span class="built_in">local</span> Terraform commands to modify this state, even though it</span><br><span class="line">  may still be <span class="keyword">in</span> use. Only <span class="string">&#x27;yes&#x27;</span> will be accepted to confirm.</span><br><span class="line"></span><br><span class="line">  Enter a value: <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">Terraform state has been successfully unlocked!</span><br><span class="line"></span><br><span class="line">The state has been unlocked, and Terraform commands should now be able to</span><br><span class="line">obtain a new lock on the remote state.</span><br></pre></td></tr></table></figure>
<p>然后重新访问 <a target="_blank" rel="noopener" href="http://localhost:8500/ui/dc1/kv">http://localhost:8500/ui/dc1/kv</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225101100.png" alt="重新访问Consul"></p>
<p>图 1.3.2/10 - 重新访问Consul</p>
<p>可以看到，包含锁的文件夹消失了。</p>
<h2 id="1-3-2-1-7-Backend-配置的动态赋值"><a href="#backend-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC"></a>1.3.2.1.7. Backend 配置的动态赋值</h2>
<p>有些读者会注意到，到目前为止我所写的代码里的配置项基本都是硬编码的，Terraform 是否支持运行时用变量动态赋值？答案是支持的，Terraform 可以通过 <code>variable</code> 变量来传值给 <code>provider</code>、<code>data</code> 和 <code>resource</code>。</p>
<p>但有一些例外，其中就有 <code>backend</code> 配置。<code>backend</code> 配置只允许硬编码，或者不传值。</p>
<p>这个问题是因为 Terraform 运行时本身设计的运行顺序导致的，一直到 2019 年 05 月官方才给出了解决方案，那就是“部分配置“(partial configuration)。</p>
<p>简单来说就是我们可以在 Terraform 代码的 <code>backend</code> 声明中不给出具体的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backend &quot;consul&quot; &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在另一个独立的文件中给出相关配置，例如我们在工作目录下创建一个名为 <code>backend.hcl</code> 的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address = &quot;localhost:8500&quot;</span><br><span class="line">scheme  = &quot;http&quot;</span><br><span class="line">path    = &quot;localstack-aws&quot;</span><br></pre></td></tr></table></figure>
<p>本质上我们就是把原本属于 <code>backend consul</code> 块的属性赋值代码搬迁到一个独立的 hcl 文件内，然后我们执行 <code>terraform init</code> 时附加 <code>backend-config</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform init -backend-config=backend.hcl</span><br></pre></td></tr></table></figure>
<p>这样也可以初始化成功。通过这种打补丁的方式，我们可以复用他人预先写好的 Terraform 代码，在执行时把属于我们自己的 Backend 配置信息以独立的 <code>backend-config</code> 文件的形式传入来进行初始化。</p>
<h2 id="1-3-2-1-8-Backend-的权限控制以及版本控制"><a href="#backend-%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"></a>1.3.2.1.8. Backend 的权限控制以及版本控制</h2>
<p>Backend 本身并没有设计任何的权限以及版本控制，这方面完全依赖于具体的 Backend 实现。以 AWS S3 为例，我们可以针对不同的 Bucket 设置不同的 IAM，用以防止开发测试人员直接操作生产环境，或是给予部分人员对状态信息的只读权限；另外我们也可以开启 S3 的版本控制功能，以防我们错误修改了状态文件(Terraform 命令行有修改状态的相关指令)。</p>
<h2 id="1-3-2-1-9-状态的隔离存储"><a href="#%E7%8A%B6%E6%80%81%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AD%98%E5%82%A8"></a>1.3.2.1.9. 状态的隔离存储</h2>
<p>我们讲完 Backend，现在要讨论另一个问题。假设我们的 Terraform 代码可以创建一个通用的基础设施，比如说是云端的一个 EKS、AKS 集群，或者是一个基于 S3 的静态网站，那么我们可能要为很多团队创建并维护这些相似但要彼此隔离的 Stack，又或者我们要为部署的应用维护开发、测试、预发布、生产四套不同的部署。那么该如何做到不同的部署，彼此状态文件隔离存储和管理呢？</p>
<p>一种简单的方法就是分成不同的文件夹存储。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-17/1605571444613-image.png" alt="将代码复制到不同的文件夹中保存"></p>
<p>图 1.3.2/11 - 将代码复制到不同的文件夹中保存</p>
<p>我们可以把不同产品不同部门使用的基础设施分成不同的文件夹，在文件夹内维护相同的代码文件，配置不同的 <code>backend-config</code>，把状态文件保存到不同的 Backend 上。这种方法可以给予最大程度的隔离，缺点是我们需要拷贝许多份相同的代码。</p>
<p>第二种更加轻量级的方法就是 Workspace。注意，Terraform 开源版的 Workspace 与 Terraform Cloud 云服务的 Workspace 实际上是两个不同的概念，我们这里介绍的是开源版的 Workspace。</p>
<p>Workspace 允许我们在同一个文件夹内，使用同样的 Backend 配置，但可以维护任意多个彼此隔离的状态文件。还是我们刚才那个使用测试 Consul 服务作为 Backend 的例子：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225174932.png" alt="重新访问 Consul，目前有一个键"></p>
<p>图 1.3.2/12 - 重新访问 Consul，目前有一个键</p>
<p>当前我们有一个状态文件，名字是 <code>localstack-aws</code>。然后我们在工作目录下执行这样的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace new feature1</span><br><span class="line">Created and switched to workspace <span class="string">&quot;feature1&quot;</span>!</span><br><span class="line"></span><br><span class="line">You<span class="string">&#x27;re now on a new, empty workspace. Workspaces isolate their state,</span></span><br><span class="line"><span class="string">so if you run &quot;terraform plan&quot; Terraform will not see any existing state</span></span><br><span class="line"><span class="string">for this configuration.</span></span><br></pre></td></tr></table></figure>
<p>通过调用 <code>workspace</code> 命令，我们成功创建了名为 <code>feature1</code> 的 Workspace。这时我们观察 <code>.terraform</code> 文件夹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">├── environment</span><br><span class="line">├── providers</span><br><span class="line">│        └── registry.terraform.io</span><br><span class="line">│             └── hashicorp</span><br><span class="line">│                 └── aws</span><br><span class="line">│                     └── 5.38.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>我们会发现多了一个 <code>environment</code> 文件，它的内容是 <code>feature1</code>。这实际上就是 Terraform 用来保存当前上下文环境使用的是哪个 Workspace 的文件。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225175538.png" alt="Consul 中多了一个 "></p>
<p>图 1.3.2/13 - Consul 中多了一个 `localstack-aws-env:feature1`</p>
<p>重新观察 Consul 存储会发现多了一个文件：<code>localstack-aws-env:feature1</code>。这就是 Terraform 为 <code>feature1</code> 这个 Workspace 创建的独立的状态文件。让我们执行一下 apply，然后再看这个文件的内容：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225175806.png" alt="此时  的内容"></p>
<p>图 1.3.2/14 - 此时 `localstack-aws-env:feature1` 的内容</p>
<p>可以看到，状态被成功写入了 <code>feature1</code> 的状态文件。</p>
<p>我们可以通过以下命令来查询当前 Backend 下所有的 Workspace：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace list</span><br><span class="line">  default</span><br><span class="line">* feature1</span><br></pre></td></tr></table></figure>
<p>我们有 <code>default</code> 和 <code>feature1</code> 两个 Workspace，当前我们工作在 <code>feature1</code> 上。我们可以用以下命令切换回 <code>default</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace <span class="keyword">select</span> default</span><br><span class="line">Switched to workspace <span class="string">&quot;default&quot;</span>.</span><br></pre></td></tr></table></figure>
<p>我们可以用以下命令确认我们成功切换回了 <code>default</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace show</span><br><span class="line">default</span><br></pre></td></tr></table></figure>
<p>我们可以用以下命令删除 <code>feature1</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace delete feature1</span><br><span class="line">╷</span><br><span class="line">│ Error: Workspace is not empty</span><br><span class="line">│</span><br><span class="line">│ Workspace <span class="string">&quot;feature1&quot;</span> is currently tracking the following resource instances:</span><br><span class="line">│   - aws_instance.web</span><br><span class="line">│</span><br><span class="line">│ Deleting this workspace would cause Terraform to lose track of any associated remote objects, <span class="built_in">which</span> would <span class="keyword">then</span> require you to    </span><br><span class="line">│ delete them manually outside of Terraform. You should destroy these objects with Terraform before deleting the workspace.        </span><br><span class="line">│</span><br><span class="line">│ If you want to delete this workspace anyway, and have Terraform forget about these managed objects, use the -force option to     </span><br><span class="line">│ <span class="built_in">disable</span> this safety check.</span><br><span class="line">╵</span><br></pre></td></tr></table></figure>
<p>Terraform 发现 <code>feature1</code> 还有资源没有被销毁，所以它拒绝了我们的删除请求。因为我们目前是使用 LocalStack 模拟的例子，所以不会有资源泄漏的问题，我们可以用以下命令强制删除 <code>feature1</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace delete -force feature1</span><br><span class="line">Deleted workspace <span class="string">&quot;feature1&quot;</span>!</span><br><span class="line">WARNING: <span class="string">&quot;feature1&quot;</span> was non-empty.</span><br><span class="line">The resources managed by the deleted workspace may still exist,</span><br><span class="line">but are no longer manageable by Terraform since the state has</span><br><span class="line">been deleted.</span><br></pre></td></tr></table></figure>
<p>再观察 Consul 存储，就会发现 <code>feature1</code> 的状态文件被删除了：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225180126.png" alt=" 被删除了"></p>
<p>图 1.3.2/15 - `localstack-aws-env:feature1` 被删除了</p>
<p>目前支持多工作区的 Backend 有：</p>
<ul>
<li>AzureRM</li>
<li>Consulf</li>
<li>COS</li>
<li>GCS</li>
<li>Kubernetes</li>
<li>Local</li>
<li>OSS</li>
<li>Postgres</li>
<li>Remote</li>
<li>S3</li>
</ul>
<h2 id="1-3-2-1-10-该使用哪种隔离"><a href="#%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9A%94%E7%A6%BB"></a>1.3.2.1.10. 该使用哪种隔离</h2>
<p>相比起多文件夹隔离的方式来说，基于 Workspace 的隔离更加简单，只需要保存一份代码，在代码中不需要为 Workspace 编写额外代码，用命令行就可以在不同工作区之间来回切换。</p>
<p>但是 Workspace 的缺点也同样明显，由于所有工作区的 Backend 配置是一样的，所以有权读写某一个 Workspace 的人可以读取同一个 Backend 路径下所有其他 Workspace；另外 Workspace 是隐式配置的(调用命令行)，所以有时人们会忘记自己工作在哪个 Workspace 下。</p>
<p>Terraform 官方为 Workspace 设计的场景是：有时开发人员想要对既有的基础设施做一些变更，并进行一些测试，但又不想直接冒险修改既有的环境。这时他可以利用 Workspace 复制出一个与既有环境完全一致的平行环境，在这个平行环境里做一些变更，并进行测试和实验工作。</p>
<p>Workspace 对应的源代码管理模型里的主干——分支模型，如果团队希望维护的是不同产品之间不同的基础设施，或是开发、测试、预发布、生产环境，那么最好还是使用不同的文件夹以及不同的 <code>backend-config</code> 进行管理。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/18/Teraform/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/17/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider%20copy/"
                            aria-label=": Terraform 基础概念-Provider"
                        >
                            Terraform 基础概念-Provider
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-17T17:43:45+08:00">
	
		    2023 年 1 月 17 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"><strong>1.3.1.1.</strong> Terraform 基础概念 —— Provider</a></p>
</li>
<li>
<p><a href="#%E4%B8%8B%E8%BD%BD-provider"><strong>1.3.1.1.1.</strong> 下载 Provider</a></p>
</li>
<li>
<p><a href="#%E6%90%9C%E7%B4%A2-provider"><strong>1.3.1.1.2.</strong> 搜索 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><strong>1.3.1.1.3.</strong> Provider 的声明</a></p>
</li>
<li>
<p><a href="#%E5%86%85%E5%BB%BA-provider"><strong>1.3.1.1.4.</strong> 内建 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.5.</strong> Provider 的配置</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><strong>1.3.1.1.6.</strong> 多 Provider 实例</a></p>
</li>
<li>
<p><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.1.</strong> 默认 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.2.</strong> 引用备用 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.3.</strong> 选择备用 Provider 配置</a></p>
</li>
</ul>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a></p>
<h2 id="1-3-1-1-Terraform-基础概念-——-Provider"><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a>1.3.1.1. Terraform 基础概念 —— Provider</h2>
<p>Terraform 被设计成一个多云基础设施编排工具，不像 CloudFormation 那样绑定 AWS 平台，Terraform 可以同时编排各种云平台或是其他基础设施的资源。Terraform 实现多云编排的方法就是 Provider 插件机制。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605496195438-image.png" alt="Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源"></p>
<p>图 1.3.1/1 - Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源</p>
<p>Terraform 使用的是 HashiCorp 自研的 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/go-plugin"><code>go-plugin</code> 库</a>)，本质上各个 Provider 插件都是独立的进程，与 Terraform 进程之间通过 Rpc 进行调用。Terraform 引擎首先读取并分析用户编写的 Terraform 代码，形成一个由 <code>data</code> 与 <code>resource</code> 组成的图(Graph)，再通过 Rpc 调用这些 <code>data</code> 与 <code>resource</code> 所对应的 Provider 插件；Provider 插件的编写者根据 Terraform 所制定的插件框架来定义各种 <code>data</code> 和 <code>resource</code>，并实现相应的 CRUD 方法；在实现这些 CRUD 方法时，可以调用目标平台提供的 SDK，或是直接通过调用 Http(s) API来操作目标平台。</p>
<h2 id="1-3-1-1-1-下载-Provider"><a href="#%E4%B8%8B%E8%BD%BD-provider"></a>1.3.1.1.1. 下载 Provider</h2>
<p>我们在第一章的小例子中，写完代码后在 <code>apply</code> 之前，首先我们执行了一次<code>terraform init</code>。<code>terraform init</code>会分析代码中所使用到的 Provider，并尝试下载 Provider 插件到本地。如果我们观察执行完第一章例子的文件夹，我们会发现有一个 <code>.terraform</code> 文件夹，我们所使用的 AWS Provider 插件就被下载安装在里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.terraform</span><br><span class="line">└── providers</span><br><span class="line">    └── registry.terraform.io</span><br><span class="line">        └── hashicorp</span><br><span class="line">            └── aws</span><br><span class="line">                └── 5.37.0</span><br><span class="line">                    └── windows_amd64</span><br><span class="line">                        └── terraform-provider-aws_v5.37.0_x5.exe</span><br></pre></td></tr></table></figure>
<p>有的时候下载某些 Provider 会非常缓慢，或是在开发环境中存在许多的 Terraform 项目，每个项目都保有自己独立的插件文件夹非常浪费磁盘，这时我们可以使用插件缓存。</p>
<p>有两种方式可以启用插件缓存：</p>
<p><strong>第一种方法</strong>是配置 <code>TF_PLUGIN_CACHE_DIR</code> 这个环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TF_PLUGIN_CACHE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.terraform.d/plugin-cache&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种方法</strong>是使用 CLI 配置文件。Windows 下是在相关用户的 <code>%APPDATA%</code> 目录下创建名为 <code>&quot;terraform.rc&quot;</code> 的文件，Macos 和 Linux 用户则是在用户的 <code>home</code> 下创建名为 <code>&quot;.terraformrc&quot;</code> 的文件。在文件中配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin_cache_dir = &quot;$HOME/.terraform.d/plugin-cache&quot;</span><br></pre></td></tr></table></figure>
<p>当启用插件缓存之后，每当执行 <code>terraform init</code> 命令时，Terraform 引擎会首先检查期望使用的插件在缓存文件夹中是否已经存在，如果存在，那么就会将缓存的插件拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。如果插件不存在，那么 Terraform 仍然会像之前那样下载插件，并首先保存在插件文件夹中，随后再从插件文件夹拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。为了尽量避免同一份插件被保存多次，只要操作系统提供支持，Terraform 就会使用符号连接而不是实际从插件缓存目录拷贝到工作目录。</p>
<p><strong>需要特别注意的是，Windows 系统下 <code>plugin_cache_dir</code> 的路径也必须使用 <code>/</code> 作为分隔符，应使用 <code>C:/somefolder/plugin_cahce</code> 而不是 <code>C:\somefolder\plugin_cache</code></strong></p>
<p>Terraform 引擎永远不会主动删除缓存文件夹中的插件，缓存文件夹的尺寸可能会随着时间而增长到非常大，这时需要手工清理。</p>
<h2 id="1-3-1-1-2-搜索-Provider"><a href="#%E6%90%9C%E7%B4%A2-provider"></a>1.3.1.1.2. 搜索 Provider</h2>
<p>想要了解有哪些被官方接纳的 Provider，就是前往<a target="_blank" rel="noopener" href="https://registry.terraform.io/browse/providers">registry.terraform.io</a>进行搜索：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-19/1605799350775-image.png" alt="registry.terraform.io上的插件页面"></p>
<p>图 1.3.1/2 - registry.terraform.io上的插件页面</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605498907942-image.png" alt="registry.terraform.io的搜索页面"></p>
<p>图 1.3.1/3 - registry.terraform.io的搜索页面</p>
<p>一般来说，相关 Provider 如何声明，以及相关 <code>data</code>、<code>resource</code> 的使用说明，都可以在 registry 上查阅到相关文档。</p>
<p><a target="_blank" rel="noopener" href="https://registry.terraform.io/"><code>registry.terraform.io</code></a> 不但可以查询 Provider，也可以用来发布 Provider；并且它也可以用来查询和发布模块(Module)，不过模块将是我们后续篇章讨论的话题。</p>
<h2 id="1-3-1-1-3-Provider-的声明"><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"></a>1.3.1.1.3. Provider 的声明</h2>
<p>一组 Terraform 代码要被执行，相关的 Provider 必须在代码中被声明。不少的 Provider 在声明时需要传入一些关键信息才能被使用，例如我们在第一章的例子中，必须给出访问密钥以及期望执行的 AWS 区域（Region）信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段 Provider 声明中，首先在 <code>terraform</code> 块的 <code>required_providers</code> 里声明了本段代码必须要名为 <code>aws</code> 的 Provider 才可以执行，<code>source = &quot;hashicorp/aws&quot;</code>这一行声明了 <code>aws</code> 这个插件的源地址(Source Address)。一个源地址是全球唯一的，它指示了 Terraform 如何下载该插件。一个源地址由三部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;HOSTNAME&gt;/]&lt;NAMESPACE&gt;/&lt;TYPE&gt;</span><br></pre></td></tr></table></figure>
<p><code>Hostname</code> 是选填的，默认是官方的 <code>registry.terraform.io</code>，读者也可以构建自己私有的Terraform仓库。<code>Namespace</code> 是在 Terraform 仓库内注册的组织名，这代表了发布和维护插件的组织或是个人。<code>Type</code> 是代表插件的一个短名，在特定的 <code>HostName</code>/<code>Namespace</code> 下 <code>Type</code> 必须唯一。</p>
<p><code>required_providers</code> 中的插件声明还声明了该源码所需要的插件的版本约束，在例子里就是 <code>version = &quot;~&gt;5.0&quot;</code>。Terraform 插件的版本号采用 <code>MAJOR.MINOR.PATCH</code> 的语义化格式，版本约束通常使用操作符和版本号表达约束条件，条件之间可以用逗号拼接，表达 <code>AND</code> 关联，例如 <code>&quot;&gt;= 1.2.0, &lt; 2.0.0&quot;</code>。可以采用的操作符有：</p>
<ul>
<li><code>=</code>(或者不加 <code>=</code>，直接使用版本号)：只允许特定版本号，不允许与其他条件合并使用</li>
<li><code>!=</code>：不允许特定版本号</li>
<li><code>\&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>：与特定版本号进行比较，可以是大于、大于等于、小于、小于等于</li>
<li><code>~&gt;</code>：只允许 <em>最右边</em> 的版本号增加。这种格式被称为 <em>悲观约束</em> 操作符。例如，要允许在特定的 <code>MINOR</code> 版本中允许新的 <code>PATCH</code> 版本：
<ul>
<li><code>~&gt; 1.0.4</code>：允许 Terraform 安装 <code>1.0.5</code> 和 <code>1.0.10</code>，但不允许 <code>1.1.0</code>。</li>
<li><code>~&gt; 1.1</code>：允许 Terraform 安装 <code>1.2</code> 和 <code>1.10</code>，但不允许 <code>2.0</code>。</li>
</ul>
</li>
</ul>
<p>Terraform 会检查当前工作环境或是插件缓存中是否存在满足版本约束的插件，如果不存在，那么 Terraform 会尝试下载。如果 Terraform 无法获得任何满足版本约束条件的插件，那么它会拒绝继续执行任何后续操作。</p>
<p>可以用添加后缀的方式来声明预览版，例如：<code>1.2.0-beta</code>。预览版只能通过 <code>&quot;=&quot;</code> 操作符(或是忽略操作符)后接明确的版本号的方式来指定，不可以与<code>&gt;=</code>、<code>~&gt;</code>等搭配使用。</p>
<ul>
<li>当依赖第三方模块时，需要指定特定版本，以确保只在您需要的时候进行更新。</li>
<li>对于在您的组织内维护的模块，如果一致使用语义版本控制，或者有一个定义良好的发布流程可以避免不必要的更新，那么指定版本范围可能是合适的。</li>
<li>可重用的模块应仅限制其 Terraform 和 Provider 的最低允许版本，例如 <code>&gt;= 0.12.0</code>。这有助于避免已知的不兼容性，同时允许模块的用户在不改变模块的情况下升级到 Terraform 的新版本。</li>
<li>根模块应使用 <code>~&gt;</code> 约束为它们依赖的每个 Provider 设置一个下限和上限版本。</li>
</ul>
<p>以上建议来自于 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/expressions/version-constraints#best-practices">HashiCorp 官方文档</a>，笔者个人给出一条个人建议：</p>
<ul>
<li>可复用的模块不但应该限制 Provider 的最低版本，同时也应该限制 Provider 的 <code>MAJOR</code> 版本。例如，<code>&gt;= 1.5.0, &lt; 2.0</code>。这样可以避免在 Provider 的 <code>MAJOR</code> 版本升级时，因为不兼容性导致的问题，Provider 的 <code>MAJOR</code> 版本升级通常会伴随着不兼容的改动，不应该在未加测试的情况下轻易升级。</li>
</ul>
<h2 id="1-3-1-1-4-内建-Provider"><a href="#%E5%86%85%E5%BB%BA-provider"></a>1.3.1.1.4. 内建 Provider</h2>
<p>绝大多数 Provider 是以插件形式单独分发的，但是目前有一个 Provider 是内建于Terraform主进程中的，那就是 <code>terraform_remote_state</code> data source。该 Provider 由于是内建的，所以使用时不需要在 <code>terraform</code> 中声明 <code>required_providers</code>。这个内建Provider的源地址是 <code>terraform.io/builtin/terraform</code>。这个地址有时可能出现在 Terraform 的错误消息和其他输出中，以便无歧义地引用内建 Provider，而不是假设的第三方提供者，其类型名称为 “terraform”。</p>
<p>还存在一个源地址为 <code>hashicorp/terraform</code> 的 Provider，这是现在内置 Provider 的旧版本，被 Terraform 的旧版本使用。<code>hashicorp/terraform</code> 与 Terraform v0.11 或更高版本不兼容，因此永远不应在 <code>required_providers</code> 块中声明。</p>
<h2 id="1-3-1-1-5-Provider-的配置"><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"></a>1.3.1.1.5. Provider 的配置</h2>
<p>Provider 的配置是声明在根模块中的一组 Terraform 配置。（子模块接收来自于根模块的 Provider 配置，更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider">模块的 <code>provider</code> 元参数</a>）</p>
<p>一个 Provider 配置是通过 <code>provider</code> 块来创建的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;google&quot; &#123;</span><br><span class="line">  project = &quot;acme-app&quot;</span><br><span class="line">  region  = &quot;us-central1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块头部设置的名称（例子中的 <code>&quot;google&quot;</code>）就是要配置的 Provider 的<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/providers/requirements#local-names">Local Name</a>。这个 Provider 必须已在 <code>required_providers</code> 块中声明。</p>
<p>块体（<code>&#123;</code> 和 <code>&#125;</code> 中间的内容）包含了 Provider 的配置参数。这些参数大多数是由 Provider 自己定义的；在这个例子中，<code>project</code> 和 <code>region</code> 都是 <code>google</code> Provider 特有的。</p>
<p>你可以在这些配置的值当中使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/8.%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，但是只能引用在配置 Provider 时已知的值。这意味着你可以安全地引用输入变量，但是不能引用从 <code>resource</code> 返回的属性（一个例外是直接在配置中硬编码的 <code>resource</code> 参数）。</p>
<p>一个 Provider 的文档应该列出它所需要的配置参数。对那些注册在 <a target="_blank" rel="noopener" href="https://registry.terraform.io/">Terraform Registry</a> 上的 Provider 来说，每个 Provider 的页面上都有版本化的文档，可以通过 Provider 页头的 “Documentation” 链接访问。</p>
<p>一些 Provider 可以使用环境变量（或是其他替代配置源，例如 AWS 的虚拟机实例 Profile）作为某些配置参数的值；我们建议尽可能使用这种方式来避免将凭证保存于版本控制的 Terraform 代码中。</p>
<p>There are also two “meta-arguments” that are defined by Terraform itself and available for all <code>provider</code> blocks:</p>
<p>有两个由 Terraform 自身定义的“元参数”，对所有 <code>provider</code> 块都可用：</p>
<ul>
<li><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><code>alias</code>，用以为不同的 <code>resource</code> 块配置参数不同的同类 Provider 实例</a></li>
<li><code>version</code>， 废弃，不推荐使用，现在请使用 <a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><code>required_providers</code></a></li>
</ul>
<p>与 Terraform 语言中的许多其他对象不同，如果 <code>provider</code> 块的内容为空，则可以省略该块。Terraform 假定未显式配置的任何 Provider 程序都具有空的默认配置。</p>
<h2 id="1-3-1-1-6-多-Provider-实例"><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"></a>1.3.1.1.6. 多 Provider 实例</h2>
<p><code>provider</code> 块声明了 <code>aws</code> 这个 Provider 所需要的各项配置。在上文的代码示例中，<code>provider &quot;aws&quot;</code>和<code>required_providers</code>中<code>aws = &#123;...&#125;</code>块里的<code>aws</code>，都是 Provider 的 Local Name，一个 Local Name 是在一个模块中对一个 Provider 的唯一的标识。</p>
<p>你可以选择为同一个 Provider 定义多个配置，并且可以根据每个资源或每个模块来选择使用哪一个。这主要是为了支持云平台的多个区域；其他例子包括针对多个 Docker 主机，多个 Consul 主机等。</p>
<p>要为某一个 Provider 创建多个配置，包括具有相同提供者名称的多个 <code>provider</code> 块。对于每个额外的非默认配置，使用 <code>alias</code> 元参数提供额外的名称段。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># The default provider configuration; resources that begin with `aws_` will use</span><br><span class="line"># it as the default, and it can be referenced as `aws`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Additional provider configuration for west coast region; resources can</span><br><span class="line"># reference this as `aws.west`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;west&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模块内声明配置 <code>alias</code> 以从父模块接收备用的 <code>provider</code> 配置，需要在该 <code>provider</code> 的 <code>required_providers</code> 条目中添加 <code>configuration_aliases</code> 参数。以下示例在包含的模块中声明了 <code>mycloud</code> 和 <code>mycloud.alternate</code> 的 <code>provider</code> 配置名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    mycloud = &#123;</span><br><span class="line">      source  = &quot;mycorp/mycloud&quot;</span><br><span class="line">      version = &quot;~&gt; 1.0&quot;</span><br><span class="line">      configuration_aliases = [ mycloud.alternate ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1-1-6-1-默认-Provider-配置"><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.1. 默认 Provider 配置</h3>
<p>没有 <code>alias</code> 参数的 <code>provider</code> 块是该 provider 的 <em>默认</em> 配置。未设置 <code>provider</code> 元参数的资源将使用与资源类型名称的第一个单词匹配的默认 provider 配置。（例如，除非另有说明，否则 <code>aws_instance</code> 资源将使用默认的 <code>aws</code> provider 配置。）</p>
<p>如果 provider 的每个显式配置都有别名，Terraform 将使用隐含的空配置作为该 provider 的默认配置。（如果 provider 有任何必需的配置参数，当资源默认使用空配置时，Terraform 将引发错误。）</p>
<h3 id="1-3-1-1-6-2-引用备用-Provider-配置"><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.2. 引用备用 Provider 配置</h3>
<p>当 Terraform 需要 provider 配置的名称时，它期望的是 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 形式的引用。在上面的例子中，<code>aws.west</code> 将引用 <code>us-west-2</code> 区域的 provider。</p>
<p>这些引用是特殊的表达式。像对其他命名实体（例如 <code>var.image_id</code>）的引用一样，它们不是字符串，不需要引号。但是它们只在 <code>resource</code>、<code>data</code> 和 <code>module</code> 块的特定元参数中有效，不能在任意表达式中使用。</p>
<h3 id="1-3-1-1-6-3-选择备用-Provider-配置"><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.3. 选择备用 Provider 配置</h3>
<p>默认情况下，资源使用从资源类型名称的第一个单词推断出的默认 provider 配置（没有 <code>alias</code> 参数的配置）。</p>
<p>要为资源或数据源指定备用 provider 配置，将其 <code>provider</code> 元参数设置为 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;foo&quot; &#123;</span><br><span class="line">  provider = aws.west</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要为子模块指定备用 provider 配置，使用其 <code>providers</code> 元参数指定应将哪些 provider 配置映射到模块内的哪些本地 provider 名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module &quot;aws_vpc&quot; &#123;</span><br><span class="line">  source = &quot;./aws_vpc&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws = aws.west</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在传递 provider 时，模块有一些特殊要求；有关更多详细信息，请参见 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html#module-providers">模块 <code>providers</code> 元参数</a>。在大多数情况下，只有 <em>根模块</em> 应定义 provider 配置，所有子模块都应从其父模块获取其 provider 配置。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/17/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider%20copy/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../2023/01/17/Teraform/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider/"
                            aria-label=": Terraform 基础概念-Provider"
                        >
                            Terraform 基础概念-Provider
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-17T17:43:45+08:00">
	
		    2023 年 1 月 17 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../categories/devops/">devops</a>, <a class="category-link" href="../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"><strong>1.3.1.1.</strong> Terraform 基础概念 —— Provider</a></p>
</li>
<li>
<p><a href="#%E4%B8%8B%E8%BD%BD-provider"><strong>1.3.1.1.1.</strong> 下载 Provider</a></p>
</li>
<li>
<p><a href="#%E6%90%9C%E7%B4%A2-provider"><strong>1.3.1.1.2.</strong> 搜索 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><strong>1.3.1.1.3.</strong> Provider 的声明</a></p>
</li>
<li>
<p><a href="#%E5%86%85%E5%BB%BA-provider"><strong>1.3.1.1.4.</strong> 内建 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.5.</strong> Provider 的配置</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><strong>1.3.1.1.6.</strong> 多 Provider 实例</a></p>
</li>
<li>
<p><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.1.</strong> 默认 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.2.</strong> 引用备用 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.3.</strong> 选择备用 Provider 配置</a></p>
</li>
</ul>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a></p>
<h2 id="1-3-1-1-Terraform-基础概念-——-Provider"><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a>1.3.1.1. Terraform 基础概念 —— Provider</h2>
<p>Terraform 被设计成一个多云基础设施编排工具，不像 CloudFormation 那样绑定 AWS 平台，Terraform 可以同时编排各种云平台或是其他基础设施的资源。Terraform 实现多云编排的方法就是 Provider 插件机制。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605496195438-image.png" alt="Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源"></p>
<p>图 1.3.1/1 - Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源</p>
<p>Terraform 使用的是 HashiCorp 自研的 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/go-plugin"><code>go-plugin</code> 库</a>)，本质上各个 Provider 插件都是独立的进程，与 Terraform 进程之间通过 Rpc 进行调用。Terraform 引擎首先读取并分析用户编写的 Terraform 代码，形成一个由 <code>data</code> 与 <code>resource</code> 组成的图(Graph)，再通过 Rpc 调用这些 <code>data</code> 与 <code>resource</code> 所对应的 Provider 插件；Provider 插件的编写者根据 Terraform 所制定的插件框架来定义各种 <code>data</code> 和 <code>resource</code>，并实现相应的 CRUD 方法；在实现这些 CRUD 方法时，可以调用目标平台提供的 SDK，或是直接通过调用 Http(s) API来操作目标平台。</p>
<h2 id="1-3-1-1-1-下载-Provider"><a href="#%E4%B8%8B%E8%BD%BD-provider"></a>1.3.1.1.1. 下载 Provider</h2>
<p>我们在第一章的小例子中，写完代码后在 <code>apply</code> 之前，首先我们执行了一次<code>terraform init</code>。<code>terraform init</code>会分析代码中所使用到的 Provider，并尝试下载 Provider 插件到本地。如果我们观察执行完第一章例子的文件夹，我们会发现有一个 <code>.terraform</code> 文件夹，我们所使用的 AWS Provider 插件就被下载安装在里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.terraform</span><br><span class="line">└── providers</span><br><span class="line">    └── registry.terraform.io</span><br><span class="line">        └── hashicorp</span><br><span class="line">            └── aws</span><br><span class="line">                └── 5.37.0</span><br><span class="line">                    └── windows_amd64</span><br><span class="line">                        └── terraform-provider-aws_v5.37.0_x5.exe</span><br></pre></td></tr></table></figure>
<p>有的时候下载某些 Provider 会非常缓慢，或是在开发环境中存在许多的 Terraform 项目，每个项目都保有自己独立的插件文件夹非常浪费磁盘，这时我们可以使用插件缓存。</p>
<p>有两种方式可以启用插件缓存：</p>
<p><strong>第一种方法</strong>是配置 <code>TF_PLUGIN_CACHE_DIR</code> 这个环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TF_PLUGIN_CACHE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.terraform.d/plugin-cache&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种方法</strong>是使用 CLI 配置文件。Windows 下是在相关用户的 <code>%APPDATA%</code> 目录下创建名为 <code>&quot;terraform.rc&quot;</code> 的文件，Macos 和 Linux 用户则是在用户的 <code>home</code> 下创建名为 <code>&quot;.terraformrc&quot;</code> 的文件。在文件中配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin_cache_dir = &quot;$HOME/.terraform.d/plugin-cache&quot;</span><br></pre></td></tr></table></figure>
<p>当启用插件缓存之后，每当执行 <code>terraform init</code> 命令时，Terraform 引擎会首先检查期望使用的插件在缓存文件夹中是否已经存在，如果存在，那么就会将缓存的插件拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。如果插件不存在，那么 Terraform 仍然会像之前那样下载插件，并首先保存在插件文件夹中，随后再从插件文件夹拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。为了尽量避免同一份插件被保存多次，只要操作系统提供支持，Terraform 就会使用符号连接而不是实际从插件缓存目录拷贝到工作目录。</p>
<p><strong>需要特别注意的是，Windows 系统下 <code>plugin_cache_dir</code> 的路径也必须使用 <code>/</code> 作为分隔符，应使用 <code>C:/somefolder/plugin_cahce</code> 而不是 <code>C:\somefolder\plugin_cache</code></strong></p>
<p>Terraform 引擎永远不会主动删除缓存文件夹中的插件，缓存文件夹的尺寸可能会随着时间而增长到非常大，这时需要手工清理。</p>
<h2 id="1-3-1-1-2-搜索-Provider"><a href="#%E6%90%9C%E7%B4%A2-provider"></a>1.3.1.1.2. 搜索 Provider</h2>
<p>想要了解有哪些被官方接纳的 Provider，就是前往<a target="_blank" rel="noopener" href="https://registry.terraform.io/browse/providers">registry.terraform.io</a>进行搜索：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-19/1605799350775-image.png" alt="registry.terraform.io上的插件页面"></p>
<p>图 1.3.1/2 - registry.terraform.io上的插件页面</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605498907942-image.png" alt="registry.terraform.io的搜索页面"></p>
<p>图 1.3.1/3 - registry.terraform.io的搜索页面</p>
<p>一般来说，相关 Provider 如何声明，以及相关 <code>data</code>、<code>resource</code> 的使用说明，都可以在 registry 上查阅到相关文档。</p>
<p><a target="_blank" rel="noopener" href="https://registry.terraform.io/"><code>registry.terraform.io</code></a> 不但可以查询 Provider，也可以用来发布 Provider；并且它也可以用来查询和发布模块(Module)，不过模块将是我们后续篇章讨论的话题。</p>
<h2 id="1-3-1-1-3-Provider-的声明"><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"></a>1.3.1.1.3. Provider 的声明</h2>
<p>一组 Terraform 代码要被执行，相关的 Provider 必须在代码中被声明。不少的 Provider 在声明时需要传入一些关键信息才能被使用，例如我们在第一章的例子中，必须给出访问密钥以及期望执行的 AWS 区域（Region）信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段 Provider 声明中，首先在 <code>terraform</code> 块的 <code>required_providers</code> 里声明了本段代码必须要名为 <code>aws</code> 的 Provider 才可以执行，<code>source = &quot;hashicorp/aws&quot;</code>这一行声明了 <code>aws</code> 这个插件的源地址(Source Address)。一个源地址是全球唯一的，它指示了 Terraform 如何下载该插件。一个源地址由三部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;HOSTNAME&gt;/]&lt;NAMESPACE&gt;/&lt;TYPE&gt;</span><br></pre></td></tr></table></figure>
<p><code>Hostname</code> 是选填的，默认是官方的 <code>registry.terraform.io</code>，读者也可以构建自己私有的Terraform仓库。<code>Namespace</code> 是在 Terraform 仓库内注册的组织名，这代表了发布和维护插件的组织或是个人。<code>Type</code> 是代表插件的一个短名，在特定的 <code>HostName</code>/<code>Namespace</code> 下 <code>Type</code> 必须唯一。</p>
<p><code>required_providers</code> 中的插件声明还声明了该源码所需要的插件的版本约束，在例子里就是 <code>version = &quot;~&gt;5.0&quot;</code>。Terraform 插件的版本号采用 <code>MAJOR.MINOR.PATCH</code> 的语义化格式，版本约束通常使用操作符和版本号表达约束条件，条件之间可以用逗号拼接，表达 <code>AND</code> 关联，例如 <code>&quot;&gt;= 1.2.0, &lt; 2.0.0&quot;</code>。可以采用的操作符有：</p>
<ul>
<li><code>=</code>(或者不加 <code>=</code>，直接使用版本号)：只允许特定版本号，不允许与其他条件合并使用</li>
<li><code>!=</code>：不允许特定版本号</li>
<li><code>\&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>：与特定版本号进行比较，可以是大于、大于等于、小于、小于等于</li>
<li><code>~&gt;</code>：只允许 <em>最右边</em> 的版本号增加。这种格式被称为 <em>悲观约束</em> 操作符。例如，要允许在特定的 <code>MINOR</code> 版本中允许新的 <code>PATCH</code> 版本：
<ul>
<li><code>~&gt; 1.0.4</code>：允许 Terraform 安装 <code>1.0.5</code> 和 <code>1.0.10</code>，但不允许 <code>1.1.0</code>。</li>
<li><code>~&gt; 1.1</code>：允许 Terraform 安装 <code>1.2</code> 和 <code>1.10</code>，但不允许 <code>2.0</code>。</li>
</ul>
</li>
</ul>
<p>Terraform 会检查当前工作环境或是插件缓存中是否存在满足版本约束的插件，如果不存在，那么 Terraform 会尝试下载。如果 Terraform 无法获得任何满足版本约束条件的插件，那么它会拒绝继续执行任何后续操作。</p>
<p>可以用添加后缀的方式来声明预览版，例如：<code>1.2.0-beta</code>。预览版只能通过 <code>&quot;=&quot;</code> 操作符(或是忽略操作符)后接明确的版本号的方式来指定，不可以与<code>&gt;=</code>、<code>~&gt;</code>等搭配使用。</p>
<ul>
<li>当依赖第三方模块时，需要指定特定版本，以确保只在您需要的时候进行更新。</li>
<li>对于在您的组织内维护的模块，如果一致使用语义版本控制，或者有一个定义良好的发布流程可以避免不必要的更新，那么指定版本范围可能是合适的。</li>
<li>可重用的模块应仅限制其 Terraform 和 Provider 的最低允许版本，例如 <code>&gt;= 0.12.0</code>。这有助于避免已知的不兼容性，同时允许模块的用户在不改变模块的情况下升级到 Terraform 的新版本。</li>
<li>根模块应使用 <code>~&gt;</code> 约束为它们依赖的每个 Provider 设置一个下限和上限版本。</li>
</ul>
<p>以上建议来自于 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/expressions/version-constraints#best-practices">HashiCorp 官方文档</a>，笔者个人给出一条个人建议：</p>
<ul>
<li>可复用的模块不但应该限制 Provider 的最低版本，同时也应该限制 Provider 的 <code>MAJOR</code> 版本。例如，<code>&gt;= 1.5.0, &lt; 2.0</code>。这样可以避免在 Provider 的 <code>MAJOR</code> 版本升级时，因为不兼容性导致的问题，Provider 的 <code>MAJOR</code> 版本升级通常会伴随着不兼容的改动，不应该在未加测试的情况下轻易升级。</li>
</ul>
<h2 id="1-3-1-1-4-内建-Provider"><a href="#%E5%86%85%E5%BB%BA-provider"></a>1.3.1.1.4. 内建 Provider</h2>
<p>绝大多数 Provider 是以插件形式单独分发的，但是目前有一个 Provider 是内建于Terraform主进程中的，那就是 <code>terraform_remote_state</code> data source。该 Provider 由于是内建的，所以使用时不需要在 <code>terraform</code> 中声明 <code>required_providers</code>。这个内建Provider的源地址是 <code>terraform.io/builtin/terraform</code>。这个地址有时可能出现在 Terraform 的错误消息和其他输出中，以便无歧义地引用内建 Provider，而不是假设的第三方提供者，其类型名称为 “terraform”。</p>
<p>还存在一个源地址为 <code>hashicorp/terraform</code> 的 Provider，这是现在内置 Provider 的旧版本，被 Terraform 的旧版本使用。<code>hashicorp/terraform</code> 与 Terraform v0.11 或更高版本不兼容，因此永远不应在 <code>required_providers</code> 块中声明。</p>
<h2 id="1-3-1-1-5-Provider-的配置"><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"></a>1.3.1.1.5. Provider 的配置</h2>
<p>Provider 的配置是声明在根模块中的一组 Terraform 配置。（子模块接收来自于根模块的 Provider 配置，更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider">模块的 <code>provider</code> 元参数</a>）</p>
<p>一个 Provider 配置是通过 <code>provider</code> 块来创建的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;google&quot; &#123;</span><br><span class="line">  project = &quot;acme-app&quot;</span><br><span class="line">  region  = &quot;us-central1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块头部设置的名称（例子中的 <code>&quot;google&quot;</code>）就是要配置的 Provider 的<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/providers/requirements#local-names">Local Name</a>。这个 Provider 必须已在 <code>required_providers</code> 块中声明。</p>
<p>块体（<code>&#123;</code> 和 <code>&#125;</code> 中间的内容）包含了 Provider 的配置参数。这些参数大多数是由 Provider 自己定义的；在这个例子中，<code>project</code> 和 <code>region</code> 都是 <code>google</code> Provider 特有的。</p>
<p>你可以在这些配置的值当中使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/8.%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，但是只能引用在配置 Provider 时已知的值。这意味着你可以安全地引用输入变量，但是不能引用从 <code>resource</code> 返回的属性（一个例外是直接在配置中硬编码的 <code>resource</code> 参数）。</p>
<p>一个 Provider 的文档应该列出它所需要的配置参数。对那些注册在 <a target="_blank" rel="noopener" href="https://registry.terraform.io/">Terraform Registry</a> 上的 Provider 来说，每个 Provider 的页面上都有版本化的文档，可以通过 Provider 页头的 “Documentation” 链接访问。</p>
<p>一些 Provider 可以使用环境变量（或是其他替代配置源，例如 AWS 的虚拟机实例 Profile）作为某些配置参数的值；我们建议尽可能使用这种方式来避免将凭证保存于版本控制的 Terraform 代码中。</p>
<p>There are also two “meta-arguments” that are defined by Terraform itself and available for all <code>provider</code> blocks:</p>
<p>有两个由 Terraform 自身定义的“元参数”，对所有 <code>provider</code> 块都可用：</p>
<ul>
<li><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><code>alias</code>，用以为不同的 <code>resource</code> 块配置参数不同的同类 Provider 实例</a></li>
<li><code>version</code>， 废弃，不推荐使用，现在请使用 <a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><code>required_providers</code></a></li>
</ul>
<p>与 Terraform 语言中的许多其他对象不同，如果 <code>provider</code> 块的内容为空，则可以省略该块。Terraform 假定未显式配置的任何 Provider 程序都具有空的默认配置。</p>
<h2 id="1-3-1-1-6-多-Provider-实例"><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"></a>1.3.1.1.6. 多 Provider 实例</h2>
<p><code>provider</code> 块声明了 <code>aws</code> 这个 Provider 所需要的各项配置。在上文的代码示例中，<code>provider &quot;aws&quot;</code>和<code>required_providers</code>中<code>aws = &#123;...&#125;</code>块里的<code>aws</code>，都是 Provider 的 Local Name，一个 Local Name 是在一个模块中对一个 Provider 的唯一的标识。</p>
<p>你可以选择为同一个 Provider 定义多个配置，并且可以根据每个资源或每个模块来选择使用哪一个。这主要是为了支持云平台的多个区域；其他例子包括针对多个 Docker 主机，多个 Consul 主机等。</p>
<p>要为某一个 Provider 创建多个配置，包括具有相同提供者名称的多个 <code>provider</code> 块。对于每个额外的非默认配置，使用 <code>alias</code> 元参数提供额外的名称段。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># The default provider configuration; resources that begin with `aws_` will use</span><br><span class="line"># it as the default, and it can be referenced as `aws`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Additional provider configuration for west coast region; resources can</span><br><span class="line"># reference this as `aws.west`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;west&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模块内声明配置 <code>alias</code> 以从父模块接收备用的 <code>provider</code> 配置，需要在该 <code>provider</code> 的 <code>required_providers</code> 条目中添加 <code>configuration_aliases</code> 参数。以下示例在包含的模块中声明了 <code>mycloud</code> 和 <code>mycloud.alternate</code> 的 <code>provider</code> 配置名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    mycloud = &#123;</span><br><span class="line">      source  = &quot;mycorp/mycloud&quot;</span><br><span class="line">      version = &quot;~&gt; 1.0&quot;</span><br><span class="line">      configuration_aliases = [ mycloud.alternate ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1-1-6-1-默认-Provider-配置"><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.1. 默认 Provider 配置</h3>
<p>没有 <code>alias</code> 参数的 <code>provider</code> 块是该 provider 的 <em>默认</em> 配置。未设置 <code>provider</code> 元参数的资源将使用与资源类型名称的第一个单词匹配的默认 provider 配置。（例如，除非另有说明，否则 <code>aws_instance</code> 资源将使用默认的 <code>aws</code> provider 配置。）</p>
<p>如果 provider 的每个显式配置都有别名，Terraform 将使用隐含的空配置作为该 provider 的默认配置。（如果 provider 有任何必需的配置参数，当资源默认使用空配置时，Terraform 将引发错误。）</p>
<h3 id="1-3-1-1-6-2-引用备用-Provider-配置"><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.2. 引用备用 Provider 配置</h3>
<p>当 Terraform 需要 provider 配置的名称时，它期望的是 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 形式的引用。在上面的例子中，<code>aws.west</code> 将引用 <code>us-west-2</code> 区域的 provider。</p>
<p>这些引用是特殊的表达式。像对其他命名实体（例如 <code>var.image_id</code>）的引用一样，它们不是字符串，不需要引号。但是它们只在 <code>resource</code>、<code>data</code> 和 <code>module</code> 块的特定元参数中有效，不能在任意表达式中使用。</p>
<h3 id="1-3-1-1-6-3-选择备用-Provider-配置"><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.3. 选择备用 Provider 配置</h3>
<p>默认情况下，资源使用从资源类型名称的第一个单词推断出的默认 provider 配置（没有 <code>alias</code> 参数的配置）。</p>
<p>要为资源或数据源指定备用 provider 配置，将其 <code>provider</code> 元参数设置为 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;foo&quot; &#123;</span><br><span class="line">  provider = aws.west</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要为子模块指定备用 provider 配置，使用其 <code>providers</code> 元参数指定应将哪些 provider 配置映射到模块内的哪些本地 provider 名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module &quot;aws_vpc&quot; &#123;</span><br><span class="line">  source = &quot;./aws_vpc&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws = aws.west</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在传递 provider 时，模块有一些特殊要求；有关更多详细信息，请参见 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html#module-providers">模块 <code>providers</code> 元参数</a>。在大多数情况下，只有 <em>根模块</em> 应定义 provider 配置，所有子模块都应从其父模块获取其 provider 配置。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../2023/01/17/Teraform/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 頁 共 1 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 210 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
