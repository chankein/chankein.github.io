
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>所有文章: 2023 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://chankein.github.io/archives/2023/page/2/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://chankein.github.io../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/"
                            aria-label=": Terraform-模块"
                        >
                            Terraform-模块
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-23T17:43:45+08:00">
	
		    2023 年 1 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/devops/">devops</a>, <a class="category-link" href="../../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#terraform%E6%A8%A1%E5%9D%97"><strong>1.6.1.</strong> Terraform模块</a></li>
</ul>
<p><a href="#terraform%E6%A8%A1%E5%9D%97"></a></p>
<h2 id="1-6-1-Terraform模块"><a href="#terraform%E6%A8%A1%E5%9D%97"></a>1.6.1. Terraform模块</h2>
<p>到目前为止我们介绍了一些代码书写的知识，但我们创建的所有资源和数据源的代码都是我们在代码文件中编写出来的。我们有没有办法不通过复制粘贴代码从而直接使用别人编写好的 Terraform 代码来创建一组资源呢？</p>
<p>Terraform 对此给出的答案就是模块 (<a target="_blank" rel="noopener" href="https://www.terraform.io/docs/modules/index.html">Module</a>)。简单来讲模块就是包含一组 Terraform 代码的文件夹，我们之前篇章中编写的代码实际上也是在模块中。要想真正理解模块的功能，我们需要去体验一下模块的使用。</p>
<p>Terraform 模块是编写高质量 Terraform 代码，提升代码复用性的重要手段，可以说，一个成熟的生产环境应该是由数个可信成熟的模块组装而成的。我们将在本章介绍关于模块的知识。</p>
<ul>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"><strong>1.6.1.1.</strong> 创建模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><strong>1.6.1.1.1.</strong> 模块结构</a></p>
</li>
<li>
<p><a href="#%E9%81%BF%E5%85%8D%E8%BF%87%E6%B7%B1%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><strong>1.6.1.1.2.</strong> 避免过深的模块结构</a></p>
</li>
</ul>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"></a></p>
<h2 id="1-6-1-1-创建模块"><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97"></a>1.6.1.1. 创建模块</h2>
<p>实际上所有包含 Terraform 代码文件的文件夹都是一个 Terraform 模块。我们如果直接在一个文件夹内执行 <code>terraform apply</code> 或者 <code>terraform plan</code> 命令，那么当前所在的文件夹就被称为根模块(root module)。我们也可以在执行 Terraform 命令时通过命令行参数指定根模块的路径。</p>
<h2 id="1-6-1-1-1-模块结构"><a href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"></a>1.6.1.1.1. 模块结构</h2>
<p>旨在被重用的模块与我们编写的根模块使用的是相同的 Terraform 代码和代码风格规范。一般来讲，在一个模块中，会有：</p>
<ul>
<li>一个 <code>README</code> 文件，用来描述模块的用途。文件名可以是 <code>README</code> 或者 <code>README.md</code>，后者应采用 Markdown 语法编写。可以考虑在 <code>README</code> 中用可视化的图形来描绘创建的基础设施资源以及它们之间的关系。<code>README</code> 中不需要描述模块的输入输出，因为工具会自动收集相关信息。如果在 <code>README</code> 中引用了外部文件或图片，请确保使用的是带有特定版本号的绝对 URL 路径以防止未来指向错误的版本</li>
<li>一个 <code>LICENSE</code> 描述模块使用的许可协议。如果你想要公开发布一个模块，最好考虑包含一个明确的许可证协议文件，许多组织不会使用没有明确许可证协议的模块</li>
<li>一个 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/terraform-aws-consul/tree/master/examples">examples 文件夹</a>用来给出一个调用样例(可选)</li>
<li>一个 <code>variables.tf</code> 文件，包含模块所有的输入变量。输入变量应该有明确的描述说明用途</li>
<li>一个 <code>outputs.tf</code> 文件，包含模块所有的输出值。输出值应该有明确的描述说明用途</li>
<li>嵌入模块文件夹，出于封装复杂性或是复用代码的目的，我们可以在 modules 子目录下建立一些嵌入模块。所有包含 README 文件的嵌入模块都可以被外部用户使用；不含 <code>README</code> 文件的模块被认为是仅在当前模块内使用的(可选)</li>
<li>一个 <code>main.tf</code>，它是模块主要的入口点。对于一个简单的模块来说，可以把所有资源都定义在里面；如果是一个比较复杂的模块，我们可以把创建的资源分布到不同的代码文件中，但引用嵌入模块的代码还是应保留在 <code>main.tf</code> 里</li>
<li>其他定义了各种基础设施对象的代码文件(可选)</li>
</ul>
<p>如果模块含有多个嵌入模块，那么应避免它们彼此之间的引用，由根模块负责组合它们。</p>
<p>由于 <code>examples/</code> 的代码经常会被拷贝到其他项目中进行修改，所有在 <code>examples/</code> 代码中引用本模块时使用的引用路径应使用外部调用者可以使用的路径，而非相对路径。</p>
<p>一个最小化模块推荐的结构是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tree minimal-module/</span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">├── outputs.tf</span><br></pre></td></tr></table></figure>
<p>一个更完整一些的模块结构可以是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ tree complete-module/</span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── main.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">├── outputs.tf</span><br><span class="line">├── ...</span><br><span class="line">├── modules/</span><br><span class="line">│   ├── nestedA/</span><br><span class="line">│   │   ├── README.md</span><br><span class="line">│   │   ├── variables.tf</span><br><span class="line">│   │   ├── main.tf</span><br><span class="line">│   │   ├── outputs.tf</span><br><span class="line">│   ├── nestedB/</span><br><span class="line">│   ├── .../</span><br><span class="line">├── examples/</span><br><span class="line">│   ├── exampleA/</span><br><span class="line">│   │   ├── main.tf</span><br><span class="line">│   ├── exampleB/</span><br><span class="line">│   ├── .../</span><br></pre></td></tr></table></figure>
<h2 id="1-6-1-1-2-避免过深的模块结构"><a href="#%E9%81%BF%E5%85%8D%E8%BF%87%E6%B7%B1%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"></a>1.6.1.1.2. 避免过深的模块结构</h2>
<p>我们刚才提到可以在 <code>modules/</code> 子目录下创建嵌入模块。Terraform 倡导&quot;扁平&quot;的模块结构，只应保持一层嵌入模块，防止在嵌入模块中继续创建嵌入模块。应将嵌入模块设计成易于组合的结构，使得在根模块中可以通过组合各个嵌入模块创建复杂的基础设施。</p>
<ul>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.</strong> 引用模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E6%BA%90"><strong>1.6.2.1.1.</strong> 模块源</a></p>
</li>
<li>
<p><a href="#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84"><strong>1.6.2.1.1.1.</strong> 本地路径</a></p>
</li>
<li>
<p><a href="#terraform-registry"><strong>1.6.2.1.1.2.</strong> Terraform Registry</a></p>
</li>
<li>
<p><a href="#github"><strong>1.6.2.1.1.3.</strong> GitHub</a></p>
</li>
<li>
<p><a href="#bitbucket"><strong>1.6.2.1.1.4.</strong> Bitbucket</a></p>
</li>
<li>
<p><a href="#%E9%80%9A%E7%94%A8-git-%E4%BB%93%E5%BA%93"><strong>1.6.2.1.1.5.</strong> 通用 Git 仓库</a></p>
</li>
<li>
<p><a href="#%E9%80%9A%E7%94%A8-mercurial-%E4%BB%93%E5%BA%93"><strong>1.6.2.1.1.6.</strong> 通用 Mercurial 仓库</a></p>
</li>
<li>
<p><a href="#http-%E5%9C%B0%E5%9D%80"><strong>1.6.2.1.1.7.</strong> HTTP 地址</a></p>
</li>
<li>
<p><a href="#s3-bucket"><strong>1.6.2.1.1.8.</strong> S3 Bucket</a></p>
</li>
<li>
<p><a href="#gcs-bucket"><strong>1.6.2.1.1.9.</strong> GCS Bucket</a></p>
</li>
<li>
<p><a href="#%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.2.</strong> 直接引用子文件夹中的模块</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.3.</strong> 使用模块</a></p>
</li>
<li>
<p><a href="#%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E5%80%BC"><strong>1.6.2.1.4.</strong> 访问模块输出值</a></p>
</li>
<li>
<p><a href="#%E5%85%B6%E4%BB%96%E7%9A%84%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.6.2.1.5.</strong> 其他的模块元参数</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F"><strong>1.6.2.1.6.</strong> 模块版本约束</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97"><strong>1.6.2.1.7.</strong> 多实例模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider"><strong>1.6.2.1.8.</strong> 模块内的 Provider</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6"><strong>1.6.2.1.9.</strong> 模块内的 Provider 版本限制</a></p>
</li>
<li>
<p><a href="#%E9%9A%90%E5%BC%8F-provider-%E7%BB%A7%E6%89%BF"><strong>1.6.2.1.10.</strong> 隐式 Provider 继承</a></p>
</li>
<li>
<p><a href="#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider"><strong>1.6.2.1.11.</strong> 显式传递 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E5%9D%97"><strong>1.6.2.1.12.</strong> Provider 代理配置块</a></p>
</li>
</ul>
<p><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97"></a></p>
<h2 id="1-6-2-1-引用模块"><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97"></a>1.6.2.1. 引用模块</h2>
<p>在 Terraform 代码中引用一个模块，使用的是 <code>module</code> 块。</p>
<p>每当在代码中新增、删除或者修改一个 <code>module</code> 块之后，都要执行 <code>terraform init</code> 或是 <code>terraform get</code> 命令来获取模块代码并安装到本地磁盘上。</p>
<h2 id="1-6-2-1-1-模块源"><a href="#%E6%A8%A1%E5%9D%97%E6%BA%90"></a>1.6.2.1.1. 模块源</h2>
<p><code>module</code> 块定义了一个 <code>source</code> 参数，指定了模块的源；Terraform 目前支持如下模块源：</p>
<ul>
<li>本地路径</li>
<li>Terraform Registry</li>
<li>GitHub</li>
<li>Bitbucket</li>
<li>通用Git、Mercurial仓库</li>
<li>HTTP地址</li>
<li>S3 buckets</li>
<li>GCS buckets</li>
</ul>
<p>我们后面会一一讲解这些模块源的使用。<code>source</code> 使用的是 URL 风格的参数，但某些源支持在 <code>source</code> 参数中通过额外参数指定模块版本。</p>
<p>出于消除重复代码的目的我们可以重构我们的根模块代码，将一些拥有重复模式的代码重构为可反复调用的嵌入模块，通过本地路径来引用。</p>
<p>许多的模块源类型都支持从当前系统环境中读取认证信息，例如环境变量或系统配置文件。我们在介绍模块源的时候会介绍到这方面的信息。</p>
<p>我们建议每个模块把期待被重用的基础设施声明在各自的根模块位置上，但是直接引用其他模块的嵌入模块也是可行的。</p>
<h3 id="1-6-2-1-1-1-本地路径"><a href="#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84"></a>1.6.2.1.1.1. 本地路径</h3>
<p>使用本地路径可以使我们引用同一项目内定义的子模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;./consul&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个本地路径必须以 <code>./</code> 或者 <code>../</code> 为前缀来标明要使用的本地路径，以区别于使用 Terraform Registry 路径。</p>
<p>本地路径引用模块和其他源类型有一个区别，本地路径引用的模块不需要下载相关源代码，代码已经存在于本地相关路径的磁盘上了。</p>
<h3 id="1-6-2-1-1-2-Terraform-Registry"><a href="#terraform-registry"></a>1.6.2.1.1.2. Terraform Registry</h3>
<p>Registry 目前是 Terraform 官方力推的模块仓库方案，采用了 Terraform 定制的协议，支持版本化管理和使用模块。</p>
<p>官方提供的<a target="_blank" rel="noopener" href="https://registry.terraform.io/">公共仓库</a>保存和索引了大量公共模块，在这里可以很容易地搜索到各种官方和社区提供的高质量模块。</p>
<p>读者也可以通过 Terraform Cloud 服务维护一个私有模块仓库，或是通过实现 <a target="_blank" rel="noopener" href="https://www.terraform.io/docs/registry/api.html">Terraform 模块注册协议</a>来实现一个私有仓库。</p>
<p>公共仓库的的模块可以用 <code>&lt;NAMESPACE&gt;/&lt;NAME&gt;/&lt;PROVIDER&gt;</code> 形式的源地址来引用，在公共仓库上的模块介绍页面上都包含了确切的源地址，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;hashicorp/consul/aws&quot;</span><br><span class="line">  version = &quot;0.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于那些托管在其他仓库的模块，在源地址头部添加 <code>&lt;HOSTNAME&gt;/</code> 部分，指定私有仓库的主机名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;app.terraform.io/example-corp/k8s-cluster/azurerm&quot;</span><br><span class="line">  version = &quot;1.1.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用的是 SaaS 版本的 Terraform Cloud，那么托管在上面的私有仓库的主机名是 <code>app.terraform.io</code>。如果使用的是私有部署的 Terraform 企业版，那么托管在上面的私有仓库的主机名就是 Terraform 企业版服务的主机名。</p>
<p>模块仓库支持版本化。你可以在 <code>module</code> 块中指定模块的版本约束。</p>
<p>如果要引用私有仓库的模块，你需要首先通过配置命令行工具配置文件来设置访问凭证。</p>
<h3 id="1-6-2-1-1-3-GitHub"><a href="#github"></a>1.6.2.1.1.3. GitHub</h3>
<p>Terraform 发现 <code>source</code> 参数的值如果是以 <code>github.com</code> 为前缀时，会将其自动识别为一个 GitHub 源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;github.com/hashicorp/example&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子里会自动使用 HTTPS 协议克隆仓库。如果要使用 SSH 协议，那么请使用如下的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;git@github.com:hashicorp/example.git&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GitHub 源的处理与后面要介绍的通用 Git 仓库是一样的，所以他们获取 git 凭证和通过 <code>ref</code> 参数引用特定版本的方式都是一样的。如果要访问私有仓库，你需要额外配置 git 凭证。</p>
<h3 id="1-6-2-1-1-4-Bitbucket"><a href="#bitbucket"></a>1.6.2.1.1.4. Bitbucket</h3>
<p>Terraform 发现 <code>source</code> 参数的值如果是以 <code>bitbucket.org</code> 为前缀时，会将其自动识别为一个 Bitbucket 源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;bitbucket.org/hashicorp/terraform-consul-aws&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种捷径方法只针对公共仓库有效，因为 Terraform 必须访问 ButBucket API 来了解仓库使用的是 Git 还是 Mercurial 协议。</p>
<p>Terraform 根据仓库的类型来决定将它作为一个 Git 仓库还是 Mercurial 仓库来处理。后面的章节会介绍如何为访问仓库配置访问凭证以及指定要使用的版本号。</p>
<h3 id="1-6-2-1-1-5-通用-Git-仓库"><a href="#%E9%80%9A%E7%94%A8-git-%E4%BB%93%E5%BA%93"></a>1.6.2.1.1.5. 通用 Git 仓库</h3>
<p>可以通过在地址开头加上特殊的 <code>git::</code> 前缀来指定使用任意的 Git 仓库。在前缀后跟随的是一个合法的 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a">Git URL</a>。</p>
<p>使用 HTTPS 和 SSH 协议的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;git::https://example.com/vpc.git&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;storage&quot; &#123;</span><br><span class="line">  source = &quot;git::ssh://username@example.com/storage.git&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 使用 <code>git clone</code> 命令安装模块代码，所以 Terraform 会使用本地 Git 系统配置，包括访问凭证。要访问私有 Git 仓库，必须先配置相应的凭证。</p>
<p>如果使用了 SSH 协议，那么会自动使用系统配置的 SSH 证书。通常情况下我们通过这种方法访问私有仓库，因为这样可以不需要交互式提示就可以访问私有仓库。</p>
<p>如果使用 HTTP/HTTPS 协议，或是其他需要用户名、密码作为凭据，你需要配置 <a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage">Git 凭据存储</a>来选择一个合适的凭据源。</p>
<p>默认情况下，Terraform 会克隆默认分支。可以通过 <code>ref</code> 参数来指定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;git::https://example.com/vpc.git?ref=v1.2.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ref 参数会被用作 git checkout 命令的参数，可以是分支名或是 tag 名。</p>
<p>使用 SSH 协议时，我们更推荐 <code>ssh://</code> 的地址。你也可以选择 scp 风格的语法，故意忽略 <code>ssh://</code> 的部分，只留 <code>git::</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;storage&quot; &#123;</span><br><span class="line">  source = &quot;git::username@example.com:storage.git&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-1-1-6-通用-Mercurial-仓库"><a href="#%E9%80%9A%E7%94%A8-mercurial-%E4%BB%93%E5%BA%93"></a>1.6.2.1.1.6. 通用 Mercurial 仓库</h3>
<p>可以通过在地址开头加上特殊的 <code>hg::</code> 前缀来指定使用任意的 Mercurial 仓库。在前缀后跟随的是一个合法的 <a target="_blank" rel="noopener" href="https://www.mercurial-scm.org/repo/hg/help/urls">Mercurial URL</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;hg::http://example.com/vpc.hg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 会通过运行 <code>hg clone</code> 命令从 Mercurial 仓库安装模块代码，所以 Terraform 会使用本地 Mercurial 系统配置，包括访问凭证。要访问私有 Mercurial 仓库，必须先配置相应的凭证。</p>
<p>如果使用了 SSH 协议，那么会自动使用系统配置的 SSH 证书。通常情况下我们通过这种方法访问私有仓库，因为这样可以不需要交互式提示就可以访问私有仓库。</p>
<p>类似 Git 源，我们可以通过 <code>ref</code> 参数指定非默认的分支或者标签来选择特定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;hg::http://example.com/vpc.hg?ref=v1.2.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-1-1-7-HTTP-地址"><a href="#http-%E5%9C%B0%E5%9D%80"></a>1.6.2.1.1.7. HTTP 地址</h3>
<p>当我们使用 HTTP 或 HTTPS 地址时，Terraform 会向指定 URL 发送一个 GET 请求，期待返回另一个源地址。这种间接的方法使得 HTTP 可以成为一个更复杂的模块源地址的指示器。</p>
<p>然后 Terraform 会再发送一个 GET 请求到之前响应的地址上，并附加一个查询参数 <code>terraform-get=1</code>，这样服务器可以选择当 Terraform 来查询时可以返回一个不一样的地址。</p>
<p>如果相应的状态码是成功的(200 范围的成功状态码)，Terraform 就会通过以下位置来获取下一个访问地址：</p>
<ul>
<li>响应头部的 <code>X-Terraform-Get</code> 值</li>
<li>如果响应内容是一个 HTML 页面，那么会检查名为 <code>terraform-get</code> 的 html meta 元素：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;terraform-get&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;github.com/hashicorp/example&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>不管用哪种方式返回的地址，Terraform 都会像本章提到的其他的源地址那样处理它。</p>
<p>如果 HTTP/HTTPS 地址需要认证凭证，可以在 HOME 文件夹下配置一个 <code>.netrc</code> 文件，详见<a target="_blank" rel="noopener" href="https://ec.haxx.se/usingcurl-netrc.html">相关文档</a></p>
<p>也有一种特殊情况，如果 Terraform 发现地址有着一个常见的存档文件的后缀名，那么 Terraform 会跳过 <code>terraform-get=1</code> 重定向的步骤，直接将响应内容作为模块代码使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;https://example.com/vpc-module.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前支持的后缀名有：</p>
<ul>
<li><code>zip</code></li>
<li><code>tar.bz2</code>和<code>tbz2</code></li>
<li><code>tar.gz</code>和<code>tgz</code></li>
<li><code>tar.xz</code>和<code>txz</code></li>
</ul>
<p>如果 HTTP 地址不以这些文件名结尾，但又的确指向模块存档文件，那么可以使用 <code>archive</code> 参数来强制按照这种行为处理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;vpc&quot; &#123;</span><br><span class="line">  source = &quot;https://example.com/vpc-module?archive=zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-1-1-8-S3-Bucket"><a href="#s3-bucket"></a>1.6.2.1.1.8. S3 Bucket</h3>
<p>你可以把模块存档保存在 AWS S3 桶里，使用 <code>s3::</code> 作为地址前缀，后面跟随一个 <a target="_blank" rel="noopener" href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro">S3 对象访问地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/vpc.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 识别到 <code>s3::</code> 前缀后会使用 AWS 风格的认证机制访问给定地址。这使得这种源地址也可以搭配其他提供了 S3 协议兼容的对象存储服务使用，只要他们的认证方式与 AWS 相同即可。</p>
<p>保存在 S3 桶内的模块存档文件格式必须与上面 HTTP 源提到的支持的格式相同，Terraform 会下载并解压缩模块代码。</p>
<p>模块安装器会从以下位置寻找AWS凭证，按照优先级顺序排列：</p>
<ul>
<li><code>AWS_ACCESS_KEY_ID</code> 和 <code>AWS_SECRET_ACCESS_KEY</code> 环境变量</li>
<li>HOME 目录下 <code>.aws/credentials</code> 文件内的默认 profile</li>
<li>如果是在 AWS EC2 主机内运行的，那么会尝试使用搭载的 IAM 主机实例配置。</li>
</ul>
<h3 id="1-6-2-1-1-9-GCS-Bucket"><a href="#gcs-bucket"></a>1.6.2.1.1.9. GCS Bucket</h3>
<p>你可以把模块存档保存在谷歌云 GCS 储桶里，使用 <code>gcs::</code> 作为地址前缀，后面跟随一个 <a target="_blank" rel="noopener" href="https://cloud.google.com/storage/docs/request-endpoints#typical">GCS 对象访问地址</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source = &quot;gcs::https://www.googleapis.com/storage/v1/modules/foomodule.zip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块安装器会使用谷歌云 SDK 的凭据来访问 GCS。要设置凭据，你可以：</p>
<ul>
<li>通过 <code>GOOGLE_APPLICATION_CREDENTIALS</code> 环境变量配置服务账号的密钥文件</li>
<li>如果是在谷歌云主机上运行的 Terraform，可以使用默认凭据。访问<a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/authentication">相关文档</a>获取完整信息</li>
<li>可以使用命令行 <code>gcloud auth application-default login</code> 设置</li>
</ul>
<h2 id="1-6-2-1-2-直接引用子文件夹中的模块"><a href="#%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"></a>1.6.2.1.2. 直接引用子文件夹中的模块</h2>
<p>引用版本控制系统或是对象存储服务中的模块时，模块本身可能存在于存档文件的一个子文件夹内。我们可以使用特殊的 <code>//</code> 语法来指定 Terraform 使用存档内特定路径作为模块代码所在位置，例如：</p>
<ul>
<li><code>hashicorp/consul/aws//modules/consul-cluster</code></li>
<li><code>git::https://example.com/network.git//modules/vpc</code></li>
<li><code>https://example.com/network-module.zip//modules/vpc</code></li>
<li><code>s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/network.zip//modules/vpc</code></li>
</ul>
<p>如果源地址中包含又参数，例如指定特定版本号的 <code>ref</code> 参数，那么把子文件夹路径放在参数之前：</p>
<ul>
<li><code>git::https://example.com/network.git//modules/vpc?ref=v1.2.0</code></li>
</ul>
<p>Terraform 会解压缩整个存档文件后，读取特定子文件夹。所以，对于一个存在于子文件夹中的模块来说，通过本地路径引用同一个存档内的另一个模块是安全的。</p>
<h2 id="1-6-2-1-3-使用模块"><a href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"></a>1.6.2.1.3. 使用模块</h2>
<p>我们刚才介绍了如何用 <code>source</code> 指定模块源，下面我们继续讲解如何在代码中使用一个模块。</p>
<p>我们可以把模块理解成类似函数，如同函数有输入参数表和输出值一样，我们之前介绍过 Terraform 代码有输入变量和输出值。我们在 <code>module</code> 块的块体内除了 <code>source</code> 参数，还可以对该模块的输入变量赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &quot;servers&quot; &#123;</span><br><span class="line">  source = &quot;./app-cluster&quot;</span><br><span class="line"></span><br><span class="line">  servers = 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子里，我们将会创建 <code>./app-cluster</code> 文件夹下 Terraform 声明的一系列资源，该模块的 <code>servers</code> 输入变量的值被我们设定成了5。</p>
<p>在代码中新增、删除或是修改一个某块的 <code>source</code>，都需要重新运行 <code>terraform init</code> 命令。默认情况下，该命令不会升级已安装的模块(例如 <code>source</code> 未指定版本，过去安装了旧版本模块代码，那么执行 <code>terraform init</code> 不会自动更新到新版本)；可以执行 <code>terraform init -upgrade</code> 来强制更新到最新版本模块。</p>
<h2 id="1-6-2-1-4-访问模块输出值"><a href="#%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E5%80%BC"></a>1.6.2.1.4. 访问模块输出值</h2>
<p>在模块中定义的资源和数据源都是被封装的，所以模块调用者无法直接访问它们的输出属性。然而，模块可以声明一系列输出值，来选择性地输出特定的数据供模块调用者使用。</p>
<p>举例来说，如果 <code>./app-cluster</code> 模块定义了名为 <code>instance_ids</code> 的输出值，那么模块的调用者可以像这样引用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_elb&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  instances = module.servers.instance_ids</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-2-1-5-其他的模块元参数"><a href="#%E5%85%B6%E4%BB%96%E7%9A%84%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"></a>1.6.2.1.5. 其他的模块元参数</h2>
<p>除了 <code>source</code> 以外，目前 Terraform 还支持在 <code>module</code> 块上声明其他一些可选元参数：</p>
<ul>
<li><code>version</code>：指定引用的模块版本，在后面的部分会详细介绍</li>
<li><code>count</code> 和 <code>for_each</code>：这是 Terraform 0.13 开始支持的特性，类似 <code>resource</code> 与 <code>data</code>，我们可以创建多个 <code>module</code> 实例</li>
<li><code>providers</code>：通过传入一个 <code>map</code> 我们可以指定模块中的 Provider 配置，我们将在后面详细介绍</li>
<li><code>depends_on</code>：创建整个模块和其他资源之间的显式依赖。直到依赖项创建完毕，否则声明了依赖的模块内部所有的资源及内嵌的模块资源都会被推迟处理。模块的依赖行为与资源的依赖行为相同</li>
</ul>
<p>除了上述元参数以外，<code>lifecycle</code> 参数目前还不能被用于模块，但关键字被保留以便将来实现。</p>
<h2 id="1-6-2-1-6-模块版本约束"><a href="#%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F"></a>1.6.2.1.6. 模块版本约束</h2>
<p>使用 registry 作为模块源时，可以使用 <code>version</code> 元参数约束使用的模块版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module &quot;consul&quot; &#123;</span><br><span class="line">  source  = &quot;hashicorp/consul/aws&quot;</span><br><span class="line">  version = &quot;0.0.5&quot;</span><br><span class="line"></span><br><span class="line">  servers = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>version</code> 元参数的格式与 Provider 版本约束的格式一致。在满足版本约束的前提下，Terraform 会使用当前已安装的最新版本的模块实例。如果当前没有满足约束的版本被安装过，那么会下载符合约束的最新的版本。</p>
<p><code>version</code> 元参数只能配合 registry 使用，<a target="_blank" rel="noopener" href="https://registry.terraform.io/">公共</a>的或者<a target="_blank" rel="noopener" href="https://www.terraform.io/docs/cloud/registry/index.html">私有</a>的模块仓库都可以。其他类型的模块源可能支持版本化，也可能不支持。本地路径模块不支持版本化。</p>
<h2 id="1-6-2-1-7-多实例模块"><a href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%9D%97"></a>1.6.2.1.7. 多实例模块</h2>
<p>可以通过在 <code>module</code> 块上声明 <code>for_each</code> 或者 <code>count</code> 来创造多实例模块。在使用上 <code>module</code> 上的 <code>for_each</code> 和 <code>count</code> 与资源、数据源块上的使用是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># my_buckets.tf</span><br><span class="line">module &quot;bucket&quot; &#123;</span><br><span class="line">  for_each = toset([&quot;assets&quot;, &quot;media&quot;])</span><br><span class="line">  source   = &quot;./publish_bucket&quot;</span><br><span class="line">  name     = &quot;$&#123;each.key&#125;_bucket&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># publish_bucket/bucket-and-cloudfront.tf</span><br><span class="line">variable &quot;name&quot; &#123;&#125; # this is the input parameter of the module</span><br><span class="line"></span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;example&quot; &#123;</span><br><span class="line">  # Because var.name includes each.key in the calling</span><br><span class="line">  # module block, its value will be different for</span><br><span class="line">  # each instance of this module.</span><br><span class="line">  bucket = var.name</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_user&quot; &quot;deploy_user&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个位于 <code>./publish_bucket</code> 目录下的本地子模块，模块创建了一个 S3 存储桶，封装了桶的信息以及其他实现细节。</p>
<p>我们通过 <code>for_each</code> 参数声明了模块的多个实例，传入一个 <code>map</code> 或是 <code>set</code> 作为参数值。另外，因为我们使用了 <code>for_each</code>，所以在 <code>module</code> 块里可以使用 <code>each</code> 对象，例子里我们使用了 <code>each.key</code>。如果我们使用的是 <code>count</code> 参数，那么我们可以使用 <code>count.index</code>。</p>
<p>子模块里创建的资源在执行计划或UI中的名称会以 <code>module.module_name[module index]</code> 作为前缀。如果一个模块没有声明 <code>count</code> 或者 <code>for_each</code>，那么资源地址将不包含 module index。</p>
<p>在上面的例子里，<code>./publish_bucket</code> 模块包含了 <code>aws_s3_bucket.example</code> 资源，所以两个 S3 桶实例的名字分别是<code>module.bucket[&quot;assets&quot;].aws_s3_bucket.example</code> 以及 <code>module.bucket[&quot;media&quot;].aws_s3_bucket.example</code>。</p>
<h2 id="1-6-2-1-8-模块内的-Provider"><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider"></a>1.6.2.1.8. 模块内的 Provider</h2>
<p>当代码中声明了多个模块时，资源如何与 Provider 实例关联就需要特殊考虑。</p>
<p>每一个资源都必须关联一个 Provider 配置。不像 Terraform 其他的概念，Provider 配置在 Terraform 项目中是全局的，可以跨模块共享。Provider 配置声明只能放在根模块中。</p>
<p>Provider 有两种方式传递给子模块：隐式继承，或是显式通过 <code>module</code> 块的 <code>providers</code> 参数传递。</p>
<p>一个旨在被复用的模块不允许声明任何 <code>provider</code> 块，只有使用&quot;代理 Provider&quot;模式的情况除外，我们后面会介绍这种模式。</p>
<p>出于向前兼容 Terraform 0.10 及更早版本的考虑，Terraform 目前在模块代码中只用到了 Terraform 0.10 及更早版本的功能时，不会针对模块代码中声明 <code>provider</code> 块报错，但这是一个不被推荐的遗留模式。一个含有自己的 <code>provider</code> 块定义的遗留模块与 <code>for_each</code>、<code>count</code> 和 <code>depends_on</code> 等 0.13 引入的新特性是不兼容的。</p>
<p>Provider 配置被用于相关资源的所有操作，包括销毁远程资源对象以及更新状态信息等。Terraform 会在状态文件中保存针对最近用来执行所有资源变更的 Provider 配置的引用。当一个 <code>resource</code> 块被删除时，状态文件中的相关记录会被用来定位到相应的配置，因为原来包含 <code>provider</code> 参数(如果声明了的话)的 <code>resource</code> 块已经不存在了。</p>
<p>这导致了，你必须确保删除所有相关的资源配置定义以后才能删除一个 Provider 配置。如果 Terraform 发现状态文件中记录的某个资源对应的 Provider 配置已经不存在了会报错，要求你重新给出相关的 Provider 配置。</p>
<h2 id="1-6-2-1-9-模块内的-Provider-版本限制"><a href="#%E6%A8%A1%E5%9D%97%E5%86%85%E7%9A%84-provider-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6"></a>1.6.2.1.9. 模块内的 Provider 版本限制</h2>
<p>虽然 Provider 配置信息在模块间共享，每个模块还是得声明各自的模块需求，这样 Terraform 才能决定一个适用于所有模块配置的 Provider 版本。</p>
<p>为了定义这样的版本约束要求，可以在 <code>terraform</code> 块中使用 <code>required_providers</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source  = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;&gt;= 2.7.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关 Provider 的 <code>source</code> 和版本约束的信息我们已经在前文中有所记述，在此不再赘述。</p>
<h2 id="1-6-2-1-10-隐式-Provider-继承"><a href="#%E9%9A%90%E5%BC%8F-provider-%E7%BB%A7%E6%89%BF"></a>1.6.2.1.10. 隐式 Provider 继承</h2>
<p>为了方便，在一些简单的代码中，一个子模块会从调用者那里自动地继承默认的 Provider 配置。这意味着显式 <code>provider</code> 块声明仅位于根模块中，并且下游子模块可以简单地声明使用该类型 Provider 的资源，这些资源会自动关联到根模块的 Provider 配置上。</p>
<p>例如，根模块可能只含有一个 <code>provider</code> 块和一个 <code>module</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-west-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;child&quot; &#123;</span><br><span class="line">  source = &quot;./child&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子模块可以声明任意关联 <code>aws</code> 类型 Provider 的资源而无需额外声明 Provider 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_s3_bucket&quot; &quot;example&quot; &#123;</span><br><span class="line">  bucket = &quot;provider-inherit-example&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当每种类型的 Provider 都只有一个实例时我们推荐使用这种方式。</p>
<p>要注意的是，只有 Provider 配置会被子模块继承，Provider 的 <code>source</code> 或是版本约束条件则不会被继承。每一个模块都必须声明各自的 Provider 需求条件，这在使用非 HashiCorp 的 Provider 时尤其重要。</p>
<h2 id="1-6-2-1-11-显式传递-Provider"><a href="#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider"></a>1.6.2.1.11. 显式传递 Provider</h2>
<p>当不同的子模块需要不同的 Provider 实例，或者子模块需要的 Provider 实例与调用者自己使用的不同时，我们需要在 <code>module</code> 块上声明 <code>providers</code> 参数来传递子模块要使用的 Provider 实例。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># The default &quot;aws&quot; configuration is used for AWS resources in the root</span><br><span class="line"># module where no explicit provider instance is selected.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-west-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># An alternate configuration is also defined for a different</span><br><span class="line"># region, using the alias &quot;usw2&quot;.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;usw2&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># An example child module is instantiated with the alternate configuration,</span><br><span class="line"># so any AWS resources it defines will use the us-west-2 region.</span><br><span class="line">module &quot;example&quot; &#123;</span><br><span class="line">  source    = &quot;./example&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws = aws.usw2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>module</code> 块里的 <code>providers</code> 参数类似 <code>resource</code> 块里的 <code>provider</code> 参数，区别是前者接收的是一个 <code>map</code> 而不是单个 <code>string</code>，因为一个模块可能含有多个不同的 Provider。</p>
<p><code>providers</code> 的 <code>map</code> 的键就是子模块中声明的 Provider 需求中的名字，值就是在当前模块中对应的 Provider 配置的名字。</p>
<p>如果 <code>module</code> 块内声明了 <code>providers</code> 参数，那么它将重载所有默认的继承行为，所以你需要确保给定的 <code>map</code> 覆盖了子模块所需要的所有 Provider。这避免了显式赋值与隐式继承混用时带来的混乱和意外。</p>
<p>额外的 Provider 配置(使用 <code>alias</code> 参数的)将永远不会被子模块隐式继承，所以必须显式通过 <code>providers</code> 传递。比如，一个模块配置了两个 AWS 区域之间的网络打通，所以需要配置一个源区域 Provider 和目标区域 Provider。这种情况下，根模块代码看起来是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;usw1&quot;</span><br><span class="line">  region = &quot;us-west-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;usw2&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;tunnel&quot; &#123;</span><br><span class="line">  source    = &quot;./tunnel&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws.src = aws.usw1</span><br><span class="line">    aws.dst = aws.usw2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子目录 <code>./tunnel</code> 必须包含像下面的例子那样声明&quot;Provider 代理&quot;，声明模块调用者必须用这些名字传递的 Provider 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias = &quot;src&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias = &quot;dst&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>./tunnel</code> 模块中的每一种资源都应该通过 <code>provider</code> 参数声明它使用的是 <code>aws.src</code> 还是 <code>aws.dst</code>。</p>
<h2 id="1-6-2-1-12-Provider-代理配置块"><a href="#provider-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E5%9D%97"></a>1.6.2.1.12. Provider 代理配置块</h2>
<p>一个 Provider 代理配置只包含 <code>alias</code> 参数，它就是一个模块间传递 Provider 配置的占位符，声明了模块期待显式传递的额外(带有 <code>alias</code> 的)Provider 配置。</p>
<p>需要注意的是，一个完全为空的 Provider 配置块也是合法的，但没有必要。只有在模块内需要带 <code>alias</code> 的 Provider 时才需要代理配置块。如果模块中只是用默认 Provider 时请不要声明代理配置块，也不要仅为了声明 Provider 版本约束而使用代理配置块。</p>
<h2 id="模块元参数"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">模块元参数</a></h2>
<ul>
<li><a href="#%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.6.3.1.</strong> 模块元参数</a></li>
</ul>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"></a></p>
<h2 id="1-6-3-1-模块元参数"><a href="#%E6%A8%A1%E5%9D%97%E5%85%83%E5%8F%82%E6%95%B0"></a>1.6.3.1. 模块元参数</h2>
<p>在 Terraform 0.13 之前，模块在使用上存在一些限制。例如我们通过模块来创建 EC2 主机，可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module &quot;ec2_instance&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要创建两台这样的主机怎么办？在 Terraform 0.13 之前的版本中，由于 Module 不支持元参数，所以我们只能手动拷贝模块代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">module &quot;ec2_instance_0&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance-0&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;ec2_instance_1&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance-1&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自从 Terraform 0.13 开始，模块也像资源一样，支持<code>count</code>、<code>for_each</code>、<code>depends_on</code>三种元参数。比如我们可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module &quot;ec2_instance&quot; &#123;</span><br><span class="line">  count = 2</span><br><span class="line">  source  = &quot;terraform-aws-modules/ec2-instance/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 3.0&quot;</span><br><span class="line"></span><br><span class="line">  name = &quot;single-instance-$&#123;count.index&#125;&quot;</span><br><span class="line"></span><br><span class="line">  ami                    = &quot;ami-ebd02392&quot;</span><br><span class="line">  instance_type          = &quot;t2.micro&quot;</span><br><span class="line">  key_name               = &quot;user1&quot;</span><br><span class="line">  monitoring             = true</span><br><span class="line">  vpc_security_group_ids = [&quot;sg-12345678&quot;]</span><br><span class="line">  subnet_id              = &quot;subnet-eddcdzz4&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Terraform   = &quot;true&quot;</span><br><span class="line">    Environment = &quot;dev&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是 Terraform 0.13 之后在模块上声明<code>depends_on</code>，列表中也可以传入另一个模块。声明<code>depends_on</code>的模块中的所有资源的创建都会发生在被依赖的模块中所有资源创建完成之后。</p>
<ul>
<li>
<p><a href="#%E9%87%8D%E6%9E%84"><strong>1.6.4.1.</strong> 重构</a></p>
</li>
<li>
<p><a href="#moved-%E5%9D%97%E8%AF%AD%E6%B3%95"><strong>1.6.4.1.1.</strong> moved 块语法</a></p>
</li>
<li>
<p><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"><strong>1.6.4.1.2.</strong> 重命名一个资源</a></p>
</li>
<li>
<p><a href="#%E4%B8%BA%E8%B5%84%E6%BA%90%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"><strong>1.6.4.1.3.</strong> 为资源添加 count 或 for_each 声明</a></p>
</li>
<li>
<p><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E8%B0%83%E7%94%A8"><strong>1.6.4.1.4.</strong> 重命名对模块的调用</a></p>
</li>
<li>
<p><a href="#%E4%B8%BA%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"><strong>1.6.4.1.5.</strong> 为模块调用添加 count 或 for_each 声明</a></p>
</li>
<li>
<p><a href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%86%E5%89%B2%E6%88%90%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.6.4.1.6.</strong> 将一个模块分割成多个模块</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4-moved-%E5%9D%97"><strong>1.6.4.1.7.</strong> 删除 moved 块</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"><strong>1.6.4.1.8.</strong> 删除模块</a></p>
</li>
</ul>
<p><a href="#%E9%87%8D%E6%9E%84"></a></p>
<h2 id="1-6-4-1-重构"><a href="#%E9%87%8D%E6%9E%84"></a>1.6.4.1. 重构</h2>
<p>请注意，本节介绍的通过 <code>moved</code> 块进行模块重构的功能是从 Terraform v1.1 开始被引入的。如果要在之前的版本进行这样的操作，必须通过 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/2.mv"><code>terraform state mv</code></a> 命令来完成。</p>
<p>对于一些旨在被人复用的老模块来说，最初的模块结构和资源名称可能会逐渐变得不再合适。例如，我们可能发现将以前的一个子模块分割成两个单独的模块会更合理，这需要将现有资源的一个子集移动到新的模块中。</p>
<p>Terraform 将以前的状态与新代码进行比较，资源与每个模块或资源的唯一地址相关联。因此，默认情况下，移动或重命名对象会被 Terraform 理解为销毁旧地址的对象并在新地址创建新的对象。</p>
<p>当我们在代码中添加 <code>moved</code> 块以记录我们移动或重命名对象过去的地址时，Terraform 会将旧地址的现有对象视为现在属于新地址。</p>
<h2 id="1-6-4-1-1-moved-块语法"><a href="#moved-%E5%9D%97%E8%AF%AD%E6%B3%95"></a>1.6.4.1.1. moved 块语法</h2>
<p><code>moved</code> 块只包含 <code>from</code> 和 <code>to</code> 参数，没有名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子演示了模块先前版本中的 <code>aws_instance.a</code> 如今以 <code>aws_instance.b</code> 的名字存在。</p>
<p>在为 <code>aws_instance.b</code> 创建新的变更计划之前，Terraform 会首先检查当前状态中是否存在地址为 <code>aws_instance.a</code> 的记录。如果存在该记录，Terraform 会将之重命名为 <code>aws_instance.b</code> 然后继续创建变更计划。最终生成的变更计划中该对象就好像一开始就是以 <code>aws_instance.b</code> 的名字被创建的，防止它在执行变更时被删除。</p>
<p><code>from</code> 和 <code>to</code> 的地址使用一种特殊的地址语法，该语法允许选定模块、资源以及子模块中的资源。下面是几种不同的重构场景中所需要的地址语法：</p>
<h2 id="1-6-4-1-2-重命名一个资源"><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"></a>1.6.4.1.2. 重命名一个资源</h2>
<p>考虑模块代码中这样一个资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  count = 2</span><br><span class="line"></span><br><span class="line">  # (resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次应用该代码时 Terraform 会创建 <code>aws_instance.a[0]</code> 以及 <code>aws_instance.a[1]</code>。</p>
<p>如果随后我们修改了该资源的名称，并且把旧名字记录在一个 <code>moved</code> 块里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;b&quot; &#123;</span><br><span class="line">  count = 2</span><br><span class="line"></span><br><span class="line">  # (resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当下一次应用使用了该模块的代码时，Terraform 会把所有地址为 <code>aws_instance.a</code> 的对象看作是一开始就以 <code>aws_instance.b</code> 的名字创建的：<code>aws_instance.a[0]</code> 会被看作是 <code>aws_instance.b[0]</code>，<code>aws_instance.a[1]</code> 会被看作是 <code>aws_instance.b[1]</code>。</p>
<p>新创建的模块实例中，因为从来就不存在 <code>aws_instance.a</code>，于是会忽略 <code>moved</code> 块而像通常那样直接创建 <code>aws_instance.b[0]</code> 以及 <code>aws_instance.b[1]</code>。</p>
<h2 id="1-6-4-1-3-为资源添加-count-或-for-each-声明"><a href="#%E4%B8%BA%E8%B5%84%E6%BA%90%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"></a>1.6.4.1.3. 为资源添加 count 或 for_each 声明</h2>
<p>一开始代码中有这样一个单实例资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  # (resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用该代码会使得 Terraform 创建了一个地址为 <code>aws_instance.a</code> 的资源对象。</p>
<p>随后我们想要在该资源上添加 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90#for_each"><code>for_each</code></a> 来创建多个实例。为了保持先前关联到 <code>aws_instance.a</code> 的资源对象不受影响，我们必须添加一个 <code>moved</code> 块来指定新代码中原先的对象实例所关联的键是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  instances = tomap(&#123;</span><br><span class="line">    big = &#123;</span><br><span class="line">      instance_type = &quot;m3.large&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    small = &#123;</span><br><span class="line">      instance_type = &quot;t2.medium&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  for_each = local.instances</span><br><span class="line"></span><br><span class="line">  instance_type = each.value.instance_type</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.a[&quot;small&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会防止 Terraform 在变更计划中销毁已经存在的 <code>aws_instance.a</code> 对象，并且将其看作是以 <code>aws_instance.a[&quot;small&quot;]</code> 的地址创建的。</p>
<p>当 <code>moved</code> 块的两个地址中的至少一个包含实例键时，如上例中的 <code>[&quot;small&quot;]</code>，Terraform 将这两个地址理解为引用资源的特定实例而不是整个资源。这意味着您可以使用 <code>moved</code> 在键之间切换以及在 <code>count</code>、<code>for_each</code> 之间切换时添加和删除键。</p>
<p>下面的例子演示了几种其他类似的记录了资源实例键变更的合法 <code>moved</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Both old and new configuration used &quot;for_each&quot;, but the</span><br><span class="line"># &quot;small&quot; element was renamed to &quot;tiny&quot;.</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.b[&quot;small&quot;]</span><br><span class="line">  to   = aws_instance.b[&quot;tiny&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># The old configuration used &quot;count&quot; and the new configuration</span><br><span class="line"># uses &quot;for_each&quot;, with the following mappings from</span><br><span class="line"># index to key:</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.c[0]</span><br><span class="line">  to   = aws_instance.c[&quot;small&quot;]</span><br><span class="line">&#125;</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.c[1]</span><br><span class="line">  to   = aws_instance.c[&quot;tiny&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># The old configuration used &quot;count&quot;, and the new configuration</span><br><span class="line"># uses neither &quot;count&quot; nor &quot;for_each&quot;, and you want to keep</span><br><span class="line"># only the object at index 2.</span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.d[2]</span><br><span class="line">  to   = aws_instance.d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：当我们在原先没有声明 <code>count</code> 的资源上添加 <code>count</code> 时，Terraform 会自动将原先的对象移动到第 0 个位置，除非我们通过一个 <code>moved</code> 块显式声明该资源。然而，我们建议使用 <code>moved</code> 块显式声明资源的移动，使得读者在未来阅读模块的代码时能够更清楚地了解到这些变更。</p>
<h2 id="1-6-4-1-4-重命名对模块的调用"><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E8%B0%83%E7%94%A8"></a>1.6.4.1.4. 重命名对模块的调用</h2>
<p>我们可以用类似重命名资源的方式来重命名对模块的调用。假设我们开始用以下代码调用一个模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &quot;a&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当应用该代码时，Terraform 会在模块内声明的资源路径前面加上一个模块路径前缀 <code>module.a</code>。比方说，模块内的 <code>aws_instance.example</code> 的完整地址为 <code>module.a.aws_instance.example</code>。</p>
<p>如果我们随后打算修改模块名称，我们可以直接修改 <code>module</code> 块的标签，并且在一个 <code>moved</code> 块内部记录该变更：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module &quot;b&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = module.a</span><br><span class="line">  to   = module.b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当下一次应用包含该模块调用的代码时，Terraform 会将所有路径前缀为 <code>module.a</code> 的对象看作从一开始就是以 <code>module.b</code> 为前缀创建的。<code>module.a.aws_instance.example</code> 会被看作是 <code>module.b.aws_instance.example</code>。</p>
<p>该例子中的 <code>moved</code> 块中的两个地址都代表对模块的调用，而 Terraform 识别出将原模块地址中所有的资源移动到新的模块地址中。如果该模块声明时使用了 <code>count</code> 或是 <code>for_each</code>，那么该移动也将被应用于所有的实例上，不需要逐个指定。</p>
<h2 id="1-6-4-1-5-为模块调用添加-count-或-for-each-声明"><a href="#%E4%B8%BA%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E6%B7%BB%E5%8A%A0-count-%E6%88%96-foreach-%E5%A3%B0%E6%98%8E"></a>1.6.4.1.5. 为模块调用添加 count 或 for_each 声明</h2>
<p>考虑一下单实例的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &quot;a&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;q</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用该段代码会导致 Terraform 创建的资源地址都拥有 <code>module.a</code> 的前缀。</p>
<p>随后如果我们可能需要再通过添加 <code>count</code> 来创建多个资源实例。为了保留先前的 <code>aws_instance.a</code> 实例不受影响，我们可以添加一个 <code>moved</code> 块来设置在新代码中该实例的对应的键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module &quot;a&quot; &#123;</span><br><span class="line">  source = &quot;../modules/example&quot;</span><br><span class="line">  count  = 3</span><br><span class="line"></span><br><span class="line">  # (module arguments)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = module.a</span><br><span class="line">  to   = module.a[2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码引导 Terraform 将所有 <code>module.a</code> 中的资源看作是从一开始就是以 <code>module.a[2]</code> 的前缀被创建的。结果就就是，Terraform 生成的变更计划中只会创建 <code>module.a[0]</code> 以及 <code>module.a[1]</code>。</p>
<p>当 <code>moved</code> 块的两个地址中的至少一个包含实例键时，例如上面例子中的 <code>[2]</code>那样，Terraform 会理解将这两个地址理解为对模块的特定实例的调用而非对模块所有实例的调用。这意味着我们可以使用 <code>moved</code> 块在不同键之间切换来添加或是删除键，该机制可用于 <code>count</code> 和 <code>for_each</code>，或删除模块上的这种声明。</p>
<h2 id="1-6-4-1-6-将一个模块分割成多个模块"><a href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%86%E5%89%B2%E6%88%90%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97"></a>1.6.4.1.6. 将一个模块分割成多个模块</h2>
<p>随着模块提供的功能越来越多，最终模块可能变得过大而不得不将之拆分成两个独立的模块。</p>
<p>我们看一下下面的这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;b&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;c&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将该模块分割为三个部分：</p>
<ul>
<li><code>aws_instance.a</code> 现在归属于模块 “x”。</li>
<li><code>aws_instance.b</code> 也属于模块 “x”。</li>
<li><code>aws_instance.c</code> 现在归属于模块 “y”。</li>
</ul>
<p>要在不替换绑定到旧资源地址的现有对象的情况下实现此重构，我们需要：</p>
<ol>
<li>编写模块 “x”，将属于它的两个资源拷贝过去。</li>
<li>编写模块 “y”，将属于它的一个资源拷贝过去。</li>
<li>编辑原有模块代码，删除这些资源，只包含有关迁移现有资源的非常简单的配置代码。</li>
</ol>
<p>新的模块 “x” 和 “y” 应该只包含 <code>resource</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># module &quot;x&quot;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;a&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;b&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># module &quot;y&quot;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;c&quot; &#123;</span><br><span class="line">  # (other resource-type-specific configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而原有模块则被修改成只包含有向下兼容逻辑的垫片，调用两个新模块，并使用 <code>moved</code> 块定义哪些资源被移动到新模块中去了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module &quot;x&quot; &#123;</span><br><span class="line">  source = &quot;../modules/x&quot;</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;y&quot; &#123;</span><br><span class="line">  source = &quot;../modules/y&quot;</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = module.x.aws_instance.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.b</span><br><span class="line">  to   = module.x.aws_instance.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.c</span><br><span class="line">  to   = module.y.aws_instance.c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个原模块的调用者升级模块版本到这个“垫片”版本时，Terraform 会注意到这些 <code>moved</code> 块，并将那些关联到老地址的资源对象看作是从一开始就是由新模块创建的那样。</p>
<p>该模块的新用户可以选择使用这个垫片模块，或是独立调用两个新模块。我们需要通知老模块的现有用户老模块已被废弃，他们将来的开发中需要独立使用这两个新模块。</p>
<p>多模块重构的场景是不多见的，因为它违反了父模块将其子模块视为黑盒的典型规则，不知道在其中声明了哪些资源。这种妥协的前提是假设所有这三个模块都由同一个人维护并分布在一个模块包中。</p>
<p>为避免独立模块之间的耦合，Terraform 只允许声明在同一个目录下的模块间的移动。换句话讲，Terraform 不允许将资源移动到一个 <code>source</code> 地址不是<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html#%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%84">本地路径</a>的模块中去。</p>
<p>Terraform 使用定义 <code>moved</code> 块的模块实例的地址的地址来解析 <code>moved</code> 块中的相对地址。例如，如果上面的原模块已经是名为 <code>module.original</code> 的子模块，则原模块中对 <code>module.x.aws_instance.a</code> 的引用在根模块中将被解析为 <code>module.original.module.x.aws_instance.a</code>。一个模块只能针对它自身或是它的子模块中的资源声明 <code>moved</code> 块。</p>
<p>如果需要引用带有 <code>count</code> 或 <code>for_each</code> 元参数的模块中的资源，则必须指定要使用的特定实例键以匹配资源配置的新位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.example</span><br><span class="line">  to   = module.new[2].aws_instance.example</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-4-1-7-删除-moved-块"><a href="#%E5%88%A0%E9%99%A4-moved-%E5%9D%97"></a>1.6.4.1.7. 删除 moved 块</h2>
<p>随着时间的推移，一些老模块可能会积累大量 <code>moved</code> 块。</p>
<p>删除 <code>moved</code> 块通常是一种破坏性变更，因为删除后所有使用旧地址引用的对象都将被删除而不是被移动。我们强烈建议保留历史上所有的 <code>moved</code> 块来保存用户从任意版本升级到当前版本的升级路径信息。</p>
<p>如果我们决定要删除 <code>moved</code> 块，需要谨慎行事。对于组织内部的私有模块来说删除 <code>moved</code> 块可能是安全的，因为我们可以确认所有用户都已经使用新版本模块代码运行过 <code>terraform apply</code> 了。</p>
<p>如果我们需要多次重命名或是移动一个对象，我们建议使用<em>串联</em>的 <code>moved</code> 块来记录完整的变更信息，新的块引用已有的块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.a</span><br><span class="line">  to   = aws_instance.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moved &#123;</span><br><span class="line">  from = aws_instance.b</span><br><span class="line">  to   = aws_instance.c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像这样记录下移动的序列可以使 <code>aws_instance.a</code> 以及 <code>aws_instance.b</code> 两种地址的资源都得到成功更新，Terraform 会将他们视作从一开始就是以 <code>aws_instance.c</code> 的地址创建的。</p>
<h2 id="1-6-4-1-8-删除模块"><a href="#%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"></a>1.6.4.1.8. 删除模块</h2>
<p>注意：<code>removed</code> 块是在 Terraform v1.7 引入的功能。对于早期的 Terraform 版本，您可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/6.rm.html"><code>terraform state rm</code></a> 命令来处理。</p>
<p>要从 Terraform 中删除模块，只需从 Terraform 代码中删除模块调用即可。</p>
<p>默认情况下，删除模块块后，Terraform 将计划销毁由该模块中声明的所有资源。这是因为当您删除模块调用时，该模块的代码将不再包含在我们当前的 Terraform 代码中。</p>
<p>有时我们可能希望从 Terraform 代码中删除模块而不破坏它管理的实际基础设施对象。在这种情况下，资源将从 Terraform 状态中删除，但真正的基础设施对象不会被销毁。</p>
<p>要声明模块已从 Terraform 配置中删除，但不应销毁其托管对象，请从配置中删除 <code>module</code> 块并将其替换为 <code>removed</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">removed &#123;</span><br><span class="line">  from = module.example</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    destroy = false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>from</code> 参数是要删除的模块的地址，不带任何实例键（例如 <code>module.example[1]</code>）。</p>
<p><code>lifecycle</code> 块是必需的。 <code>destroy</code> 参数确定 Terraform 是否会尝试销毁模块管理的对象。 <code>false</code> 值表示 Terraform 将从状态中删除资源而不破坏它们。</p>
<ul>
<li>
<p><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A8%A1%E5%BC%8F"><strong>1.6.5.1.</strong> 设计新模块的模式</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><strong>1.6.5.1.1.</strong> 模块创建的工作流</a></p>
</li>
<li>
<p><a href="#%E5%B0%86%E9%9C%80%E6%B1%82%E8%8C%83%E5%9B%B4%E5%88%92%E5%88%86%E6%88%90%E5%90%88%E9%80%82%E7%9A%84%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.1.1.</strong> 将需求范围划分成合适的模块</a></p>
</li>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8F%AF%E8%A1%8C%E4%BA%A7%E5%93%81"><strong>1.6.5.1.1.2.</strong> 创建模块的最小可行产品</a></p>
</li>
<li>
<p><a href="#%E6%8E%A2%E7%B4%A2%E9%81%B5%E5%BE%AA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"><strong>1.6.5.1.2.</strong> 探索遵循这些原则的一个示例场景</a></p>
</li>
<li>
<p><a href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.2.1.</strong> 网络模块</a></p>
</li>
<li>
<p><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.2.2.</strong> 应用程序模块</a></p>
</li>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8F%90%E7%A4%BA"><strong>1.6.5.1.3.</strong> 创建模块的提示</a></p>
</li>
<li>
<p><a href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.3.1.</strong> 嵌套模块</a></p>
</li>
<li>
<p><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%8F%E4%BD%9C"><strong>1.6.5.1.4.</strong> 模块的协作</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%BF%BD%E8%B8%AA%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.5.</strong> 使用源代码控制系统追踪模块</a></p>
</li>
<li>
<p><a href="#%E5%BC%80%E5%8F%91%E4%B8%80%E5%A5%97%E6%A8%A1%E5%9D%97%E6%B6%88%E8%B4%B9%E5%B7%A5%E4%BD%9C%E6%B5%81"><strong>1.6.5.1.6.</strong> 开发一套模块消费工作流</a></p>
</li>
<li>
<p><a href="#%E9%98%90%E6%98%8E%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><strong>1.6.5.1.6.1.</strong> 阐明团队应该如何使用模块</a></p>
</li>
</ul>
<p><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A8%A1%E5%BC%8F"></a></p>
<h2 id="1-6-5-1-设计新模块的模式"><a href="#%E8%AE%BE%E8%AE%A1%E6%96%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A8%A1%E5%BC%8F"></a>1.6.5.1. 设计新模块的模式</h2>
<p>Terraform 模块是独立的基础设施即代码片段，抽象了基础设施部署的底层复杂性。Terraform 用户通过使用预置的配置代码加速采用 IaC，并降低了使用门槛。所以，模块的作者应尽量遵循诸如清晰的代码结构以及 DRY(“Dont’t Repeat Yourself”)原则的代码最佳实践。</p>
<p>本篇指导讨论了模块架构的原则，用以帮助读者编写易于组合、易于分享及重用的基础设施模块。这些架构建议对使用任意版本 Terraform 的企业都有助益，某些诸如“私有模块注册表(Registry)”的模式仅在 Terraform Cloud 以及企业版中才能使用。（本文不对相关内容进行翻译）</p>
<p>本文是对 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/1.%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">Terraform 模块文档</a>的补充和扩展。</p>
<p>通过阅读文本，读者可以：</p>
<ol>
<li>学习有关 Terraform 模块创建的典型工作流程和基本原则。</li>
<li>探索遵循这些原则的示例场景。</li>
<li>学习如何通过协作改进 Terraform 模块</li>
<li>了解如何创建一套使用模块的工作流程。</li>
</ol>
<h2 id="1-6-5-1-1-模块创建的工作流"><a href="#%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"></a>1.6.5.1.1. 模块创建的工作流</h2>
<p>要创建一个新模块，第一步是寻找一个早期采纳者团队，收集他们的需求。</p>
<p>与这支早期采纳团队一起工作使我们可以通过使用输入变量以及输出值来确保模块足够灵活，从而打磨模块的功能。此外，还可以用最小的代码变更代价吸纳其他有类似需求的团队加入进来。这消除了代码重复，并缩短了交付时间。</p>
<p>完成以上任务后，需要谨记两点：</p>
<ol>
<li>将需求范围划分成合适的模块。</li>
<li>创建模块的最小可行产品(Minimum Viable Product, MVP)</li>
</ol>
<h3 id="1-6-5-1-1-1-将需求范围划分成合适的模块"><a href="#%E5%B0%86%E9%9C%80%E6%B1%82%E8%8C%83%E5%9B%B4%E5%88%92%E5%88%86%E6%88%90%E5%90%88%E9%80%82%E7%9A%84%E6%A8%A1%E5%9D%97"></a>1.6.5.1.1.1. 将需求范围划分成合适的模块</h3>
<p>创建新 Terraform 模块时最具挑战的方面之一是决定要包含哪些基础设施资源。</p>
<p>模块设计应该是有主见的，并且被设计成能很好地完成一个目标。如果一个模块的功能或目的很难解释，那么这个模块可能太复杂了。在最初确定模块的范围时，目标应当足够小且简单，易于开始编写。</p>
<p>当构建一个模块时，需要考虑以下三个方面：</p>
<ul>
<li><strong>封装</strong>：一组始终被一起部署的基础设施资源 在模块中包含更多的基础设施资源简化了终端用户部署基础设施的工作，但会使得模块的目的与需求变得更难理解。</li>
<li><strong>职责</strong>：限制模块职责的边界 如果模块中的基础设施资源由多个组来负责，使用该模块可能会意外违反职责分离原则。模块中仅包含职责边界内的一组资源可以提升基础设施资源的隔离性，并保护我们的基础设施。</li>
<li><strong>变化频率</strong>：隔离长短生命周期基础设施资源 举例来说，数据库基础设施资源相对来说较为静态，而团队可能在一天内多次部署更新应用程序服务器。在同一个模块中同时管理数据库与应用程序服务器使得保存状态数据的重要基础设施没有必要地暴露在数据丢失的风险之中。</li>
</ul>
<h3 id="1-6-5-1-1-2-创建模块的最小可行产品"><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8F%AF%E8%A1%8C%E4%BA%A7%E5%93%81"></a>1.6.5.1.1.2. 创建模块的最小可行产品</h3>
<p>如同所有类型的代码一样，模块的开发永远不会完成，永远会有新的模块需求以及变更。拥抱变化，最初的模块版本应致力于满足最小可行产品（MVP）的标准。以下是在设计最小可行产品时需要谨记的指导清单：</p>
<ul>
<li>永远致力于交付至少可以满足 80% 场景的模块</li>
<li>模块中永远不要处理边缘场景。边缘场景是很少见的。一个模块应该是一组可重用的代码。</li>
<li>在最小可行产品中避免使用条件表达式。最小可行产品应缩小范围，不应该同时完成多种任务。</li>
<li>模块应该只将最常被修改的参数公开为输入变量。一开始时，模块应该只提供最可能需要的输入变量。</li>
</ul>
<h4 id="尽可能多输出"><a href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%9A%E8%BE%93%E5%87%BA"></a>尽可能多输出</h4>
<p>在最小可行产品中输出尽可能多的信息，哪怕目前没有用户需要这些信息。这使得那些通常使用多个模块的终端用户在使用该模块时更加轻松，可以使用一个模块的输出作为下一个模块的输入。</p>
<p>请记住在模块的 <code>README</code> 文档中记录输出值的文档。</p>
<h2 id="1-6-5-1-2-探索遵循这些原则的一个示例场景"><a href="#%E6%8E%A2%E7%B4%A2%E9%81%B5%E5%BE%AA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"></a>1.6.5.1.2. 探索遵循这些原则的一个示例场景</h2>
<p>某团队想要通过 Terraform 创建一套包含 Web 层应用、App 层应用的基础设施。</p>
<p>他们想要使用一个专用的 VPC，并遵循传统的三层架构设计。他们的 Web 层应用需要一个自动伸缩组（AutoScaling Group）。他们的 App 层服务需要一个自动伸缩组，一个 S3 存储桶以及一个数据库。下面的架构图描述了期望的结果：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504165650.png" alt=""></p>
<p>该场景中，一个负责从零开始撰写 Terraform 代码的团队，负责编写一组用以配置基础设施及应用的模块。负责应用程序的团队成员将使用这些模块来配置他们需要的基础设施。</p>
<p><strong>请注意</strong>，虽然该示例使用了 AWS 命名，但所描述的模式适用于所有云平台。</p>
<p>经过对应用程序团队的需求进行审核，模块团队将该应用基础设施分割成如下模块：网络、Web、App、数据库、路由，以及安全。</p>
<p>当 Terraform 模块团队完成模块开发后，他们应该将模块导入到私有模块注册表中，并且向对应的团队成员宣传模块的使用方法。举例来说，负责网络的团队成员将会使用开发的网络模块来部署和配置相应的应用程序网络。</p>
<h3 id="1-6-5-1-2-1-网络模块"><a href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97"></a>1.6.5.1.2.1. 网络模块</h3>
<p>网络模块负责网络基础设施。它包含了网络访问控制列表（ACL）以及 NAT 网关。它也可以包含应用程序所需的 VPC、子网、对等连接以及 Direct Connect 等。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170456.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改网络资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<p>网络模块返回一组其他工作区（Workspace）以及模块可以使用的输出值。如果 VPC 的创建过程是由多个方面组成的，我们可能最终会需要将该模块进一步切割成拥有不同功能的不同模块。</p>
<h3 id="1-6-5-1-2-2-应用程序模块"><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97"></a>1.6.5.1.2.2. 应用程序模块</h3>
<p>本场景中有两个应用程序模块 —— 一个是 Web 层模块，另一个是 App 层模块。</p>
<p>Terraform 模块团队完成这两个模块的开发后，它们应被分发给对应的团队成员来部署他们的应用。随着应用程序团队的成员变得越来越熟悉 Terraform 代码，它们可以提出基础设施方面的增强建议，或是通过 Pull Request 配合他们自己的应用代码发布提交对基础设施的变更请求。</p>
<h4 id="Web-模块"><a href="#web-%E6%A8%A1%E5%9D%97"></a>Web 模块</h4>
<p>Web 模块创建和管理运行 Web 应用程序所需的基础设施。它包含了负载均衡器和自动伸缩组，同时也可以包含应用程序中使用的 EC2 虚拟机实例、S3 存储桶、安全组，以及日志系统。该模块接收一个通过 Packer 预构建的包含最新 Web 层应用发布版本代码的虚拟机镜像的 AMI ID 作为输入。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170534.png" alt=""></p>
<p>该模块包含这些资源是因为它们是<strong>高度封装</strong>的，并且它们<strong>变化频率较高</strong>。</p>
<ol>
<li>此模块中的资源高度内聚，并且与 Web 应用程序紧密相关（例如，此模块需要一个包含最新 Web 层应用程序代码版本的 AMI）。结果就是它们被编制进同一个模块，这样 Web 应用团队的成员们就可以轻松地部署它们。</li>
<li>该模块的资源变更频率较高（每次发布更新版本都需要更新对应基础设施资源）。通过将它们组合在单独的模块中，我们降低了将其他模块的资源暴露在没有必要的数据丢失的风险中的可能性。</li>
</ol>
<h4 id="App-模块"><a href="#app-%E6%A8%A1%E5%9D%97"></a>App 模块</h4>
<p>App 模块创建和管理运行 App 层应用所需的基础设施。它包含了负载均衡器和自动伸缩组，同时也包含了应用程序中使用的 EC2 虚拟机实例、S3 存储桶、安全组，以及日志系统。该模块接收一个通过 Packer 预构建的包含最新 App 层应用发布版本代码的虚拟机镜像的 AMI ID 作为输入。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170602.png" alt=""></p>
<p>该模块包含这些资源是因为它们是<strong>高度封装</strong>的，并且它们<strong>变化频率较高</strong>。</p>
<ol>
<li>此模块中的资源高度内聚，并且与 App 应用程序紧密相关。结果就是它们被编制进同一个模块，这样 App 层应用团队的成员们就可以轻松地部署它们。</li>
<li>该模块的资源变更频率较高（每次发布更新版本都需要更新对应基础设施资源）。通过将它们组合在单独的模块中，我们降低了将其他模块的资源暴露在没有必要的数据丢失的风险中的可能性。</li>
</ol>
<h4 id="数据库模块"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97"></a>数据库模块</h4>
<p>数据库模块创建并管理了运行数据库所需的基础设施资源。它包含了应用程序所需的 RDS 实例，也包含了所有关联的存储、备份以及日志资源。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170632.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改数据库资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<h4 id="路由模块"><a href="#%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97"></a>路由模块</h4>
<p>路由模块创建并管理网络路由所需的基础设施资源。它包含了公共托管区域（Hosted Zone）、Route 53 以及路由表，也可以包含私有托管区域。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170657.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改路由资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<h4 id="安全模块"><a href="#%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97"></a>安全模块</h4>
<p>安全模块创建并管理所有安全所需的基础设施资源。它包含一组 IAM 资源，也可以包含安全组（Security Group）及多因素认证（MFA）。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20220504170717.png" alt=""></p>
<p>该模块包含这些资源是因为它们<strong>需要特定权限</strong>并且<strong>变化频率较低</strong>。</p>
<ol>
<li>只有应用程序团队中有权创建或修改 IAM 或是安全资源的成员可以使用该模块。</li>
<li>该模块的资源不会经常变更。将它们组合在单独的模块中可以保护它们免于暴露在没有必要的数据丢失的风险之中。</li>
</ol>
<h2 id="1-6-5-1-3-创建模块的提示"><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9A%84%E6%8F%90%E7%A4%BA"></a>1.6.5.1.3. 创建模块的提示</h2>
<p>除了范围界定之外，我们在创建模块时还应牢记以下几点：</p>
<h3 id="1-6-5-1-3-1-嵌套模块"><a href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%9D%97"></a>1.6.5.1.3.1. 嵌套模块</h3>
<p>嵌套模块是指在当前模块中对另一个模块的引用。嵌套模块可以是外部的，也可以是当前工作空间内的。使用嵌套模块是一项强大的功能；然而我们必须谨慎实践以避免引入错误。</p>
<p>对于所有类型的嵌套模块，请考虑以下事项：</p>
<ul>
<li>嵌套模块可以加速开发速度，但可能会引发未知以及意料之外的结果。请在文档中清晰地记录输入变量、模块行为以及输出值。</li>
<li>通常来说，不要让主模块的嵌套深度超过两层。常用且简单的工具模块，例如专门用来定义 Tag 的模块，则不受此限制制约。</li>
<li>嵌套模块必须包含必要的用来创建指定的资源配置的输入参数以及输出值。</li>
<li>输入参数以及输出值的命名应遵循一致的命名约定，以使得模块可以更容易地被分享，以及将一个模块的的输出值作为另一个模块的输入参数。</li>
<li>嵌套模块可能会导致代码冗余。必须同时在父模块与嵌套模块中声明输入参数和输出值。</li>
</ul>
<h4 id="嵌套的外部模块"><a href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9D%97"></a>嵌套的外部模块</h4>
<p>当我们需要使用那些定义了被多个应用程序堆栈、应用程序和团队复用的标准化资源的通用模块时，嵌套的外部模块会很有用。外部模块通被集中管理和版本化控制，以使得消费者在使用新版本之前可以对其进行验证。当我们依赖或希望使用位于外部的子模块时，请注意以下几点：</p>
<ul>
<li>外部模块必须被独立维护，并可供任何需要调用它的模块使用。使用模块注册表可以确保这一点。</li>
<li>根据模块注册要求，嵌套模块将拥有自己的版本控制代码仓库，独立于调用模块进行版本控制。</li>
<li>对嵌套模块的变更可能会影响调用模块，即使调用模块的调用代码及版本没有发生变化，这会破坏调用代码的信任。</li>
<li>对调用模块如何使用外部模块在文档中进行记录，使得模块行为以及调用关系可以被轻松理解。</li>
<li>对外部模块的变更应该是向后兼容的。如果向后兼容是不可能的，则应清楚地记录需要对任何调用模块进行的更改，并将之分发给所有模块使用者以避免意外。</li>
</ul>
<h4 id="嵌套的嵌入模块"><a href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9D%97"></a>嵌套的嵌入模块</h4>
<p>在当前工作空间中嵌入一个模块使得我们能够清晰地分离模块的逻辑组件，或是创建可在调用模块执行期间多次调用的可重用代码块。在下面的例子中，<code>ec2-instance</code> 是一个嵌入模块，根模块的 <code>main.tf</code> 引用了该模块：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root-module-directory</span><br><span class="line">├── README.md</span><br><span class="line">├── main.tf</span><br><span class="line">└── ec2-instances</span><br><span class="line">    └── main.tf</span><br></pre></td></tr></table></figure>
<p>如果我们需要或者倾向于使用嵌入模块，需要考虑以下几点：</p>
<ul>
<li>在“根模块”中添加嵌入模块意味着子模块与根模块被放在一起进行版本控制。</li>
<li>任何影响两个模块间兼容性的变更都会被快速发现，因为它们必须被一同测试和发布。</li>
<li>（嵌入的）子模块不能被代码树之外的其他模块调用，所以可能会增加重复的代码。举例来说，如果嵌入的 <code>ec2-instance</code> 模块是用来创建一台被用在多个地方的标准化的计算实例，该模块<strong>无法</strong>以这种形式被分享。</li>
</ul>
<h4 id="标签化模块名并记录在文档中"><a href="#%E6%A0%87%E7%AD%BE%E5%8C%96%E6%A8%A1%E5%9D%97%E5%90%8D%E5%B9%B6%E8%AE%B0%E5%BD%95%E5%9C%A8%E6%96%87%E6%A1%A3%E4%B8%AD"></a>标签化模块名并记录在文档中</h4>
<p>为我们的模块创建并遵循一个命名约定将使得模块易于理解与使用。这将促进模块的采用和贡献。以下是一个用以提升模块元素一致性的建议列表：</p>
<ul>
<li>使用一个对人类来说一致且易于理解的模块命名约定。举例来说：</li>
</ul>
<table>
<thead>
<tr>
<th>terraform</th>
<th>cloud provider</th>
<th>function</th>
<th>full name</th>
</tr>
</thead>
<tbody>
<tr>
<td>terraform</td>
<td>aws</td>
<td>consul cluster</td>
<td><code>terraform-aws-consul_cluser</code></td>
</tr>
<tr>
<td>terraform</td>
<td>aws</td>
<td>security module</td>
<td><code>terraform-aws-security</code></td>
</tr>
<tr>
<td>terraform</td>
<td>azure</td>
<td>database</td>
<td><code>terraform-azure-database</code></td>
</tr>
</tbody>
</table>
<ul>
<li>使用人类可以理解的输入变量命名约定。模块是编写一次并多次使用的代码，因此请完整命名所有内容以提升可读性，并在编写代码时在文档中进行记录。</li>
<li>对所有模块进行文档记录。确保文档中包含有：
<ul>
<li>必填的输入变量：这些输入变量应该是经过深思熟虑后的选择。如果这些输入变量值未定义，模块运行将失败。只在必要时为这些输入变量设置默认值。例如 <code>var.vpc_id</code> 永远不应该有默认值，因为每次使用模块时值都会不同。</li>
<li>可选的输入变量：这些输入变量应该有一个合理的，适用于大多数场景的默认值，同时又可以根据需求进行调整。公告输入变量的默认值。例如 <code>var.elb_idle_timeout</code> 会有一个合理的默认值，但调用者也可以根据需求修改它的值。</li>
<li>输出值：列出模块的所有输出值，并将重要的输出和信息性的输出包装在对用户友好的输出模板中。</li>
</ul>
</li>
</ul>
<h4 id="定义并使用一个一致的模块结构"><a href="#%E5%AE%9A%E4%B9%89%E5%B9%B6%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E4%B8%80%E8%87%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"></a>定义并使用一个一致的模块结构</h4>
<p>虽然模块结构是一个品味问题，我们应当将模块的结构记录在文档中，并且在我们的所有模块之间保持统一的结构。为了要维持模块结构的一致：</p>
<ul>
<li>定义一组模块必须包含的 <code>.tf</code> 文件，定义它们应包含哪些内容</li>
<li>为模块定义一个 <code>.gitignore</code>(或类似作用的)文件</li>
<li>创建供样例代码所使用的输入变量值的标准方式（例如一个 <code>terraform.tfvars.example</code> 文件）</li>
<li>使用具有固定子目录的一致的目录结构，即使它们可能是空的</li>
<li>所有模块目录都必须包含一个 <code>README</code> 文件详细记述目录存在的目的以及如何使用其中的文件</li>
</ul>
<h2 id="1-6-5-1-4-模块的协作"><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8D%8F%E4%BD%9C"></a>1.6.5.1.4. 模块的协作</h2>
<p>随着团队模块的开发工作，简化我们的协作。</p>
<ol>
<li>为每个模块创建路线图</li>
<li>从用户处收集需求信息，并按受欢迎程度进行优先级排序。
<ul>
<li>不使用模块的最常见原因是“它不符合我的要求”。收集这些需求并将它们添加到路线图或对用户的工作流程提出建议。</li>
<li>检查每一项需求以确认它引用的用例是否正确。</li>
<li>公布和维护需求列表。分享该列表并让用户参与列表管理过程。</li>
<li>不要为边缘用例排期。</li>
</ul>
</li>
<li>将每一个决策记录进文档。</li>
<li>在公司内部采用开源社区原则。一些用户希望尽可能高效地使用这些模块，而另一些用户则希望帮助创建这些模块。
<ul>
<li>创建一个社区</li>
<li>维护一份清晰和公开的贡献指引</li>
<li>最终，我们将允许可信的社区成员获得某些模块的所有权</li>
</ul>
</li>
</ol>
<h2 id="1-6-5-1-5-使用源代码控制系统追踪模块"><a href="#%E4%BD%BF%E7%94%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%BF%BD%E8%B8%AA%E6%A8%A1%E5%9D%97"></a>1.6.5.1.5. 使用源代码控制系统追踪模块</h2>
<p>一个 Terraform 模块应遵守所有良好的代码实践：</p>
<ul>
<li>将模块置于源代码控制中以管理版本发布、协作、变更的审计跟踪。</li>
<li>为所有 <code>main</code> 分支的发布版本建立版本标签，记录文档（最起码在 <code>CHANGELOG</code> 及 <code>README</code> 中记录）。</li>
<li>对 <code>main</code> 分支的所有变更进行代码审查</li>
<li>鼓励模块的用户通过版本标签引用模块</li>
<li>为每一个模块指派一位负责人</li>
<li>一个代码仓库只负责一个模块
<ul>
<li>这对于模块的幂等性和作为库的功能至关重要。</li>
<li>我们应该对模块打上版本标签或是版本化控制。打上版本标签或是版本化的模块应该是不可变的。</li>
<li>发布到私有模块注册表的模块必须要有版本标签。</li>
</ul>
</li>
</ul>
<h2 id="1-6-5-1-6-开发一套模块消费工作流"><a href="#%E5%BC%80%E5%8F%91%E4%B8%80%E5%A5%97%E6%A8%A1%E5%9D%97%E6%B6%88%E8%B4%B9%E5%B7%A5%E4%BD%9C%E6%B5%81"></a>1.6.5.1.6. 开发一套模块消费工作流</h2>
<p>定义和宣传一套消费者团队使用模块时应遵循的可重复工作流程。这个工作流程，就像模块本身一样，应该考虑到用户的需求。</p>
<h3 id="1-6-5-1-6-1-阐明团队应该如何使用模块"><a href="#%E9%98%90%E6%98%8E%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"></a>1.6.5.1.6.1. 阐明团队应该如何使用模块</h3>
<ul>
<li><strong>分散的安全性</strong>：如果每个模块都在自己的存储库中进行版本控制，则可以使用存储库 RBAC 来管理谁拥有写访问权限，从而允许相关团队管理相关的基础设施（例如网络团队拥有对网络模块的写访问权限）。</li>
<li><strong>培育代码社区</strong>：鉴于上述建议，模块开发的最佳实践是允许对存储在私有模块存储库中的模块的所有模块存储库提出 Pull Request。这促进了组织内的代码社区，保持模块内容的相关性和最大的灵活性，并有助于保持模块注册表的长期有效性。</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2023/01/23/Teraform/Terraform-%E6%A8%A1%E5%9D%97/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2023/01/21/Teraform/Terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"
                            aria-label=": Terraform 文件与目录"
                        >
                            Terraform 文件与目录
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-21T17:43:45+08:00">
	
		    2023 年 1 月 21 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/devops/">devops</a>, <a class="category-link" href="../../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="Terraform-文件与目录"><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/">Terraform 文件与目录</a></h2>
<ul>
<li>
<p><a href="#terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95"><strong>1.5.1.</strong> Terraform 文件与目录</a></p>
</li>
<li>
<p><a href="#%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81"><strong>1.5.1.1.</strong> 文本编码</a></p>
</li>
<li>
<p><a href="#%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E6%A8%A1%E5%9D%97"><strong>1.5.1.2.</strong> 文件夹与模块</a></p>
</li>
<li>
<p><a href="#%E6%A0%B9%E6%A8%A1%E5%9D%97"><strong>1.5.1.3.</strong> 根模块</a></p>
</li>
</ul>
<p><a href="#terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95"></a></p>
<h2 id="1-5-1-Terraform-文件与目录"><a href="#terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95"></a>1.5.1. Terraform 文件与目录</h2>
<p>Terraform 语言的代码存储在文件扩展名为 <code>.tf</code> 的纯文本文件中。该语言还有一种基于 JSON 的变体，以 <code>.tf.json</code> 文件扩展名命名（本书精力所限将不涉及这方面的内容）。 包含 Terraform 代码的文件通常称为配置文件。</p>
<h2 id="1-5-1-1-文本编码"><a href="#%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81"></a>1.5.1.1. 文本编码</h2>
<p>配置文件必须始终使用 UTF-8 编码，并且按照惯例通常使用 Unix 样式行结束符 (LF)，而不是 Windows 样式行结束符 (CRLF)，尽管两者都被接受。</p>
<h2 id="1-5-1-2-文件夹与模块"><a href="#%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E6%A8%A1%E5%9D%97"></a>1.5.1.2. 文件夹与模块</h2>
<p>同一个文件夹中一起保存的一组 <code>.tf</code> 以及 <code>.tf.json</code> 文件组成一个<em>模块</em>。</p>
<p>Terraform 模块仅由直接隶属于该目录的配置文件组成；子目录被视为完全独立的模块，并且不会自动包含在配置中。</p>
<p>Terraform 执行模块中的所有配置文件，最终将整个模块视为单个代码文件。将各个块分成不同的文件纯粹是为了方便读者和维护者，对模块的行为没有影响。</p>
<p>Terraform 模块可以使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html">模块调用</a>将其他模块显式包含到配置中。这些子模块可以来自本地目录（嵌套在父模块的目录中，或磁盘上的任意其他位置），也可以来自 <a target="_blank" rel="noopener" href="https://registry.terraform.io/">Terraform 注册表</a>等外部源。</p>
<h2 id="1-5-1-3-根模块"><a href="#%E6%A0%B9%E6%A8%A1%E5%9D%97"></a>1.5.1.3. 根模块</h2>
<p>Terraform 始终在单一的根模块的上下文中运行。完整的 Terraform 配置由根模块和子模块树组成（其中包括根模块调用的模块、以及由这些模块调用的任何模块等）。</p>
<ul>
<li>
<p>在 Terraform 命令行 中，根模块是执行 Terraform 命令的工作目录。 （我们可以使用命令行参数来指定不同于当前工作目录的根模块，但实际上这种情况很少见。）</p>
</li>
<li>
<p>在 HCP Terraform 和 Terraform Enterprise 中，工作区的根模块默认为配置目录的顶层（通过版本控制存储库或直接上传提供），但工作区设置可以指定要使用的子目录。</p>
</li>
<li>
<p><a href="#%E9%87%8D%E8%BD%BDoverride-%E6%96%87%E4%BB%B6"><strong>1.5.1.1.</strong> 重载(Override) 文件</a></p>
</li>
<li>
<p><a href="#%E7%A4%BA%E4%BE%8B"><strong>1.5.1.1.1.</strong> 示例</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6%E8%A7%84%E5%88%99"><strong>1.5.1.1.2.</strong> 合并规则</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-resource-%E5%92%8C-data-%E5%9D%97"><strong>1.5.1.1.2.1.</strong> 合并 resource 和 data 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-variable-%E5%9D%97"><strong>1.5.1.1.2.2.</strong> 合并 variable 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-output-%E5%9D%97"><strong>1.5.1.1.2.3.</strong> 合并 output 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-locals-%E5%9D%97"><strong>1.5.1.1.2.4.</strong> 合并 locals 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-terraform-%E5%9D%97"><strong>1.5.1.1.2.5.</strong> 合并 terraform 块</a></p>
</li>
</ul>
<p><a href="#%E9%87%8D%E8%BD%BDoverride-%E6%96%87%E4%BB%B6"></a></p>
<h2 id="1-5-1-1-重载-Override-文件"><a href="#%E9%87%8D%E8%BD%BDoverride-%E6%96%87%E4%BB%B6"></a>1.5.1.1. 重载(Override) 文件</h2>
<p>Terraform 通常会加载目录中的所有 <code>.tf</code> 和 <code>.tf.json</code> 文件，并假设每个文件中配置的对象是不同的。如果两个文件尝试定义同一对象，Terraform 将返回错误。</p>
<p>在某些极少数情况下，能够很方便地重载某一文件中声明配置的对象的指定部分。例如，可以使用 JSON 语法以编程方式生成的文件部分重载那些使用 HCL 语法人工编辑的 Terraform 配置文件。</p>
<p>对于这些不常见的场景，Terraform 对名称以 <code>_override.tf</code> 或 <code>_override.tf.json</code> 结尾的配置文件进行特殊处理。这种特殊处理也适用于字面名称为 <code>override.tf</code> 或 <code>override.tf.json</code> 的文件。</p>
<p>Terraform 最初在加载配置时跳过这些重载文件，然后依次处理每个文件（按字典顺序）。对于重载文件中定义的每个顶级块，Terraform 尝试查找与该块对应的已定义对象，然后将重载块的内容合并到现有对象中。</p>
<p>请确保仅在特殊情况下使用重载文件。过度使用重载文件会损害可读性，因为仅查看原始文件的读者无法在不查阅所有重载文件的情况下轻松地认识到这些文件的某些部分已被重载。使用重载文件时，请在原文件中对重载文件修改的每一个块添加注释警告。</p>
<h2 id="1-5-1-1-1-示例"><a href="#%E7%A4%BA%E4%BE%8B"></a>1.5.1.1.1. 示例</h2>
<p>假设我们有一个名为 <code>example.tf</code> 的文件中包含如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  ami           = &quot;ami-408c7f28&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，创建名为 <code>override.tf</code> 的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami = &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 会将后者合并到前者中，其行为就好比我们一开始就写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  ami           = &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-1-1-2-合并规则"><a href="#%E5%90%88%E5%B9%B6%E8%A7%84%E5%88%99"></a>1.5.1.1.2. 合并规则</h2>
<p>不同的块类型所对应的合并行为略有不同，某些块内的一些特殊结构以特殊方式合并。</p>
<p>适用于大多数情况的一般规则是：</p>
<ul>
<li>重载文件中的顶级块与具有相同<em>块头</em>的普通配置文件中的块合并。<em>块头</em>是块类型及其后面的所有标签。</li>
<li>顶级块中的属性值将被替换为重载块中的同名属性值。</li>
<li>顶级块中的内嵌块全部都会被重载块中相同类型的块替换。任何未出现在重载块中的块类型仍保留在原始块中。</li>
<li>内嵌块的内容不会合并。</li>
<li>合并后的块仍必须符合所有适用于该类型块的验证规则。</li>
</ul>
<p>如果多个重载文件定义相同的顶级块，则重载效果会叠加，后面的块优先于前面的块。重载首先按文件名（按字典顺序）然后按每个文件中的位置进行处理。</p>
<p>以下部分描述了适用于某些顶级块类型中的特定参数的特殊合并行为。</p>
<h3 id="1-5-1-1-2-1-合并-resource-和-data-块"><a href="#%E5%90%88%E5%B9%B6-resource-%E5%92%8C-data-%E5%9D%97"></a>1.5.1.1.2.1. 合并 resource 和 data 块</h3>
<p>在 <code>resource</code> 块内，所有 <code>lifecycle</code> 块的内容都会按参数进行合并。例如，如果重载块仅设置了 <code>create_before_destroy</code> 参数，则原始块中 <code>ignore_changes</code> 参数会被保留。</p>
<p>如果重载 <code>resource</code> 块包含一个或多个 <code>provisioner</code> 块，则原始块中的所有 <code>provisioner</code> 块都将被忽略。</p>
<p>如果重载 <code>resource</code> 块包含 <code>connection</code> 块，则它完全取代原始块中存在的所有 <code>connection</code> 块。</p>
<p>不允许在重载块中声明 <code>depends_on</code> 元参数，那将会返回错误。</p>
<h3 id="1-5-1-1-2-2-合并-variable-块"><a href="#%E5%90%88%E5%B9%B6-variable-%E5%9D%97"></a>1.5.1.1.2.2. 合并 variable 块</h3>
<p><code>variable</code> 块内的参数按照上述的标准方式合并，但由于 <code>type</code> 和 <code>default</code> 参数之间存在相互作用，有一些特殊规则。</p>
<p>如果原始块定义了 <code>default</code> 值并且重载块更改了变量的 <code>type</code>，Terraform 会尝试将默认值转换为重载的类型，如果无法进行这样的转换，则会产生错误。</p>
<p>相反，如果原始块定义 <code>type</code> 并且重载块更改 <code>default</code> 值，则重载的默认值必须与原始块定义的类型兼容。</p>
<h3 id="1-5-1-1-2-3-合并-output-块"><a href="#%E5%90%88%E5%B9%B6-output-%E5%9D%97"></a>1.5.1.1.2.3. 合并 output 块</h3>
<p>不允许在重载块中声明 <code>depends_on</code> 元参数，那将会返回错误。</p>
<h3 id="1-5-1-1-2-4-合并-locals-块"><a href="#%E5%90%88%E5%B9%B6-locals-%E5%9D%97"></a>1.5.1.1.2.4. 合并 locals 块</h3>
<p>每个 <code>locals</code> 块定义了键值对。重载是在逐个值进行的，不论它们定义在哪个 <code>locals</code> 块中。</p>
<h3 id="1-5-1-1-2-5-合并-terraform-块"><a href="#%E5%90%88%E5%B9%B6-terraform-%E5%9D%97"></a>1.5.1.1.2.5. 合并 terraform 块</h3>
<p><code>terraform</code> 块内的配置在合并时会有不同的规则。</p>
<p>如果设置了 <code>required_providers</code> 参数，则其值将以 Provider 的尺度进行合并，这允许重载块调整单个 Provider 的约束，而不影响其他 Provider 的约束。</p>
<p>在 <code>required_version</code> 和 <code>required_providers</code> 设置中，所有重载的约束都会彻底替换原始块中同一组件的约束。如果原始块和重载块都设置了 <code>required_version</code>，则原始块中的约束将被彻底忽略。</p>
<p>重载文件中定义 Backend（<code>cloud</code>或 <code>backend</code>）的块始终优先于原始配置中定义 Backend 的块。也就是说，如果在原始配置中设置了 <code>cloud</code> 块，并在重载文件中设置了 <code>backend</code> 块，则 Terraform 将在合并时使用重载文件中指定的 <code>backend</code> 块。同样，如果在原始配置中设置了 <code>backend</code> 块，并且在重载文件中设置了 <code>cloud</code> 块，则 Terraform 将在合并时使用重载文件中指定的 <code>cloud</code> 块。</p>
<ul>
<li>
<p><a href="#%E4%BE%9D%E8%B5%96%E9%94%81dependency-lock%E6%96%87%E4%BB%B6"><strong>1.5.2.1.</strong> 依赖锁(Dependency Lock)文件</a></p>
</li>
<li>
<p><a href="#%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE"><strong>1.5.2.1.1.</strong> 锁文件的位置</a></p>
</li>
<li>
<p><a href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A1%8C%E4%B8%BA"><strong>1.5.2.1.2.</strong> 安装依赖的行为</a></p>
</li>
<li>
<p><a href="#%E9%AA%8C%E8%AF%81%E6%A0%A1%E9%AA%8C%E5%92%8C"><strong>1.5.2.1.2.1.</strong> 验证校验和</a></p>
</li>
<li>
<p><a href="#%E7%90%86%E8%A7%A3%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E6%9B%B4"><strong>1.5.2.1.3.</strong> 理解锁文件的变更</a></p>
</li>
<li>
<p><a href="#%E6%96%B0-provider-%E7%9A%84%E4%BE%9D%E8%B5%96"><strong>1.5.2.1.3.1.</strong> 新 Provider 的依赖</a></p>
</li>
<li>
<p><a href="#%E7%8E%B0%E5%AD%98-provider-%E7%9A%84%E6%96%B0%E7%89%88%E6%9C%AC"><strong>1.5.2.1.3.2.</strong> 现存 Provider 的新版本</a></p>
</li>
<li>
<p><a href="#%E6%96%B0-provider-%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%A0%A1%E9%AA%8C%E5%92%8C"><strong>1.5.2.1.3.3.</strong> 新 Provider 程序包校验和</a></p>
</li>
<li>
<p><a href="#%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84-provider"><strong>1.5.2.1.3.4.</strong> 那些不再被使用的 Provider</a></p>
</li>
</ul>
<p><a href="#%E4%BE%9D%E8%B5%96%E9%94%81dependency-lock%E6%96%87%E4%BB%B6"></a></p>
<h2 id="1-5-2-1-依赖锁-Dependency-Lock-文件"><a href="#%E4%BE%9D%E8%B5%96%E9%94%81dependency-lock%E6%96%87%E4%BB%B6"></a>1.5.2.1. 依赖锁(Dependency Lock)文件</h2>
<p><strong>注意</strong>：该功能是自 Terraform 0.14 起引入的一项功能。 Terraform 的更早期版本不跟踪依赖项，因此本节与这些早期版本无关。</p>
<p>Terraform 配置文件中可以引用来自其自身代码库之外的两种不同类型的外部依赖项：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html">Providers</a>，它们是 Terraform 的插件，用以与各种外部系统交互。</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/">模块</a>，允许将一组 Terraform 配置（用 Terraform 语言编写）拆分为可重用的抽象组件。</li>
</ul>
<p>这两种类型的依赖都可以独立于 Terraform 本身以及依赖于它们的代码进行发布和更新。因此，Terraform 必须确定这些依赖项的哪些版本可能与当前配置兼容以及当前选择使用哪些版本。</p>
<p>配置本身内的版本约束决定了哪些版本的依赖项可能与当前配置兼容，但在为每个依赖项选定的特定版本后，Terraform 会记住它在依赖锁文件中所做的决定，以便它可以（默认情况下）在将来再次做出相同的决定。</p>
<p>目前，依赖锁文件<strong>仅追踪</strong> Provider 的依赖项。 Terraform 不会保存远程模块的版本选择，因此 Terraform 将始终选择满足指定版本约束的最新可用模块版本。我们可以使用精确的版本约束来确保 Terraform 始终选择相同版本的模块。</p>
<h2 id="1-5-2-1-1-锁文件的位置"><a href="#%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE"></a>1.5.2.1.1. 锁文件的位置</h2>
<p>依赖锁文件是记录的是整个配置的依赖，而不是配置代码中使用每个单独的模块的依赖。因此，Terraform 在运行 Terraform 时的当前工作目录中创建该文件，并假设该文件存在于此，同时该目录也包含了配置根模块的 <code>.tf</code> 文件的。</p>
<p>依赖锁文件的名字始终是 <code>.terraform.lock.hcl</code>，此名称旨在表示它是 Terraform 缓存在工作目录的 <code>.terraform</code> 子目录中的各种项目的锁定文件。</p>
<p>每次运行 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/12.init.html"><code>terraform init</code> 命令</a>时，Terraform 都会自动创建或更新依赖项锁定文件。我们应该将此文件包含在版本控制存储库中，以便我们可以在代码审查过程中对那些外部依赖项的更改进行审查，就像对配置本身的更改进行审查一样。</p>
<p>依赖锁定文件使用与 Terraform 语言相同的语法，但依赖锁定文件本身并不是 Terraform 语言配置文件。它以后缀 <code>.hcl</code> 而不是 <code>.tf</code> 命名，以显示这种差异。</p>
<h2 id="1-5-2-1-2-安装依赖的行为"><a href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A1%8C%E4%B8%BA"></a>1.5.2.1.2. 安装依赖的行为</h2>
<p>当 <code>terraform init</code> 正在安装配置所需的所有 Provider 程序时，Terraform 会同时参考配置中的版本约束以及锁定文件中记录的版本选择。</p>
<p>如果某个 Provider 程序没有在锁文件中找到对应的记录，Terraform 将选择与给定版本约束匹配的最新可用版本，然后更新锁定文件以保存该选择。</p>
<p>如果某个 Provider 程序已在锁文件中保存了一个版本选择记录，Terraform 将始终重新选择该版本进行安装，即使有更新的版本可用。我们可以通过在运行 <code>terraform init</code> 时添加 <code>-upgrade</code> 选项来重载该行为，在这种情况下，Terraform 将忽略现有选择并再次选择与版本约束匹配的最新可用版本。</p>
<p>如果某次 <code>terraform init</code> 调用对锁文件进行了更改，Terraform 会在其输出中提到这一点：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Terraform has made some changes to the provider dependency selections recorded</span><br><span class="line">in the .terraform.lock.hcl file. Review those changes and commit them to your</span><br><span class="line">version control system if they represent changes you intended to make.</span><br></pre></td></tr></table></figure>
<p>当我们看到这样的消息时，我们可以使用版本控制系统来<a href="#%E7%90%86%E8%A7%A3%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E6%9B%B4">查看 Terraform 提到的那些在文件中的变更</a>，如果变更的确是我们有意为之的，那我们可以将这些变更发送至团队的常规代码审核流程进行审查。</p>
<h3 id="1-5-2-1-2-1-验证校验和"><a href="#%E9%AA%8C%E8%AF%81%E6%A0%A1%E9%AA%8C%E5%92%8C"></a>1.5.2.1.2.1. 验证校验和</h3>
<p>Terraform 还将验证它安装的每个包是否与之前在锁定文件中记录的校验和至少一个相匹配（如果有），如果没有校验和匹配，则返回错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error: Failed to install provider</span><br><span class="line"></span><br><span class="line">Error while installing hashicorp/azurerm v2.1.0: the current package for</span><br><span class="line">registry.terraform.io/hashicorp/azurerm 2.1.0 doesn&#x27;t match any of the</span><br><span class="line">checksums previously recorded in the dependency lock file.</span><br></pre></td></tr></table></figure>
<p>此校验和验证采用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Trust_on_first_use">“<em>初次使用时信任</em>”</a>原则。当我们第一次添加新的 Provider 程序时，我们可以通过各种方式或相关法规要求的所有方法对其进行验证，然后确信如果未来运行 <code>terraform init</code> 时，在安装相同 Provider 程序时遇到不匹配的包时 Terraform 会返回错误。</p>
<p>“初次使用时”模型有两个特殊考虑因素：</p>
<ul>
<li>如果我们从源注册表安装 Provider 程序时，该 Provider 程序提供了使用加密签名算法签名的校验和，那么只要有一个校验和匹配，Terraform 就会将所有已签名的校验和视为有效。因此，锁文件将包含该 Provider 所适用的所有平台的所有不同包的校验和。</li>
</ul>
<p>在这种情况下，<code>terraform init</code> 的输出将包括对校验和进行签名的密钥的指纹，以及像这样的信息 <code>(signed by a HashiCorp partner, key ID DC9FC6B1FCE47986)</code>。在提交包含签名校验和的锁文件之前，最好先确认我们能够信任给该密钥的持有者，或者检索并验证指定 Provider 版本的所有可用包的集合。</p>
<ul>
<li>如果我们首次安装 Provider 时使用的是替代安装方法（例如文件系统或网络镜像），Terraform 将无法验证除运行 <code>terraform init</code> 的平台之外的其他所有平台的校验和，因此它不会记录其他平台的校验和，导致该配置将无法在任何其他平台上使用。</li>
</ul>
<p>为了避免此问题，您可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/15.providers/3.lock.html"><code>terraform providers lock</code> 命令</a>在锁文件中预先记录各种不同平台的校验和，这样我们将来可以调用 <code>terraform init</code> 命令来验证我们选择的镜像中可用的包是否与该 Provider 源注册表提供的官方包相匹配。</p>
<h2 id="1-5-2-1-3-理解锁文件的变更"><a href="#%E7%90%86%E8%A7%A3%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E6%9B%B4"></a>1.5.2.1.3. 理解锁文件的变更</h2>
<p>由于依赖锁文件主要由 Terraform 本身自动维护，而不是手动更新，因此我们的版本控制系统可能会向我们显示该文件已更改。</p>
<p>Terraform 可能会对我们的锁文件进行几种不同类型的变更，我们可能需要了解这些更改才能查看建议的变更。以下各节将描述这些常见变更。</p>
<h3 id="1-5-2-1-3-1-新-Provider-的依赖"><a href="#%E6%96%B0-provider-%E7%9A%84%E4%BE%9D%E8%B5%96"></a>1.5.2.1.3.1. 新 Provider 的依赖</h3>
<p>如果我们向配置中任意模块的 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html#provider-%E7%9A%84%E5%A3%B0%E6%98%8E">Provider 的声明</a>配置节中添加新条目，或者添加了包含新 Provider 程序依赖项的外部模块，<code>terraform init</code> 将通过选择满足配置中所有版本约束的最新版本的 Provider 程序，并将这条决策保存为依赖锁文件中的一个新的 Provider 程序块。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- .terraform.lock.hcl 2020-10-07 16:12:07.539570634 -0700</span></span><br><span class="line"><span class="comment">+++ .terraform.lock.hcl 2020-10-07 16:12:15.267487237 -0700</span></span><br><span class="line"><span class="meta">@@ -6,6 +6,26 @@</span></span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+provider &quot;registry.terraform.io/hashicorp/azurerm&quot; &#123;</span></span><br><span class="line"><span class="addition">+  version     = &quot;2.30.0&quot;</span></span><br><span class="line"><span class="addition">+  constraints = &quot;~&gt; 2.12&quot;</span></span><br><span class="line"><span class="addition">+  hashes = [</span></span><br><span class="line"><span class="addition">+    &quot;h1:FJwsuowaG5CIdZ0WQyFZH9r6kIJeRKts9+GcRsTz1+Y=&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;h1:c/ntSXrDYM1mUir2KufijYebPcwKqS9CRGd3duDSGfY=&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;h1:yre4Ph76g9H84MbuhZ2z5MuldjSA4FsrX6538O7PCcY=&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:04f0a50bb2ba92f3bea6f0a9e549ace5a4c13ef0cbb6975494cac0ef7d4acb43&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:2082e12548ebcdd6fd73580e83f626ed4ed13f8cdfd51205d8696ffe54f30734&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:246bcc449e9a92679fb30f3c0a77f05513886565e2dcc66b16c4486f51533064&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:24de3930625ac9014594d79bfa42d600eca65e9022b9668b54bfd0d924e21d14&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:2a22893a576ff6f268d9bf81cf4a56406f7ba79f77826f6df51ee787f6d2840a&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:2b27485e19c2aaa9f15f29c4cff46154a9720647610171e30fc6c18ddc42ec28&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:435f24ce1fb2b63f7f02aa3c84ac29c5757cd29ec4d297ed0618423387fe7bd4&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:7d99725923de5240ff8b34b5510569aa4ebdc0bdb27b7bac2aa911a8037a3893&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:7e3b5d0af3b7411dd9dc65ec9ab6caee8c191aee0fa7f20fc4f51716e67f50c0&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:da0af4552bef5a29b88f6a0718253f3bf71ce471c959816eb7602b0dadb469ca&quot;,</span></span><br><span class="line"><span class="addition">+  ]</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> provider &quot;registry.terraform.io/newrelic/newrelic&quot; &#123;</span><br><span class="line">   version     = &quot;2.1.2&quot;</span><br><span class="line">   constraints = &quot;~&gt; 2.1.1&quot;</span><br></pre></td></tr></table></figure>
<p>新的锁文件条目记录了几条信息：</p>
<ul>
<li><code>version</code>：Terraform 根据配置中的版本约束所选择的版本。</li>
<li><code>constraints</code>：Terraform 在进行此选择时所遵守的所有的版本约束。 （Terraform 实际上并不使用此信息来做出安装决策，而是保存该信息以帮助向人类读者解释之前的决策是如何做出的。）</li>
<li><code>hashes</code>：给定 Provider 程序在不同平台上有效的安装包所对应的一组校验和。这些哈希值的含义在下面的<a href="#%E6%96%B0-provider-%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%A0%A1%E9%AA%8C%E5%92%8C">新 Provider 程序包校验和</a>中有进一步的解释。</li>
</ul>
<h3 id="1-5-2-1-3-2-现存-Provider-的新版本"><a href="#%E7%8E%B0%E5%AD%98-provider-%E7%9A%84%E6%96%B0%E7%89%88%E6%9C%AC"></a>1.5.2.1.3.2. 现存 Provider 的新版本</h3>
<p>如果我们运行 <code>terraform init -upgrade</code> 来命令 Terraform 在遵守配置的版本约束匹配的前提下将 Provider 升级到更新的版本，那么 Terraform 可能会为 Provider 程序选择较新的版本并更新其现有的 Provider 程序块，以体现该变更。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- .terraform.lock.hcl 2020-10-07 16:44:25.819579509 -0700</span></span><br><span class="line"><span class="comment">+++ .terraform.lock.hcl 2020-10-07 16:43:42.785665945 -0700</span></span><br><span class="line"><span class="meta">@@ -7,22 +7,22 @@</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> provider &quot;registry.terraform.io/hashicorp/azurerm&quot; &#123;</span><br><span class="line"><span class="deletion">-  version     = &quot;2.1.0&quot;</span></span><br><span class="line"><span class="deletion">-  constraints = &quot;~&gt; 2.1.0&quot;</span></span><br><span class="line"><span class="addition">+  version     = &quot;2.0.0&quot;</span></span><br><span class="line"><span class="addition">+  constraints = &quot;2.0.0&quot;</span></span><br><span class="line">   hashes      = [</span><br><span class="line"><span class="deletion">-    &quot;h1:EOJImaEaVThWasdqnJjfYc6/P8N/MRAq1J7avx5ZbV4=&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:0015b491cf9151235e57e35ea6b89381098e61bd923f56dffc86026d58748880&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:4c5682ba1e0fc7e2e602d3f103af1638f868c31fe80cc1a884a97f6dad6e1c11&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:57bac885b108c91ade4a41590062309c832c9ab6bf6a68046161636fcaef1499&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:5810d48f574c0e363c969b3f45276369c8f0a35b34d6202fdfceb7b85b3ac597&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:5c6e37a44462b8662cf9bdd29ce30523712a45c27c5d4711738705be0785db41&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:64548940a3387aa3a752e709ee9eb9982fa820fe60eb60e5f212cc1d2c58549e&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:7f46749163da17330bbb5293dc825333c86304baa0a7c6256650ac536b4567c8&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:8f8970f2df75ac43ffdd112055ee069d8bd1030f7eb4367cc4cf494a1fa802c3&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:9ad693d00dc5d7d455d06faba70e716bce727c6706f7293288e87fd7956b8fe0&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:b6e3cb55e6aec62b47edd0d2bd5e14bd6a2bcfdac65930a6e9e819934734c57b&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:d6a3f3b9b05c28ecf3919e9e7afa185805a6d7442fc4b3eedba749c2731d1f0e&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:d81fb624a357c57c7ea457ce543d865b39b12f26c2edd58a2f7cd43326c91010&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;h1:bigGXBoRbp7dv79bEEn+aaju8575qEXHQ57XHVPJeB8=&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:09c603c8904ca4a5bc19e82335afbc2837dcc4bee81e395f9daccef2f2cba1c8&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:194a919d4836d6c6d4ce598d0c66cce00ddc0d0b5c40d01bb32789964d818b42&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:1f269627df4e266c4e0ef9ee2486534caa3c8bea91a201feda4bca525005aa0a&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:2bae3071bd5f8e553355c4b3a547d6efe1774a828142b762e9a4e85f79be7f63&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:6c98dfa5c3468e8d02e2b3af7c4a8a14a5d469ce5a642909643b413a17ca338b&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:7af78f61666fd45fbf428161c061ea2623162d601b79dc71d6a5158756853ffa&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:883c2df86ae9ba2a5c167cf5c2c7deca0239171a224d6d335f0fd6dd9c283830&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:a2028379078577d8ff5ecfca6e8a8b25a25ffb1686de0ee52a7fe8011783488b&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:abe6ef399552fd3861a454a839cd978c1d15735658fdc00f9054435aff0f4620&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:c30b1bf14077913c3cdf34979b1434dbb1353cb5995eb3956b191c50538b64a9&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:ca64ae2ad9793e5631e3b0b9327f7cb22cb5d8e9de57be7d85821791b1d5a375&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;zh:fffe56904a38109bb8d613b02808a177c3ddfac19f03b3aac799281fea38f475&quot;,</span></span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>选择新的 Provider 程序版本的对锁文件进行的修改主要是更改了 <code>provider</code> 块中 <code>version</code> 的值。如果升级伴随着对配置文件中声明的版本约束的变更，Terraform 还将在 <code>constraints</code> 中记录该变更。</p>
<p>由于每个版本都有自己的一组分发包，因此切换到新版本也往往会替换 <code>hashes</code> 中的所有值，以体现新版本包的校验和。</p>
<h3 id="1-5-2-1-3-3-新-Provider-程序包校验和"><a href="#%E6%96%B0-provider-%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%A0%A1%E9%AA%8C%E5%92%8C"></a>1.5.2.1.3.3. 新 Provider 程序包校验和</h3>
<p>我们可能在 <code>provider</code> 块中看到的一个很细微的变化是添加了以前未记录的新校验和，即使 <code>provider</code> 块中的所有其他内容都没有更改：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- .terraform.lock.hcl 2020-10-07 17:24:23.397892140 -0700</span></span><br><span class="line"><span class="comment">+++ .terraform.lock.hcl 2020-10-07 17:24:57.423130253 -0700</span></span><br><span class="line"><span class="meta">@@ -10,6 +10,7 @@</span></span><br><span class="line">   version     = &quot;2.1.0&quot;</span><br><span class="line">   constraints = &quot;~&gt; 2.1.0&quot;</span><br><span class="line">   hashes = [</span><br><span class="line"><span class="addition">+    &quot;h1:1xvaS5D8B8t6J6XmXxX8spo97tAzjhacjedFX1B47Fk=&quot;,</span></span><br><span class="line">     &quot;h1:EOJImaEaVThWasdqnJjfYc6/P8N/MRAq1J7avx5ZbV4=&quot;,</span><br><span class="line">     &quot;zh:0015b491cf9151235e57e35ea6b89381098e61bd923f56dffc86026d58748880&quot;,</span><br><span class="line">     &quot;zh:4c5682ba1e0fc7e2e602d3f103af1638f868c31fe80cc1a884a97f6dad6e1c11&quot;,</span><br></pre></td></tr></table></figure>
<p>在 <code>hashes</code> 中添加的新的校验和代表 Terraform 在不同哈希方案之间逐渐过渡。这些值上的 <code>h1:</code> 和 <code>zh:</code> 前缀代表不同的哈希方案，每个方案都代表使用不同的算法计算校验和。如果现有方案存在某种局限性或者新方案提供了一些相当明显的收益，有时我们可能会引入新的哈希方案。</p>
<p>目前支持两种哈希方案：</p>
<ul>
<li><code>zh:</code>: 代表“zip hash”，这是一种遗留哈希格式，是 Terraform Provider 程序注册表协议的一部分，因此用于直接从源注册表安装的 Provider 程序。</li>
</ul>
<p>此哈希方案捕记录下注册表中索引的每个官方 <code>.zip</code> 包的 SHA256 哈希值。这是验证从注册表安装的官方发布包的有效方案，但它无法验证来自<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html#provider-%E7%9A%84%E5%AE%89%E8%A3%85">其他 Provider 程序安装方法</a>的包，例如文件系统中指向解压后的安装包的镜像。</p>
<ul>
<li><code>h1:</code>: 代表“hash schema 1”，它是当前首选的哈希方案。</li>
</ul>
<p>Hash Schema 1 也是 SHA256 哈希，但它是根据提供 Provider 安装包内包含的内容计算得出的，而不是根据其包含的 <code>.zip</code> 文件的内容计算得出的。因此，该方案的优点是可以针对官方 <code>.zip</code> 文件、具有相同内容的解压目录或包含相同文件但可能具有不同元数据或压缩方案的重新压缩 <code>.zip</code> 文件计算出相同的校验和。</p>
<p>由于 <code>zh:</code> 方案的局限性，Terraform 将在计算出相应的 <code>h1:</code> 校验和时适时添加它们，这就是导致在上面所示的示例更改中添加第二个 <code>h1:</code> 校验和的原因。</p>
<p>Terraform 只会在安装包与已有哈希值之一相匹配时，才会把新计算出的哈希值添加到锁文件中。在上面的示例中，Terraform 在与生成原始 <code>h1:</code> 校验和的平台不同的平台安装了 <code>hashcorp/azurerm</code> 包，但能够匹配到之前记录的 <code>zh:</code> 校验和的其中之一，确认 <code>zh:</code> 校验和匹配后，Terraform 保存相应的 <code>h1:</code> 校验和，以便逐步从旧方案迁移到新方案。</p>
<p>首次安装某个 Provider 程序时（没有已有的 <code>provider</code> 块），Terraform 将使用 Provider 插件开发人员的加密签名（通常涵盖所有可用包）所涵盖适用于所有受支持平台上的该 Provider 程序版本校验集合来预先填充 <code>hashes</code>。但是，由于 Provider 程序注册表协议仍然使用 <code>zh:</code> 方案，因此初始集将主要包含使用该方案的哈希值，然后当我们在不同平台上安装软件包时，Terraform 将适时升级该哈希值。</p>
<p>如果我们希望避免在新目标平台上使用配置时不断添加新的 <code>h1:</code> 哈希值，或者如果因为我们是从镜像安装的 Provider 程序，因此无法提供官方签名的校验和，您可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/15.providers/3.lock.html"><code>terraform providers lock</code></a> 命令要求 Terraform 预填充一组选定平台的哈希值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terraform providers lock \</span><br><span class="line">  -platform=linux_arm64 \</span><br><span class="line">  -platform=linux_amd64 \</span><br><span class="line">  -platform=darwin_amd64 \</span><br><span class="line">  -platform=windows_amd64</span><br></pre></td></tr></table></figure>
<p>上述命令将下载并验证所有四个给定平台上所有我们指定的 Provider 程序的官方软件包，然后在锁文件中记录每个软件包的 <code>zh:</code> 和 <code>h1:</code> 校验和，从而避免 Terraform 在之后只能得到 <code>h1:</code> 校验和这种情况。有关此命令的更多信息，请参阅 <code>terraform providers lock</code> 命令。</p>
<h3 id="1-5-2-1-3-4-那些不再被使用的-Provider"><a href="#%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84-provider"></a>1.5.2.1.3.4. 那些不再被使用的 Provider</h3>
<p>为了确定是否仍然存在对某个 Provider 程序的依赖，Terraform 使用两个事实来源：配置代码和状态。如果我们从配置和状态中删除对某个 Provider 程序的最后一个依赖项，则 <code>terraform init</code> 将从锁文件中删除该 Provider 的现存记录。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- .terraform.lock.hcl 2020-10-07 16:12:07.539570634 -0700</span></span><br><span class="line"><span class="comment">+++ .terraform.lock.hcl 2020-10-07 16:12:15.267487237 -0700</span></span><br><span class="line"><span class="meta">@@ -6,26 +6,6 @@</span></span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-provider &quot;registry.terraform.io/hashicorp/azurerm&quot; &#123;</span></span><br><span class="line"><span class="deletion">-  version     = &quot;2.30.0&quot;</span></span><br><span class="line"><span class="deletion">-  constraints = &quot;~&gt; 2.12&quot;</span></span><br><span class="line"><span class="deletion">-  hashes = [</span></span><br><span class="line"><span class="deletion">-    &quot;h1:FJwsuowaG5CIdZ0WQyFZH9r6kIJeRKts9+GcRsTz1+Y=&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;h1:c/ntSXrDYM1mUir2KufijYebPcwKqS9CRGd3duDSGfY=&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;h1:yre4Ph76g9H84MbuhZ2z5MuldjSA4FsrX6538O7PCcY=&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:04f0a50bb2ba92f3bea6f0a9e549ace5a4c13ef0cbb6975494cac0ef7d4acb43&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:2082e12548ebcdd6fd73580e83f626ed4ed13f8cdfd51205d8696ffe54f30734&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:246bcc449e9a92679fb30f3c0a77f05513886565e2dcc66b16c4486f51533064&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:24de3930625ac9014594d79bfa42d600eca65e9022b9668b54bfd0d924e21d14&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:2a22893a576ff6f268d9bf81cf4a56406f7ba79f77826f6df51ee787f6d2840a&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:2b27485e19c2aaa9f15f29c4cff46154a9720647610171e30fc6c18ddc42ec28&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:435f24ce1fb2b63f7f02aa3c84ac29c5757cd29ec4d297ed0618423387fe7bd4&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:7d99725923de5240ff8b34b5510569aa4ebdc0bdb27b7bac2aa911a8037a3893&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:7e3b5d0af3b7411dd9dc65ec9ab6caee8c191aee0fa7f20fc4f51716e67f50c0&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;zh:da0af4552bef5a29b88f6a0718253f3bf71ce471c959816eb7602b0dadb469ca&quot;,</span></span><br><span class="line"><span class="deletion">-  ]</span></span><br><span class="line"><span class="deletion">-&#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"> provider &quot;registry.terraform.io/newrelic/newrelic&quot; &#123;</span><br><span class="line">   version     = &quot;2.1.2&quot;</span><br><span class="line">   constraints = &quot;~&gt; 2.1.1&quot;</span><br></pre></td></tr></table></figure>
<p>如果我们稍后为同一 Provider 程序添加新的引用并再次运行 <code>terraform init</code>，Terraform 会将其视为全新的 Provider 程序，因此不一定会选择之前选择的相同版本，并且无法验证校验和是否保持不变。</p>
<p><strong>注意</strong>：在 Terraform v1.0 及更早版本中，<code>terraform init</code> 不会自动从锁文件中删除现在不需要的 Provider 程序，而只是忽略它们。如果您之前使用早期版本的 Terraform 时删除了提供 Provider 依赖项，然后升级到 Terraform v1.1 或更高版本，那么您可能会看到错误“missing or corrupted provider plugins”，指向过时的锁文件条目。如果是这样，请使用新的 Terraform 版本运行 <code>terraform init</code> 以整理那些不需要的条目，然后重试之前的操作。</p>
<ul>
<li>
<p><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6"><strong>1.5.3.1.</strong> 测试文件</a></p>
</li>
<li>
<p><a href="#%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><strong>1.5.3.1.1.</strong> 文件扩展名</a></p>
</li>
<li>
<p><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE"><strong>1.5.3.1.2.</strong> 测试文件的位置</a></p>
</li>
</ul>
<p><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6"></a></p>
<h2 id="1-5-3-1-测试文件"><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6"></a>1.5.3.1. 测试文件</h2>
<p>某些的 Terraform 命令（例如 <code>test</code>、<code>init</code> 和 <code>validate</code>）会针对配置代码加载 Terraform 测试文件。</p>
<p>测试文件包含 Terraform 测试执行的代码。有关 Terraform 测试命令的更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/23.test.html">命令：<code>test</code></a>。有关语法和 Terraform 测试文件语言的更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test/">测试</a>。</p>
<h2 id="1-5-3-1-1-文件扩展名"><a href="#%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"></a>1.5.3.1.1. 文件扩展名</h2>
<p>测试文件的扩展名是 <code>.tftest.hcl</code> 以及 <code>.tftest.json</code>。</p>
<h2 id="1-5-3-1-2-测试文件的位置"><a href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE"></a>1.5.3.1.2. 测试文件的位置</h2>
<p>Terraform 加载根模块目录中的所有测试文件。</p>
<p>Terraform 还会加载测试目录中的测试文件。我们可以通过在那些会加载测试文件的命令后添加 <code>-test-directory</code> 参数来修改测试目录的位置。默认测试目录是根模块目录下的 <code>tests</code> 目录。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2023/01/21/Teraform/Terraform-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2023/01/19/Teraform/Terraform-%E4%BB%A3%E7%A0%81/"
                            aria-label=": Terraform-代码-类型"
                        >
                            Terraform-代码-类型
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-19T17:43:45+08:00">
	
		    2023 年 1 月 19 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/devops/">devops</a>, <a class="category-link" href="../../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#%E7%B1%BB%E5%9E%8B"><strong>1.4.1.1.</strong> 类型</a></p>
</li>
<li>
<p><a href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><strong>1.4.1.1.1.</strong> 原始类型</a></p>
</li>
<li>
<p><a href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"><strong>1.4.1.1.2.</strong> 复杂类型</a></p>
</li>
<li>
<p><a href="#any"><strong>1.4.1.1.3.</strong> any</a></p>
</li>
<li>
<p><a href="#null"><strong>1.4.1.1.4.</strong> null</a></p>
</li>
<li>
<p><a href="#object-%E7%9A%84-optional-%E6%88%90%E5%91%98"><strong>1.4.1.1.5.</strong> object 的 optional 成员</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B8%A6%E6%9C%89-optional-%E5%B1%9E%E6%80%A7%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84"><strong>1.4.1.1.5.1.</strong> 例子：带有 optional 属性和默认值的内嵌结构</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7"><strong>1.4.1.1.5.2.</strong> 例子：有条件地设置一个默认属性</a></p>
</li>
</ul>
<p><a href="#%E7%B1%BB%E5%9E%8B"></a></p>
<h2 id="1-4-1-1-类型"><a href="#%E7%B1%BB%E5%9E%8B"></a>1.4.1.1. 类型</h2>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/8.%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>的结果是一个值。所有的值都有一个类型，这个类型决定了这个值可以在哪里使用以及可以对它应用哪些转换。</p>
<p>Terraform 的某些类型之间存在隐式类型转换规则，如果无法隐式转换类型，那么不同类型数据间的赋值将会报错。</p>
<p>Terraform 类型分为原始类型、复杂类型，以及 <code>null</code>。</p>
<h2 id="1-4-1-1-1-原始类型"><a href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"></a>1.4.1.1.1. 原始类型</h2>
<p>原始类型分三类：<code>string</code>、<code>number</code>、<code>bool</code>。</p>
<ul>
<li><code>string</code> 代表一组 Unicode 字符串，例如：<code>&quot;hello&quot;</code>。</li>
<li><code>number</code> 代表数字，可以为整数，也可以为小数。</li>
<li><code>bool</code> 代表布尔值，要么为 <code>true</code>，要么为 <code>false</code>。<code>bool</code> 值可以被用做逻辑判断。</li>
</ul>
<p><code>number</code> 和 <code>bool</code> 都可以和 <code>string</code> 进行隐式转换，当我们把 <code>number</code> 或 <code>bool</code> 类型的值赋给 <code>string</code> 类型的值，或是反过来时，Terraform 会自动替我们转换类型，其中：</p>
<ul>
<li><code>true</code> 值会被转换为 <code>&quot;true&quot;</code>，反之亦然</li>
<li><code>false</code> 值会被转换为 <code>&quot;false&quot;</code>，反之亦然</li>
<li><code>15</code> 会被转换为 <code>&quot;15&quot;</code>，<code>3.1415</code> 会被转换为 <code>&quot;3.1415&quot;</code>，反之亦然</li>
</ul>
<h2 id="1-4-1-1-2-复杂类型"><a href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"></a>1.4.1.1.2. 复杂类型</h2>
<p>复杂类型是一组值所组成的符合类型，有两类复杂类型。</p>
<p>一种是集合类型。一个集合包含了一组同一类型的值。集合内元素的类型成为元素类型。一个集合变量在构造时必须确定集合类型。集合内所有元素的类型必须相同。</p>
<p>Terraform 支持三种集合：</p>
<ul>
<li>
<p><code>list(...)</code>：列表是一组值的连续集合，可以用下标访问内部元素，下标从 <code>0</code> 开始。例如名为 <code>l</code> 的 <code>list</code>，<code>l[0]</code> 就是第一个元素。<code>list</code> 类型的声明可以是 <code>list(number)</code>、<code>list(string)</code>、<code>list(bool)</code>等，括号中的类型即为元素类型。</p>
</li>
<li>
<p><code>map(...)</code>：字典类型(或者叫映射类型)，代表一组键唯一的键值对，键类型必须是 <code>string</code>，值类型任意。<code>map(number)</code> 代表键为 <code>string</code> 类型而值为 <code>number</code> 类型，其余类推。<code>map</code> 值有两种声明方式，一种是类似 <code>&#123;&quot;foo&quot;: &quot;bar&quot;, &quot;bar&quot;: &quot;baz&quot;&#125;</code>，另一种是 <code>&#123;foo=&quot;bar&quot;, bar=&quot;baz&quot;&#125;</code>。键可以不用双引号，但如果键是以数字开头则例外。多对键值对之间要用逗号分隔，也可以用换行符分隔。推荐使用 <code>=</code> 号(Terraform 代码规范中规定按等号对齐，使用等号会使得代码在格式化后更加美观)</p>
</li>
<li>
<p><code>set(...)</code>：集合类型，代表一组不重复的值。</p>
</li>
</ul>
<p>以上集合类型都支持通配类型缩写，例如 <code>list</code> 等价于 <code>list(any)</code>，<code>map</code> 等价于 <code>map(any)</code>，<code>set</code> 等价于 <code>set(any)</code>。<code>any</code> 代表支持任意的元素类型，前提是所有元素都是一个类型。例如，将 <code>list(number)</code> 赋给 <code>list(any)</code> 是合法的，<code>list(string)</code> 赋给 <code>list(any)</code> 也是合法的，但是 <code>list</code> 内部所有的元素必须是同一种类型的。</p>
<p>第二种复杂类型是结构化类型。一个结构化类型允许多个不同类型的值组成一个类型。结构化类型需要提供一个 <code>schema</code> 结构信息作为参数来指明元素的结构。</p>
<p>Terraform 支持两种结构化类型：</p>
<ul>
<li><code>object(...)</code>：对象是指一组由具有名称和类型的属性所构成的符合类型，它的 schema 信息由 <code>&#123; \&lt;KEY\&gt;=\&lt;TYPE\&gt;, \&lt;KEY\&gt;=\&lt;TYPE\&gt;,...&#125;</code> 的形式描述，例如 <code>object(&#123;age=number, name=string&#125;)</code>，代表由名为 <code>&quot;age“</code> 类型为<code>number</code>，以及名为 <code>&quot;name&quot;</code> 类型为 <code>string</code> 两个属性组成的对象。赋给 <code>object</code> 类型的合法值必须含有所有属性值，但是可以拥有多余的属性(多余的属性在赋值时会被抛弃)。例如对于 <code>object(&#123;age=number,name=string&#125;)</code> 来说，<code>&#123; age=18 &#125;</code> 是一个非法值，而 <code>&#123; age=18, name=&quot;john&quot;, gender=&quot;male&quot; &#125;</code> 是一个合法值，但赋值时 <code>gender</code> 会被抛弃</li>
<li><code>tuple(...)</code>：元组类似 <code>list</code>，也是一组值的连续集合，但每个元素都有独立的类型。元组同 <code>list</code> 一样，也可以用下标访问内部元素，下标从 <code>0</code> 开始。元组 schema 用 <code>[\&lt;TYPE\&gt;, \&lt;TYPE\&gt;, ...]</code> 的形式描述。元组的元素数量必须与 schema 声明的类型数量相等，并且每个元素的类型必须与元组 schema 相应位置的类型相等。例如，<code>tuple([string, number, bool])</code> 类型的一个合法值可以是 <code>[&quot;a&quot;, 15, true]</code></li>
</ul>
<p>复杂类型也支持隐式类型转换。</p>
<p>Terraform 会尝试转换相似的类型，转换规则有：</p>
<ul>
<li><code>object</code> 和 <code>map</code>：如果一个 <code>map</code> 的键集合含有 <code>object</code> 规定的所有属性，那么 <code>map</code> 可以被转换为 <code>object</code>，<code>map</code> 里多余的键值对会被抛弃。由 <code>map</code> -&gt; <code>object</code> -&gt; <code>map</code> 的转换可能会丢失数据。</li>
<li><code>tuple</code> 和 <code>list</code>：当一个 <code>list</code> 元素的数量正好等于一个 <code>tuple</code> 声明的长度时，<code>list</code> 可以被转换为 <code>tuple</code>。例如：值为 <code>[&quot;18&quot;, &quot;true&quot;, &quot;john&quot;]</code> 的 <code>list</code> 转换为 <code>tuple([number,bool, string])</code> 的结果为 <code>[18, true, &quot;john&quot;]</code></li>
<li><code>set</code> 和 <code>tuple</code>：当一个 <code>list</code> 或是 <code>tuple</code> 被转换为一个 <code>set</code>，那么重复的值将被丢弃，并且值原有的顺序也将丢失。如果一个 <code>set</code> 被转换到 <code>list</code> 或是 <code>tuple</code>，那么元素将按照以下顺序排列：如果 <code>set</code> 的元素是 <code>string</code>，那么将按照字段顺序排列；其他类型的元素不承诺任何特定的排列顺序。</li>
</ul>
<p>复杂类型转换时，元素类型将在可能的情况下发生隐式转换，类似上述 <code>list</code> 到 <code>tuple</code> 转换举的例子。</p>
<p>如果类型不匹配，Terraform 会报错，例如我们试图把<code>object(&#123;name = [&quot;Kristy&quot;, &quot;Claudia&quot;, &quot;Mary Anne&quot;, &quot;Stacey&quot;], age = 12&#125;)</code>转换到 <code>map(string)</code> 类型，这是不合法的，因为 <code>name</code> 的值为 <code>list</code>，无法转换为 <code>string</code>。</p>
<h2 id="1-4-1-1-3-any"><a href="#any"></a>1.4.1.1.3. any</h2>
<p><code>any</code> 是 Terraform 中非常特殊的一种类型约束，它本身并非一个类型，而只是一个占位符。每当一个值被赋予一个由 <code>any</code> 约束的复杂类型时，Terraform 会尝试计算出一个最精确的类型来取代 <code>any</code>。</p>
<p>例如我们把 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code> 赋给 <code>list(any)</code>，它在 Terraform 中实际的物理类型首先被编译成 <code>tuple([string, string, string])</code>，然后 Terraform 认为 <code>tuple</code> 和 <code>list</code> 相似，所以会尝试将它转换为 <code>list(string)</code>。然后 Terraform 发现 <code>list(string)</code> 符合 <code>list(any)</code> 的约束，所以会用 <code>string</code> 取代 <code>any</code>，于是赋值后最终的类型是 <code>list(string)</code>。</p>
<p>由于即使是 <code>list(any)</code>，所有元素的类型也必须是一样的，所以某些类型转换到 <code>list(any)</code> 时会对元素进行隐式类型转换。例如将 <code>[&quot;a&quot;, 1, &quot;b&quot;]</code> 赋给 <code>list(any)</code>，Terraform 发现 <code>1</code> 可以转换到 <code>&quot;1&quot;</code>，所以最终的值是 <code>[&quot;a&quot;, &quot;1&quot;, &quot;b&quot;]</code>，最终的类型会是 <code>list(string)</code>。再比如我们想把 <code>[&quot;a&quot;, \[\], &quot;b&quot;]</code> 转换成 <code>list(any)</code>，由于 Terraform 无法找到一个一个合适的目标类型使得所有元素都能成功隐式转换过去，所以 Terraform 会报错，要求所有元素都必须是同一个类型的。</p>
<p>声明类型时如果不想有任何的约束，那么可以用 <code>any</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;no_type_constraint&quot; &#123;</span><br><span class="line">  type = any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，Terraform 可以将任何类型的数据赋予它。</p>
<h2 id="1-4-1-1-4-null"><a href="#null"></a>1.4.1.1.4. null</h2>
<p>存在一种特殊值是无类型的，那就是 <code>null</code>。<code>null</code> 代表数据缺失。如果我们把一个参数设置为 <code>null</code>，Terraform 会认为你忘记为它赋值。如果该参数有默认值，那么 Terraform 会使用默认值；如果没有又恰巧该参数是必填字短，Terraform 会报错。<code>null</code> 在条件表达式中非常有用，你可以在某项条件不满足时跳过对某参数的赋值。</p>
<h2 id="1-4-1-1-5-object-的-optional-成员"><a href="#object-%E7%9A%84-optional-%E6%88%90%E5%91%98"></a>1.4.1.1.5. object 的 optional 成员</h2>
<p>自 Terraform 1.3 开始，我们可以在 <code>object</code> 类型定义中使用 <code>optional</code> 修饰属性。</p>
<p>在 1.3 之前，如果一个 <code>variable</code> 的类型为 <code>object</code>，那么使用时必须传入一个结构完全相符的对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;an_object&quot; &#123;</span><br><span class="line">  type = object(&#123;</span><br><span class="line">    a = string</span><br><span class="line">    b = string</span><br><span class="line">    c = number</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想传入一个对象给 <code>var.an_object</code>，但不准备给 <code>b</code> 和 <code>c</code> 赋值，我们必须这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a = &quot;a&quot;</span><br><span class="line">  b = null</span><br><span class="line">  c = null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入的对象必须完全匹配类型定义的结构，哪怕我们不想对某些属性赋值。这使得我们如果想要定义一些比较复杂，属性比较多的 <code>object</code> 类型时会给用户在使用上造成一些麻烦。</p>
<p>Terraform 1.3 允许我们为一个属性添加 <code>optional</code> 声明，还是用上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;with_optional_attribute&quot; &#123;</span><br><span class="line">  type = object(&#123;</span><br><span class="line">    a = string                # a required attribute</span><br><span class="line">    b = optional(string)      # an optional attribute</span><br><span class="line">    c = optional(number, 127) # an optional attribute with default value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们将 <code>b</code> 声明为 <code>optional</code>，如果传入的对象没有 <code>b</code>，则会使用 <code>null</code> 作为值；<code>c</code> 不但声明为 <code>optional</code> 的，还添加了 <code>127</code> 作为默认值，传入的对象如果没有 <code>c</code>，那么会使用 <code>127</code> 作为它的值。</p>
<p><code>optional</code> 修饰符有这样两个参数：</p>
<ul>
<li>类型：（必填）第一个参数标明了属性的类型</li>
<li>默认值：（选填）第二个参数定义了 Terraform 在对象中没有定义该属性值时使用的默认值。默认值必须与类型参数兼容。如果没有指定默认值，Terraform 会使用 <code>null</code> 作为默认值。</li>
</ul>
<p>一个包含非 <code>null</code> 默认值的 <code>optional</code> 属性在模块内使用时可以确保不会读到 <code>null</code> 值。当用户没有设置该属性，或是显式将其设置为 <code>null</code> 时，Terraform 会使用默认值，所以模块内无需再次判断该属性是否为 <code>null</code>。</p>
<p>Terraform 采用自上而下的顺序来设置对象的默认值，也就是说，Terraform 会先应用 <code>optional</code> 修饰符中的指定的默认值，然后再为其中可能存在的内嵌对象设置默认值。</p>
<h3 id="1-4-1-1-5-1-例子：带有-optional-属性和默认值的内嵌结构"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%B8%A6%E6%9C%89-optional-%E5%B1%9E%E6%80%A7%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84"></a>1.4.1.1.5.1. 例子：带有 optional 属性和默认值的内嵌结构</h3>
<p>下面的例子演示了一个输入变量，用来描述一个存储了静态网站内容的存储桶。该变量的类型包含了一系列的 <code>optional</code> 属性，包括 <code>website</code>，不但其自身是 <code>optional</code> 的，其内部包含了数个 <code>optional</code> 的属性以及默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;buckets&quot; &#123;</span><br><span class="line">  type = list(object(&#123;</span><br><span class="line">    name    = string</span><br><span class="line">    enabled = optional(bool, true)</span><br><span class="line">    website = optional(object(&#123;</span><br><span class="line">      index_document = optional(string, &quot;index.html&quot;)</span><br><span class="line">      error_document = optional(string, &quot;error.html&quot;)</span><br><span class="line">      routing_rules  = optional(string)</span><br><span class="line">    &#125;), &#123;&#125;)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下给出一个样例 <code>terraform.tfvars</code> 文件，为 <code>var.buckets</code> 定义了三个存储桶：</p>
<ul>
<li><code>production</code> 配置了一条重定向的路由规则</li>
<li><code>archived</code> 使用了默认配置，但被关闭了</li>
<li><code>docs</code> 使用文本文件取代了索引页和错误页</li>
</ul>
<p><code>production</code> 桶没有指定索引页和错误页，<code>archived</code> 桶完全忽略了网站配置。Terraform 会使用 <code>bucket</code> 类型约束中指定的默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">buckets = [</span><br><span class="line">  &#123;</span><br><span class="line">    name = &quot;production&quot;</span><br><span class="line">    website = &#123;</span><br><span class="line">      routing_rules = &lt;&lt;-EOT</span><br><span class="line">      [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;Condition&quot; = &#123; &quot;KeyPrefixEquals&quot;: &quot;img/&quot; &#125;,</span><br><span class="line">          &quot;Redirect&quot;  = &#123; &quot;ReplaceKeyPrefixWith&quot;: &quot;images/&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">      EOT</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name = &quot;archived&quot;</span><br><span class="line">    enabled = false</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name = &quot;docs&quot;</span><br><span class="line">    website = &#123;</span><br><span class="line">      index_document = &quot;index.txt&quot;</span><br><span class="line">      error_document = &quot;error.txt&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>该配置会产生如下的 <code>variable</code> 值：</p>
<ul>
<li>对 <code>production</code> 和 <code>docs</code> 桶，Terraform 会将 <code>enabled</code> 设置为 <code>true</code>。Terraform 会同时使用默认值配置 <code>website</code>，然后使用 <code>docs</code> 中指定的值来覆盖默认值。</li>
<li>对 <code>archived</code> 和 <code>docs</code> 桶，Terraform 会将 <code>routing_rules</code> 设置为 <code>null</code>。当 Terraform 没有读取到 <code>optional</code> 的属性，并且属性上没有设置默认值时，Terraform 会将这些属性设置为 <code>null</code>。</li>
<li>对于 <code>archived</code> 桶，Terraform 会将 <code>website</code> 属性设置为 <code>buckets</code> 类型约束中定义的默认值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">tolist([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;enabled&quot; = true</span><br><span class="line">    &quot;name&quot; = &quot;production&quot;</span><br><span class="line">    &quot;website&quot; = &#123;</span><br><span class="line">      &quot;error_document&quot; = &quot;error.html&quot;</span><br><span class="line">      &quot;index_document&quot; = &quot;index.html&quot;</span><br><span class="line">      &quot;routing_rules&quot; = &lt;&lt;-EOT</span><br><span class="line">      [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;Condition&quot; = &#123; &quot;KeyPrefixEquals&quot;: &quot;img/&quot; &#125;,</span><br><span class="line">          &quot;Redirect&quot;  = &#123; &quot;ReplaceKeyPrefixWith&quot;: &quot;images/&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">      EOT</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;enabled&quot; = false</span><br><span class="line">    &quot;name&quot; = &quot;archived&quot;</span><br><span class="line">    &quot;website&quot; = &#123;</span><br><span class="line">      &quot;error_document&quot; = &quot;error.html&quot;</span><br><span class="line">      &quot;index_document&quot; = &quot;index.html&quot;</span><br><span class="line">      &quot;routing_rules&quot; = tostring(null)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;enabled&quot; = true</span><br><span class="line">    &quot;name&quot; = &quot;docs&quot;</span><br><span class="line">    &quot;website&quot; = &#123;</span><br><span class="line">      &quot;error_document&quot; = &quot;error.txt&quot;</span><br><span class="line">      &quot;index_document&quot; = &quot;index.txt&quot;</span><br><span class="line">      &quot;routing_rules&quot; = tostring(null)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h3 id="1-4-1-1-5-2-例子：有条件地设置一个默认属性"><a href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7"></a>1.4.1.1.5.2. 例子：有条件地设置一个默认属性</h3>
<p>有时我们需要根据其他数据的值来动态决定是否要为一个 <code>optional</code> 参数设置值。在这种场景下，发起调用的 <code>module</code> 块可以使用条件表达式搭配 <code>null</code> 来动态地决定是否设置该参数。</p>
<p>还是上一个例子中的 <code>variable &quot;buckets&quot;</code> 的例子，使用下面演示的例子可以根据新输入参数 <code>var.legacy_filenames</code> 的值来有条件地覆盖 <code>website</code> 对象中 <code>index_document</code> 以及 <code>error_document</code> 的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;legacy_filenames&quot; &#123;</span><br><span class="line">  type     = bool</span><br><span class="line">  default  = false</span><br><span class="line">  nullable = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;buckets&quot; &#123;</span><br><span class="line">  source = &quot;./modules/buckets&quot;</span><br><span class="line"></span><br><span class="line">  buckets = [</span><br><span class="line">    &#123;</span><br><span class="line">      name = &quot;maybe_legacy&quot;</span><br><span class="line">      website = &#123;</span><br><span class="line">        error_document = var.legacy_filenames ? &quot;ERROR.HTM&quot; : null</span><br><span class="line">        index_document = var.legacy_filenames ? &quot;INDEX.HTM&quot; : null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>var.legacy_filenames</code> 设置为 <code>true</code> 时，调用会覆盖 <code>document</code> 的文件名。当它的值为 <code>false</code> 时，调用不会指定这两个文件名，这样就会使得模块使用定义的默认值。</p>
<ul>
<li>
<p><a href="#%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95"><strong>1.4.2.1.</strong> 配置语法</a></p>
</li>
<li>
<p><a href="#%E5%8F%82%E6%95%B0"><strong>1.4.2.1.1.</strong> 参数</a></p>
</li>
<li>
<p><a href="#%E5%9D%97"><strong>1.4.2.1.2.</strong> 块</a></p>
</li>
<li>
<p><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88identifiers%EF%BC%89"><strong>1.4.2.1.3.</strong> 标识符（Identifiers）</a></p>
</li>
<li>
<p><a href="#%E6%B3%A8%E9%87%8A"><strong>1.4.2.1.4.</strong> 注释</a></p>
</li>
<li>
<p><a href="#%E7%BC%96%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%8D%A2%E8%A1%8C"><strong>1.4.2.1.5.</strong> 编码以及换行</a></p>
</li>
</ul>
<p><a href="#%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95"></a></p>
<h2 id="1-4-2-1-配置语法"><a href="#%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95"></a>1.4.2.1. 配置语法</h2>
<p>这里讲的仍然是 HCL 的语法，但我们只讲一些关键语法。如果读者有兴趣了解完整信息可以访问 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/hcl/blob/hcl2/hclsyntax/spec.md">HCL 语法规约</a></p>
<p>HCL 的语法由两个关键元素构成：参数(Argument)与块(Block)</p>
<h2 id="1-4-2-1-1-参数"><a href="#%E5%8F%82%E6%95%B0"></a>1.4.2.1.1. 参数</h2>
<p>HCL 中的参数就是将一个值赋给一个特定的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image_id = &quot;abc123&quot;</span><br></pre></td></tr></table></figure>
<p>等号前的标识符就是参数名，等号后的表达式就是参数值。参数赋值时 Terraform 会检查类型是否匹配。参数名是确定的，参数值可以是确定的字面量硬编码，也可以是一组表达式，用以通过其他的值加以计算得出结果值。</p>
<h2 id="1-4-2-1-2-块"><a href="#%E5%9D%97"></a>1.4.2.1.2. 块</h2>
<p>一个块是包含一组其他内容（参数和块）的容器，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami = &quot;abc123&quot;</span><br><span class="line"></span><br><span class="line">  network_interface &#123;</span><br><span class="line">    # ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个块有一个类型(上面的例子里类型就是 <code>resource</code>)。每个块类型都定义了类型关键字后面要跟多少标签，例如 <code>resource</code> 块规定了后面要跟两个标签 —— 在例子里就是 <code>aws_instance</code> 和 <code>example</code>。一个块类型可以规定任意多个标签，也可以没有标签，比如内嵌的 <code>network_interface</code> 块。</p>
<p>在块类型及其后续标签之后，就是块体。块体必须被包含在一对花括号中间。在块体中可以进一步定义各种参数和其他的块。</p>
<p>Terraform 规范定义了有限个顶级块类型，也就是可以游离于任何其他块独立定义在配置文件中的块。大部分的 Terraform 功能(例如 <code>resource</code>, <code>variable</code>, <code>output</code>, <code>data</code>等)都是顶级块。</p>
<h2 id="1-4-2-1-3-标识符（Identifiers）"><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88identifiers%EF%BC%89"></a>1.4.2.1.3. 标识符（Identifiers）</h2>
<p>参数名、块类型名以及其他 Terraform 规范中定义的结构的名称，例如 <code>resource</code>、<code>variable</code> 等，都是标识符。</p>
<p>合法的标识符可以包含字母、数字、下划线(<code>_</code>)以及连字符(<code>-</code>)。标识符首字母不可以为数字。</p>
<p>要了解完整的标识符规范，请访问 <a target="_blank" rel="noopener" href="http://unicode.org/reports/tr31/">Unicode 标识符语法</a>。</p>
<h2 id="1-4-2-1-4-注释"><a href="#%E6%B3%A8%E9%87%8A"></a>1.4.2.1.4. 注释</h2>
<p>Terraform支持三种注释：</p>
<ul>
<li><code>#</code> 单行注释，其后的内容为注释</li>
<li><code>//</code> 单行注释，其后的内容为注释</li>
<li><code>/*</code> 和 <code>*/</code>，多行注释，可以注释多行</li>
</ul>
<p>默认情况下单行注释优先使用 <code>#</code>。自动化格式整理工具会自动把 <code>//</code> 替换成 <code>#</code>。</p>
<h2 id="1-4-2-1-5-编码以及换行"><a href="#%E7%BC%96%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%8D%A2%E8%A1%8C"></a>1.4.2.1.5. 编码以及换行</h2>
<p>Terraform 配置文件必须始终使用 UTF-8 编码。分隔符必须使用 ASCII 符号，其他标识符、注释以及字符串字面量均可使用非 ASCII 字符。</p>
<p>Terraform 兼容 Unix 风格的换行符（LF）以及 Windows 风格的换行符（CRLF），但是理想状态下应使用 Unix 风格换行符。</p>
<ul>
<li>
<p><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F"><strong>1.4.3.1.</strong> 输入变量</a></p>
</li>
<li>
<p><a href="#%E7%B1%BB%E5%9E%8B-type"><strong>1.4.3.1.1.</strong> 类型 (type)</a></p>
</li>
<li>
<p><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC-default"><strong>1.4.3.1.2.</strong> 默认值 (default)</a></p>
</li>
<li>
<p><a href="#%E6%8F%8F%E8%BF%B0-description"><strong>1.4.3.1.3.</strong> 描述 (description)</a></p>
</li>
<li>
<p><a href="#%E6%96%AD%E8%A8%80-validation"><strong>1.4.3.1.4.</strong> 断言 (validation)</a></p>
</li>
<li>
<p><a href="#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%EF%BC%88ephemeral%EF%BC%89"><strong>1.4.3.1.5.</strong> 临时输入变量（ephemeral）</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"><strong>1.4.3.1.6.</strong> 在命令行输出中隐藏值 (sensitive)</a></p>
</li>
<li>
<p><a href="#terraform-%E5%8F%AF%E8%83%BD%E6%9A%B4%E9%9C%B2%E6%95%8F%E6%84%9F%E5%8F%98%E9%87%8F%E7%9A%84%E6%83%85%E5%86%B5"><strong>1.4.3.1.6.1.</strong> Terraform 可能暴露敏感变量的情况</a></p>
</li>
<li>
<p><a href="#%E7%A6%81%E6%AD%A2%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E4%B8%BA%E7%A9%BA-nullable"><strong>1.4.3.1.7.</strong> 禁止输入变量为空 (nullable)</a></p>
</li>
<li>
<p><a href="#%E5%AF%B9%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><strong>1.4.3.1.8.</strong> 对输入变量赋值</a></p>
</li>
<li>
<p><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><strong>1.4.3.1.8.1.</strong> 命令行参数</a></p>
</li>
<li>
<p><a href="#%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6"><strong>1.4.3.1.8.2.</strong> 参数文件</a></p>
</li>
<li>
<p><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><strong>1.4.3.1.8.3.</strong> 环境变量</a></p>
</li>
<li>
<p><a href="#%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2%E4%BC%A0%E5%80%BC"><strong>1.4.3.1.8.4.</strong> 交互界面传值</a></p>
</li>
<li>
<p><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%BC%98%E5%85%88%E7%BA%A7"><strong>1.4.3.1.9.</strong> 输入变量赋值优先级</a></p>
</li>
<li>
<p><a href="#terraform-%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E5%80%BC"><strong>1.4.3.1.9.1.</strong> Terraform 测试中的输入变量值</a></p>
</li>
<li>
<p><a href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%80%BC"><strong>1.4.3.1.10.</strong> 复杂类型传值</a></p>
</li>
</ul>
<p><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F"></a></p>
<h2 id="1-4-3-1-输入变量"><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F"></a>1.4.3.1. 输入变量</h2>
<p>在前面的例子中，我们在代码中都是使用字面量硬编码的，如果我们想要在创建、修改基础设施时动态传入一些值呢？比如说在代码中定义 Provider 时用变量替代硬编码的访问密钥，或是由创建基础设施的用户来决定创建什么样尺寸的主机？我们需要的是输入变量。</p>
<p>如果我们把一组 Terraform 代码想像成一个函数，那么输入变量就是函数的入参。输入变量用 <code>variable</code> 块进行定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;image_id&quot; &#123;</span><br><span class="line">  type = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;availability_zone_names&quot; &#123;</span><br><span class="line">  type    = list(string)</span><br><span class="line">  default = [&quot;us-west-1a&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;docker_ports&quot; &#123;</span><br><span class="line">  type = list(object(&#123;</span><br><span class="line">    internal = number</span><br><span class="line">    external = number</span><br><span class="line">    protocol = string</span><br><span class="line">  &#125;))</span><br><span class="line">  default = [</span><br><span class="line">    &#123;</span><br><span class="line">      internal = 8300</span><br><span class="line">      external = 8300</span><br><span class="line">      protocol = &quot;tcp&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是合法的输入参数定义。紧跟 <code>variable</code> 关键字的就是变量名。在一个 Terraform 模块(同一个文件夹中的所有 Terraform 代码文件，不包含子文件夹)中变量名必须是唯一的。我们在代码中可以通过<code>var.&lt;NAME&gt;</code>的方式引用变量的值。有一组关键字<strong>不可以</strong>被用作输入变量的名字：</p>
<ul>
<li><code>source</code></li>
<li><code>version</code></li>
<li><code>providers</code></li>
<li><code>count</code></li>
<li><code>for_each</code></li>
<li><code>lifecycle</code></li>
<li><code>depends_on</code></li>
<li><code>locals</code></li>
</ul>
<p>输入变量只能在声明该变量的目录下的代码中使用。</p>
<p>输入变量块中可以定义一些属性。</p>
<h2 id="1-4-3-1-1-类型-type"><a href="#%E7%B1%BB%E5%9E%8B-type"></a>1.4.3.1.1. 类型 (type)</h2>
<p>可以在输入变量块中通过 <code>type</code> 定义类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;name&quot; &#123;</span><br><span class="line">    type = string</span><br><span class="line">&#125;</span><br><span class="line">variable &quot;ports&quot; &#123;</span><br><span class="line">    type = list(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了类型的输入变量只能被赋予符合类型约束的值。</p>
<h2 id="1-4-3-1-2-默认值-default"><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC-default"></a>1.4.3.1.2. 默认值 (default)</h2>
<p>默认值定义了当 Terraform 无法获得一个输入变量得到值的时候会使用的默认值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;name&quot; &#123;</span><br><span class="line">    type    = string</span><br><span class="line">    default = &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Terraform 无法通过其他途径获得name的值时，<code>var.name</code> 的值为 <code>&quot;John Doe&quot;</code>。</p>
<h2 id="1-4-3-1-3-描述-description"><a href="#%E6%8F%8F%E8%BF%B0-description"></a>1.4.3.1.3. 描述 (description)</h2>
<p>可以在输入变量中定义一个描述，简单地向调用者描述该变量的意义和用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;image_id&quot; &#123;</span><br><span class="line">  type        = string</span><br><span class="line">  description = &quot;The id of the machine image (AMI) to use for the server.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在执行 <code>terraform plan</code> 或是 <code>terraform apply</code> 时 Terraform 不知道某个输入变量的值，Terraform 会在命令行界面上提示我们为输入变量设置一个值。例如上面的输入变量代码，执行 <code>terraform apply</code> 时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply</span><br><span class="line">var.image_id</span><br><span class="line">  The <span class="built_in">id</span> of the machine image (AMI) to use <span class="keyword">for</span> the server.</span><br><span class="line"></span><br><span class="line">  Enter a value:</span><br></pre></td></tr></table></figure>
<p>为了使得代码的使用者能够准确理解输入变量的意义和用法，我们应该站在代码使用者而非代码维护者的角度编写输入变量的描述。<strong>描述并不是注释！</strong></p>
<h2 id="1-4-3-1-4-断言-validation"><a href="#%E6%96%AD%E8%A8%80-validation"></a>1.4.3.1.4. 断言 (validation)</h2>
<p>输入变量的断言是 Terraform 0.13.0 开始引入的新功能，在过去，Terraform 只能用类型约束确保输入参数的类型是正确的，曾经有不少人试图通过奇技淫巧来实现更加复杂的变量校验断言。如今 Terraform 终于正式添加了相关的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;image_id&quot; &#123;</span><br><span class="line">  type        = string</span><br><span class="line">  description = &quot;The id of the machine image (AMI) to use for the server.&quot;</span><br><span class="line"></span><br><span class="line">  validation &#123;</span><br><span class="line">    condition     = length(var.image_id) &gt; 4 &amp;&amp; substr(var.image_id, 0, 4) == &quot;ami-&quot;</span><br><span class="line">    error_message = &quot;The image_id value must be a valid AMI id, starting with \&quot;ami-\&quot;.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>condition</code> 参数是一个 <code>bool</code> 类型的参数，我们可以用一个表达式来定义如何界定输入变量是合法的。当 <code>condition</code> 为 <code>true</code> 时输入变量合法，反之不合法。<code>condition</code> 表达式中只能通过 <code>var.\&lt;NAME\&gt;</code> 引用当前定义的变量，并且它的计算不能产生错误。</p>
<p>假如表达式的计算产生一个错误是输入变量验证的一种判定手段，那么可以使用 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/functions/can"><code>can</code> 函数</a>来判定表达式的执行是否抛错。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;image_id&quot; &#123;</span><br><span class="line">  type        = string</span><br><span class="line">  description = &quot;The id of the machine image (AMI) to use for the server.&quot;</span><br><span class="line"></span><br><span class="line">  validation &#123;</span><br><span class="line">    # regex(...) fails if it cannot find a match</span><br><span class="line">    condition     = can(regex(&quot;^ami-&quot;, var.image_id))</span><br><span class="line">    error_message = &quot;The image_id value must be a valid AMI id, starting with \&quot;ami-\&quot;.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，如果输入的 <code>image_id</code> 不符合正则表达式的要求，那么 <code>regex</code> 函数调用会抛出一个错误，这个错误会被 <code>can</code> 函数捕获，输出 <code>false</code>。</p>
<p><code>condition</code> 表达式如果为 <code>false</code>，Terraform 会返回 <code>error_message</code> 中定义的错误信息。<code>error_message</code> 应该完整描述输入变量校验失败的原因，以及输入变量的合法约束条件。</p>
<h2 id="1-4-3-1-5-临时输入变量（ephemeral）"><a href="#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%EF%BC%88ephemeral%EF%BC%89"></a>1.4.3.1.5. 临时输入变量（ephemeral）</h2>
<p><strong>注意</strong>：临时输入变量是 Terraform v1.10 开始引入的功能</p>
<p>将变量设置为 <code>ephemeral</code> 的结果是，该输入值在运行时可用，但 Terraform 不会在状态和计划文件中记录这种临时值。将输入变量标记为 <code>ephemeral</code> 变量对于仅需要暂时存在的数据非常有用，例如短生命周期的令牌或会话标识符。</p>
<p>要将输入变量标记为临时变量，只通过将 <code>ephemeral</code> 参数设置为 <code>true</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;session_token&quot; &#123;</span><br><span class="line">  type      = string</span><br><span class="line">  ephemeral = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>临时变量在当前 Terraform 运行期间可用，并且 Terraform 不会将它们存储在状态或计划文件中。因此，与 <a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"><code>sensitive</code> 输入</a>不同，Terraform 确保临时值在当前 Terraform 运行结束后无法读取。</p>
<p>您只能在特定上下文中引用临时变量，否则 Terraform 会返回错误。以下是引用临时变量的有效上下文：</p>
<ul>
<li>另一个临时变量</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/5.%E5%B1%80%E9%83%A8%E5%80%BC.html#%E4%B8%B4%E6%97%B6%E5%B1%80%E9%83%A8%E5%80%BC"><code>local</code> 表达式</a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/4.%E8%BE%93%E5%87%BA%E5%80%BC.html#%E4%B8%B4%E6%97%B6%E5%80%BCephemeral-%E9%81%BF%E5%85%8D%E5%B0%86%E5%80%BC%E5%AD%98%E5%82%A8%E5%88%B0%E7%8A%B6%E6%80%81%E6%88%96%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E4%B8%AD">临时输出值</a></li>
</ul>
<h2 id="1-4-3-1-6-在命令行输出中隐藏值-sensitive"><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"></a>1.4.3.1.6. 在命令行输出中隐藏值 (sensitive)</h2>
<p>该功能于 Terraform v0.14.0 开始引入。</p>
<p>将变量设置为 <code>sensitive</code> 可以防止我们在配置文件中使用变量时 Terraform 在 <code>plan</code> 和 <code>apply</code> 命令的输出中展示与变量相关的值。</p>
<p>Terraform <strong>仍然会</strong>将敏感数据记录在<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html">状态文件</a>中，任何可以访问状态文件的人都<strong>可以</strong>读取到明文的敏感数据值。</p>
<p>声明一个变量包含敏感数据值需要将 <code>sensitive</code> 参数设置为 <code>true</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;user_information&quot; &#123;</span><br><span class="line">  type = object(&#123;</span><br><span class="line">    name    = string</span><br><span class="line">    address = string</span><br><span class="line">  &#125;)</span><br><span class="line">  sensitive = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;some_resource&quot; &quot;a&quot; &#123;</span><br><span class="line">  name    = var.user_information.name</span><br><span class="line">  address = var.user_information.address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何使用了敏感变量的表达式都将被视为敏感的，因此在上面的示例中，<code>resource “some_resource” “a”</code>的两个参数也将在计划输出中被隐藏：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Terraform will perform the following actions:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">some_resource.a will be created</span></span><br><span class="line">  + resource &quot;some_resource&quot; &quot;a&quot; &#123;</span><br><span class="line">      + name    = (sensitive)</span><br><span class="line">      + address = (sensitive)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure>
<p>在某些情况下，我们会在嵌套块中使用敏感变量，Terraform 可能会将整个块视为敏感的。这发生在那些包含有要求值是唯一的内嵌块的资源中，公开这种内嵌块的部分内容可能会暗示兄弟块的内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">some_resource.a will be updated in-place</span></span><br><span class="line"> ~ resource &quot;some_resource&quot; &quot;a&quot; &#123;</span><br><span class="line">     ~ nested_block &#123;</span><br><span class="line">         # At least one attribute in this block is (or was) sensitive,</span><br><span class="line">         # so its contents will not be displayed.</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Provider 还可以将资源属性声明为敏感属性，这将导致 Terraform 将其从常规输出中隐藏。</p>
<p>如果打算使用敏感值作为输出值的一部分，Terraform 将要求您将输出值本身标记为敏感值，以确认确实打算将其导出。</p>
<h3 id="1-4-3-1-6-1-Terraform-可能暴露敏感变量的情况"><a href="#terraform-%E5%8F%AF%E8%83%BD%E6%9A%B4%E9%9C%B2%E6%95%8F%E6%84%9F%E5%8F%98%E9%87%8F%E7%9A%84%E6%83%85%E5%86%B5"></a>1.4.3.1.6.1. Terraform 可能暴露敏感变量的情况</h3>
<p><code>sensitive</code> 变量是一个以配置文件为中心的概念，值被不加混淆地发送给 Provider。如果该值被包含在错误消息中，则 Provider 报错时可能会暴露该值。例如，即使 <code>&quot;foo&quot;</code> 是敏感值，Provider 也可能返回以下错误：<code>&quot;Invalid value 'foo' for field&quot;</code></p>
<p>如果将资源属性用作、或是作为 Provider 定义的资源 ID 的一部分，则 <code>apply</code> 将公开该值。在下面的示例中，前缀属性已设置为 <code>sensitive</code> 变量，但随后该值（<code>&quot;jae&quot;</code>）作为资源 ID 的一部分公开：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">random_pet.animal will be created</span></span><br><span class="line">  + resource &quot;random_pet&quot; &quot;animal&quot; &#123;</span><br><span class="line">      + id        = (known after apply)</span><br><span class="line">      + length    = 2</span><br><span class="line">      + prefix    = (sensitive)</span><br><span class="line">      + separator = &quot;-&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">random_pet.animal: Creating...</span><br><span class="line">random_pet.animal: Creation complete after 0s [id=jae-known-mongoose]</span><br></pre></td></tr></table></figure>
<h2 id="1-4-3-1-7-禁止输入变量为空-nullable"><a href="#%E7%A6%81%E6%AD%A2%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E4%B8%BA%E7%A9%BA-nullable"></a>1.4.3.1.7. 禁止输入变量为空 (nullable)</h2>
<p>该功能自 Terraform v1.1.0 开始被引入</p>
<p>输入变量的 <code>nullable</code> 参数控制模块调用者是否可以将 <code>null</code> 赋值给变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;example&quot; &#123;</span><br><span class="line">  type     = string</span><br><span class="line">  nullable = false </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nullable</code> 的默认值为 <code>true</code>。当 <code>nullable</code> 为 <code>true</code> 时，<code>null</code> 是变量的有效值，并且模块代码必须始终考虑变量值为 <code>null</code> 的可能性。将 <code>null</code> 作为模块输入参数传递将覆盖输入变量上定义的默认值。</p>
<p>将 <code>nullable</code> 设置为 <code>false</code> 可确保变量值在模块内永远不会为空。如果 <code>nullable</code> 为 <code>false</code> 并且输入变量定义有默认值，则当模块输入参数为 <code>null</code> 时，Terraform 将使用默认值。</p>
<p><code>nullable</code> 参数仅控制变量的直接值可能为 <code>null</code> 的情况。对于集合或对象类型的变量，例如列表或对象，调用者仍然可以在集合元素或属性中使用 <code>null</code>，只要集合或对象本身不为 <code>null</code>。</p>
<h2 id="1-4-3-1-8-对输入变量赋值"><a href="#%E5%AF%B9%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"></a>1.4.3.1.8. 对输入变量赋值</h2>
<h3 id="1-4-3-1-8-1-命令行参数"><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"></a>1.4.3.1.8.1. 命令行参数</h3>
<p>对输入变量赋值有几种途径，一种是在调用 <code>terraform plan</code> 或是 <code>terraform apply</code> 命令时以参数的形式传入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply -var=<span class="string">&quot;image_id=ami-abc123&quot;</span></span><br><span class="line">$ terraform apply -var=<span class="string">&#x27;image_id_list=[&quot;ami-abc123&quot;,&quot;ami-def456&quot;]&#x27;</span></span><br><span class="line">$ terraform plan -var=<span class="string">&#x27;image_id_map=&#123;&quot;us-east-1&quot;:&quot;ami-abc123&quot;,&quot;us-east-2&quot;:&quot;ami-def456&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以在一条命令中使用多个 <code>-var</code> 参数。</p>
<h3 id="1-4-3-1-8-2-参数文件"><a href="#%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6"></a>1.4.3.1.8.2. 参数文件</h3>
<p>第二种方法是使用参数文件。参数文件的后缀名可以是 <code>.tfvars</code> 或是 <code>.tfvars.json</code>。<code>.tfvars</code> 文件使用 HCL 语法，<code>.tfvars.json</code> 使用 JSON 语法。</p>
<p>以 <code>.tfvars</code> 为例，参数文件中用 HCL 代码对需要赋值的参数进行赋值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image_id = &quot;ami-abc123&quot;</span><br><span class="line">availability_zone_names = [</span><br><span class="line">  &quot;us-east-1a&quot;,</span><br><span class="line">  &quot;us-west-1c&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>后缀名为 <code>.tfvars.json</code> 的文件用一个 JSON 对象来对输入变量赋值，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;image_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ami-abc123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;availability_zone_names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;us-west-1a&quot;</span><span class="punctuation">,</span> <span class="string">&quot;us-west-1c&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>调用 terraform 命令时，通过 <code>-var-file</code> 参数指定要用的参数文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -var-file=<span class="string">&quot;testing.tfvars&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -var-file=<span class="string">&quot;testing.tfvars.json&quot;</span></span><br></pre></td></tr></table></figure>
<p>有两种情况，你<strong>无需</strong>指定参数文件：</p>
<ul>
<li>当前模块内有名为 <code>terraform.tfvars</code> 或是 <code>terraform.tfvars.json</code> 的文件</li>
<li>当前模块内有一个或多个后缀名为 <code>.auto.tfvars</code> 或是 <code>.auto.tfvars.json</code> 的文件</li>
</ul>
<p>Terraform 会自动使用这两种自动参数文件对输入参数赋值。</p>
<h3 id="1-4-3-1-8-3-环境变量"><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"></a>1.4.3.1.8.3. 环境变量</h3>
<p>可以通过设置名为 <code>TF_VAR_&lt;NAME&gt;</code> 的环境变量为输入变量赋值，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TF_VAR_image_id=ami-abc123</span><br><span class="line">$ terraform plan</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在环境变量名大小写敏感的操作系统上，Terraform 要求环境变量中的 <code>&lt;NAME&gt;</code> 与 Terraform 代码中定义的输入变量名大小写完全一致。</p>
<p>环境变量传值非常适合在自动化流水线中使用，尤其适合用来传递敏感数据，类似密码、访问密钥等。</p>
<h3 id="1-4-3-1-8-4-交互界面传值"><a href="#%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2%E4%BC%A0%E5%80%BC"></a>1.4.3.1.8.4. 交互界面传值</h3>
<p>在前面介绍断言的例子中我们看到过，当我们从命令行界面执行 terraform 操作，Terraform 无法通过其他途径获取一个输入变量的值，而该变量也没有定义默认值时，Terraform 会进行最后的尝试，在交互界面上要求我们给出变量值。</p>
<h2 id="1-4-3-1-9-输入变量赋值优先级"><a href="#%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%BC%98%E5%85%88%E7%BA%A7"></a>1.4.3.1.9. 输入变量赋值优先级</h2>
<p>当上述的赋值方式同时存在时，同一个变量可能会被赋值多次。Terraform 会使用新值覆盖旧值。</p>
<p>Terraform 加载变量值的顺序是：</p>
<ol>
<li>环境变量</li>
<li><code>terraform.tfvars</code> 文件(如果存在的话)</li>
<li><code>terraform.tfvars.json</code> 文件(如果存在的话)</li>
<li>所有的 <code>.auto.tfvars</code> 或者 <code>.auto.tfvars.json</code> 文件，以字母顺序排序处理</li>
<li>通过 <code>-var</code> 或是 <code>-var-file</code> 命令行参数传递的输入变量，按照在命令行参数中定义的顺序加载</li>
</ol>
<p>假如以上方式均未能成功对变量赋值，那么 Terraform 会尝试使用默认值；对于没有定义默认值的变量，Terraform 会采用交互界面方式要求用户输入一个。对于某些 Terraform 命令，如果执行时带有 <code>-input=false</code> 参数禁用了交互界面传值方式，那么就会报错。</p>
<p><strong>重要提示</strong>：在 Terraform 0.12 及更高版本中，类型为 <code>map</code> 或 <code>object</code> 的输入变量的读取行为与其他变量相同：后找到的值会覆盖之前的值。这与 Terraform 的早期版本不同，早期版本会合并 <code>map</code>，而不是覆盖它们。</p>
<h3 id="1-4-3-1-9-1-Terraform-测试中的输入变量值"><a href="#terraform-%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F%E5%80%BC"></a>1.4.3.1.9.1. Terraform 测试中的输入变量值</h3>
<p>在 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/7.test">Terraform 测试文件</a>中，您可以在 <code>variable</code> 块中指定变量值，这些 <code>variable</code> 块可以嵌套在 <code>run</code> 块中，也可以直接在文件中定义。</p>
<p>以这种方式定义的变量在测试执行期间优先于所有其他机制，其中在 <code>run</code> 块中定义的变量优先于在文件中定义的变量。</p>
<h2 id="1-4-3-1-10-复杂类型传值"><a href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%80%BC"></a>1.4.3.1.10. 复杂类型传值</h2>
<p>通过参数文件传值时，可以直接使用 HCL 或是 JSON 语法对复杂类型传值，例如 <code>list</code> 或 <code>map</code>。</p>
<p>对于某些场景下必须使用 <code>-var</code> 命令行参数，或是环境变量传值时，可以用单引号引用 HCL 语法的字面量来定义复杂类型，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TF_VAR_availability_zone_names=<span class="string">&#x27;[&quot;us-west-1b&quot;,&quot;us-west-1d&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于采用这种方法需要手工处理引号的转义，所以这种方法比较容易出错，复杂类型的传值建议尽量通过参数文件。</p>
<ul>
<li>
<p><a href="#%E8%BE%93%E5%87%BA%E5%80%BC"><strong>1.4.4.1.</strong> 输出值</a></p>
</li>
<li>
<p><a href="#%E8%BE%93%E5%87%BA%E5%80%BC%E7%9A%84%E5%A3%B0%E6%98%8E"><strong>1.4.4.1.1.</strong> 输出值的声明</a></p>
</li>
<li>
<p><a href="#%E6%8F%8F%E8%BF%B0-description"><strong>1.4.4.1.1.1.</strong> 描述 description</a></p>
</li>
<li>
<p><a href="#%E4%B8%B4%E6%97%B6%E5%80%BC%EF%BC%88ephemeral%EF%BC%89%E2%80%94%E2%80%94-%E9%81%BF%E5%85%8D%E5%B0%86%E5%80%BC%E5%AD%98%E5%82%A8%E5%88%B0%E7%8A%B6%E6%80%81%E6%88%96%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E4%B8%AD"><strong>1.4.4.1.1.2.</strong> 临时值（ephemeral）—— 避免将值存储到状态或计划文件中</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"><strong>1.4.4.1.1.3.</strong> 在命令行输出中隐藏值 sensitive</a></p>
</li>
<li>
<p><a href="#dependson"><strong>1.4.4.1.1.4.</strong> depends_on</a></p>
</li>
<li>
<p><a href="#%E6%96%AD%E8%A8%80-precondition"><strong>1.4.4.1.1.5.</strong> 断言 precondition</a></p>
</li>
</ul>
<p><a href="#%E8%BE%93%E5%87%BA%E5%80%BC"></a></p>
<h2 id="1-4-4-1-输出值"><a href="#%E8%BE%93%E5%87%BA%E5%80%BC"></a>1.4.4.1. 输出值</h2>
<p>我们在介绍输入变量时提到过，如果我们把一组 Terraform 代码想像成一个函数，那么输入变量就是函数的入参；函数可以有入参，也可以有返回值，同样的，Terraform 代码也可以有返回值，这就是输出值。</p>
<p>大部分语言的的函数只支持无返回值或是单返回值，但是 Terraform 支持多返回值。在当前模块 apply 一段 Terraform 代码，运行成功后命令行会输出代码中定义的返回值。另外我们也可以通过 <code>terraform output</code> 命令来输出当前模块对应的状态文件中的返回值。</p>
<h2 id="1-4-4-1-1-输出值的声明"><a href="#%E8%BE%93%E5%87%BA%E5%80%BC%E7%9A%84%E5%A3%B0%E6%98%8E"></a>1.4.4.1.1. 输出值的声明</h2>
<p>输出值的声明使用输出块，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output &quot;instance_ip_addr&quot; &#123;</span><br><span class="line">  value = aws_instance.server.private_ip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>output</code> 关键字后紧跟的就是输出值的名称。在当前模块内的所有输出值的名字都必须是唯一的。<code>output</code> 块内的 <code>value</code> 参数即为输出值，它可以像是上面的例子里那样某个 resource 的输出属性，也可以是任意合法的表达式。</p>
<p>输出值只有在执行 <code>terraform apply</code> 后才会被计算，光是执行 <code>terraform plan</code> 并不会计算输出值。</p>
<p>Terraform 代码中无法引用本目录下定义的输出值。</p>
<p><code>output</code> 块还有一些可选的属性：</p>
<h3 id="1-4-4-1-1-1-描述-description"><a href="#%E6%8F%8F%E8%BF%B0-description"></a>1.4.4.1.1.1. 描述 description</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output &quot;instance_ip_addr&quot; &#123;</span><br><span class="line">  value       = aws_instance.server.private_ip</span><br><span class="line">  description = &quot;The private IP address of the main server instance.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与输入变量的<code>description</code>类似，我们不再赘述。</p>
<h3 id="1-4-4-1-1-2-临时值（ephemeral）——-避免将值存储到状态或计划文件中"><a href="#%E4%B8%B4%E6%97%B6%E5%80%BC%EF%BC%88ephemeral%EF%BC%89%E2%80%94%E2%80%94-%E9%81%BF%E5%85%8D%E5%B0%86%E5%80%BC%E5%AD%98%E5%82%A8%E5%88%B0%E7%8A%B6%E6%80%81%E6%88%96%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E4%B8%AD"></a>1.4.4.1.1.2. 临时值（ephemeral）—— 避免将值存储到状态或计划文件中</h3>
<p><strong>注意</strong>：临时输出值是 Terraform v1.10 开始引入的功能</p>
<p>我们可以在子模块中将 <code>output</code> 标记为 <code>ephemeral</code>，以在模块之间传递临时值，同时避免将这些值保留到状态或计划文件中。这对于管理我们不想存储在 Terraform 状态文件中的凭据、令牌或其他临时资源非常有用。</p>
<p>我们可以通过将 <code>ephemeral</code> 属性设置为 <code>true</code> 将子模块中的输出标记为临时输出值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># modules/db/main.tf</span><br><span class="line"></span><br><span class="line">output &quot;secret_id&quot; &#123;</span><br><span class="line">  value       = aws_secretsmanager_secret.secret_id</span><br><span class="line">  description = &quot;Temporary secret ID for accessing database in AWS.&quot;</span><br><span class="line">  ephemeral   = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 可以在 <code>plan</code> 和 <code>apply</code> 操作期间访问 <code>output</code> 块的值。在 <code>plan</code> 或 <code>apply</code> 操作结束时，Terraform 不会保存任何临时输出的值。</p>
<p>我们只能在特定上下文中引用临时输出，否则 Terraform 会返回错误。以下是引用临时输出的有效上下文：</p>
<ul>
<li>另一个临时输出值</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8Fephemeral">临时输入变量</a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/12.Ephemeral%E8%B5%84%E6%BA%90.html">临时资源</a></li>
</ul>
<p><strong>注意</strong>：我们不可以在根模块中将 <code>output</code> 声明为 <code>ephemeral</code>。</p>
<h3 id="1-4-4-1-1-3-在命令行输出中隐藏值-sensitive"><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%B8%AD%E9%9A%90%E8%97%8F%E5%80%BC-sensitive"></a>1.4.4.1.1.3. 在命令行输出中隐藏值 sensitive</h3>
<p>一个输出值可以标记 <code>sensitive</code> 为 <code>true</code>，表示该输出值含有敏感信息。被标记 <code>sensitive</code> 的输出值只是在执行 <code>terraform apply</code> 命令成功后会打印 <code>&quot;&lt;sensitive&gt;&quot;</code> 以取代真实的输出值，执行 <code>terraform output</code> 时也会输出<code>&quot;&lt;sensitive&gt;&quot;</code>，但仍然可以通过执行 <code>terraform output -json</code> 看到实际的敏感值。</p>
<p>需要注意的是，标记为 <code>sensitive</code> 输出值仍然会被记录在状态文件中，任何有权限读取状态文件的人仍然可以读取到敏感数据。</p>
<h3 id="1-4-4-1-1-4-depends-on"><a href="#dependson"></a>1.4.4.1.1.4. depends_on</h3>
<p>关于 <code>depends_on</code> 的内容将在 resource 章节里详细介绍，所以这里我们只是粗略地介绍一下。</p>
<p>Terraform 会解析代码所定义的各种 <code>data</code>、<code>resource</code>，以及他们之间的依赖关系，例如，创建虚拟机时用的 <code>image_id</code> 参数是通过 <code>data</code> 查询而来的，那么虚拟机实例就依赖于这个镜像的 <code>data</code>，Terraform 会首先创建 <code>data</code>，得到查询结果后，再创建虚拟机 <code>resource</code>。一般来说，<code>data</code>、<code>resource</code> 之间的创建顺序是由 Terraform 自动计算的，不需要代码的编写者显式指定。但有时有些依赖关系无法通过分析代码得出，这时我们可以在代码中通过 <code>depends_on</code> 显式声明依赖关系。</p>
<p>一般 <code>output</code> 很少会需要显式依赖某些资源，但有一些特殊场景，例如某些资源的属性必须在另外一些资源被创建后才能被读取，这种情况下我们可以通过 <code>depends_on</code> 来显式声明依赖关系。</p>
<p><code>depends_on</code> 的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">output &quot;instance_ip_addr&quot; &#123;</span><br><span class="line">  value       = aws_instance.server.private_ip</span><br><span class="line">  description = &quot;The private IP address of the main server instance.&quot;</span><br><span class="line"></span><br><span class="line">  depends_on = [</span><br><span class="line">    # Security group rule must be created before this IP address could</span><br><span class="line">    # actually be used, otherwise the services will be unreachable.</span><br><span class="line">    aws_security_group_rule.local_access,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不鼓励针对 <code>output</code> 定义<code>depends_on</code>，只能作为最后的手段加以应用。如果不得不针对 <code>output</code> 定义<code>depends_on</code>，请务必通过注释说明原因，方便后人进行维护。</p>
<h3 id="1-4-4-1-1-5-断言-precondition"><a href="#%E6%96%AD%E8%A8%80-precondition"></a>1.4.4.1.1.5. 断言 precondition</h3>
<p><code>output</code> 块从 Terraform v1.2.0 开始也可以包含一个 <code>precondition</code> 块。</p>
<p><code>output</code> 块上的 <code>precondition</code> 对应于 <code>variable</code> 块中的 <code>validation</code> 块。<code>validation</code> 块检查输入变量值是否符合模块的要求，<code>precondition</code> 则确保模块的输出值满足某种要求。我们可以通过 <code>precondition</code> 来防止 Terraform 把一个不合法的输入值写入状态文件。我们可以在合适的场景下通过 <code>precondition</code> 来保护上一次 <code>apply</code> 留下的合法的输出值。</p>
<p>Terraform 在计算输出值的 <code>value</code> 表达式之前执行 <code>precondition</code> 检查，这可以防止 <code>value</code> 表达式中的潜在错误被激发。</p>
<ul>
<li>
<p><a href="#%E5%B1%80%E9%83%A8%E5%80%BC"><strong>1.4.5.1.</strong> 局部值</a></p>
</li>
<li>
<p><a href="#%E4%B8%B4%E6%97%B6%EF%BC%88ephemeral%EF%BC%89%E5%B1%80%E9%83%A8%E5%80%BC"><strong>1.4.5.1.1.</strong> 临时（Ephemeral）局部值</a></p>
</li>
</ul>
<p><a href="#%E5%B1%80%E9%83%A8%E5%80%BC"></a></p>
<h2 id="1-4-5-1-局部值"><a href="#%E5%B1%80%E9%83%A8%E5%80%BC"></a>1.4.5.1. 局部值</h2>
<p>有时我们会需要用一个比较复杂的表达式计算某一个值，并且反复使用之，这时我们把这个复杂表达式赋予一个局部值，然后反复引用该局部值。如果说输入变量相当于函数的入参，输出值相当于函数的返回值，那么局部值就相当于函数内定义的局部变量。</p>
<p>局部值通过 <code>locals</code> 块定义，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  service_name = &quot;forum&quot;</span><br><span class="line">  owner        = &quot;Community Team&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 <code>locals</code> 块可以定义多个局部值，也可以定义任意多个 <code>locals</code> 块。赋给局部值的可以是更复杂的表达式，也可以是其他 <code>data</code>、<code>resource</code> 的输出、输入变量，甚至是其他的局部值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  # Ids for multiple sets of EC2 instances, merged together</span><br><span class="line">  instance_ids = concat(aws_instance.blue.*.id, aws_instance.green.*.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  # Common tags to be assigned to all resources</span><br><span class="line">  common_tags = &#123;</span><br><span class="line">    Service = local.service_name</span><br><span class="line">    Owner   = local.owner</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用局部值的表达式是 <code>local.&lt;NAME&gt;</code> (注意，虽然局部值定义在 <code>locals</code> 块内，但引用是务必使用 <code>local</code> 而不是 <code>locals</code>)，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  tags = local.common_tags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部值只能在同一模块内的代码中引用。</p>
<p>局部值可以帮助我们避免重复复杂的表达式，提升代码的可读性，但如果过度使用也有可能增加代码的复杂度，使得代码的维护者更难理解所使用的表达式和值。适度使用局部值，仅用于反复引用同一复杂表达式的场景，未来当我们需要修改该表达式时局部值将使得修改变得相当轻松。</p>
<h2 id="1-4-5-1-1-临时（Ephemeral）局部值"><a href="#%E4%B8%B4%E6%97%B6%EF%BC%88ephemeral%EF%BC%89%E5%B1%80%E9%83%A8%E5%80%BC"></a>1.4.5.1.1. 临时（Ephemeral）局部值</h2>
<p><strong>注意</strong>：临时局部值是 Terraform v1.10 开始引入的功能</p>
<p>如果局部值的表达式中引用了临时值，则本地值会隐式地变为临时值。例如，您可以创建引用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8Fephemeral">临时输入变量</a> <code>service_token</code> 的局部值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;service_name&quot; &#123;</span><br><span class="line">  type    = string</span><br><span class="line">  default = &quot;forum&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;environment&quot; &#123;</span><br><span class="line">  type    = string</span><br><span class="line">  default = &quot;dev&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;service_token&quot; &#123;</span><br><span class="line">  type      = string</span><br><span class="line">  ephemeral = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  service_tag   = &quot;$&#123;var.service_name&#125;-$&#123;var.environment&#125;&quot;</span><br><span class="line">  session_token = &quot;$&#123;var.service_name&#125;:$&#123;var.service_token&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式 <code>local.session_token</code> 的值隐式地成为了临时值，因为它依赖于临时输入变量 <code>var.service_token</code>。</p>
<ul>
<li>
<p><a href="#%E8%B5%84%E6%BA%90"><strong>1.4.6.1.</strong> 资源</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E8%AF%AD%E6%B3%95"><strong>1.4.6.1.1.</strong> 资源语法</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B"><strong>1.4.6.1.2.</strong> 资源类型</a></p>
</li>
<li>
<p><a href="#providers"><strong>1.4.6.1.2.1.</strong> Providers</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E5%8F%82%E6%95%B0"><strong>1.4.6.1.2.2.</strong> 资源参数</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E6%A1%A3"><strong>1.4.6.1.2.3.</strong> 资源类型的文档</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E8%A1%8C%E4%B8%BA"><strong>1.4.6.1.3.</strong> 资源的行为</a></p>
</li>
<li>
<p><a href="#%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E8%BE%93%E5%87%BA%E5%B1%9E%E6%80%A7"><strong>1.4.6.1.4.</strong> 访问资源输出属性</a></p>
</li>
<li>
<p><a href="#%E6%95%8F%E6%84%9F%E7%9A%84%E8%B5%84%E6%BA%90%E5%B1%9E%E6%80%A7"><strong>1.4.6.1.4.1.</strong> 敏感的资源属性</a></p>
</li>
<li>
<p><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><strong>1.4.6.1.5.</strong> 资源的依赖关系</a></p>
</li>
<li>
<p><a href="#%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.4.6.1.6.</strong> 元参数</a></p>
</li>
<li>
<p><a href="#dependson"><strong>1.4.6.1.6.1.</strong> depends_on</a></p>
</li>
<li>
<p><a href="#count"><strong>1.4.6.1.6.2.</strong> count</a></p>
</li>
<li>
<p><a href="#foreach"><strong>1.4.6.1.6.3.</strong> for_each</a></p>
</li>
<li>
<p><a href="#%E5%9C%A8-foreach-%E5%92%8C-count-%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9"><strong>1.4.6.1.6.4.</strong> 在 for_each 和 count 之间选择</a></p>
</li>
<li>
<p><a href="#provider"><strong>1.4.6.1.6.5.</strong> provider</a></p>
</li>
<li>
<p><a href="#lifecycle"><strong>1.4.6.1.6.6.</strong> lifecycle</a></p>
</li>
<li>
<p><a href="#precondition-%E4%B8%8E-postcondition"><strong>1.4.6.1.6.7.</strong> Precondition 与 Postcondition</a></p>
</li>
<li>
<p><a href="#provisioner-%E5%92%8C-connection"><strong>1.4.6.1.6.8.</strong> provisioner 和 connection</a></p>
</li>
<li>
<p><a href="#%E5%88%9B%E5%BB%BA%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8"><strong>1.4.6.1.7.</strong> 创建时预置器</a></p>
</li>
<li>
<p><a href="#%E9%94%80%E6%AF%81%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8"><strong>1.4.6.1.8.</strong> 销毁时预置器</a></p>
</li>
<li>
<p><a href="#%E9%A2%84%E7%BD%AE%E5%99%A8%E5%A4%B1%E8%B4%A5%E8%A1%8C%E4%B8%BA"><strong>1.4.6.1.9.</strong> 预置器失败行为</a></p>
</li>
<li>
<p><a href="#%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90"><strong>1.4.6.1.10.</strong> 删除资源</a></p>
</li>
<li>
<p><a href="#%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90"><strong>1.4.6.1.11.</strong> 本地资源</a></p>
</li>
<li>
<p><a href="#%E6%93%8D%E4%BD%9C%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE"><strong>1.4.6.1.12.</strong> 操作超时设置</a></p>
</li>
</ul>
<p><a href="#%E8%B5%84%E6%BA%90"></a></p>
<h2 id="1-4-6-1-资源"><a href="#%E8%B5%84%E6%BA%90"></a>1.4.6.1. 资源</h2>
<p>资源是 Terraform 最重要的组成部分，而本节亦是本教程最重要的一节。资源通过 <code>resource</code> 块来定义，一个 <code>resource</code> 可以定义一个或多个基础设施资源对象，例如 VPC、虚拟机，或是 DNS 记录、Consul 的键值对数据等。</p>
<h2 id="1-4-6-1-1-资源语法"><a href="#%E8%B5%84%E6%BA%90%E8%AF%AD%E6%B3%95"></a>1.4.6.1.1. 资源语法</h2>
<p>资源通过 <code>resource</code> 块定义，我们首先讲解通过 <code>resource</code> 块定义单个资源对象的场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_vpc&quot; &quot;main&quot; &#123;</span><br><span class="line">  cidr_block = var.base_cidr_block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;BLOCK TYPE&gt; &quot;&lt;BLOCK LABEL&gt;&quot; &quot;&lt;BLOCK LABEL&gt;&quot; &#123;</span><br><span class="line">  # Block body</span><br><span class="line">  &lt;IDENTIFIER&gt; = &lt;EXPRESSION&gt; # Argument</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>块</strong> 是其他内容的容器，通常代表某种对象的配置，比如资源。块有一个块类型，可以有零个或多个标签，有一个包含任意数量的参数和嵌套块的块体。Terraform 的大部分功能都是由配置文件中的顶级块控制的。</li>
<li><strong>参数</strong> 为一个名称赋值。它们出现在块内。</li>
<li><strong>表达式</strong> 表示一个值，可以是字面量，也可以是引用和组合其他值。它们出现在参数的值中，或者在其他表达式中。</li>
</ul>
<p>Terraform 是一种声明式语言，描述的是一个期望的资源状态，而不是达到期望状态所需要的步骤。块的顺序和它们所在的文件通常不重要；Terraform 只在确定操作顺序时考虑资源之间的隐式和显式关系。</p>
<p>在下面的例子里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧跟 <code>resource</code> 关键字的是资源类型，在上面的例子里就是 <code>aws_instance</code>。后面是资源的 Local Name，例子里就是 <code>web</code>。Local Name 可以在同一模块内的代码里被用来引用该资源，但类型加 Local Name 的组合在当前模块内必须是唯一的，不同类型的两个资源 Local Name 可以相同。随后的花括号内的内容就是块体，创建资源所用到的各种参数的值就在块体内定义。例子中我们定义了虚拟机所使用的镜像 id 以及虚拟机的尺寸。</p>
<p>请注意：资源名称必须以字母或下划线开头，只能包含字母、数字、下划线(<code>_</code>)和连字符(<code>-</code>)。</p>
<h2 id="1-4-6-1-2-资源类型"><a href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B"></a>1.4.6.1.2. 资源类型</h2>
<p>每个资源都与一个<em>资源类型</em>相关联，<em>资源类型</em>决定了它管理的基础设施对象的类型，以及资源支持的参数和其他属性。</p>
<h3 id="1-4-6-1-2-1-Providers"><a href="#providers"></a>1.4.6.1.2.1. Providers</h3>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html">Provider</a> 是 Terraform 用以提供一组资源类型的插件。每个资源类型都是由一个 Provider 实现的。Provider 提供了管理单个云或本地基础设施平台的资源。Provider 与 Terraform 分开发布，但 Terraform 可以在初始化工作目录时自动安装大多数 Provider。</p>
<p>要管理资源，Terraform 模块必须指定所需的 Provider。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html#provider-%E7%9A%84%E5%A3%B0%E6%98%8E">Provider 的声明</a>。</p>
<p>大部分 Provider 需要一些配置来访问远程 API，这些配置是在根模块中配置的。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.Provider.html#provider-%E7%9A%84%E9%85%8D%E7%BD%AE">Provider 配置</a>。</p>
<p>根据一个 <code>resource</code> 块的类型名，Terraform 通常可以确定使用哪个 Provider。按照约定，资源类型名以其 Provider 的首选 Local Name 开头。当使用一个 Provider 的多个配置或非首选的本地 Provider 名称时，你必须使用 <a href="#provider">provider 元参数</a> 来手动选择一个 Provider 配置。</p>
<h3 id="1-4-6-1-2-2-资源参数"><a href="#%E8%B5%84%E6%BA%90%E5%8F%82%E6%95%B0"></a>1.4.6.1.2.2. 资源参数</h3>
<p>不同资源定义了不同的可赋值的属性，官方文档将之称为参数(Argument)，有些参数是必填的，有些参数是可选的。使用某项资源前可以通过阅读相关文档了解参数列表以及他们的含义、赋值的约束条件。</p>
<p>参数值可以是简单的字面量，也可以是一个复杂的表达式。</p>
<h3 id="1-4-6-1-2-3-资源类型的文档"><a href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%87%E6%A1%A3"></a>1.4.6.1.2.3. 资源类型的文档</h3>
<p>每一个 Terraform Provider 都有自己的文档，用以描述它所支持的资源类型种类，以及每种资源类型所支持的属性列表。</p>
<p>大部分公共的 Provider 都是通过 <a target="_blank" rel="noopener" href="https://registry.terraform.io/browse/providers">Terraform Registry</a> 连带文档一起发布的。当我们在 Terraform Registry 站点上浏览一个 Provider 的页面时，我们可以点击 “Documentation” 链接来浏览相关文档。Provider 的文档都是版本化的，我们可以选择特定版本的 Provider 文档。</p>
<p>需要注意的是，Provider 文档曾经是直接托管在 <a target="_blank" rel="noopener" href="http://terraform.io">terraform.io</a> 站点上的，也就是 Terraform 核心主站的一部分，有些 Provider 的文档目前依然托管在那里，但目前 Terraform Registry 才是所有公共 Provider 文档的主站。</p>
<h2 id="1-4-6-1-3-资源的行为"><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E8%A1%8C%E4%B8%BA"></a>1.4.6.1.3. 资源的行为</h2>
<p>一个 <code>resource</code> 块声明了作者想要创建的一个确切的基础设施对象，并且设定了各项属性的值。如果我们正在编写一个新的 Terraform 代码文件，那么代码所定义的资源仅仅只在代码中存在，并没有与之对应的实际的基础设施资源存在。</p>
<p>对一组 Terraform 代码执行 <code>terraform apply</code> 可以创建、更新或者销毁实际的基础设施对象，Terraform 会制定并执行变更计划，以使得实际的基础设施符合代码的定义。</p>
<p>每当 Terraform 按照一个 <code>resource</code> 块创建了一个新的基础设施对象，这个实际的对象的 id 会被保存进 Terraform 状态中，使得将来 Terraform 可以根据变更计划对它进行更新或是销毁操作。如果一个 <code>resource</code> 块描述的资源在状态文件中已有记录，那么 Terraform 会比对记录的状态与代码描述的状态，如果有必要，Terraform 会制定变更计划以使得资源状态能够符合代码的描述。</p>
<p>这种行为适用于所有资源而无关其类型。创建、更新、销毁一个资源的细节会根据资源类型而不同，但是这个行为规则却是普适的。</p>
<h2 id="1-4-6-1-4-访问资源输出属性"><a href="#%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E8%BE%93%E5%87%BA%E5%B1%9E%E6%80%A7"></a>1.4.6.1.4. 访问资源输出属性</h2>
<p>资源不但可以通过参数传值，成功创建的资源还对外输出一些通过调用 API 才能获得的只读数据，经常包含了一些我们在实际创建一个资源之前无法获知的数据，比如云主机的 id 等，官方文档将之称为属性(Attribute)。我们可以在同一模块内的代码中引用资源的属性来创建其他资源或是表达式。在表达式中引用资源属性的语法是<code>&lt;RESOURCE TYPE&gt;.&lt;NAME&gt;.&lt;ATTRIBUTE&gt;</code>。</p>
<p>要获取一个资源类型输出的属性列表，我们可以查阅对应的 Provider 文档，一般在文档中会专门记录资源的输出属性列表。</p>
<h3 id="1-4-6-1-4-1-敏感的资源属性"><a href="#%E6%95%8F%E6%84%9F%E7%9A%84%E8%B5%84%E6%BA%90%E5%B1%9E%E6%80%A7"></a>1.4.6.1.4.1. 敏感的资源属性</h3>
<p>在为资源类型定义架构时，Provider 开发着可以将某些属性标记为 <code>sensitive</code>，在这种情况下，Terraform 将在展示涉及该属性的计划时显示占位符标记<code>(sensitive)</code> 而不是实际值。</p>
<p>标记为 <code>sensitive</code> 的 Provider 属性的行为类似于声明为 <code>sensitive</code> 的输入变量，Terraform 将隐藏计划中的值，还将隐藏从该值派生出的任何其他敏感值。但是，该行为存在一些限制，如 Terraform 可能暴露敏感变量。</p>
<p>如果使用资源属性中的敏感值作为输出值的一部分，Terraform 将要求将输出值本身标记为 <code>sensitive</code>，以确认确实打算将其导出。</p>
<p>Terraform 仍会在状态中记录敏感值，因此任何可以访问状态数据的人都可以以明文形式访问敏感值。</p>
<p>注意：Terraform 从 v0.15 开始将从敏感资源属性派生的值视为敏感值本身。早期版本的 Terraform 将隐藏敏感资源属性的直接值，但不会自动隐藏从敏感资源属性派生的其他值。</p>
<h2 id="1-4-6-1-5-资源的依赖关系"><a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"></a>1.4.6.1.5. 资源的依赖关系</h2>
<p>我们在介绍输出值的<code>depends_on</code>的时候已经简单介绍过了依赖关系。一般来说在 Terraform 代码定义的资源之间不会有特定的依赖关系，Terraform 可以并行地对多个无依赖关系的资源执行变更，默认情况下这个并行度是 10。</p>
<p>然而，创建某些资源所需要的信息依赖于另一个资源创建后输出的属性，又或者必须在某些资源成功创建后才可以被创建，这时资源之间就存在依赖关系。</p>
<p>大部分资源间的依赖关系可以被 Terraform 自动处理，Terraform 会分析 <code>resource</code> 块内的表达式，根据表达式的引用链来确定资源之间的引用，进而计算出资源在创建、更新、销毁时的执行顺序。大部分情况下，我们不需要显式指定资源之间的依赖关系。</p>
<p>然而，有时候某些依赖关系是无法从代码中推导出来的。例如，Terraform 必须要创建一个访问控制权限资源，以及另一个需要该权限才能成功创建的资源。后者的创建依赖于前者的成功创建，然而这种依赖在代码中没有表现为数据引用关联，这种情况下，我们需要用 <code>depends_on</code> 来显式声明这种依赖关系。</p>
<h2 id="1-4-6-1-6-元参数"><a href="#%E5%85%83%E5%8F%82%E6%95%B0"></a>1.4.6.1.6. 元参数</h2>
<p><code>resource</code> 块支持几种元参数声明，这些元参数可以被声明在所有类型的 <code>resource</code> 块内，它们将会改变资源的行为：</p>
<ul>
<li><code>depends_on</code>：显式声明依赖关系</li>
<li><code>count</code>：创建多个资源实例</li>
<li><code>for_each</code>：迭代集合，为集合中每一个元素创建一个对应的资源实例</li>
<li><code>provider</code>：指定非默认 Provider 实例</li>
<li><code>lifecycle</code>：自定义资源的生命周期行为</li>
<li><code>provisioner</code> 和 <code>connection</code>：在资源创建后执行一些额外的操作</li>
</ul>
<p>下面我们将逐一讲解他们的用法。</p>
<h3 id="1-4-6-1-6-1-depends-on"><a href="#dependson"></a>1.4.6.1.6.1. depends_on</h3>
<p>使用 <code>depends_on</code> 可以显式声明资源之间哪些 Terraform 无法自动推导出的隐含的依赖关系。只有当资源间确实存在依赖关系，但是彼此间又没有数据引用的场景下才有必要使用 <code>depends_on</code>。</p>
<p>使用 <code>depends_on</code> 的例子是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_role&quot; &quot;example&quot; &#123;</span><br><span class="line">  name = &quot;example&quot;</span><br><span class="line"></span><br><span class="line">  # assume_role_policy is omitted for brevity in this example. See the</span><br><span class="line">  # documentation for aws_iam_role for a complete example.</span><br><span class="line">  assume_role_policy = &quot;...&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_instance_profile&quot; &quot;example&quot; &#123;</span><br><span class="line">  # Because this expression refers to the role, Terraform can infer</span><br><span class="line">  # automatically that the role must be created first.</span><br><span class="line">  role = aws_iam_role.example.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_role_policy&quot; &quot;example&quot; &#123;</span><br><span class="line">  name   = &quot;example&quot;</span><br><span class="line">  role   = aws_iam_role.example.name</span><br><span class="line">  policy = jsonencode(&#123;</span><br><span class="line">    &quot;Statement&quot; = [&#123;</span><br><span class="line">      # This policy allows software running on the EC2 instance to</span><br><span class="line">      # access the S3 API.</span><br><span class="line">      &quot;Action&quot; = &quot;s3:*&quot;,</span><br><span class="line">      &quot;Effect&quot; = &quot;Allow&quot;,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  # Terraform can infer from this that the instance profile must</span><br><span class="line">  # be created before the EC2 instance.</span><br><span class="line">  iam_instance_profile = aws_iam_instance_profile.example</span><br><span class="line"></span><br><span class="line">  # However, if software running in this EC2 instance needs access</span><br><span class="line">  # to the S3 API in order to boot properly, there is also a &quot;hidden&quot;</span><br><span class="line">  # dependency on the aws_iam_role_policy that Terraform cannot</span><br><span class="line">  # automatically infer, so it must be declared explicitly:</span><br><span class="line">  depends_on = [</span><br><span class="line">    aws_iam_role_policy.example,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来分段解释一下这个场景，首先我们声明了一个 AWS IAM 角色，将角色绑定在一个主机实例配置文件上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_role&quot; &quot;example&quot; &#123;</span><br><span class="line">  name = &quot;example&quot;</span><br><span class="line"></span><br><span class="line">  # assume_role_policy is omitted for brevity in this example. See the</span><br><span class="line">  # documentation for aws_iam_role for a complete example.</span><br><span class="line">  assume_role_policy = &quot;...&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_instance_profile&quot; &quot;example&quot; &#123;</span><br><span class="line">  # Because this expression refers to the role, Terraform can infer</span><br><span class="line">  # automatically that the role must be created first.</span><br><span class="line">  role = aws_iam_role.example.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟机的声明代码中的这个赋值使得 Terraform 能够判断出虚拟机依赖于主机实例配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  # Terraform can infer from this that the instance profile must</span><br><span class="line">  # be created before the EC2 instance.</span><br><span class="line">  iam_instance_profile = aws_iam_instance_profile.example</span><br></pre></td></tr></table></figure>
<p>至此，Terraform 规划出的创建顺序是 IAM 角色 -&gt; 主机实例配置文件 -&gt; 主机实例。但是我们又为这个 IAM 角色添加了对 S3 存储服务的完全控制权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_role_policy&quot; &quot;example&quot; &#123;</span><br><span class="line">  name   = &quot;example&quot;</span><br><span class="line">  role   = aws_iam_role.example.name</span><br><span class="line">  policy = jsonencode(&#123;</span><br><span class="line">    &quot;Statement&quot; = [&#123;</span><br><span class="line">      # This policy allows software running on the EC2 instance to</span><br><span class="line">      # access the S3 API.</span><br><span class="line">      &quot;Action&quot; = &quot;s3:*&quot;,</span><br><span class="line">      &quot;Effect&quot; = &quot;Allow&quot;,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，虚拟机实例由于绑定了主机实例配置文件，从而在运行时拥有了一个 IAM 角色，而这个 IAM 角色又被赋予了 S3 的权限。但是虚拟机实例的声明代码中并没有引用 S3 权限的任何输出属性，这将导致 Terraform 无法理解他们之间存在依赖关系，进而可能会并行地创建两者，如果虚拟机实例被先创建了出来，内部的程序开始运行时，它所需要的 S3 权限却还没有创建完成，那么就将导致程序运行错误。为了确保虚拟机创建时 S3 权限一定已经存在，我们可以用 <code>depends_on</code> 显式声明它们的依赖关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># However, if software running in this EC2 instance needs access</span><br><span class="line">  # to the S3 API in order to boot properly, there is also a &quot;hidden&quot;</span><br><span class="line">  # dependency on the aws_iam_role_policy that Terraform cannot</span><br><span class="line">  # automatically infer, so it must be declared explicitly:</span><br><span class="line">  depends_on = [</span><br><span class="line">    aws_iam_role_policy.example,</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p><code>depends_on</code> 的赋值必须是包含同一模块内声明的其他资源名称的列表，不允许包含其他表达式，例如不允许使用其他资源的输出属性，这是因为 Terraform 必须在计算资源间关系之前就能理解列表中的值，为了能够安全地完成表达式计算，所以限制只能使用资源实例的名称。</p>
<p><code>depends_on</code> 只能作为最后的手段使用，如果我们使用 <code>depends_on</code>，我们应该用注释记录我们使用它的原因，以便今后代码的维护者能够理解隐藏的依赖关系。</p>
<h3 id="1-4-6-1-6-2-count"><a href="#count"></a>1.4.6.1.6.2. count</h3>
<p>一般来说，一个 resource 块定义了一个对应的实际基础设施资源对象。但是有时候我们希望创建多个相似的对象，比如创建一组虚拟机。Terraform 提供了两种方法实现这个目标：<code>count</code> 与 <code>for_each</code>。</p>
<p><code>count</code> 参数可以是任意自然数，Terraform 会创建 <code>count</code> 个资源实例，每一个实例都对应了一个独立的基础设施对象，并且在执行 Terraform 代码时，这些对象是被分别创建、更新或者销毁的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;server&quot; &#123;</span><br><span class="line">  count = 4 # create four similar EC2 instances</span><br><span class="line"></span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;Server $&#123;count.index&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在 <code>resource</code> 块中的表达式里使用 <code>count</code> 对象来获取当前的 <code>count</code> 索引号。<code>count</code> 对象只有一个属性：</p>
<ul>
<li><code>count.index</code>：代表当前对象对应的 <code>count</code> 下标索引(从 <code>0</code> 开始)</li>
</ul>
<p>如果一个 <code>resource</code> 块定义了 <code>count</code> 参数，那么 Terraform 会把这种多资源实例对象与没有 <code>count</code> 参数的单实例资源对象区别开：</p>
<ul>
<li>访问单资源实例对象：<code>&lt;TYPE&gt;.&lt;NAME&gt;</code>(例如：<code>aws_instance.server</code>)</li>
<li>访问多资源实例对象：<code>&lt;TYPE&gt;.&lt;NAME&gt;[&lt;INDEX&gt;]</code> (例如：<code>aws_instance.server[0]</code>，<code>aws_instance.server[1]</code>)</li>
</ul>
<p>声明了 <code>count</code> 或 <code>for_each</code> 的资源必须使用下标索引或者键来访问。</p>
<p><code>count</code> 参数可以是任意自然数，然而与 <code>resource</code> 的其他参数不同，<code>count</code> 的值在 Terraform 进行任何远程资源操作(实际的增删改查)之前必须是已知的，这也就意味着赋予 <code>count</code> 参数的表达式不可以引用任何其他资源的输出属性(例如由其他资源对象创建时返回的一个唯一的 ID)。</p>
<h3 id="1-4-6-1-6-3-for-each"><a href="#foreach"></a>1.4.6.1.6.3. for_each</h3>
<p><code>for_each</code> 是 Terraform 0.12.6 开始引入的新特性。一个 <code>resource</code> 块不允许同时声明 <code>count</code> 与 <code>for_each</code>。<code>for_each</code> 参数可以是一个 <code>map</code> 或是一个 <code>set(string)</code>，Terraform 会为集合中每一个元素都创建一个独立的基础设施资源对象，和 <code>count</code> 一样，每一个基础设施资源对象在执行 Terraform 代码时都是独立创建、修改、销毁的。</p>
<p>使用 <code>map</code> 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_resource_group&quot; &quot;rg&quot; &#123;</span><br><span class="line">  for_each = &#123;</span><br><span class="line">    a_group = &quot;eastus&quot;</span><br><span class="line">    another_group = &quot;westus2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  name     = each.key</span><br><span class="line">  location = each.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>set(string)</code> 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_user&quot; &quot;the-accounts&quot; &#123;</span><br><span class="line">  for_each = toset( [&quot;Todd&quot;, &quot;James&quot;, &quot;Alice&quot;, &quot;Dottie&quot;] )</span><br><span class="line">  name     = each.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在声明了 <code>for_each</code> 参数的 <code>resource</code> 块内使用 <code>each</code> 对象来访问当前的迭代器对象：</p>
<ul>
<li><code>each.key</code>：<code>map</code> 的键，或是 <code>set</code> 中的值</li>
<li><code>each.value</code>：<code>map</code> 的值，或是 <code>set</code> 中的值</li>
</ul>
<p>如果 <code>for_each</code> 的值是一个 <code>set</code>，那么 <code>each.key</code> 和 <code>each.value</code> 是相等的。</p>
<p>使用 <code>for_each</code> 时，<code>map</code> 的所有键、<code>set</code> 的所有 <code>string</code> 值都必须是已知的，也就是状态文件中已有记录的值。所以有时候我们可能需要在执行 <code>terraform apply</code> 时添加 <code>-target</code> 参数，实现分步创建。另外，<code>for_each</code> 所使用的键集合不能够包含或依赖非纯函数，也就是反复执行会返回不同返回值的函数，例如 <code>uuid</code>、<code>bcrypt</code>、<code>timestamp</code> 等。</p>
<p>当一个 <code>resource</code> 声明了 <code>for_each</code> 时，Terraform 会把这种多资源实例对象与没有 <code>count</code> 参数的单资源实例对象区别开：</p>
<ul>
<li>访问单资源实例对象：<code>&lt;TYPE&gt;.&lt;NAME&gt;</code>(例如：<code>aws_instance.server</code>)</li>
<li>访问多资源实例对象：<code>&lt;TYPE&gt;.&lt;NAME&gt;[&lt;KE&gt;]</code> (例如：<code>aws_instance.server[&quot;ap-northeast-1&quot;]</code>，<code>aws_instance.server[&quot;ap-northeast-2&quot;]</code>)</li>
</ul>
<p>声明了<code>count</code>或 <code>for_each</code> 的资源必须使用下标索引或者键来访问。</p>
<p>由于 Terraform 没有用以声明 <code>set</code> 的字面量，所以我们有时需要使用 <code>toset</code> 函数把 <code>list(string)</code> 转换为 <code>set(string)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  subnet_ids = toset([</span><br><span class="line">    &quot;subnet-abcdef&quot;,</span><br><span class="line">    &quot;subnet-012345&quot;,</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;server&quot; &#123;</span><br><span class="line">  for_each = local.subnet_ids</span><br><span class="line"></span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  subnet_id     = each.key # note: each.key and each.value are the same for a set</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;Server $&#123;each.key&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们用 <code>toset</code> 把一个 <code>list(string)</code> 转换成了 <code>set(string)</code>，然后赋予 <code>for_each</code>。在转换过程中，<code>list</code> 中所有重复的元素会被抛弃，只剩下不重复的元素，例如 <code>toset([&quot;b&quot;, &quot;a&quot;, &quot;b&quot;])</code> 的结果只有<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>，并且 <code>set</code> 的元素没有特定顺序。</p>
<p>如果我们要把一个输入变量赋予 <code>for_each</code>，我们可以直接定义变量的类型约束来避免显式调用 <code>toset</code> 转换类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;subnet_ids&quot; &#123;</span><br><span class="line">  type = set(string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;server&quot; &#123;</span><br><span class="line">  for_each = var.subnet_ids</span><br><span class="line"></span><br><span class="line">  # (and the other arguments as above)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-6-1-6-4-在-for-each-和-count-之间选择"><a href="#%E5%9C%A8-foreach-%E5%92%8C-count-%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9"></a>1.4.6.1.6.4. 在 for_each 和 count 之间选择</h3>
<p>如果创建的资源实例彼此之间几乎完全一致，那么 <code>count</code> 比较合适。如果彼此之间的参数差异无法直接从 <code>count</code> 的下标派生，那么使用 <code>for_each</code> 会更加安全。</p>
<p>在 Terraform 引入 <code>for_each</code> 之前，我们经常使用 <code>count.index</code> 搭配 <code>length</code> 函数和 <code>list</code> 来创建多个资源实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;subnet_ids&quot; &#123;</span><br><span class="line">  type = list(string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;server&quot; &#123;</span><br><span class="line">  # Create one instance for each subnet</span><br><span class="line">  count = length(var.subnet_ids)</span><br><span class="line"></span><br><span class="line">  ami           = &quot;ami-a1b2c3d4&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  subnet_id     = var.subnet_ids[count.index]</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;Server $&#123;count.index&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现方法是脆弱的，因为资源仍然是以他们的下标而不是实际的字符串值来区分的。如果我们从 <code>subnet_ids</code> 列表的中间移除了一个元素，那么从该位置起后续所有的 <code>aws_instance</code> 都会发现它们的 <code>subnet_id</code> 发生了变化，结果就是所有后续的 <code>aws_instance</code> 都需要更新。这种场景下如果使用 <code>for_each</code> 就更为妥当，如果使用 <code>for_each</code>，那么只有被移除的 <code>subnet_id</code> 对应的 <code>aws_instance</code> 会被销毁。</p>
<h3 id="1-4-6-1-6-5-provider"><a href="#provider"></a>1.4.6.1.6.5. provider</h3>
<p>关于 <code>provider</code> 的定义我们在前面介绍 Provider 的章节已经提到过了，如果我们声明了同一类型 Provider 的多个实例，那么我们在创建资源时可以通过指定 <code>provider</code> 参数选择要使用的 Provider 实例。如果没有指定 <code>provider</code> 参数，那么 Terraform 默认使用资源类型名中第一个单词所对应的 Provider 实例，例如 <code>google_compute_instance</code> 的默认 Provider 实例就是 <code>google</code>，<code>aws_instance</code> 的默认 Provider 就是 <code>aws</code>。</p>
<p>指定 <code>provider</code> 参数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># default configuration</span><br><span class="line">provider &quot;google&quot; &#123;</span><br><span class="line">  region = &quot;us-central1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># alternate configuration, whose alias is &quot;europe&quot;</span><br><span class="line">provider &quot;google&quot; &#123;</span><br><span class="line">  alias  = &quot;europe&quot;</span><br><span class="line">  region = &quot;europe-west1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;google_compute_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # This &quot;provider&quot; meta-argument selects the google provider</span><br><span class="line">  # configuration whose alias is &quot;europe&quot;, rather than the</span><br><span class="line">  # default configuration.</span><br><span class="line">  provider = google.europe</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>provider</code>参数期待的赋值是<code>&lt;PROVIDER&gt;</code>或是<code>&lt;PROVIDER&gt;.&lt;ALIAS&gt;</code>，不需要双引号。因为在Terraform开始计算依赖路径图时，provider关系必须是已知的，所以除了这两种以外的表达式是不被接受的。</p>
<h3 id="1-4-6-1-6-6-lifecycle"><a href="#lifecycle"></a>1.4.6.1.6.6. lifecycle</h3>
<p>通常一个资源对象的生命周期在前面<a href="#%E8%B5%84%E6%BA%90%E7%9A%84%E8%A1%8C%E4%B8%BA">“资源的行为”</a>一节中已经描述了，但是我们可以用 <code>lifecycle</code> 块来定一个不一样的行为方式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;azurerm_resource_group&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    create_before_destroy = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lifecycle</code> 块和它的内容都属于元参数，可以被声明于任意类型的资源块内部。Terraform 支持如下几种 <code>lifecycle</code>：</p>
<ul>
<li><code>create_before_destroy</code> (<code>bool</code>)：默认情况下，当 Terraform 需要修改一个由于服务端 API 限制导致无法直接升级的资源时，Terraform 会删除现有资源对象，然后用新的配置参数创建一个新的资源对象取代之。<code>create_before_destroy</code> 参数可以修改这个行为，使得 Terraform 首先创建新对象，只有在新对象成功创建并取代老对象后再销毁老对象。这并不是默认的行为，因为许多基础设施资源需要有一个唯一的名字或是别的什么标识属性，在新老对象并存时也要符合这种约束。有些资源类型有特别的参数可以为每个对象名称添加一个随机的前缀以防止冲突。Terraform 不能默认采用这种行为，所以在使用 <code>create_before_destroy</code> 前你必须了解每一种资源类型在这方面的约束。</li>
<li><code>prevent_destroy</code> (<code>bool</code>)：这个参数是一个保险措施，只要它被设置为 <code>true</code> 时，Terraform 会拒绝执行任何可能会销毁该基础设施资源的变更计划。这个参数可以预防意外删除关键资源，例如错误地执行了 <code>terraform destroy</code>，或者是意外修改了资源的某个参数，导致 Terraform 决定删除并重建新的资源实例。在 <code>resource</code> 块内声明了 <code>prevent_destroy = true</code> 会导致无法执行 <code>terraform destroy</code>，所以对它的使用要节制。需要注意的是，该措施无法防止我们删除 <code>resource</code> 块后 Terraform 删除相关资源，因为对应的 <code>prevent_destroy = true</code> 声明也被一并删除了。</li>
<li><code>ignore_changes</code> (<code>list(string)</code>)：默认情况下，Terraform 检测到代码描述的配置与真实基础设施对象之间有任何差异时都会计算一个变更计划来更新基础设施对象，使之符合代码描述的状态。在一些非常罕见的场景下，实际的基础设施对象会被 Terraform 之外的流程所修改，这就会使得 Terraform 不停地尝试修改基础设施对象以弥合和代码之间的差异。这种情况下，我们可以通过设定 <code>ignore_changes</code> 来指示 Terraform 忽略某些属性的变更。<code>ignore_changes</code> 的值定义了一组在创建时需要按照代码定义的值来创建，但在更新时不需要考虑值的变化的属性名，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    ignore_changes = [</span><br><span class="line">      # Ignore changes to tags, e.g. because a management agent</span><br><span class="line">      # updates these based on some ruleset managed elsewhere.</span><br><span class="line">      tags,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以忽略 <code>map</code> 中特定的元素，例如 <code>tags[&quot;Name&quot;]</code>，但是要注意的是，如果你是想忽略 <code>map</code> 中特定元素的变更，那么你必须首先确保 <code>map</code> 中含有这个元素。如果一开始 <code>map</code> 中并没有这个键，而后外部系统添加了这个键，那么 Terraform 还是会把它当成一次变更来处理。比较好的方法是你在代码中先为这个键创建一个占位元素来确保这个键已经存在，这样在外部系统修改了键对应的值以后 Terraform 会忽略这个变更。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    # Initial value for Name is overridden by our automatic scheduled</span><br><span class="line">    # re-tagging process; changes to this are ignored by ignore_changes</span><br><span class="line">    # below.</span><br><span class="line">    Name = &quot;placeholder&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    ignore_changes = [</span><br><span class="line">      tags[&quot;Name&quot;],</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用一个 <code>list(string)</code>，也可以使用关键字 <code>all</code> ，这时 Terraform 会忽略资源一切属性的变更，这样 Terraform 只会创建或销毁一个对象，但绝不会尝试更新一个对象。你只能在 <code>ignore_changes</code> 里忽略所属的 <code>resource</code> 的属性，<code>ignore_changes</code> 不可以赋予它自身或是其他任何元参数。</p>
<ul>
<li><code>replace_triggered_by</code> (包含资源引用的列表)：强制 Terraform 在引用的资源或是资源属性发生变更时替换声明该块的父资源，值为一个包含了托管资源、实例或是实例属性引用表达式的列表。当声明该块的资源声明了 <code>count</code> 或是 <code>for_each</code> 时，我们可以在表达式中使用 <code>count.index</code> 或是 <code>each.key</code> 来指定引用实例的序号。</li>
</ul>
<p><code>replace_triggered_by</code> 可以在以下几种场景中使用：</p>
<ul>
<li>如果表达式指向多实例的资源声明（例如声明了 <code>count</code> 或是 <code>for_each</code> 的资源），那么这组资源中任意实例发生变更或被替换时都将引发声明 <code>replace_triggered_by</code> 的资源被替换</li>
<li>如果表达式指向单个资源实例，那么该实例发生变更或被替换时将引发声明 <code>replace_triggered_by</code> 的资源被替换</li>
<li>如果表达式指向单个资源实例的单个属性，那么该属性值的任何变化都将引发声明 <code>replace_triggered_by</code> 的资源被替换</li>
</ul>
<p>我们在 <code>replace_triggered_by</code> 中只能引用托管资源。这允许我们在不引发强制替换的前提下修改这些表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_appautoscaling_target&quot; &quot;ecs_target&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    replace_triggered_by = [</span><br><span class="line">      # Replace `aws_appautoscaling_target` each time this instance of </span><br><span class="line">      # the `aws_ecs_service` is replaced.</span><br><span class="line">      aws_ecs_service.svc.id</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lifecycle</code> 配置影响了 Terraform 如何构建并遍历依赖图。作为结果，<code>lifecycle</code> 内赋值仅支持字面量，因为它的计算过程发生在 Terraform 计算的极早期。这就是说，例如 <code>prevent_destroy</code>、<code>create_before_destroy</code> 的值只能是 <code>true</code> 或者 <code>false</code>，<code>ignore_changes</code>、<code>replace_triggered_by</code> 的列表内只能是硬编码的属性名。</p>
<h3 id="1-4-6-1-6-7-Precondition-与-Postcondition"><a href="#precondition-%E4%B8%8E-postcondition"></a>1.4.6.1.6.7. Precondition 与 Postcondition</h3>
<p>请注意，Precondition 与 Postcondition 是从 Terraform v1.2.0 开始被引入的功能。</p>
<p>在 <code>lifecycle</code> 块中声明 <code>precondition</code> 与 <code>postcondition</code> 块可以为资源、数据源以及输出值创建自定义的验证规则。</p>
<p>Terraform 在计算一个对象之前会首先检查该对象关联的 <code>precondition</code>，并且在对象计算完成后执行 <code>postcondition</code> 检查。Terraform 会尽可能早地执行自定义检查，但如果表达式中包含了只有在 <code>apply</code> 阶段才能知晓的值，那么该检查也将被推迟执行。</p>
<p>每一个 <code>precondition</code> 与 <code>postcondition</code> 块都需要一个 <code>condition</code> 参数。该参数是一个表达式，在满足条件时返回 <code>true</code>，否则返回 <code>false</code>。该表达式可以引用同一模块内的任意其他对象，只要这种引用不会产生环依赖。在 <code>postcondition</code> 表达式中也可以使用 <code>self</code> 对象引用声明 <code>postcondition</code> 的资源实例的属性。</p>
<p>如果 <code>condition</code> 表达式计算结果为 <code>false</code>，Terraform 会生成一条错误信息，包含了 <code>error_message</code> 表达式的内容。如果我们声明了多条 <code>precondition</code> 或 <code>postcondition</code>，Terraform 会返回所有失败条件对应的错误信息。</p>
<p>下面的例子演示了通过 <code>postcondition</code> 检测调用者是否不小心传入了错误的 AMI 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data &quot;aws_ami&quot; &quot;example&quot; &#123;</span><br><span class="line">  id = var.aws_ami_id</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    # The AMI ID must refer to an existing AMI that has the tag &quot;nomad-server&quot;.</span><br><span class="line">    postcondition &#123;</span><br><span class="line">      condition     = self.tags[&quot;Component&quot;] == &quot;nomad-server&quot;</span><br><span class="line">      error_message = &quot;tags[\&quot;Component\&quot;] must be \&quot;nomad-server\&quot;.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>resource</code> 或 <code>data</code> 块中的 <code>lifecycle</code> 块可以同时包含 <code>precondition</code> 与 <code>postcondition</code> 块。</p>
<ul>
<li>Terraform 会在计算完 <code>count</code> 和 <code>for_each</code> 元参数后执行 <code>precondition</code> 块。这使得 Terraform 可以对每一个实例独立进行检查，并允许在表达式中使用 <code>each.key</code>、<code>count.index</code> 等。Terraform 还会在计算资源的参数表达式之前执行 <code>precondition</code> 检查。<code>precondition</code> 可以用来防止参数表达式计算中的错误被激发。</li>
<li>Terraform 在计算和执行对一个托管资源的变更之后执行 <code>postcondition</code> 检查，或是在完成数据源读取后执行它关联的 <code>postcondition</code> 检查。<code>postcondition</code> 失败会阻止其他依赖于此失败资源的其他资源的变更。</li>
</ul>
<p>在大多数情况下，我们不建议在同一配置文件中同时包含表示同一个对象的 <code>data</code> 块和 <code>resource</code> 块。这样做会使得 Terraform 无法理解 <code>data</code> 块的结果会被 <code>resource</code> 块的变更所影响。然而，当我们需要检查一个 <code>resource</code> 块的结果，恰巧该结果又没有被资源直接输出时，我们可以使用 <code>data</code> 块并在块中直接使用 <code>postcondition</code> 来检查该对象。这等于告诉 Terraform 该 <code>data</code> 块是用来检查其他什么地方定义的对象的，从而允许 Terraform 以正确的顺序执行操作。</p>
<h3 id="1-4-6-1-6-8-provisioner-和-connection"><a href="#provisioner-%E5%92%8C-connection"></a>1.4.6.1.6.8. provisioner 和 connection</h3>
<p>某些基础设施对象需要在创建后执行特定的操作才能正式工作。比如说，主机实例必须在上传了配置或是由配置管理工具初始化之后才能正常工作。</p>
<p>像这样创建后执行的操作可以使用预置器(Provisioner)。预置器是由 Terraform 所提供的另一组插件，每种预置器可以在资源对象创建后执行不同类型的操作。</p>
<p>使用预置器需要节制，因为他们采取的操作并非 Terraform 声明式的风格，所以 Terraform 无法对他们执行的变更进行建模和保存。</p>
<p>预置器也可以声明为资源销毁前执行，但会有一些限制。</p>
<p>作为元参数，<code>provisioner</code> 和 <code>connection</code> 可以声明在任意类型的 <code>resource</code> 块内。</p>
<p>举一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  provisioner &quot;file&quot; &#123;</span><br><span class="line">  source       = &quot;conf/myapp.conf&quot;</span><br><span class="line">  destination  = &quot;/etc/myapp.conf&quot;</span><br><span class="line"></span><br><span class="line">    connection &#123;</span><br><span class="line">      type     = &quot;ssh&quot;</span><br><span class="line">      user     = &quot;root&quot;</span><br><span class="line">      password = var.root_password</span><br><span class="line">      host     = self.public_ip</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 <code>aws_instance</code> 中定义了类型为 <code>file</code> 的预置器，该预置器可以本机文件或文件夹拷贝到目标机器的指定路径下。我们在预置器内部定义了<code>connection</code>块，类型是<code>ssh</code>。我们对<code>connection</code>的<code>host</code>赋值<code>self.public_ip</code>，在这里<code>self</code>代表预置器所在的母块，也就是<code>aws_instance.web</code>，所以<code>self.public_ip</code>代表着<code>aws_instance.web.public_ip</code>，也就是创建出来的主机的公网ip。</p>
<p><code>file</code> 类型预置器支持 <code>ssh</code> 和 <code>winrm</code> 两种类型的 <code>connection</code>。</p>
<p>预置器根据运行的时机分为两种类型，创建时预置器以及销毁时预置器。</p>
<h2 id="1-4-6-1-7-创建时预置器"><a href="#%E5%88%9B%E5%BB%BA%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8"></a>1.4.6.1.7. 创建时预置器</h2>
<p>默认情况下，创建时资源对象会运行预置器，在对象更新、销毁时则不会运行。预置器的默认行为是为了引导一个系统。</p>
<p>如果创建时预置器失败了，那么资源对象会被标记污点(我们将在介绍 <code>terraform taint</code> 命令时详细介绍)。一个被标记污点的资源在下次执行 <code>terraform apply</code> 命令时会被销毁并重建。Terraform 的这种设计是因为当预置器运行失败时标志着资源处于半就绪的状态。由于 Terraform 无法衡量预置器的行为，所以唯一能够完全确保资源被正确初始化的方式就是删除重建。</p>
<p>我们可以通过设置 <code>on_failure</code> 参数来改变这种行为。</p>
<h2 id="1-4-6-1-8-销毁时预置器"><a href="#%E9%94%80%E6%AF%81%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8"></a>1.4.6.1.8. 销毁时预置器</h2>
<p>如果我们设置预置器的 <code>when</code> 参数为 <code>destroy</code>，那么预置器会在资源被销毁时执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    when    = destroy</span><br><span class="line">    command = &quot;echo &#x27;Destroy-time provisioner&#x27;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁时预置器在资源被实际销毁前运行。如果运行失败，Terraform 会报错，并在下次运行 <code>terraform apply</code> 操作时重新执行预置器。在这种情况下，需要仔细关注销毁时预置器以使之能够安全地反复执行。</p>
<p>注意：销毁时预置器不会在 <code>resource</code> 块配置了 <code>create_before_destroy = true</code> 时运行。</p>
<p>销毁时预置器只有在存在于代码中的情况下才会在销毁时被执行。如果一个 <code>resource</code> 块连带内部的销毁时预置器块一起被从代码中删除，那么被删除的预置器在资源被销毁时<strong>不会</strong>被执行。要解决这个问题，我们需要使用多个步骤来绕过这个限制：</p>
<ul>
<li>修改资源声明代码，添加 <code>count = 0</code> 参数</li>
<li>执行 <code>terraform apply</code>，运行删除时预置器，然后删除资源实例</li>
<li>删除 <code>resource</code> 块</li>
<li>重新执行 <code>terraform apply</code>，此时应该不会有任何变更需要执行</li>
</ul>
<p>该限制在未来将会得到解决，但目前来说我们必须节制使用销毁时预置器。</p>
<p>注意：一个被标记污点的 <code>resource</code> 块内的销毁时预置器不会被执行。这包括了因为创建时预置器失败或是手动使用 <code>terraform taint</code> 命令标记污点的资源。</p>
<h2 id="1-4-6-1-9-预置器失败行为"><a href="#%E9%A2%84%E7%BD%AE%E5%99%A8%E5%A4%B1%E8%B4%A5%E8%A1%8C%E4%B8%BA"></a>1.4.6.1.9. 预置器失败行为</h2>
<p>默认情况下，预置器运行失败会导致<code>terraform apply</code>执行失败。可以通过设置<code>on_failure</code>参数来改变这一行为。可以设置的值为：</p>
<ul>
<li><code>continue</code>：忽视错误，继续执行创建或是销毁</li>
<li><code>fail</code>：报错并终止执行变更(这是默认行为)。如果这是一个创建时预置器，则在对应资源对象上标记污点</li>
</ul>
<p>样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    command    = &quot;echo The server&#x27;s IP address is $&#123;self.private_ip&#125;&quot;</span><br><span class="line">    on_failure = continue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-6-1-10-删除资源"><a href="#%E5%88%A0%E9%99%A4%E8%B5%84%E6%BA%90"></a>1.4.6.1.10. 删除资源</h2>
<p>注意：<code>removed</code> 块是在 Terraform v1.7 引入的功能。对于早期的 Terraform 版本，您可以使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/18.state/6.rm.html"><code>terraform state rm</code></a> 命令来处理。</p>
<p>要从 Terraform 中删除资源，只需从 Terraform 代码中删除 <code>resource</code> 块即可。</p>
<p>默认情况下，删除 <code>resource</code> 块后，Terraform 将计划销毁该资源管理的所有实际基础设施对象。</p>
<p>有时，我们可能希望从 Terraform 配置中删除资源，而不破坏它管理的实际基础设施对象。在这种情况下，资源将从 Terraform 状态中删除，但真正的基础设施对象不会被破坏。</p>
<p>要声明资源已从 Terraform 配置中删除，但不应销毁其托管对象，请从配置中删除 <code>resource</code> 块并将其替换为 <code>removed</code> 块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">removed &#123;</span><br><span class="line">  from = aws_instance.example</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    destroy = false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>from</code> 参数是您要删除的资源的地址，没有任何实例键（例如 <code>aws_instance.example[1]</code>）。</p>
<p><code>lifecycle</code> 块是必需的。 <code>destroy</code> 参数确定 Terraform 是否会尝试销毁资源管理的对象。 <code>false</code> 值表示 Terraform 将从状态中删除资源而不销毁实际的远程资源。</p>
<p><code>removed</code> 块还可以包含<a href="#%E9%94%80%E6%AF%81%E6%97%B6%E9%A2%84%E7%BD%AE%E5%99%A8">销毁时预置器</a>，以便即使 <code>resource</code> 块已被删除，预制器也可以保留在代码中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">removed &#123;</span><br><span class="line">  from = aws_instance.example</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    destroy = true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    when    = destroy</span><br><span class="line">    command = &quot;echo &#x27;Instance $&#123;self.id&#125; has been destroyed.&#x27;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通的销毁时预置器中的引用规则相同，仅允许使用 <code>count.index</code>、<code>each.key</code> 和 <code>self</code>。预置器必须指定 <code>when = destroy</code>，并且 <code>removed</code> 块必须声明 <code>destroy = true</code> 才能执行预置器。</p>
<h2 id="1-4-6-1-11-本地资源"><a href="#%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90"></a>1.4.6.1.11. 本地资源</h2>
<p>虽然大部分资源类型都对应的是通过远程基础设施 API 控制的一个资源对象，但也有一些资源对象他们只存在于 Terraform 进程自身内部，用来计算生成某些结果，并将这些结果保存在状态中以备日后使用。</p>
<p>比如说，我们可以用 <code>tls_private_key</code> 生成公私钥，用 <code>tls_self_signed_cert</code> 生成自签名证书，或者是用 <code>random_id</code> 生成随机 id。虽不像其他“真实”基础设施对象那般重要，但这些本地资源也可以成为连接其他资源有用的黏合剂。</p>
<p>本地资源的行为与其他类型资源是一致的，但是他们的结果数据仅存在于 Terraform 状态文件中。“销毁”这种资源只是将结果数据从状态中删除。</p>
<h2 id="1-4-6-1-12-操作超时设置"><a href="#%E6%93%8D%E4%BD%9C%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE"></a>1.4.6.1.12. 操作超时设置</h2>
<p>有些资源类型提供了特殊的 <code>timeouts</code> 内嵌块参数，它允许我们配置我们允许操作持续多长时间，超时将被认定为失败。比如说，<code>aws_db_instance</code> 资源允许我们分别为 <code>create</code>，<code>update</code>，<code>delete</code> 操作设置超时时间。</p>
<p>超时完全由资源对应的 Provider 来处理，但支持超时设置的 Provider 一般都遵循相同的传统，那就是由一个名为 <code>timeouts</code> 的内嵌块参数定义超时设置，<code>timeouts</code> 块内可以分别设置不同操作的超时时间。超时时间由 <code>string</code> 描述，比如 <code>&quot;60m&quot;</code> 代表 60 分钟，<code>&quot;10s&quot;</code> 代表 10 秒，<code>&quot;2h&quot;</code> 代表 2 小时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_db_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  # ...</span><br><span class="line"></span><br><span class="line">  timeouts &#123;</span><br><span class="line">    create = &quot;60m&quot;</span><br><span class="line">    delete = &quot;2h&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可配置超时的操作类别由每种支持超时设定的资源类型自行决定。大部分资源类型不支持设置超时。使用超时前请先查阅相关文档。</p>
<ul>
<li>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.7.1.</strong> 数据源</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.7.1.1.</strong> 使用数据源</a></p>
</li>
<li>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%82%E6%95%B0"><strong>1.4.7.1.2.</strong> 数据源参数</a></p>
</li>
<li>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E8%A1%8C%E4%B8%BA"><strong>1.4.7.1.3.</strong> 数据源行为</a></p>
</li>
<li>
<p><a href="#%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.7.1.4.</strong> 本地数据源</a></p>
</li>
<li>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><strong>1.4.7.1.5.</strong> 数据源的依赖关系</a></p>
</li>
<li>
<p><a href="#precondition-%E4%B8%8E-postcondition"><strong>1.4.7.1.6.</strong> Precondition 与 Postcondition</a></p>
</li>
<li>
<p><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><strong>1.4.7.1.7.</strong> 生命周期</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E4%BE%8B"><strong>1.4.7.1.8.</strong> 多数据源实例</a></p>
</li>
<li>
<p><a href="#%E6%8C%87%E5%AE%9A%E7%89%B9%E5%AE%9A-provider-%E5%AE%9E%E4%BE%8B"><strong>1.4.7.1.9.</strong> 指定特定 Provider 实例</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90"><strong>1.4.7.1.10.</strong> 例子</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.7.1.11.</strong> 引用数据源</a></p>
</li>
</ul>
<p><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90"></a></p>
<h2 id="1-4-7-1-数据源"><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.7.1. 数据源</h2>
<p>数据源允许查询或计算一些数据以供其他地方使用。使用数据源可以使得 Terraform 代码使用在 Terraform 管理范围之外的一些信息，或者是读取其他 Terraform 代码保存的状态。</p>
<p>每一种 Provider 都可以在定义一些资源类型的同时定义一些数据源。</p>
<h2 id="1-4-7-1-1-使用数据源"><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.7.1.1. 使用数据源</h2>
<p>数据源通过一种特殊的资源访问：<code>data</code> 资源。数据源通过 <code>data</code> 块声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data &quot;aws_ami&quot; &quot;example&quot; &#123;</span><br><span class="line">  most_recent = true</span><br><span class="line"></span><br><span class="line">  owners = [&quot;self&quot;]</span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name   = &quot;app-server&quot;</span><br><span class="line">    Tested = &quot;true&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 <code>data</code> 块请求 Terraform 从一个指定的数据源 <code>aws_ami</code> 读取指定数据并且把结果输出到 Local Name 为 <code>example</code> 的实例中。我们可以在同一模块内的代码中通过数据源名称来引用数据源，但无法从模块外部直接访问数据源。</p>
<p>同资源类似，一个数据源类型以及它的名称一同构成了该数据源的标识符，所以数据源类型加名称的组合在同一模块内必须是唯一的。</p>
<p>在 <code>data</code> 块体(<code>&#123;</code> 与 <code>&#125;</code> 中间的内容)是传给数据源的查询条件。查询条件参数的种类取决于数据源的类型，在上述例子中，<code>most_recent</code>、<code>owners</code> 和 <code>tags</code> 都是定义查询 <code>aws_ami</code> 数据源时使用的查询条件。</p>
<p>与数据源这种特殊资源不同的是，我们在上一节介绍的主要资源(使用 <code>resource</code> 块定义的)是一种“托管资源”。这两种资源都可以接收参数并对外输出属性，但托管资源会触发 Terraform 对基础设施对象进行增删改操作，而数据源只会触发读取操作。简单来说，我们一般说的“资源”就是特指托管资源。</p>
<h2 id="1-4-7-1-2-数据源参数"><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%82%E6%95%B0"></a>1.4.7.1.2. 数据源参数</h2>
<p>每一种数据源资源都关联到一种外部数据源，数据源类型决定了它接收的查询参数以及输出的数据。每一种数据源类型都属于一个 Provider。大部分 <code>data</code> 块内的数据源参数都是由对应的数据源类型定义的，这些参数的赋值可以使用完整的 Terraform 表达式能力或其他 Terraform 语言的功能。</p>
<p>然而类似资源，Terraform 也为所有类型的数据源定义了一些元参数。这些元参数的限制和功能我们将在后续节当中叙述。</p>
<h2 id="1-4-7-1-3-数据源行为"><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E8%A1%8C%E4%B8%BA"></a>1.4.7.1.3. 数据源行为</h2>
<p>如果数据源的查询参数涉及到的表达式只引用了字面量或是在执行 <code>terraform plan</code> 时就已知的数据(比如输入变量)，那么数据源会在执行 Terraform 的 “refersh” 阶段时被读取，然后 Terraform 会构建变更计划。这保证了在制定变更计划时 Terraform 可以使用这些数据源的返回数据。</p>
<p>如果查询参数的表达式引用了那些只有执行部分执行变更计划以后才能知晓的数据，比如另一个还未被创建的托管资源的输出，那么数据源的读取操作会被推迟到 “apply” 阶段。以下几种情况下 Terraform 会推迟数据源的读取：</p>
<ul>
<li>给定的参数中至少有一个是一个托管资源的属性或是其他值，Terraform 在执行步骤之前无法预测。</li>
<li><code>data</code> 块内的查询参数引用了一个还未被创建的托管资源的输出。</li>
<li><code>data</code> 块内声明的 <code>precondition</code> 或 <code>postcondition</code> 直接或间接地依赖了一个在当前计划中有变更的托管资源。</li>
</ul>
<p>任何引用该数据源输出的表达式的值在执行到数据源被读取完之前都是未知的。</p>
<h2 id="1-4-7-1-4-本地数据源"><a href="#%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.7.1.4. 本地数据源</h2>
<p>虽然绝大多数数据源都对应了一个通过远程基础设施 API 访问的外部数据源，但是也有一些特殊的数据源仅存在于 Terraform 进程内部，计算并对外输出一些数据。</p>
<p>比如说，本地数据源有 <code>template_file</code>、<code>local_file</code>、<code>aws_iam_policy_document</code> 等。</p>
<p>本地数据源的行为与其他数据源完全一致，但他们输出的结果数据只是临时存在于 Terraform 运行时，每次计算一个新的变更计划时这些值都会被重新计算。</p>
<h2 id="1-4-7-1-5-数据源的依赖关系"><a href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"></a>1.4.7.1.5. 数据源的依赖关系</h2>
<p>数据源有着与资源一样的依赖机制，我们也可以在 <code>data</code> 块内设置 <code>depends_on</code> 元参数来显式声明依赖关系，在此不再赘述。</p>
<p>注意：在 Terraform 0.12 及更早版本中，由于 <code>data</code> 会将尚不知晓值的读取推迟到 Apply 阶段，因此将 <code>dependent_on</code> 与 <code>data</code> 一起使用将强制将数据的读取推迟到 Apply 阶段，因此，使用 <code>depends_on</code> 的 <code>data</code> 数据源配置永远无法收敛。由于这种行为，我们不建议对 <code>data</code> 使用 <code>depends_on</code>。</p>
<h2 id="1-4-7-1-6-Precondition-与-Postcondition"><a href="#precondition-%E4%B8%8E-postcondition"></a>1.4.7.1.6. Precondition 与 Postcondition</h2>
<p>您可以使用 <code>precondition</code> 和 <code>postcondition</code> 块来指定有关 <code>data</code> 如何运行的假设和验证。以下实力创建一个 <code>postcondition</code> 来检查 AMI 是否具有正确的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data &quot;aws_ami&quot; &quot;example&quot; &#123;</span><br><span class="line">  id = var.aws_ami_id</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    # The AMI ID must refer to an existing AMI that has the tag &quot;nomad-server&quot;.</span><br><span class="line">    postcondition &#123;</span><br><span class="line">      condition     = self.tags[&quot;Component&quot;] == &quot;nomad-server&quot;</span><br><span class="line">      error_message = &quot;tags[\&quot;Component\&quot;] must be \&quot;nomad-server\&quot;.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义条件检查可以声明对数据的假设，帮助未来的维护人员了解代码的设计和意图。它们还可以更早地在上下文中返回有关错误的有用信息，帮助使用者更轻松地诊断其配置中的问题。</p>
<h2 id="1-4-7-1-7-生命周期"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"></a>1.4.7.1.7. 生命周期</h2>
<p>同资源<strong>不一样</strong>，数据源目前的 <code>lifecycle</code> 块中只支持 <code>precondition</code> 和 <code>postcondition</code> 块。</p>
<h2 id="1-4-7-1-8-多数据源实例"><a href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E4%BE%8B"></a>1.4.7.1.8. 多数据源实例</h2>
<p>与资源一样，数据源也可以通过设置 <code>count</code>、<code>for_each</code> 元参数来创建一组多个数据源实例，并且 Terraform 也会把每个数据源实例单独创建并读取相应的外部数据，对 <code>count.index</code> 与 <code>each</code> 的使用也是一样的，在 <code>count</code> 与 <code>for_each</code> 之间选择的原则也是一样的。</p>
<h2 id="1-4-7-1-9-指定特定-Provider-实例"><a href="#%E6%8C%87%E5%AE%9A%E7%89%B9%E5%AE%9A-provider-%E5%AE%9E%E4%BE%8B"></a>1.4.7.1.9. 指定特定 Provider 实例</h2>
<p>同资源一样，数据源也可以通过 <code>provider</code> 元参数指定使用特定 Provider 实例，在此不再赘述。</p>
<h2 id="1-4-7-1-10-例子"><a href="#%E4%BE%8B%E5%AD%90"></a>1.4.7.1.10. 例子</h2>
<p>一个数据源定义例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Find the latest available AMI that is tagged with Component = web</span><br><span class="line">data &quot;aws_ami&quot; &quot;web&quot; &#123;</span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;state&quot;</span><br><span class="line">    values = [&quot;available&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;tag:Component&quot;</span><br><span class="line">    values = [&quot;web&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  most_recent = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-7-1-11-引用数据源"><a href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.7.1.11. 引用数据源</h2>
<p>引用数据源数据的语法是<code>data.&lt;TYPE&gt;.&lt;NAME&gt;.&lt;ATTRIBUTE&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = data.aws_ami.web.id</span><br><span class="line">  instance_type = &quot;t1.micro&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>1.4.8.1.</strong> 表达式</a></p>
</li>
<li>
<p><a href="#%E4%B8%8B%E6%A0%87%E5%92%8C%E5%B1%9E%E6%80%A7"><strong>1.4.8.1.1.</strong> 下标和属性</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E5%91%BD%E5%90%8D%E5%80%BC"><strong>1.4.8.1.2.</strong> 引用命名值</a></p>
</li>
<li>
<p><a href="#%E5%B1%80%E9%83%A8%E5%91%BD%E5%90%8D%E5%80%BC"><strong>1.4.8.1.3.</strong> 局部命名值</a></p>
</li>
<li>
<p><a href="#%E5%91%BD%E5%90%8D%E5%80%BC%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><strong>1.4.8.1.4.</strong> 命名值的依赖关系</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90%E8%BE%93%E5%87%BA%E5%B1%9E%E6%80%A7"><strong>1.4.8.1.5.</strong> 引用资源输出属性</a></p>
</li>
<li>
<p><a href="#%E5%B0%9A%E4%B8%8D%E7%9F%A5%E6%99%93%E7%9A%84%E5%80%BC"><strong>1.4.8.1.6.</strong> 尚不知晓的值</a></p>
</li>
<li>
<p><a href="#%E7%AE%97%E6%95%B0%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.</strong> 算数和逻辑操作符</a></p>
</li>
<li>
<p><a href="#%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.1.</strong> 算数操作符</a></p>
</li>
<li>
<p><a href="#%E7%9B%B8%E7%AD%89%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.2.</strong> 相等性操作符</a></p>
</li>
<li>
<p><a href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.3.</strong> 比较操作符</a></p>
</li>
<li>
<p><a href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>1.4.8.1.7.4.</strong> 逻辑操作符</a></p>
</li>
<li>
<p><a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>1.4.8.1.8.</strong> 条件表达式</a></p>
</li>
<li>
<p><a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><strong>1.4.8.1.9.</strong> 函数调用</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E5%BC%80%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82"><strong>1.4.8.1.9.1.</strong> 展开函数入参</a></p>
</li>
<li>
<p><a href="#for-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>1.4.8.1.10.</strong> for 表达式</a></p>
</li>
<li>
<p><a href="#%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8Fsplat-expression"><strong>1.4.8.1.11.</strong> 展开表达式(Splat Expression)</a></p>
</li>
<li>
<p><a href="#%E9%81%97%E7%95%99%E7%9A%84%E6%97%A7%E6%9C%89%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>1.4.8.1.11.1.</strong> 遗留的旧有展开表达式</a></p>
</li>
<li>
<p><a href="#dynamic-%E5%9D%97"><strong>1.4.8.1.12.</strong> dynamic 块</a></p>
</li>
<li>
<p><a href="#dynamic-%E5%9D%97%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><strong>1.4.8.1.12.1.</strong> dynamic 块的最佳实践</a></p>
</li>
<li>
<p><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><strong>1.4.8.1.13.</strong> 字符串字面量</a></p>
</li>
<li>
<p><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%89%88"><strong>1.4.8.1.14.</strong> 字符串模版</a></p>
</li>
<li>
<p><a href="#%E6%8F%92%E5%80%BCinterpolation"><strong>1.4.8.1.14.1.</strong> 插值(Interpolation)</a></p>
</li>
<li>
<p><a href="#%E5%91%BD%E4%BB%A4directive"><strong>1.4.8.1.14.2.</strong> 命令(Directive)</a></p>
</li>
<li>
<p><a href="#terraform-%E6%8F%92%E5%80%BC"><strong>1.4.8.1.15.</strong> Terraform 插值</a></p>
</li>
</ul>
<p><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a></p>
<h2 id="1-4-8-1-表达式"><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a>1.4.8.1. 表达式</h2>
<p>表达式用来在配置文件中进行一些计算。最简单的表达式就是字面量，比如 <code>&quot;hello&quot;</code>，或者 <code>5</code>。<code>Terraform</code> 也支持一些更加复杂的表达式，比如引用其他 <code>resource</code> 的输出值、数学计算、布尔条件计算，以及一些内建的函数。</p>
<p>Terraform 配置中很多地方都可以使用表达式，但某些特定的场景下限制了可以使用的表达式的类型，例如只准使用特定数据类型的字面量，或是禁止使用 <code>resource</code> 的输出值。</p>
<p>您可以通过运行 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/6.Terraform%E5%91%BD%E4%BB%A4%E8%A1%8C/5.console"><code>terraform console</code> 命令</a>，从 Terraform 表达式控制台测试 Terraform 表达式的行为。</p>
<p>我们在类型章节中已经基本介绍了类型以及类型相关的字面量，下面我们来介绍一些其他的表达式。</p>
<h2 id="1-4-8-1-1-下标和属性"><a href="#%E4%B8%8B%E6%A0%87%E5%92%8C%E5%B1%9E%E6%80%A7"></a>1.4.8.1.1. 下标和属性</h2>
<p><code>list</code> 和 <code>tuple</code> 可以通过下标访问成员，例如 <code>local.list[3]</code>、<code>var.tuple[2]</code>。<code>map</code> 和 <code>object</code> 可以通过属性访问成员，例如 <code>local.object.attrname</code>、<code>local.map.keyname</code>。由于 <code>map</code> 的键是用户定义的，可能无法成为合法的 Terraform 标识符，所以访问 <code>map</code> 成员时我们推荐使用方括号：<code>local.map[&quot;keyname&quot;]</code>。</p>
<h2 id="1-4-8-1-2-引用命名值"><a href="#%E5%BC%95%E7%94%A8%E5%91%BD%E5%90%8D%E5%80%BC"></a>1.4.8.1.2. 引用命名值</h2>
<p>Terraform 中定义了多种命名值，表达式中的每一个命名值都关联到一个具体的值，我们可以用单一命名值作为一个表达式，或是组合多个命名值来计算出一个新值。</p>
<p>命名值有如下种类：</p>
<ul>
<li><code>&lt;RESOURCE TYPE&gt;.&lt;NAME&gt;</code>：表示一个资源对象。凡是不符合后面列出的命名值模式的表达式都会被 Terraform 解释为一个托管资源。如果资源声明了 <code>count</code> 元参数，那么该表达式表示的是一个对象实例的 <code>list</code>。如果资源声明了 <code>for_each</code> 元参数，那么该表达式表示的是一个对象实例的 <code>map</code>。</li>
<li><code>var.&lt;NAME&gt;</code>：表示一个输入变量</li>
<li><code>local.&lt;NAME&gt;</code>：表示一个局部值</li>
<li><code>module.&lt;MODULE_NAME&gt;.&lt;OUTPUT_NAME&gt;</code>：表示一个模块的一个输出值</li>
<li><code>data.&lt;DATA_TYPE&gt;.&lt;NAME&gt;</code>：表示一个数据源实例。如果数据源声明了 <code>count</code> 元参数，那么该表达式表示的是一个数据源实例 <code>list</code>。如果数据源声明了 <code>for_each</code> 元参数，那么该表达式表示的是一个数据源实例 <code>map</code>。</li>
<li><code>path.module</code>：表示当前模块在文件系统中的路径</li>
<li><code>path.root</code>：表示根模块(调用 Terraform 命令行执行的代码文件所在的模块)在文件系统中的路径</li>
<li><code>path.cwd</code>：表示当前工作目录的路径。一般来说该路径等同于 <code>path.root</code>，但在调用 Terraform 命令行时如果指定了代码路径，那么二者将会不同。</li>
<li><code>terraform.workspace</code>：当前使用的 Workspace (我们在状态管理的<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/2.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html#%E7%8A%B6%E6%80%81%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AD%98%E5%82%A8">&quot;状态的隔离存储&quot;</a>中介绍过)</li>
</ul>
<p>虽然这些命名表达式可以使用 <code>.&lt;NAME&gt;</code> 号来访问对象的各种属性，但实际上他们实际类型并不是我们在类型章节里提到过的 <code>object</code>。两者的区别在于，<code>object</code> 同时支持使用 <code>.&lt;NAME&gt;</code> 或者 <code>[&quot;&lt;NAME&gt;&quot;]</code> 两种方式访问对象成员属性，而上述命名表达式仅支持 <code>.&lt;NAME&gt;</code>。</p>
<h2 id="1-4-8-1-3-局部命名值"><a href="#%E5%B1%80%E9%83%A8%E5%91%BD%E5%90%8D%E5%80%BC"></a>1.4.8.1.3. 局部命名值</h2>
<p>在某些特定表达式或上下文当中，有一些特殊的命名值可以被使用，他们是局部命名值。几种比较常见的局部命名值有：</p>
<ul>
<li><code>count.index</code>：表达当前 <code>count</code> 下标序号</li>
<li><code>each.key</code>：表达当前 <code>for_each</code> 迭代器实例</li>
<li><code>self</code>：在预置器中指代声明预置器的资源</li>
</ul>
<h2 id="1-4-8-1-4-命名值的依赖关系"><a href="#%E5%91%BD%E5%90%8D%E5%80%BC%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"></a>1.4.8.1.4. 命名值的依赖关系</h2>
<p>构建资源或是模块时经常会使用含有命名值的表达式赋值，Terraform 会分析这些表达式并自动计算出对象之间的依赖关系。</p>
<h2 id="1-4-8-1-5-引用资源输出属性"><a href="#%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90%E8%BE%93%E5%87%BA%E5%B1%9E%E6%80%A7"></a>1.4.8.1.5. 引用资源输出属性</h2>
<p>最常见的引用类型就是引用一个 <code>resource</code> 或 <code>data</code> 块定义的对象的输出属性。由于这些资源与数据源对象结构可能非常复杂，所以对它们的输出属性的引用表达式也可能非常复杂。</p>
<p>比如下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-abc123&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  ebs_block_device &#123;</span><br><span class="line">    device_name = &quot;sda2&quot;</span><br><span class="line">    volume_size = 16</span><br><span class="line">  &#125;</span><br><span class="line">  ebs_block_device &#123;</span><br><span class="line">    device_name = &quot;sda3&quot;</span><br><span class="line">    volume_size = 20</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>aws_instance</code> 文档列出了该类型所支持的所有输入参数和内嵌块，以及对外输出的属性列表。所有这些不同的资源类型 Schema 都可以在引用中使用，如下所示：</p>
<ul>
<li><code>ami</code> 参数可以在可以在其他地方用 <code>aws_instance.example.ami</code> 表达式来引用</li>
<li><code>id</code> 属性可以用 <code>aws_instance.example.id</code> 的表达式来引用</li>
<li>内嵌的 <code>ebs_block_device</code> 参数可以通过后面会介绍的<a href="#%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8Fsplat-expression">展开表达式(splat expression)</a>来访问，比如我们获取所有的 <code>ebs_block_device</code> 的 <code>device_name</code> 列表：<code>aws_instance.example.ebs_block_device[*].device_name</code></li>
<li>在 <code>aws_instance</code> 类型里的内嵌块并没有任何输出属性，但如果 <code>ebs_block_device</code> 添加了一个名为 <code>&quot;id&quot;</code> 的输出属性，那么可以用 <code>aws_instance.example.ebs_block_device[*].id</code> 表达式来访问含有所有 <code>id</code> 的列表</li>
<li>有时多个内嵌块会各自包含一个逻辑键来区分彼此，类似用资源名访问资源，我们也可以用内嵌块的名字来访问特定内嵌块。假如 <code>aws_instance</code> 类型有一个假想的内嵌块类型 <code>device</code> 并规定 <code>device</code> 可以赋予这样的一个逻辑键，那么代码看起来就会是这样的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">device &quot;foo&quot; &#123;</span><br><span class="line">  size = 2</span><br><span class="line">&#125;</span><br><span class="line">device &quot;bar&quot; &#123;</span><br><span class="line">  size = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用键来访问特定块的数据，例如：<code>aws_instance.example.device[&quot;foo&quot;].size</code></p>
<p>要获取一个 <code>device</code> 名称到 <code>device</code> 大小的映射，可以使用 <code>for</code> 表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;for k, device in aws_instance.example.device : k =&gt; device.size&#125;</span><br></pre></td></tr></table></figure>
<p>当一个资源声明了 <code>count</code> 参数，那么资源本身就成了一个资源对象列表而非单个资源。这种情况下要访问资源输出属性，要么使用展开表达式，要么使用下标索引：</p>
<ul>
<li><code>aws_instance.example[*].id</code>：返回所有 instance 的 <code>id</code> 列表</li>
<li><code>aws_instance.example[0].id</code>：返回第一个 instance的 <code>id</code></li>
</ul>
<p>当一个资源声明了 <code>for_each</code> 参数，那么资源本身就成了一个资源对象字典而非单个资源。这种情况下要访问资源的输出属性，要么使用特定键，要么使用 <code>for</code> 表达式：</p>
<ul>
<li><code>aws_instance.example[&quot;a&quot;].id</code>：返回 <code>&quot;a&quot;</code> 对应的实例的 <code>id</code></li>
<li><code>[for value in aws_instance.example: value.id]</code>：返回所有 instance 的 <code>id</code></li>
</ul>
<p>注意不像使用 <code>count</code>，使用 <code>for_each</code> 的资源集合不能直接使用展开表达式，展开表达式只能适用于列表。你可以把字典转换成列表后再使用展开表达式：</p>
<ul>
<li><code>values(aws_instance.example)[*].id</code></li>
</ul>
<h2 id="1-4-8-1-6-尚不知晓的值"><a href="#%E5%B0%9A%E4%B8%8D%E7%9F%A5%E6%99%93%E7%9A%84%E5%80%BC"></a>1.4.8.1.6. 尚不知晓的值</h2>
<p>当 Terraform 在计算变更计划时，有些资源输出属性无法立即求值，因为他们的值取决于远程API的返回值。比如说，有一个远程对象可以在创建时返回一个生成的唯一 <code>id</code>，Terraform 无法在创建它之前就预知这个值。</p>
<p>为了允许在计算变更阶段就能计算含有这种值的表达式，Terraform 使用了一个特殊的&quot;尚不知晓(unknown value)&quot;占位符来代替这些结果。大部分时候你不需要特意理会它们，因为 Terraform 语言会自动处理这些尚不知晓的值，比如说使两个尚不知晓的值相加得到的会是一个尚不知晓的值。</p>
<p>然而，有些情况下表达式中含有尚不知晓的值会有明显的影响：</p>
<ul>
<li><code>count</code> 元参数不可以为尚不知晓，因为变更计划必须明确地知晓到底要维护多少个目标实例</li>
<li>如果尚不知晓的值被用于数据源，那么数据源在计算变更计划阶段就无法读取，它会被推迟到执行阶段读取。这种情况下，在计划阶段该数据源的一切输出均为尚不知晓</li>
<li>如果声明 <code>module</code> 块时传递给模块输入变量的表达式使用了尚不知晓值，那么在模块代码中任何使用了该输入变量值的表达式的值都将是尚不知晓</li>
<li>如果模块输出值表达式中含有尚不知晓值，任何使用该模块输出值的表达式都将是尚不知晓</li>
<li>Terraform 会尝试验证尚不知晓值的数据类型是否合法，但仍然有可能无法正确检查数据类型，导致执行阶段发生错误</li>
</ul>
<p>尚不知晓值在执行 <code>terraform plan</code> 时会被输出为 “(not yet known)”。</p>
<h2 id="1-4-8-1-7-算数和逻辑操作符"><a href="#%E7%AE%97%E6%95%B0%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7. 算数和逻辑操作符</h2>
<p>一个操作符是一种用以转换或合并一个或多个表达式的表达式。操作符要么是把两个值计算为第三个值，也就是二元操作符；要么是把一个值转换成另一个值，也就是一元操作符。</p>
<p>二元操作符位于两个表达式的中间，类似 <code>1+2</code>。一元操作符位于一个表达式的前面，类似 <code>!true</code>。</p>
<p>Terraform 的 HCL 语言支持一组算数和逻辑操作符，它们的功能类似于 JavaScript 或 Ruby 里的操作符功能。</p>
<p>当一个表达式中含有多个操作符时，它们的优先级顺序为：</p>
<ol>
<li><code>!</code>，<code>-</code> (负号)</li>
<li><code>*</code>，<code>/</code>，<code>%</code></li>
<li><code>+</code>，<code>-</code> (减号)</li>
<li><code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li>
<li><code>==</code>，<code>!=</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
</ol>
<p>可以使用小括号覆盖默认优先级。如果没有小括号，高优先级操作符会被先计算，例如 <code>1+2*3</code> 会被解释成 <code>1+(2*3)</code> 而不是 <code>(1+2)*3</code>。</p>
<p>不同的操作符可以按它们之间相似的行为被归纳为几组，每一组操作符都期待被给予特定类型的值。Terraform 会在类型不符时尝试进行隐式类型转换，如果失败则会抛错。</p>
<h3 id="1-4-8-1-7-1-算数操作符"><a href="#%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7.1. 算数操作符</h3>
<ul>
<li><code>a + b</code>：返回 <code>a</code> 与 <code>b</code> 的和</li>
<li><code>a - b</code>：返回 <code>a</code> 与 <code>b</code> 的差</li>
<li><code>a * b</code>：返回 <code>a</code> 与 <code>b</code> 的积</li>
<li><code>a / b</code>：返回 <code>a</code> 与 <code>b</code> 的商</li>
<li><code>a % b</code>：返回 <code>a</code> 与 <code>b</code> 的模。该操作符一般仅在 <code>a</code> 与 <code>b</code> 是整数时有效</li>
<li><code>-a</code>：返回 <code>a</code> 与 <code>-1</code> 的商</li>
</ul>
<h3 id="1-4-8-1-7-2-相等性操作符"><a href="#%E7%9B%B8%E7%AD%89%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7.2. 相等性操作符</h3>
<ul>
<li><code>a == b</code>：如果 <code>a</code> 与 <code>b</code> 类型与值都相等返回 <code>true</code>，否则返回 <code>false</code></li>
<li><code>a != b</code>：与 <code>==</code> 相反</li>
</ul>
<h3 id="1-4-8-1-7-3-比较操作符"><a href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7.3. 比较操作符</h3>
<ul>
<li><code>a &lt; b</code>：如果 <code>a</code> 比 <code>b</code> 小则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>a &gt; b</code>：如果 <code>a</code> 比 <code>b</code> 大则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>a &lt;= b</code>：如果 <code>a</code> 比 <code>b</code> 小或者相等则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>a &gt;= b</code>：如果 <code>a</code> 比 <code>b</code> 大或者相等则为 <code>true</code>，否则为 <code>false</code></li>
</ul>
<h3 id="1-4-8-1-7-4-逻辑操作符"><a href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"></a>1.4.8.1.7.4. 逻辑操作符</h3>
<ul>
<li><code>a || b</code>：<code>a</code> 或 <code>b</code> 中有至少一个为 <code>true</code> 则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>a &amp;&amp; b</code>：<code>a</code> 与比都为 <code>true</code> 则为 <code>true</code>，否则为 <code>false</code></li>
<li><code>!a</code>：如果 <code>a</code> 为 <code>true</code> 则为 <code>false</code>，如果 <code>a</code> 为 <code>false</code> 则为 <code>true</code></li>
</ul>
<h2 id="1-4-8-1-8-条件表达式"><a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a>1.4.8.1.8. 条件表达式</h2>
<p>条件表达式是判断一个布尔表达式的结果以便于在后续两个值当中选择一个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? true_val : false_val</span><br></pre></td></tr></table></figure>
<p>如果 <code>condition</code> 表达式为 <code>true</code>，那么结果是 <code>true_value</code>，反之则为 <code>false_value</code>。</p>
<p>一个常见的条件表达式用法是使用默认值替代非法值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var.a != &quot;&quot; ? var.a : &quot;default-a&quot;</span><br></pre></td></tr></table></figure>
<p>(注：以上表达式目前推荐写为：<code>coalesce(var.a, &quot;default-a&quot;)</code>)</p>
<p>如果输入变量 <code>a</code> 的值是空字符串，那么结果会是 <code>default-a</code>，否则返回输入变量 <code>a</code> 的值。</p>
<p>条件表达式的判断条件可以使用上述的任意操作符。供选择的两个值也可以是任意类型，但它们的类型必须相同，这样 Terraform 才能判断条件表达式的输出类型。</p>
<h2 id="1-4-8-1-9-函数调用"><a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"></a>1.4.8.1.9. 函数调用</h2>
<p>Terraform 支持在计算表达式时使用一些内建函数，函数调用表达式类似操作符，通用语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FUNCTION NAME&gt;(&lt;ARGUMENT 1&gt;, &lt;ARGUMENT 2&gt;)</span><br></pre></td></tr></table></figure>
<p>函数名标明了要调用的函数。每一个函数都定义了数量不等、类型不一的入参以及不同类型的返回值。</p>
<p>有些函数定义了不定长的入参表，例如，<code>min</code> 函数可以接收任意多个数值类型入参，返回其中最小的数值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min(55, 3453, 2)</span><br></pre></td></tr></table></figure>
<h3 id="1-4-8-1-9-1-展开函数入参"><a href="#%E5%B1%95%E5%BC%80%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82"></a>1.4.8.1.9.1. 展开函数入参</h3>
<p>如果想要把列表或元组的元素作为参数传递给函数，那么我们可以使用展开符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min([55, 2453, 2]...)</span><br></pre></td></tr></table></figure>
<p>展开符使用的是三个独立的 <code>.</code> 号组成的 <code>...</code>，不是 Unicode 中的省略号 <code>…</code>。展开符是一种只能用在函数调用场景下的特殊语法。</p>
<p>有关完整的内建函数我们可能会在今后撰写相应的章节介绍。</p>
<h2 id="1-4-8-1-10-for-表达式"><a href="#for-%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a>1.4.8.1.10. for 表达式</h2>
<p><code>for</code> 表达式是将一种复杂类型映射成另一种复杂类型的表达式。输入类型值中的每一个元素都会被映射为一个或零个结果。</p>
<p>举例来说，如果 <code>var.list</code> 是一个字符串列表，那么下面的表达式将会把列表元素全部转为大写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for s in var.list : upper(s)]</span><br></pre></td></tr></table></figure>
<p>在这里 <code>for</code> 表达式迭代了 <code>var.list</code> 中每一个元素(就是 <code>s</code>)，然后计算了 <code>upper(s)</code>，最后构建了一个包含了所有 <code>upper(s)</code> 结果的新元组，元组内元素顺序与源列表相同。</p>
<p><code>for</code> 表达式周围的括号类型决定了输出值的类型。上面的例子里我们使用了方括号，所以输出类型是元组。如果使用的是花括号，那么输出类型是对象，<code>for</code> 表达式内部冒号后面应该使用以 <code>=&gt;</code> 符号分隔的表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;for s in var.list : s =&gt; upper(s)&#125;</span><br></pre></td></tr></table></figure>
<p>该表达式返回一个对象，对象的成员属性名称就是源列表中的元素，值就是对应的大写值。</p>
<p>一个 <code>for</code> 表达式还可以包含一个可选的 <code>if</code> 子句用以过滤结果，这可能会减少返回的元素数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for s in var.list : upper(s) if s != &quot;&quot;]</span><br></pre></td></tr></table></figure>
<p>被 <code>for</code> 迭代的也可以是对象或者字典，这样的话迭代器就会被表示为两个临时变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for k, v in var.map : length(k) + length(v)]</span><br></pre></td></tr></table></figure>
<p>最后，如果返回类型是对象(使用花括号)那么表达式中可以使用 <code>...</code> 符号实现 group by：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;for s in var.list : substr(s, 0, 1) =&gt; s... if s != &quot;&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-8-1-11-展开表达式-Splat-Expression"><a href="#%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8Fsplat-expression"></a>1.4.8.1.11. 展开表达式(Splat Expression)</h2>
<p>展开表达式提供了一种类似 <code>for</code> 表达式的简洁表达方式。比如说 <code>var.list</code> 包含一组对象，每个对象有一个属性 <code>id</code>，那么读取所有 <code>id</code> 的 <code>for</code> 表达式会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for o in var.list : o.id]</span><br></pre></td></tr></table></figure>
<p>与之等价的展开表达式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var.list[*].id</span><br></pre></td></tr></table></figure>
<p>这个特殊的 <code>[*]</code> 符号迭代了列表中每一个元素，然后返回了它们在 <code>.</code> 号右边的属性值。</p>
<p>展开表达式只能被用于列表(所以使用 <code>for_each</code> 参数的资源不能使用展开表达式，因为它的类型是字典)。然而，如果一个展开表达式被用于一个既不是列表又不是元组的值，那么这个值会被自动包装成一个单元素的列表然后被处理。</p>
<p>比如说，<code>var.single_object[*].id</code> 等价于 <code>[var.single_object][*].id</code>。大部分场景下这种行为没有什么意义，但在访问一个不确定是否会定义 <code>count</code> 参数的资源时，这种行为很有帮助，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws_instance.example[*].id</span><br></pre></td></tr></table></figure>
<p>上面的表达式不论 <code>aws_instance.example</code> 定义了 <code>count</code> 与否都会返回实例的 <code>id</code> 列表，这样如果我们以后为 <code>aws_instance.example</code> 添加了 <code>count</code> 参数我们也不需要修改这个表达式。</p>
<h3 id="1-4-8-1-11-1-遗留的旧有展开表达式"><a href="#%E9%81%97%E7%95%99%E7%9A%84%E6%97%A7%E6%9C%89%E5%B1%95%E5%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"></a>1.4.8.1.11.1. 遗留的旧有展开表达式</h3>
<p>曾经存在另一种旧的展开表达式语法，它是一种比较弱化的展开表达式，现在应该尽量避免使用。</p>
<p>这种旧的展开表达式使用 <code>.*</code> 而不是 <code>[*]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var.list.*.interfaces[0].name</span><br></pre></td></tr></table></figure>
<p>要特别注意该表达式与现有的展开表达式结果不同，它的行为等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for o in var.list : o.interfaces][0].name</span><br></pre></td></tr></table></figure>
<p>而现有 <code>[*]</code> 展开表达式的行为等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[for o in var.list : o.interfaces[0].name]</span><br></pre></td></tr></table></figure>
<p>注意两者右方括号的位置。</p>
<h2 id="1-4-8-1-12-dynamic-块"><a href="#dynamic-%E5%9D%97"></a>1.4.8.1.12. dynamic 块</h2>
<p>在顶级块，例如 <code>resource</code> 块当中，一般只能以类似 <code>name = expression</code> 的形式进行一对一的赋值。大部分情况下这已经够用了，但某些资源类型包含了可重复的内嵌块，无法使用表达式循环赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource  &quot;aws_elastic_beanstalk_environment&quot; &quot;tfenvtest&quot; &#123;</span><br><span class="line">  name = &quot;tf-test-name&quot; # can use expressions here</span><br><span class="line"></span><br><span class="line">  setting &#123;</span><br><span class="line">    # but the &quot;setting&quot; block is always a literal block</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以用 <code>dynamic</code> 块来动态构建重复的 <code>setting</code> 这样的内嵌块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_elastic_beanstalk_environment&quot; &quot;tfenvtest&quot; &#123;</span><br><span class="line">  name                = &quot;tf-test-name&quot;</span><br><span class="line">  application         = &quot;$&#123;aws_elastic_beanstalk_application.tftest.name&#125;&quot;</span><br><span class="line">  solution_stack_name = &quot;64bit Amazon Linux 2018.03 v2.11.4 running Go 1.12.6&quot;</span><br><span class="line"></span><br><span class="line">  dynamic &quot;setting&quot; &#123;</span><br><span class="line">    for_each = var.settings</span><br><span class="line">    content &#123;</span><br><span class="line">      namespace = setting.value[&quot;namespace&quot;]</span><br><span class="line">      name = setting.value[&quot;name&quot;]</span><br><span class="line">      value = setting.value[&quot;value&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dynamic</code> 可以在 <code>resource</code>、<code>data</code>、<code>provider</code> 和 <code>provisioner</code> 块内使用。一个 <code>dynamic</code> 块类似于 <code>for</code> 表达式，只不过它产生的是内嵌块。它可以迭代一个复杂类型数据然后为每一个元素生成相应的内嵌块。在上面的例子里：</p>
<ul>
<li><code>dynamic</code> 的标签(也就是 <code>&quot;setting&quot;</code>)确定了我们要生成的内嵌块种类</li>
<li><code>for_each</code> 参数提供了需要迭代的复杂类型值</li>
<li><code>iterator</code> 参数(可选)设置了用以表示当前迭代元素的临时变量名。如果没有设置 <code>iterator</code>，那么临时变量名默认就是 <code>dynamic</code> 块的标签(也就是 <code>setting</code>)</li>
<li><code>labels</code> 参数(可选)是一个表示块标签的有序列表，用以按次序生成一组内嵌块。有 <code>labels</code> 参数的表达式里可以使用临时的 <code>iterator</code> 变量</li>
<li>内嵌的 <code>content</code> 块定义了要生成的内嵌块的块体。你可以在 <code>content</code> 块内部使用临时的 <code>iterator</code> 变量</li>
</ul>
<p>由于 <code>for_each</code> 参数可以是集合或者结构化类型，所以你可以使用 <code>for</code> 表达式或是展开表达式来转换一个现有集合的类型。</p>
<p><code>iterator</code> 变量(上面的例子里就是 <code>setting</code>)有两个属性：</p>
<ul>
<li><code>key</code>：迭代容器如果是 <code>map</code>，那么就是当前元素的键；迭代容器如果是 <code>list</code>，那么就是当前元素在 <code>list</code> 中的下标序号；如果是由 <code>for_each</code> 表达式产出的 <code>set</code>，那么 <code>key</code> 和 <code>value</code> 是一样的，这时我们不应该使用 <code>key</code>。</li>
<li><code>value</code>：当前元素的值</li>
</ul>
<p>一个 <code>dynamic</code> 块只能生成属于当前块定义过的内嵌块参数。无法生成诸如 <code>lifecycle</code>、<code>provisioner</code> 这样的元参数，因为 Terraform 必须在确保对这些元参数求值的计算是成功的。</p>
<p><code>for_each</code> 的值必须是不为空的 <code>map</code> 或者 <code>set</code>。如果你需要根据内嵌数据结构或者多个数据结构的元素组合来声明资源实例集合，你可以使用 Terraform 表达式和函数来生成合适的值。</p>
<h3 id="1-4-8-1-12-1-dynamic-块的最佳实践"><a href="#dynamic-%E5%9D%97%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"></a>1.4.8.1.12.1. dynamic 块的最佳实践</h3>
<p>过度使用 <code>dynamic</code> 块会导致代码难以阅读以及维护，所以我们建议只在需要构造可重用的模块代码时使用 <code>dynamic</code> 块。尽可能手写内嵌块。</p>
<h2 id="1-4-8-1-13-字符串字面量"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"></a>1.4.8.1.13. 字符串字面量</h2>
<p>Terraform 有两种不同的字符串字面量。最通用的就是用一对双引号包裹的字符，比如 <code>&quot;hello&quot;</code>。在双引号之间，反斜杠 <code>\</code> 被用来进行转义。Terraform 支持的转义符有：</p>
<table>
<thead>
<tr>
<th>Sequence</th>
<th>Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号 (不会截断字符串)</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠</td>
</tr>
<tr>
<td><code>\uNNNN</code></td>
<td>普通字符映射平面的Unicode字符(NNNN代表四位16进制数)</td>
</tr>
<tr>
<td><code>\UNNNNNNNN</code></td>
<td>补充字符映射平面的Unicode字符(NNNNNNNN代表八位16进制数)</td>
</tr>
</tbody>
</table>
<p>另一种字符串表达式被称为 “heredoc” 风格，是受 Unix Shell 语言启发。它可以使用自定义的分隔符更加清晰地表达多行字符串：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;EOT</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code> 标记后面直到行尾组成的标识符开启了字符串，然后 Terraform 会把剩下的行都添加进字符串，直到遇到与标识符完全相等的字符串为止。在上面的例子里，<code>EOT</code> 就是标识符。任何字符都可以用作标识符，但传统上标识符一般以 <code>EO</code> 开头。上面例子里的 <code>EOT</code> 代表&quot;文本的结束(end of text)&quot;。</p>
<p>上面例子里的 heredoc 风格字符串要求内容必须对齐行头，这在块内声明时看起来会比较奇怪：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">block &#123;</span><br><span class="line">  value = &lt;&lt;EOT</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">EOT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了改进可读性，Terraform 也支持<em><strong>缩进的</strong></em> heredoc，只要把 <code>&lt;&lt;</code> 改成 <code>&lt;&lt;-</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">block &#123;</span><br><span class="line">  value = &lt;&lt;-EOT</span><br><span class="line">  hello</span><br><span class="line">    world</span><br><span class="line">  EOT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子里，Terraform 会以最靠近行头的行作为基准来调整行头缩进，得到的字符串是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">  world</span><br></pre></td></tr></table></figure>
<p>heredoc 中的反斜杠不会被解释成转义，而只会是简单的反斜杠。</p>
<p>双引号和 heredoc 两种字符串都支持字符串模版，模版的形式是 <code>$&#123;...&#125;</code> 以及 <code>%&#123;...&#125;</code>。如果想要表达 <code>$&#123;</code> 或者 <code>%&#123;</code> 的字面量，那么可以重复第一个字符：<code>$$&#123;</code> 和 <code>%%&#123;</code> 。</p>
<h2 id="1-4-8-1-14-字符串模版"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%89%88"></a>1.4.8.1.14. 字符串模版</h2>
<p>字符串模版允许我们在字符串中嵌入表达式，或是通过其他值动态构造字符串。</p>
<h3 id="1-4-8-1-14-1-插值-Interpolation"><a href="#%E6%8F%92%E5%80%BCinterpolation"></a>1.4.8.1.14.1. 插值(Interpolation)</h3>
<p>一个 <code>$&#123;...&#125;</code> 序列被称为插值，插值计算花括号之间的表达式的值，有必要的话将之转换为字符串，然后插入字符串模版，形成最终的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello, $&#123;var.name&#125;!&quot;</span><br></pre></td></tr></table></figure>
<p>上面的例子里，输入变量 <code>var.name</code> 的值被访问后插入了字符串模版，产生了最终的结果，比如：<code>&quot;Hello, Juan!&quot;</code></p>
<h3 id="1-4-8-1-14-2-命令-Directive"><a href="#%E5%91%BD%E4%BB%A4directive"></a>1.4.8.1.14.2. 命令(Directive)</h3>
<p>一个 <code>%&#123;...&#125;</code> 序列被称为命令，命令可以是一个布尔表达式或者是对集合的迭代，类似条件表达式以及 <code>for</code> 表达式。有两种命令：</p>
<ul>
<li><code>if \&lt;BOOL\&gt;</code> / <code>else</code> /<code>endif</code> 命令根据布尔表达式的结果在两个模版中选择一个：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello, %&#123; if var.name != &quot;&quot; &#125;$&#123;var.name&#125;%&#123; else &#125;unnamed%&#123; endif &#125;!&quot;</span><br></pre></td></tr></table></figure>
<p><code>else</code> 部分可以省略，这样如果布尔表达结果为false那么就会插入空字符串。</p>
<ul>
<li><code>for \&lt;NAME\&gt; in \&lt;COLLECTION\&gt;</code> / <code>endfor</code> 命令迭代一个结构化对象或者集合，用每一个元素渲染模版，然后把它们拼接起来：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;EOT</span><br><span class="line">%&#123; for ip in aws_instance.example.*.private_ip &#125;</span><br><span class="line">server $&#123;ip&#125;</span><br><span class="line">%&#123; endfor &#125;</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>
<p><code>for</code> 关键字后紧跟的名字被用作代表迭代器元素的临时变量，可以用来在内嵌模版中使用。</p>
<p>为了在不添加额外空格和换行的前提下提升可读性，所有的模版序列都可以在首尾添加 <code>~</code> 符号。如果有 <code>~</code> 符号，那么模版序列会去除字符串左右的空白(空格以及换行)。如果 <code>~</code> 出现在头部，那么会去除字符串左侧的空白；如果出现在尾部，那么会去除字符串右边的空白：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;EOT</span><br><span class="line">%&#123; for ip in aws_instance.example.*.private_ip ~&#125;</span><br><span class="line">server $&#123;ip&#125;</span><br><span class="line">%&#123; endfor ~&#125;</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>
<p>上面的例子里，命令符后面的换行符被忽略了，但是 <code>server $&#123;ip&#125;</code> 后面的换行符被保留了，这确保了每一个元素生成一行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server 10.1.16.154</span><br><span class="line">server 10.1.16.1</span><br><span class="line">server 10.1.16.34</span><br></pre></td></tr></table></figure>
<p>当使用模版命令时，我们推荐使用 heredoc 风格字符串，用多行模版提升可读性。双引号字符串内最好只使用插值。</p>
<h2 id="1-4-8-1-15-Terraform-插值"><a href="#terraform-%E6%8F%92%E5%80%BC"></a>1.4.8.1.15. Terraform 插值</h2>
<p>Terraform 曾经只支持在表达式中使用插值，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = var.image_id</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种语法是在 Terraform 0.12 后才被支持的。在 Terraform 0.11 及更早的版本中，这段代码只能被写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  ami           = &quot;$&#123;var.image_id&#125;&quot;</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 0.12 保持了向前兼容，所以现在这样的代码也仍然是合法的。读者们也许会在一些 Terraform 代码和文档中继续看到这样的写法，但请尽量避免继续这样书写纯插值字符串，而是直接使用表达式。</p>
<ul>
<li>
<p><a href="#%E9%87%8D%E8%BD%BD%E6%96%87%E4%BB%B6"><strong>1.4.9.1.</strong> 重载文件</a></p>
</li>
<li>
<p><a href="#%E4%BE%8B%E5%AD%90"><strong>1.4.9.1.1.</strong> 例子</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6%E8%A1%8C%E4%B8%BA"><strong>1.4.9.1.2.</strong> 合并行为</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-resource-%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%90%88%E5%B9%B6-data-%E5%9D%97"><strong>1.4.9.1.2.1.</strong> 合并 resource 块以及合并 data 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-variable-%E5%9D%97"><strong>1.4.9.1.2.2.</strong> 合并 variable 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-output-%E5%9D%97"><strong>1.4.9.1.2.3.</strong> 合并 output 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-locals-%E5%9D%97"><strong>1.4.9.1.2.4.</strong> 合并 locals 块</a></p>
</li>
<li>
<p><a href="#%E5%90%88%E5%B9%B6-terraform-%E5%9D%97"><strong>1.4.9.1.2.5.</strong> 合并 terraform 块</a></p>
</li>
</ul>
<p><a href="#%E9%87%8D%E8%BD%BD%E6%96%87%E4%BB%B6"></a></p>
<h2 id="1-4-9-1-重载文件"><a href="#%E9%87%8D%E8%BD%BD%E6%96%87%E4%BB%B6"></a>1.4.9.1. 重载文件</h2>
<p>一般来说 Terraform 会加载模块内所有的 <code>.tf</code> 和 <code>.tf.json</code> 文件，并要求文件内定义了一组无重复的对象。如果两个文件尝试定义同一个对象，那么 Terraform 会报错。</p>
<p>在某些少见场景中，能够用单独的文件重载已有对象配置的特定部分将会十分有用。比如说，由工程师编写的配置文件能够在运行时被程序生成的 JSON 文件部分重载。</p>
<p>为支持这些少见场景，Terraform 会对后缀名为 <code>override.tf</code> 和 <code>override.tf.json</code> 的代码文件进行特殊处理。对于名为 <code>override.tf</code> 和 <code>override.tf.json</code> 的代码文件也会进行相同的特殊处理。</p>
<p>Terraform 一开始加载代码文件时会跳过这些重载文件，然后才会按照字典序一个一个处理重载文件。对重载文件中定义的所有顶级块(<code>resource</code>、<code>data</code>等)，Terraform 会尝试找到对应的已有对象并且将重载内容合并进已有对象。</p>
<p>重载文件只应使用于特殊场景，过度使用会使得读者在阅读原始代码文件时被迫还要阅读所有的重载文件才能理解对象配置，从而降低了代码的可读性。使用重载文件时，请在原始文件被重载的部分添加相应注释，提醒未来的读者哪些部分会被重载文件修改。</p>
<h2 id="1-4-9-1-1-例子"><a href="#%E4%BE%8B%E5%AD%90"></a>1.4.9.1.1. 例子</h2>
<p>如果我们有一个名为 <code>example.tf</code> 的代码文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  ami           = &quot;ami-408c7f28&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们创建一个名为 <code>override.tf</code> 的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami = &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Terraform 随后会合并两者，实际的配置会是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line">  ami           = &quot;foo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-9-1-2-合并行为"><a href="#%E5%90%88%E5%B9%B6%E8%A1%8C%E4%B8%BA"></a>1.4.9.1.2. 合并行为</h2>
<p>不同的块类型有着些微不同的合并行为，某些特定块内的特殊构造会以特殊形式被合并。</p>
<p>一般来说：</p>
<ul>
<li>重载文件内的顶级块会和普通文件内同类型同名的顶级块合并</li>
<li>重载文件内的顶级块配置册参数会覆盖普通文件内对应块内的同名参数</li>
<li>重载块内的内嵌块会<strong>取代</strong>普通文件内对应块内的<strong>所有</strong>同类型内嵌块。所有重载块内没有定义的内嵌块在普通文件内保持不变</li>
<li>内嵌块的内容<strong>不会</strong>进行合并</li>
<li>合并后的块仍然需要符合对应块类型的所有验证规则</li>
</ul>
<p>如果有多个重载文件定义了同一个顶级块，那么重载效果是叠加的，后加载的重载块会在先前加载的重载块生效的基础上合并。重载操作首先按照文件名的字典序其次是在重载文件中的位置决定执行顺序。</p>
<p>有一些针对特定顶级块类型的特殊合并行为规则，我们将重载文件中定义的块称为重载块，重载块在普通文件中对应的块称为源块：</p>
<h3 id="1-4-9-1-2-1-合并-resource-块以及合并-data-块"><a href="#%E5%90%88%E5%B9%B6-resource-%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%90%88%E5%B9%B6-data-%E5%9D%97"></a>1.4.9.1.2.1. 合并 resource 块以及合并 data 块</h3>
<p>在 <code>resource</code> 块内，所有 <code>lifecycle</code> 块的内容会按照参数逐条合并。比如说，一个重载块只定义了 <code>create_before_destroy</code> 参数而源块定义了 <code>ignore_changes</code>，那么 <code>create_before_destroy</code> 被合并的同时 <code>igonore_changes</code> 将会被保留。</p>
<p>如果重载的 <code>resource</code> 块包含了一个或多个 <code>provisioner</code>，那么源块内所有的 <code>provisioner</code> 会被忽略。</p>
<p>如果重载的 <code>resource</code> 块内包含了一个 <code>connection</code> 块，那么它将会完全覆盖所有源块内定义的 <code>connection</code> 块</p>
<p>不允许在重载块内定义 <code>depends_on</code> 参数，那将会引发一个错误。</p>
<h3 id="1-4-9-1-2-2-合并-variable-块"><a href="#%E5%90%88%E5%B9%B6-variable-%E5%9D%97"></a>1.4.9.1.2.2. 合并 variable 块</h3>
<p><code>variable</code> 块内参数的合并遵循上述的标准流程，但对于 <code>type</code> 和 <code>default</code> 参数的处理会有一些特殊的考虑。</p>
<p>如果源块定义了 <code>default</code> 值而重载块修改了变量的 <code>type</code>，Terraform 会尝试将 <code>default</code> 值转换成新类型，如果转换失败则会报错。</p>
<p>同样的，如果源块定义了 <code>type</code> 参数而重载块修改了 <code>default</code> 值，那么新的 <code>default</code> 值必须能够被转换成原先的类型。</p>
<h3 id="1-4-9-1-2-3-合并-output-块"><a href="#%E5%90%88%E5%B9%B6-output-%E5%9D%97"></a>1.4.9.1.2.3. 合并 output 块</h3>
<p>不允许在重载块内定义 <code>depends_on</code> 参数，这会引发一个错误。</p>
<h3 id="1-4-9-1-2-4-合并-locals-块"><a href="#%E5%90%88%E5%B9%B6-locals-%E5%9D%97"></a>1.4.9.1.2.4. 合并 locals 块</h3>
<p>所有的 <code>locals</code> 块都定义了一个或多个命名值。针对 <code>locals</code> 的合并会是按照命名值的名字逐条执行的，不论命名值是在哪个 <code>locals</code> 块内被定义的。</p>
<h3 id="1-4-9-1-2-5-合并-terraform-块"><a href="#%E5%90%88%E5%B9%B6-terraform-%E5%9D%97"></a>1.4.9.1.2.5. 合并 terraform 块</h3>
<p>如果重载块定义了 <code>required_providers</code> 参数，那么它的值会被逐条合并，这就允许重载块在不影响其他Provider的情况下调整单个 Provider 的版本约束。</p>
<p>重载块内的 <code>requeired_version</code> 和 <code>required_providers</code> 里的配置完全覆盖源块内的相应配置。如果源块和重载块都定义了 <code>required_version</code>，那么源块的配置会被完全忽略。</p>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83"><strong>1.4.10.1.</strong> 代码风格规范</a></li>
</ul>
<p><a href="#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83"></a></p>
<h2 id="1-4-10-1-代码风格规范"><a href="#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83"></a>1.4.10.1. 代码风格规范</h2>
<p>Terraform 推荐以下代码规范：</p>
<ul>
<li>使用两个空格缩进</li>
<li>同一缩进层级的多个赋值语句以等号对齐：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ami           = &quot;abc123&quot;</span><br><span class="line">instance_type = &quot;t2.micro&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>当块体内同时有参数赋值以及内嵌块时，请先编写参数赋值，然后是内嵌块。参数与内嵌块之间空一行分隔</li>
<li>对于同时包含参数赋值以及元参数赋值的块，请先编写元参数赋值语句，然后是参数赋值语句，之间空一行分隔。元参数块请置于块体的最后，空一行分隔：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">  count = 2 # meta-argument first</span><br><span class="line"></span><br><span class="line">  ami           = &quot;abc123&quot;</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  network_interface &#123;</span><br><span class="line">    # ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lifecycle &#123; # meta-argument block last</span><br><span class="line">    create_before_destroy = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>顶层块之间应空一行分隔。内嵌块之间也应该空一行分隔，除非是相同类型的内嵌块(比如 <code>resource</code> 块内部多个 <code>provisioner</code> 块)</p>
</li>
<li>
<p>同类型块之间尽量避免插入其他类型块，除非不同类型块共同组成了一个有语义的家族(比方说，<code>aws_instnace</code> 资源内的 <code>root_block_device</code>、<code>ebs_block_device</code>、<code>ephemeral_block_device</code> 内嵌块共同构成了描述 AWS 块存储的块家族，所以他们可以被混合编写)。</p>
</li>
<li>
<p><a href="#checks"><strong>1.4.11.1.</strong> Checks</a></p>
</li>
<li>
<p><a href="#%E8%AF%AD%E6%B3%95"><strong>1.4.11.1.1.</strong> 语法</a></p>
</li>
<li>
<p><a href="#%E6%9C%89%E9%99%90%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90"><strong>1.4.11.1.1.1.</strong> 有限作用范围的数据源</a></p>
</li>
<li>
<p><a href="#%E6%96%AD%E8%A8%80"><strong>1.4.11.1.1.2.</strong> 断言</a></p>
</li>
<li>
<p><a href="#check-%E5%9D%97%E7%9A%84%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.4.11.1.1.3.</strong> check 块的元参数</a></p>
</li>
<li>
<p><a href="#%E6%98%AF%E4%BD%BF%E7%94%A8-check-%E5%9D%97%E8%BF%98%E6%98%AF%E5%85%B6%E4%BB%96%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E6%A3%80%E6%9F%A5"><strong>1.4.11.1.2.</strong> 是使用 check 块还是其他自定义条件检查</a></p>
</li>
<li>
<p><a href="#%E8%BE%93%E5%87%BA%E5%80%BC%E4%B8%8E%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0"><strong>1.4.11.1.2.1.</strong> 输出值与输入参数</a></p>
</li>
<li>
<p><a href="#resource-%E5%9D%97%E7%9A%84-precondition-%E4%B8%8E-postcondition"><strong>1.4.11.1.2.2.</strong> resource 块的 precondition 与 postcondition</a></p>
</li>
</ul>
<p><a href="#checks"></a></p>
<h2 id="1-4-11-1-Checks"><a href="#checks"></a>1.4.11.1. Checks</h2>
<p><code>check</code> 块是 Terraform 1.5 开始引入的新功能。</p>
<p>过去我们可以在 <code>resource</code> 块里的 <code>lifecycle</code> 块中验证基础设施的状态。<code>check</code> 块填补了在 Terraform <code>apply</code> 后验证基础设施状态这一功能中的一块空白。</p>
<p><code>check</code> 块允许我们定义在每次 <code>plan</code> 以及 <code>apply</code> 操作后执行的自定义的验证。<code>check</code> 块定义的验证逻辑是作为 <code>plan</code> 和 <code>apply</code> 操作的最后一步执行的。</p>
<h2 id="1-4-11-1-1-语法"><a href="#%E8%AF%AD%E6%B3%95"></a>1.4.11.1.1. 语法</h2>
<p>你可以定义一个包含本地名称的 <code>check</code> 块，其中可以定义一个 <a href="#%E6%9C%89%E9%99%90%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90">有限作用范围的 <code>data</code> 块</a>，以及至少一个的<a href="#%E6%96%AD%E8%A8%80">断言</a>。</p>
<p>下面的例子演示了加载 Terraform 官网并验证 HTTP 返回状态码为 <code>200</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">check &quot;health_check&quot; &#123;</span><br><span class="line">  data &quot;http&quot; &quot;terraform_io&quot; &#123;</span><br><span class="line">    url = &quot;https://www.terraform.io&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert &#123;</span><br><span class="line">    condition = data.http.terraform_io.status_code == 200</span><br><span class="line">    error_message = &quot;$&#123;data.http.terraform_io.url&#125; returned an unhealthy status code&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-11-1-1-1-有限作用范围的数据源"><a href="#%E6%9C%89%E9%99%90%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90"></a>1.4.11.1.1.1. 有限作用范围的数据源</h3>
<p>我们可以在 <code>check</code> 块使用任意 Provider 提供的任意数据源作为一个有限作用范围的数据源。</p>
<p>一个 <code>check</code> 块可以配一个可选的内嵌（也叫有限作用范围）数据源。该 <code>data</code> 块和普通的 <code>data</code> 块行为类似，但你不能在定义它的 <code>check</code> 块以外引用它。另外，如果一个有限作用范围的数据源运行时触发了任意错误，这些错误将被标记为警告，不会阻止 Terraform 继续执行操作。</p>
<p>你可以使用有限作用范围的数据源在 <code>resource</code> 的 <code>lifecycle</code> 外验证相关基础设施片段的状态。在上面的例子里，如果 <code>terraform_io</code> 数据源在加载时发生错误，那么我们将会收到一个警告而不是中断执行的错误。</p>
<h4 id="元参数"><a href="#%E5%85%83%E5%8F%82%E6%95%B0"></a>元参数</h4>
<p>有限作用域的数据源支持 <code>depends_on</code> 和 <code>provider</code> <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#%E5%85%83%E5%8F%82%E6%95%B0">元参数</a>，但不支持 <code>count</code> 或 <code>for_each</code> 元参数。</p>
<p><code>depends_on</code></p>
<p><code>depends_on</code> 元参数配合有限作用域数据源可以提供非常强大的能力。</p>
<p>假设上述例子中的 Terraform 网站是我们即将用同一目录下的 Terraform 代码部署的，在第一次创建 Plan 时因为网站还没有被创建，所以验证会失败，Terraform 总是会在一开始显示一条让人分心的警告信息。</p>
<p>我们可以给该内嵌数据源添加 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#depends_on"><code>depends_on</code></a> 来确保该数据源依赖于某项组成基础设施的必要资源，例如负载均衡器。这样对该数据源的检查结果将保持 <code>known after apply</code> 直到依赖项创建完成。该策略避免了在配置阶段产生无意义的警告信息，直到在 <code>plan</code> 和 <code>apply</code> 操作的合适阶段执行检查。</p>
<p>该策略的一个问题是如果有限作用域数据源所依赖的资源发生了变化，那么 <code>check</code> 块将返回 <code>known after apply</code> 直到 Terraform 完成了对被依赖资源的更新。在某些情况下，这种行为将会引发一些问题。</p>
<p>我们推荐只有在内嵌数据源依赖于某项资源，但又没有显式的引用其数据时使用 <code>depends_on</code> 元参数。</p>
<h3 id="1-4-11-1-1-2-断言"><a href="#%E6%96%AD%E8%A8%80"></a>1.4.11.1.1.2. 断言</h3>
<p>我们在 <code>check</code> 块中使用 <code>assert</code> 块定义自定义的断言条件。每个 <code>check</code> 块必须声明至少一个或更多的 <code>assert</code> 块。每个 <code>assert</code> 块都包含了一个 <code>condition</code> 属性与一个 <code>error_message</code> 属性。</p>
<p>与其他自定义检查（<code>variable</code> 中的 <code>validation</code> 以及 <code>lifecycle</code> 中的 <code>precondition</code> 和 <code>postcondition</code>）不同，<code>assert</code> 的断言不会影响 Terraform 执行操作。失败的断言将以警告信息的形式输出而不会中断后续的操作。这与其他诸如 <code>postcondition</code> 这样的自定义检查形成了对比，因为它们的检查失败会立即终止后续的 <code>plan</code> 以及 <code>apply</code> 操作，返回错误信息。</p>
<p><code>assert</code> 块中的断言条件表达式可以引用同一 <code>check</code> 块里的内嵌数据源数据，以及同一模块中的任意输入参数、资源、数据源、模块的输出值。</p>
<h3 id="1-4-11-1-1-3-check-块的元参数"><a href="#check-%E5%9D%97%E7%9A%84%E5%85%83%E5%8F%82%E6%95%B0"></a>1.4.11.1.1.3. check 块的元参数</h3>
<p><code>check</code> 块目前不支持元参数。Terraform 团队目前正在<a target="_blank" rel="noopener" href="https://github.com/hashicorp/terraform/issues/new/choose">收集</a>有关这一功能的反馈。</p>
<h2 id="1-4-11-1-2-是使用-check-块还是其他自定义条件检查"><a href="#%E6%98%AF%E4%BD%BF%E7%94%A8-check-%E5%9D%97%E8%BF%98%E6%98%AF%E5%85%B6%E4%BB%96%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E6%A3%80%E6%9F%A5"></a>1.4.11.1.2. 是使用 check 块还是其他自定义条件检查</h2>
<p><code>check</code> 块提供了 Terraform 中最灵活的验证功能。我们可以在其中引用输出值、输入参数、资源以及数据源的值。我们的确可以使用 <code>check</code> 块取代所有其他的自定义条件检查，但这并不意味着我们应该要这么做。</p>
<p><code>check</code> 与其他检查最大的区别在于 <code>check</code> 块不会中断 Terraform 的执行。我们需要将这种非阻塞性的行为特点计入考量来决定采取何种检查。</p>
<h3 id="1-4-11-1-2-1-输出值与输入参数"><a href="#%E8%BE%93%E5%87%BA%E5%80%BC%E4%B8%8E%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0"></a>1.4.11.1.2.1. 输出值与输入参数</h3>
<p><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/4.%E8%BE%93%E5%87%BA%E5%80%BC.html#%E6%96%AD%E8%A8%80-precondition">输出值的 <code>precondition</code></a> 以及 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E6%96%AD%E8%A8%80-validation">输入变量的 <code>validation</code></a>都可以对输入输出值进行断言。</p>
<p>这些检查是用来阻止 Terraform 在数据有问题时继续执行的。</p>
<p>举例来说，如果输入参数的值是无效的那么任由 Terraform 执行整个配置文件并没有什么意义，这种情况下，<code>check</code> 块只会输出有关无效输入参数的警告，不会打断 Terraform 的执行，而 <code>validation</code> 块则会警告输入参数值非法，并终止 Terraform 执行 <code>plan</code> 或 <code>apply</code> 操作。</p>
<h3 id="1-4-11-1-2-2-resource-块的-precondition-与-postcondition"><a href="#resource-%E5%9D%97%E7%9A%84-precondition-%E4%B8%8E-postcondition"></a>1.4.11.1.2.2. resource 块的 precondition 与 postcondition</h3>
<p><code>check</code> 块与 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#precondition-%E4%B8%8E-postcondition"><code>precondition</code> 和 <code>postcondition</code></a> 的区别更加微妙。</p>
<p><code>precondition</code> 是自定义条件检查中最特殊的，因为它们是在资源的变更被计算或应用之前执行的检查。决定使用 <code>precondition</code> 还是 <code>postcondition</code> 的考量也适用于选择是使用 <code>precondition</code> 还是 <code>check</code> 块。</p>
<p>我们可以在 <code>postcondition</code> 与 <code>check</code> 块之间互换来验证资源和数据源。例如，我们可以把上述例子中的 <code>check</code> 块改写成 <code>postcondition</code>，以下的 <code>postcondition</code> 块将会验证对 Terraform 网站的请求是否返回了状态码 <code>200</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data &quot;http&quot; &quot;terraform_io&quot; &#123;</span><br><span class="line">  url = &quot;https://www.terraform.io&quot;</span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    postcondition &#123;</span><br><span class="line">        condition = self.status_code == 200</span><br><span class="line">        error_message = &quot;$&#123;self.url&#125; returned an unhealthy status code&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>check</code> 和 <code>postcondition</code> 块都在 <code>plan</code> 或 <code>apply</code> 操作中验证了 Terraform 网站是否返回 <code>200</code> 状态码，它们的区别是发生错误时的行为。</p>
<p>如果是 <code>postcondition</code> 失败，那么将无法继续执行。Terraform 会阻止任意后续的 <code>plan</code> 或 <code>apply</code> 操作。</p>
<p>我们推荐使用 <code>check</code> 块来验证基础设施的整体状态，仅在希望确保单一资源状态符合预期时使用 <code>postcondition</code>。</p>
<ul>
<li>
<p><a href="#ephemeral-%E8%B5%84%E6%BA%90"><strong>1.4.12.1.</strong> Ephemeral 资源</a></p>
</li>
<li>
<p><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><strong>1.4.12.1.1.</strong> 生命周期</a></p>
</li>
<li>
<p><a href="#%E4%BE%9D%E8%B5%96%E5%9B%BE"><strong>1.4.12.1.2.</strong> 依赖图</a></p>
</li>
<li>
<p><a href="#%E4%B8%B4%E6%97%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%A3%B0%E6%98%8E"><strong>1.4.12.1.3.</strong> 临时资源的声明</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E4%B8%B4%E6%97%B6%E8%B5%84%E6%BA%90"><strong>1.4.12.1.4.</strong> 引用临时资源</a></p>
</li>
<li>
<p><a href="#%E5%85%83%E5%8F%82%E6%95%B0"><strong>1.4.12.1.5.</strong> 元参数</a></p>
</li>
<li>
<p><a href="#%E7%A4%BA%E4%BE%8B"><strong>1.4.12.1.6.</strong> 示例</a></p>
</li>
</ul>
<p><a href="#ephemeral-%E8%B5%84%E6%BA%90"></a></p>
<h2 id="1-4-12-1-Ephemeral-资源"><a href="#ephemeral-%E8%B5%84%E6%BA%90"></a>1.4.12.1. Ephemeral 资源</h2>
<p>临时（Ephemeral）资源是本质上是临时的（Temporary） Terraform 资源。临时资源具有独特的生命周期，Terraform 不会将它们存储在其状态文件中。每个 <code>ephemeral</code> 块描述一个或多个临时资源，例如临时密码或与另一个系统的连接。</p>
<p><code>ephemeral</code> 块的声明包含了临时资源的类型以及本地名，就像 <code>resource</code> 块那样。 Terraform 使用临时资源的名称来引用同一模块中的该资源，但临时资源的名称在该模块的范围之外没有任何意义。</p>
<h2 id="1-4-12-1-1-生命周期"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"></a>1.4.12.1.1. 生命周期</h2>
<p><code>ephemeral</code> 的生命周期与 <code>resource</code> 和 <code>data</code> 不同。当 Terraform 创建临时资源时，它会执行以下步骤：</p>
<ol>
<li>如果 Terraform 需要访问临时资源的结果，它将“打开”该临时资源。例如，如果 Terraform “打开”一个包含了 Vault 机密的临时资源，则 Vault 的 Provider 将获取租约并返回一个机密。</li>
<li>如果 Terraform 需要访问临时资源的时间比远程系统为机密设置的过期时间还长，Terraform 会要求 Provider 定期续约。例如，如果 Terraform 对包含了 Vault 机密的临时资源续约，则 Vault Provider 程序将调用 Vault 的租约续约 API 来延长到期时间。</li>
<li>一旦 Terraform 不再需要临时资源，Terraform 就会将其关闭。这种情况发生在依赖于某个临时资源的 Provider 完成当前 Terraform 运行阶段的所有工作之后。例如，关闭 Vault 机密临时资源意味着 Vault Provider 明确吊销租约，从而使得 Vault 立即撤销相关凭证。</li>
</ol>
<p>Terraform 对于给定配置中的每个临时资源实例都遵循这些生命周期步骤。</p>
<h2 id="1-4-12-1-2-依赖图"><a href="#%E4%BE%9D%E8%B5%96%E5%9B%BE"></a>1.4.12.1.2. 依赖图</h2>
<p>临时资源对应了 Terraform 依赖关系图中的节点，其交互方式与 <code>resource</code> 和 <code>data</code> 类似。例如，当 <code>resource</code> 或 <code>data</code> 依赖于临时资源的属性时，Terraform 首先自动配置临时资源。</p>
<h2 id="1-4-12-1-3-临时资源的声明"><a href="#%E4%B8%B4%E6%97%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%A3%B0%E6%98%8E"></a>1.4.12.1.3. 临时资源的声明</h2>
<p><code>ephemeral</code> 块中的绝大多数参数是由您正在定义的临时资源类型所决定的。与 <code>resource</code> 和 <code>data</code> 一样，<a target="_blank" rel="noopener" href="https://registry.terraform.io/browse/providers">Terraform 注册表</a>中的每个 Provider 程序都包含其支持的临时资源（如果有）的文档。临时资源类型的文档列出了可用的参数以及应如何配置的格式。</p>
<p>临时资源由两部分组成：</p>
<ul>
<li>属性</li>
<li>元参数</li>
</ul>
<p><code>ephemeral</code> 块的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ephemeral &quot;&lt;resource_type&gt;&quot; &quot;&lt;resource_name&gt;&quot; &#123;</span><br><span class="line">  &lt;attributes&gt;</span><br><span class="line">  &lt;meta-arguments&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-12-1-4-引用临时资源"><a href="#%E5%BC%95%E7%94%A8%E4%B8%B4%E6%97%B6%E8%B5%84%E6%BA%90"></a>1.4.12.1.4. 引用临时资源</h2>
<p>只允许在特定的临时上下文中引用临时资源，否则 Terraform 会返回错误。以下是可以引用临时资源的上下文：</p>
<ul>
<li>另一个临时资源</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/5.%E5%B1%80%E9%83%A8%E5%80%BC.html#%E4%B8%B4%E6%97%B6ephemeral%E5%B1%80%E9%83%A8%E5%80%BC">局部值</a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/3.%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F.html#%E4%B8%B4%E6%97%B6%E8%BE%93%E5%85%A5%E5%8F%98%E9%87%8F-ephemeral">临时输入变量</a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/4.%E8%BE%93%E5%87%BA%E5%80%BC.html#%E4%B8%B4%E6%97%B6%E5%80%BCephemeral-%E9%81%BF%E5%85%8D%E5%B0%86%E5%80%BC%E5%AD%98%E5%82%A8%E5%88%B0%E7%8A%B6%E6%80%81%E6%88%96%E8%AE%A1%E5%88%92%E6%96%87%E4%BB%B6%E4%B8%AD">临时输出值</a></li>
<li>在 <code>provider</code> 块中配置 Provider</li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#provisioner-%E5%92%8C-connection"><code>provisioner</code></a> 与 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#provisioner-%E5%92%8C-connection"><code>connection</code></a> 块</li>
</ul>
<h2 id="1-4-12-1-5-元参数"><a href="#%E5%85%83%E5%8F%82%E6%95%B0"></a>1.4.12.1.5. 元参数</h2>
<p>我们可以将在临时资源块内声明以下元参数，来更改这些资源的行为。以下元参数对于资源、数据源和临时资源的工作方式相同：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#depends_on"><code>depends_on</code></a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#count"><code>count</code></a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#for_each"><code>for_each</code></a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#provider"><code>provider</code></a></li>
<li><a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/6.%E8%B5%84%E6%BA%90.html#lifecycle"><code>lifecycle</code></a></li>
</ul>
<p>临时资源不支持 <code>provisioner</code> 元参数。</p>
<h2 id="1-4-12-1-6-示例"><a href="#%E7%A4%BA%E4%BE%8B"></a>1.4.12.1.6. 示例</h2>
<p>以下示例使用临时资源的凭据配置 <code>postgresql</code> Provider 程序。由于这些凭据由临时资源管理，因此 Terraform 不会将它们存储在状态或计划文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ephemeral &quot;aws_secretsmanager_secret_version&quot; &quot;db_master&quot; &#123;</span><br><span class="line">  secret_id = data.aws_db_instance.example.master_user_secret[0].secret_arn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">locals &#123;</span><br><span class="line">  credentials = jsondecode(ephemeral.aws_secretsmanager_secret_version.db_master.secret_string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;postgresql&quot; &#123;</span><br><span class="line">  host     = data.aws_db_instance.example.address</span><br><span class="line">  port     = data.aws_db_instance.example.port</span><br><span class="line">  username = local.credentials[&quot;username&quot;]</span><br><span class="line">  password = local.credentials[&quot;password&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2023/01/19/Teraform/Terraform-%E4%BB%A3%E7%A0%81/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2023/01/18/Teraform/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"
                            aria-label=": Terraform-基础概念-状态管理"
                        >
                            Terraform-基础概念-状态管理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-18T17:43:45+08:00">
	
		    2023 年 1 月 18 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/devops/">devops</a>, <a class="category-link" href="../../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><strong>1.3.2.1.</strong> Terraform 基础概念——状态管理</a></p>
</li>
<li>
<p><a href="#%E5%88%9D%E6%8E%A2%E7%8A%B6%E6%80%81%E6%96%87%E4%BB%B6"><strong>1.3.2.1.1.</strong> 初探状态文件</a></p>
</li>
<li>
<p><a href="#%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%89%E5%85%A8%E8%AD%A6%E7%A4%BA%E2%80%94%E2%80%94-tfstate-%E6%98%AF%E6%98%8E%E6%96%87%E7%9A%84"><strong>1.3.2.1.2.</strong> 极其重要的安全警示—— tfstate 是明文的</a></p>
</li>
<li>
<p><a href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-tfstate-%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94-backend"><strong>1.3.2.1.3.</strong> 生产环境的 tfstate 管理方案—— Backend</a></p>
</li>
<li>
<p><a href="#consul%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85"><strong>1.3.2.1.4.</strong> Consul简介以及安装</a></p>
</li>
<li>
<p><a href="#%E4%BD%BF%E7%94%A8-backend"><strong>1.3.2.1.5.</strong> 使用 Backend</a></p>
</li>
<li>
<p><a href="#%E8%A7%82%E5%AF%9F%E9%94%81%E6%96%87%E4%BB%B6"><strong>1.3.2.1.6.</strong> 观察锁文件</a></p>
</li>
<li>
<p><a href="#backend-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC"><strong>1.3.2.1.7.</strong> Backend 配置的动态赋值</a></p>
</li>
<li>
<p><a href="#backend-%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><strong>1.3.2.1.8.</strong> Backend 的权限控制以及版本控制</a></p>
</li>
<li>
<p><a href="#%E7%8A%B6%E6%80%81%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AD%98%E5%82%A8"><strong>1.3.2.1.9.</strong> 状态的隔离存储</a></p>
</li>
<li>
<p><a href="#%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9A%94%E7%A6%BB"><strong>1.3.2.1.10.</strong> 该使用哪种隔离</a></p>
</li>
</ul>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"></a></p>
<h2 id="1-3-2-1-Terraform-基础概念——状态管理"><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"></a>1.3.2.1. Terraform 基础概念——状态管理</h2>
<p>我们在第一章的末尾提过，当我们成功地执行了一次 <code>terraform apply</code>，创建了期望的基础设施以后，我们如果再次执行 <code>terraform apply</code>，生成的新的执行计划将不会包含任何变更，Terraform 会记住当前基础设施的状态，并将之与代码所描述的期望状态进行比对。第二次 apply 时，因为当前状态已经与代码描述的状态一致了，所以会生成一个空的执行计划。</p>
<h2 id="1-3-2-1-1-初探状态文件"><a href="#%E5%88%9D%E6%8E%A2%E7%8A%B6%E6%80%81%E6%96%87%E4%BB%B6"></a>1.3.2.1.1. 初探状态文件</h2>
<p>在这里，Terraform 引入了一个独特的概念——状态管理，这是 Ansible 等配置管理工具或是自研工具调用 SDK 操作基础设施的方案所没有的。简单来说，Terraform 将每次执行基础设施变更操作时的状态信息保存在一个状态文件中，默认情况下会保存在当前工作目录下的 <code>terraform.tfstate</code> 文件里。例如我们之前在使用 LocalStack 模拟环境的代码中声明一个 <code>data</code> 和一个 <code>resource</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_ami&quot; &quot;ubuntu&quot; &#123;</span><br><span class="line">  most_recent = true</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;name&quot;</span><br><span class="line">    values = [&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;virtualization-type&quot;</span><br><span class="line">    values = [&quot;hvm&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  owners = [&quot;099720109477&quot;] # Canonical</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = data.aws_ami.ubuntu.id</span><br><span class="line">  instance_type = &quot;t3.micro&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;HelloWorld&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>terraform apply</code> 后，我们可以看到 <code>terraform.tfstate</code> 的内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;terraform_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.7.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;serial&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lineage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;159018e2-63f4-2dfa-ce0d-873a37a1e0a7&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;resources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aws_ami&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;provider[\&quot;registry.terraform.io/hashicorp/aws\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;instances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;schema_version&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x86_64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;arn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:ec2:us-east-1::image/ami-1e749f67&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;block_device_mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;device_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/sda1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ebs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;delete_on_termination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;encrypted&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;iops&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;snapshot_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;snap-15bd5527&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;throughput&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;volume_size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;15&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;volume_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standard&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;no_device&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;virtual_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;boot_mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;creation_date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-02-20T13:52:42.000Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;deprecation_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Canonical, Ubuntu, 14.04 LTS, amd64 trusty image build on 2017-07-27&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ena_support&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;executable_users&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                  <span class="string">&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;virtualization-type&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                  <span class="string">&quot;hvm&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hypervisor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xen&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ami-1e749f67&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;image_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ami-1e749f67&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;image_location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amazon/getting-started&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;image_owner_alias&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amazon&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;image_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;machine&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;imds_support&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;include_deprecated&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;kernel_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;None&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;most_recent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name_regex&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;owner_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;099720109477&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;owners&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;099720109477&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;platform_details&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;product_codes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ramdisk_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ari-1a2b3c4d&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;root_device_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/sda1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;root_device_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ebs&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;root_snapshot_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;snap-15bd5527&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;sriov_net_support&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;available&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;state_reason&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UNSET&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UNSET&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;timeouts&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tpm_support&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;usage_operation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;virtualization_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hvm&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;sensitive_attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;managed&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aws_instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;web&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;provider[\&quot;registry.terraform.io/hashicorp/aws\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;instances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;schema_version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;ami&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ami-1e749f67&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;arn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:ec2:us-east-1::instance/i-288a34165ed2ad2f7&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;associate_public_ip_address&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;availability_zone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;us-east-1a&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;capacity_reservation_specification&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cpu_core_count&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cpu_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cpu_threads_per_core&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;credit_specification&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;disable_api_stop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;disable_api_termination&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ebs_block_device&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ebs_optimized&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;enclave_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ephemeral_block_device&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;get_password_data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hibernation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;host_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;host_resource_group_arn&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;iam_instance_profile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;i-288a34165ed2ad2f7&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_initiated_shutdown_behavior&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stop&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_lifecycle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_market_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;running&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;instance_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t3.micro&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ipv6_address_count&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ipv6_addresses&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;key_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;launch_template&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;maintenance_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;metadata_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;monitoring&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;network_interface&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;outpost_arn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;password_data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;placement_group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;placement_partition_number&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;primary_network_interface_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eni-68899bf6&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_dns&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ip-10-13-239-41.ec2.internal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_dns_name_options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.13.239.41&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_dns&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ec2-54-214-132-221.compute-1.amazonaws.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;54.214.132.221&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;root_block_device&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;delete_on_termination&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;device_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/sda1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;encrypted&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;iops&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kms_key_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;throughput&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volume_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vol-6dde834f&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volume_size&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;volume_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gp2&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;secondary_private_ips&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;security_groups&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;source_dest_check&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;spot_instance_request_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;subnet_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;subnet-dbb4c2f9&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tenancy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;timeouts&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user_data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user_data_base64&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user_data_replace_on_change&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;volume_tags&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;vpc_security_group_ids&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;sensitive_attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6MTIwMDAwMDAwMDAwMCwidXBkYXRlIjo2MDAwMDAwMDAwMDB9LCJzY2hlbWFfdmVyc2lvbiI6IjEifQ==&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;data.aws_ami.ubuntu&quot;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;check_results&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，查询到的 <code>data</code> 以及创建的 <code>resource</code> 信息都被以 json 格式保存在 <code>tfstate</code> 文件里。</p>
<p>我们前面已经说过，由于 <code>tfstate</code> 文件的存在，我们在 <code>terraform apply</code> 之后立即再次 apply 是不会执行任何变更的，那么如果我们删除了这个 <code>tfstate</code> 文件，然后再执行 apply 会发生什么呢？Terraform 读取不到 <code>tfstate</code> 文件，会认为这是我们第一次创建这组资源，所以它会再一次创建代码中描述的所有资源。更加麻烦的是，由于我们前一次创建的资源所对应的状态信息被我们删除了，所以我们再也无法通过执行 <code>terraform destroy</code> 来销毁和回收这些资源，实际上产生了资源泄漏。所以妥善保存这个状态文件是非常重要的。</p>
<p>另外，如果我们对 Terraform 的代码进行了一些修改，导致生成的执行计划将会改变状态，那么在实际执行变更之前，Terraform 会复制一份当前的 <code>tfstate</code> 文件到同路径下的 <code>terraform.tfstate.backup</code> 中，以防止由于各种意外导致的 <code>tfstate</code> 损毁。</p>
<p>在 Terraform 发展的极早期，HashiCorp 曾经尝试过无状态文件的方案，也就是在执行 Terraform 变更计划时，给所有涉及到的资源都打上特定的 tag，在下次执行变更时，先通过 tag 读取相关资源来重建状态信息。但因为并不是所有资源都支持打 tag，也不是所有公有云都支持多 tag，所以 Terraform 最终决定用状态文件方案。</p>
<p>还有一点，HashiCorp 官方从未公开过 <code>tfstate</code> 的格式，也就是说，HashiCorp 保留随时修改 <code>tfstate</code> 格式的权力。所以不要试图手动或是用自研代码去修改 <code>tfstate</code>，Terraform 命令行工具提供了相关的指令(我们后续会介绍到)，请确保只通过命令行的指令操作状态文件。</p>
<h2 id="1-3-2-1-2-极其重要的安全警示——-tfstate-是明文的"><a href="#%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%89%E5%85%A8%E8%AD%A6%E7%A4%BA%E2%80%94%E2%80%94-tfstate-%E6%98%AF%E6%98%8E%E6%96%87%E7%9A%84"></a>1.3.2.1.2. 极其重要的安全警示—— tfstate 是明文的</h2>
<p>关于 Terraform 状态，还有极其重要的事，所有考虑在生产环境使用 Terraform 的人都必须格外小心并再三警惕：Terraform 的状态文件是明文的，这就意味着代码中所使用的一切机密信息都将以明文的形式保存在状态文件里。例如我们创建一个私钥文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;tls_private_key&quot; &quot;example&quot; &#123;</span><br><span class="line">  algorithm = &quot;RSA&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行了<code>terraform apply</code>后我们观察 <code>tfstate</code> 文件中相关段落：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;terraform_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.7.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;serial&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lineage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dec42d6b-d61f-30b3-0b83-d5d8881c29ea&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;resources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;managed&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tls_private_key&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;example&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;provider[\&quot;registry.terraform.io/hashicorp/tls\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;instances&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;schema_version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;algorithm&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RSA&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ecdsa_curve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;P224&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d47d1465586d25322bb8ca16029fe4fb2ec001e0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_key_openssh&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-----BEGIN OPENSSH PRIVATE KEY-----\nb3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABFwAAAAdz\nc2gtcnNhAAAAAwEAAQAAAQEAsdD9sJ/L5m8cRB19V20HA9BIqZwnT3id5JoMNUuW\nYn4sJTWHa/JHkQ5akrWH50aIdzQrQneIZXJyx1OMlqKbVxAc2+u/8qd2m2GrsWKZ\neqQcpNT7v76QowDcvdggad3Tezn3XU/eBukVj9i+lnN1ofyQzVEQAdvW8TpRdUL5\nb/bIsz1RzGWzUrWD8XTFLf2RuvvzhgBViuuWI0ns3WQMpa6Dcu+nWfGLCl26Wlph\nNmoUAv8wCay7KoynG58pJW+uqYA7lTx4tNMLhIW7rM4roYbXctkCi03PcW3x25O8\nyKSzYIi5xH7CQ7ggwXzcx4r06NXkaE9/LHuBSFJcIMvH8QAAA7jnMVXy5zFV8gAA\nAAdzc2gtcnNhAAABAQCx0P2wn8vmbxxEHX1XbQcD0EipnCdPeJ3kmgw1S5Zifiwl\nNYdr8keRDlqStYfnRoh3NCtCd4hlcnLHU4yWoptXEBzb67/yp3abYauxYpl6pByk\n1Pu/vpCjANy92CBp3dN7OfddT94G6RWP2L6Wc3Wh/JDNURAB29bxOlF1Qvlv9siz\nPVHMZbNStYPxdMUt/ZG6+/OGAFWK65YjSezdZAylroNy76dZ8YsKXbpaWmE2ahQC\n/zAJrLsqjKcbnyklb66pgDuVPHi00wuEhbusziuhhtdy2QKLTc9xbfHbk7zIpLNg\niLnEfsJDuCDBfNzHivTo1eRoT38se4FIUlwgy8fxAAAAAwEAAQAAAQEAleLv5ZFd\nY9mm/vfIrwg1UI6ioW4CaOfoWElOHyKfGlj2x0qu41wv3WM3D9G7REVdRPYRvQ5b\nSABIJiMUL+nTfXkUioDXpShqPyH+gyD09L8fcgYiS4fMDcrtR43GDNcyq/25uMtZ\nAYQ6a62tQc8Dik8GlDtPffGc5mxdO7X/4tLAObBPqO+lvGX2K/2hV2ql/a4fBVXR\nOMPc9A0eva2exifZyFo9vT9CCcW4iNY2BHY2hXAPI1gFpBnmnY2twFof4EvX6tfZ\nGjt20QCqTi41P8Obrfqi108zRAKtjJFeezNY+diVvxZaCDb/7ceFbFUrXq9u2UVD\nExn9joOLTJTEwQAAAIEAgOQ/mjRousgSenXW2nE2aq0m7oKQzhsF/8k5UPj6mym1\nvwUyC2gglTIOGVkUpj91L/Fh2nCuX5BLyzzIee0twRvT1Kj11BU6UoElStpR/JEC\n7trKWJrBddphBWHAuVcU5AQQPwI/9sg27q/9y16WTIQAJzx8GwGcDbgZj8/LbB4A\nAACBAMpVcX+2smqt8T9mbwU7e7ZaCQM0c3/7F2S2Z26Zl16k+8WPr6+CyJd3d2s2\nQkrmqVKJzDqPYidU0EmaNOrqytvUTUDK9KJgKsJuNC9ZbODqTCMA03ntr+hVcfdt\nd9F5fxyBJSrzpAhUQKadHs8jtAa1ENAhPmwKzvcJ51Gp4R3ZAAAAgQDg+s4nk926\njuLQGlweOi2HY6eeMQF8MOnXEhM8P7ErdRR73ql7GlhBNoGzuI6YTaqjLXBGNetj\nm4iziPLapbqBXSeia3y1JU71e1M+J342CxQwZRKTI9G/AB2AzspB4VfjAT9ZYJM1\nSFH7cDTejcrkfWko8TqyRLwtTPDa7Xlz2QAAAAAB\n-----END OPENSSH PRIVATE KEY-----\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_key_pem&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEAsdD9sJ/L5m8cRB19V20HA9BIqZwnT3id5JoMNUuWYn4sJTWH\na/JHkQ5akrWH50aIdzQrQneIZXJyx1OMlqKbVxAc2+u/8qd2m2GrsWKZeqQcpNT7\nv76QowDcvdggad3Tezn3XU/eBukVj9i+lnN1ofyQzVEQAdvW8TpRdUL5b/bIsz1R\nzGWzUrWD8XTFLf2RuvvzhgBViuuWI0ns3WQMpa6Dcu+nWfGLCl26WlphNmoUAv8w\nCay7KoynG58pJW+uqYA7lTx4tNMLhIW7rM4roYbXctkCi03PcW3x25O8yKSzYIi5\nxH7CQ7ggwXzcx4r06NXkaE9/LHuBSFJcIMvH8QIDAQABAoIBAQCV4u/lkV1j2ab+\n98ivCDVQjqKhbgJo5+hYSU4fIp8aWPbHSq7jXC/dYzcP0btERV1E9hG9DltIAEgm\nIxQv6dN9eRSKgNelKGo/If6DIPT0vx9yBiJLh8wNyu1HjcYM1zKr/bm4y1kBhDpr\nra1BzwOKTwaUO0998ZzmbF07tf/i0sA5sE+o76W8ZfYr/aFXaqX9rh8FVdE4w9z0\nDR69rZ7GJ9nIWj29P0IJxbiI1jYEdjaFcA8jWAWkGeadja3AWh/gS9fq19kaO3bR\nAKpOLjU/w5ut+qLXTzNEAq2MkV57M1j52JW/FloINv/tx4VsVSter27ZRUMTGf2O\ng4tMlMTBAoGBAMpVcX+2smqt8T9mbwU7e7ZaCQM0c3/7F2S2Z26Zl16k+8WPr6+C\nyJd3d2s2QkrmqVKJzDqPYidU0EmaNOrqytvUTUDK9KJgKsJuNC9ZbODqTCMA03nt\nr+hVcfdtd9F5fxyBJSrzpAhUQKadHs8jtAa1ENAhPmwKzvcJ51Gp4R3ZAoGBAOD6\nzieT3bqO4tAaXB46LYdjp54xAXww6dcSEzw/sSt1FHveqXsaWEE2gbO4jphNqqMt\ncEY162ObiLOI8tqluoFdJ6JrfLUlTvV7Uz4nfjYLFDBlEpMj0b8AHYDOykHhV+MB\nP1lgkzVIUftwNN6NyuR9aSjxOrJEvC1M8NrteXPZAoGAIQf/5nSh/e51ov8LAtSq\nJqPeMsq+TFdmg0eP7Stf3dCbVa5WZRW5v5h+Q19xRR8Q52udjrXXtUoQUuO83dkE\n0wx+rCQ1+cgvUtyA4nX741/8m/5Hh/E4tXo1h8o0NFtcV//xXGi4D7AJeenOnMxc\nWHf4zbGPqj29efEA9YEBQkkCgYABhG+DgNHMAk6xTJw2b/oCob9tp7L03XeWRb7v\ndxaAzodW1oeaFvFlbzKsvZ/okw2FkDbjolV2FIR1gYTxyJBbcv9jbwomRpwjt7M2\nBhopzyVRtjzL1UAC48NPLRXcH+Lx2v5MYgRcJaK36WfR4G7v35CoAAh/T0tdmtk9\nAMEC8QKBgQCA5D+aNGi6yBJ6ddbacTZqrSbugpDOGwX/yTlQ+PqbKbW/BTILaCCV\nMg4ZWRSmP3Uv8WHacK5fkEvLPMh57S3BG9PUqPXUFTpSgSVK2lH8kQLu2spYmsF1\n2mEFYcC5VxTkBBA/Aj/2yDbur/3LXpZMhAAnPHwbAZwNuBmPz8tsHg==\n-----END RSA PRIVATE KEY-----\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;private_key_pem_pkcs8&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCx0P2wn8vmbxxE\nHX1XbQcD0EipnCdPeJ3kmgw1S5ZifiwlNYdr8keRDlqStYfnRoh3NCtCd4hlcnLH\nU4yWoptXEBzb67/yp3abYauxYpl6pByk1Pu/vpCjANy92CBp3dN7OfddT94G6RWP\n2L6Wc3Wh/JDNURAB29bxOlF1Qvlv9sizPVHMZbNStYPxdMUt/ZG6+/OGAFWK65Yj\nSezdZAylroNy76dZ8YsKXbpaWmE2ahQC/zAJrLsqjKcbnyklb66pgDuVPHi00wuE\nhbusziuhhtdy2QKLTc9xbfHbk7zIpLNgiLnEfsJDuCDBfNzHivTo1eRoT38se4FI\nUlwgy8fxAgMBAAECggEBAJXi7+WRXWPZpv73yK8INVCOoqFuAmjn6FhJTh8inxpY\n9sdKruNcL91jNw/Ru0RFXUT2Eb0OW0gASCYjFC/p0315FIqA16Uoaj8h/oMg9PS/\nH3IGIkuHzA3K7UeNxgzXMqv9ubjLWQGEOmutrUHPA4pPBpQ7T33xnOZsXTu1/+LS\nwDmwT6jvpbxl9iv9oVdqpf2uHwVV0TjD3PQNHr2tnsYn2chaPb0/QgnFuIjWNgR2\nNoVwDyNYBaQZ5p2NrcBaH+BL1+rX2Ro7dtEAqk4uNT/Dm636otdPM0QCrYyRXnsz\nWPnYlb8WWgg2/+3HhWxVK16vbtlFQxMZ/Y6Di0yUxMECgYEAylVxf7ayaq3xP2Zv\nBTt7tloJAzRzf/sXZLZnbpmXXqT7xY+vr4LIl3d3azZCSuapUonMOo9iJ1TQSZo0\n6urK29RNQMr0omAqwm40L1ls4OpMIwDTee2v6FVx92130Xl/HIElKvOkCFRApp0e\nzyO0BrUQ0CE+bArO9wnnUanhHdkCgYEA4PrOJ5Pduo7i0BpcHjoth2OnnjEBfDDp\n1xITPD+xK3UUe96pexpYQTaBs7iOmE2qoy1wRjXrY5uIs4jy2qW6gV0nomt8tSVO\n9XtTPid+NgsUMGUSkyPRvwAdgM7KQeFX4wE/WWCTNUhR+3A03o3K5H1pKPE6skS8\nLUzw2u15c9kCgYAhB//mdKH97nWi/wsC1Komo94yyr5MV2aDR4/tK1/d0JtVrlZl\nFbm/mH5DX3FFHxDna52Otde1ShBS47zd2QTTDH6sJDX5yC9S3IDidfvjX/yb/keH\n8Ti1ejWHyjQ0W1xX//FcaLgPsAl56c6czFxYd/jNsY+qPb158QD1gQFCSQKBgAGE\nb4OA0cwCTrFMnDZv+gKhv22nsvTdd5ZFvu93FoDOh1bWh5oW8WVvMqy9n+iTDYWQ\nNuOiVXYUhHWBhPHIkFty/2NvCiZGnCO3szYGGinPJVG2PMvVQALjw08tFdwf4vHa\n/kxiBFwlorfpZ9Hgbu/fkKgACH9PS12a2T0AwQLxAoGBAIDkP5o0aLrIEnp11tpx\nNmqtJu6CkM4bBf/JOVD4+psptb8FMgtoIJUyDhlZFKY/dS/xYdpwrl+QS8s8yHnt\nLcEb09So9dQVOlKBJUraUfyRAu7ayliawXXaYQVhwLlXFOQEED8CP/bINu6v/cte\nlkyEACc8fBsBnA24GY/Py2we\n-----END PRIVATE KEY-----\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_key_fingerprint_md5&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a9:cc:2d:0f:66:b9:a9:89:94:f1:da:8f:93:df:63:d5&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_key_fingerprint_sha256&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SHA256:ias4wauIC4J/zd/cVoXT6UUSUZLQXaxdpJfkGAfRDz0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_key_openssh&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCx0P2wn8vmbxxEHX1XbQcD0EipnCdPeJ3kmgw1S5ZifiwlNYdr8keRDlqStYfnRoh3NCtCd4hlcnLHU4yWoptXEBzb67/yp3abYauxYpl6pByk1Pu/vpCjANy92CBp3dN7OfddT94G6RWP2L6Wc3Wh/JDNURAB29bxOlF1Qvlv9sizPVHMZbNStYPxdMUt/ZG6+/OGAFWK65YjSezdZAylroNy76dZ8YsKXbpaWmE2ahQC/zAJrLsqjKcbnyklb66pgDuVPHi00wuEhbusziuhhtdy2QKLTc9xbfHbk7zIpLNgiLnEfsJDuCDBfNzHivTo1eRoT38se4FIUlwgy8fx\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;public_key_pem&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsdD9sJ/L5m8cRB19V20H\nA9BIqZwnT3id5JoMNUuWYn4sJTWHa/JHkQ5akrWH50aIdzQrQneIZXJyx1OMlqKb\nVxAc2+u/8qd2m2GrsWKZeqQcpNT7v76QowDcvdggad3Tezn3XU/eBukVj9i+lnN1\nofyQzVEQAdvW8TpRdUL5b/bIsz1RzGWzUrWD8XTFLf2RuvvzhgBViuuWI0ns3WQM\npa6Dcu+nWfGLCl26WlphNmoUAv8wCay7KoynG58pJW+uqYA7lTx4tNMLhIW7rM4r\noYbXctkCi03PcW3x25O8yKSzYIi5xH7CQ7ggwXzcx4r06NXkaE9/LHuBSFJcIMvH\n8QIDAQAB\n-----END PUBLIC KEY-----\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rsa_bits&quot;</span><span class="punctuation">:</span> <span class="number">2048</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;sensitive_attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;check_results&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到不应该被第三方知晓的 <code>private_key_openssh</code>、<code>private_key_pem</code> 和 <code>private_key_pem_pkcs8</code> 是以明文形式被写在 <code>tfstate</code> 文件里的。这是 Terraform 从设计之初就确定的，并且在可见的未来不会有改善。不论你是在代码中明文硬编码，还是使用参数(variable，我们之后的章节会介绍)，亦或是妙想天开地使用函数在运行时从外界读取，都无法改变这个结果。</p>
<p>解决之道有两种，一种是使用 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/essential-vault/">Vault</a> 或是 <a target="_blank" rel="noopener" href="https://aws.amazon.com/secrets-manager/">AWS Secret Manager</a> 这样的动态机密管理工具生成临时有效的动态机密(比如有效期只有 5 分钟，即使被他人读取到，机密也早已失效)；另一种就是我们下面将要介绍的 —— Terraform Backend。</p>
<h2 id="1-3-2-1-3-生产环境的-tfstate-管理方案——-Backend"><a href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-tfstate-%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94-backend"></a>1.3.2.1.3. 生产环境的 tfstate 管理方案—— Backend</h2>
<p>到目前为止我们的 <code>tfstate</code> 文件是保存在当前工作目录下的本地文件，假设我们的计算机损坏了，导致文件丢失，那么 <code>tfstate</code> 文件所对应的资源都将无法管理，而产生资源泄漏。</p>
<p>另外如果我们是一个团队在使用 Terraform 管理一组资源，团队成员之间要如何共享这个状态文件？能不能把 <code>tfstate</code> 文件签入源代码管理工具进行保存？</p>
<p>把 <code>tfstate</code> 文件签入管代码管理工具是非常错误的，这就好比把数据库签入了源代码管理工具，如果两个人同时签出了同一份 <code>tfstate</code>，并且对代码做了不同的修改，又同时 apply 了，这时想要把 <code>tfstate</code> 签入源码管理系统可能会遭遇到无法解决的冲突。况且如果代码仓库是公开的，那么保存在 State 中的明文机密就会泄露。</p>
<p>为了解决状态文件的存储和共享问题，Terraform 引入了远程状态存储机制，也就是 Backend。Backend 是一种抽象的远程存储接口，如同 Provider 一样，Backend 也支持多种不同的远程存储服务：</p>
<ul>
<li><code>local</code></li>
<li><code>remote</code></li>
<li><code>azurerm</code></li>
<li><code>consul</code></li>
<li><code>cos</code></li>
<li><code>gcs</code></li>
<li><code>http</code></li>
<li><code>kubernetes</code></li>
<li><code>oss</code></li>
<li><code>pg</code></li>
<li><code>s3</code></li>
</ul>
<p><strong>注意</strong>：在 Terraform 1.1.0 之前的版本中，Backend 分为<em>标准</em>和<em>增强</em>两种。<em>增强</em>是一种特殊的 <code>remote</code> Backend，它既可以存储状态，也可以执行 Terraform 操作。但是这种分类已被移除。请参考<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/cli/cloud">使用 Terraform Cloud</a> 了解关于存储状态、执行远程操作以及直接从 Terraform 调用 Terraform Cloud 的详细信息。</p>
<p>状态锁是指，当针对一个 <code>tfstate</code> 进行变更操作时，可以针对该状态文件添加一把全局锁，确保同一时间只能有一个变更被执行。不同的 Backend 对状态锁的支持不尽相同，实现状态锁的机制也不尽相同，例如 <code>consul</code> Backend就通过一个 <code>.lock</code> 节点来充当锁，一个 <code>.lockinfo</code> 节点来描述锁对应的会话信息，<code>tfstate</code> 文件被保存在 Backend 定义的路径节点内；<code>s3</code> Backend 则需要用户传入一个 Dynamodb 表来存放锁信息，而 <code>tfstate</code> 文件被存储在 S3 存储桶里，等等等等。读者可以根据实际情况，挑选自己合适的 Backend。接下来我将以 <code>consul</code> 为范例为读者演示 Backend 机制。</p>
<h2 id="1-3-2-1-4-Consul简介以及安装"><a href="#consul%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85"></a>1.3.2.1.4. Consul简介以及安装</h2>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/">Consul</a> 是 HashiCorp 推出的一个开源工具，主要用来解决服务发现、配置中心以及 Service Mesh 等问题；Consul 本身也提供了类似 ZooKeeper、Etcd 这样的分布式键值存储服务，具有基于 Gossip 协议的最终一致性，所以可以被用来充当 Terraform Backend 存储。</p>
<p>安装 Consul 十分简单，如果你是 Ubuntu 用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O- https://apt.releases.hashicorp.com/gpg | <span class="built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com <span class="subst">$(lsb_release -cs)</span> main&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/hashicorp.list</span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install consul</span><br></pre></td></tr></table></figure>
<p>对于CentOS用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils</span><br><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo</span><br><span class="line"><span class="built_in">sudo</span> yum -y install consul</span><br></pre></td></tr></table></figure>
<p>对于Macos用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap hashicorp/tap</span><br><span class="line">brew install hashicorp/tap/consul</span><br></pre></td></tr></table></figure>
<p>对于 Windows 用户，如果按照前文安装 Terraform 教程已经配置了 Chocolatey 的话：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install consul</span><br></pre></td></tr></table></figure>
<p>安装完成后的验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ consul</span><br><span class="line">Usage: consul [--version] [--<span class="built_in">help</span>] &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Available commands are:</span><br><span class="line">    acl             Interact with Consul<span class="string">&#x27;s ACLs</span></span><br><span class="line"><span class="string">    agent           Runs a Consul agent</span></span><br><span class="line"><span class="string">    catalog         Interact with the catalog</span></span><br><span class="line"><span class="string">    config          Interact with Consul&#x27;</span>s Centralized Configurations</span><br><span class="line">    connect         Interact with Consul Connect</span><br><span class="line">    debug           Records a debugging archive <span class="keyword">for</span> operators</span><br><span class="line">    event           Fire a new event</span><br><span class="line">    <span class="built_in">exec</span>            Executes a <span class="built_in">command</span> on Consul nodes</span><br><span class="line">    force-leave     Forces a member of the cluster to enter the <span class="string">&quot;left&quot;</span> state</span><br><span class="line">    info            Provides debugging information <span class="keyword">for</span> operators.</span><br><span class="line">    intention       Interact with Connect service intentions</span><br><span class="line">    <span class="built_in">join</span>            Tell Consul agent to <span class="built_in">join</span> cluster</span><br><span class="line">    keygen          Generates a new encryption key</span><br><span class="line">    keyring         Manages gossip layer encryption keys</span><br><span class="line">    kv              Interact with the key-value store</span><br><span class="line">    leave           Gracefully leaves the Consul cluster and shuts down</span><br><span class="line">    lock            Execute a <span class="built_in">command</span> holding a lock</span><br><span class="line">    login           Login to Consul using an auth method</span><br><span class="line">    <span class="built_in">logout</span>          Destroy a Consul token created with login</span><br><span class="line">    maint           Controls node or service maintenance mode</span><br><span class="line">    members         Lists the members of a Consul cluster</span><br><span class="line">    monitor         Stream logs from a Consul agent</span><br><span class="line">    operator        Provides cluster-level tools <span class="keyword">for</span> Consul operators</span><br><span class="line">    peering         Create and manage peering connections between Consul clusters</span><br><span class="line">    reload          Triggers the agent to reload configuration files</span><br><span class="line">    resource        Interact with Consul<span class="string">&#x27;s resources</span></span><br><span class="line"><span class="string">    rtt             Estimates network round trip time between nodes</span></span><br><span class="line"><span class="string">    services        Interact with services</span></span><br><span class="line"><span class="string">    snapshot        Saves, restores and inspects snapshots of Consul server state</span></span><br><span class="line"><span class="string">    tls             Builtin helpers for creating CAs and certificates</span></span><br><span class="line"><span class="string">    troubleshoot    CLI tools for troubleshooting Consul service mesh</span></span><br><span class="line"><span class="string">    validate        Validate config files/directories</span></span><br><span class="line"><span class="string">    version         Prints the Consul version</span></span><br><span class="line"><span class="string">    watch           Watch for changes in Consul</span></span><br></pre></td></tr></table></figure>
<p>安装完 Consul 后，我们可以启动一个测试版 Consul 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul agent -dev</span><br></pre></td></tr></table></figure>
<p>Consul 会在本机 <code>8500</code> 端口开放 Http 终结点，我们可以通过浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8500/">http://localhost:8500</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220224455.png" alt="Consul的GUI界面"></p>
<p>图 1.3.2/1 - Consul的GUI界面</p>
<h2 id="1-3-2-1-5-使用-Backend"><a href="#%E4%BD%BF%E7%94%A8-backend"></a>1.3.2.1.5. 使用 Backend</h2>
<p>我们还是利用 LocalStack 来执行一段简单的 Terraform 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backend &quot;consul&quot; &#123;</span><br><span class="line">    address = &quot;localhost:8500&quot;</span><br><span class="line">    scheme  = &quot;http&quot;</span><br><span class="line">    path    = &quot;localstack-aws&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    docdb          = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_ami&quot; &quot;ubuntu&quot; &#123;</span><br><span class="line">  most_recent = true</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;name&quot;</span><br><span class="line">    values = [&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;virtualization-type&quot;</span><br><span class="line">    values = [&quot;hvm&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  owners = [&quot;099720109477&quot;] # Canonical</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = data.aws_ami.ubuntu.id</span><br><span class="line">  instance_type = &quot;t3.micro&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;HelloWorld&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>terraform</code> 节中，我们添加了 <code>backend</code> 配置节，指定使用 <code>localhost:8500</code> 为地址(也就是我们刚才启动的测试版 Consul 服务)，指定使用 http 协议访问该地址，指定 <code>tfstate</code> 文件存放在 Consul 键值存储服务的 <code>localstack-aws</code> 路径下。</p>
<p>当我们执行完 <code>terraform apply</code> 后，我们访问 <a target="_blank" rel="noopener" href="http://localhost:8500/ui/dc1/kv">http://localhost:8500/ui/dc1/kv</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220230042.png" alt="Consul 中可以看到名为  的键"></p>
<p>图 1.3.2/2 - Consul 中可以看到名为 `localstack-aws` 的键</p>
<p>可以看到 <code>localstack-aws</code>，点击进入：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220230136.png" alt="键的内容"></p>
<p>图 1.3.2/3 - 键的内容</p>
<p>可以看到，原本保存在工作目录下的 <code>tfstate</code> 文件的内容，被保存在了 Consul 的名为 <code>localstack-aws</code> 的键下。</p>
<p>让我们执行 <code>terraform destroy</code> 后，重新访问 <a target="_blank" rel="noopener" href="http://localhost:8500/ui/dc1/kv">http://localhost:8500/ui/dc1/kv</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220230312.png" alt="键依然存在"></p>
<p>图 1.3.2/4 - 键依然存在</p>
<p>可以看到，<code>localstack-aws</code> 这个键仍然存在。让我们点击进去：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240220230350.png" alt="内容已被清空"></p>
<p>图 1.3.2/5 - 内容已被清空</p>
<p>可以看到，它的内容为空，代表基础设施已经被成功销毁。</p>
<h2 id="1-3-2-1-6-观察锁文件"><a href="#%E8%A7%82%E5%AF%9F%E9%94%81%E6%96%87%E4%BB%B6"></a>1.3.2.1.6. 观察锁文件</h2>
<p>那么在这个过程里，锁究竟在哪里？我们如何能够体验到锁的存在？让我们对代码进行一点修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backend &quot;consul&quot; &#123;</span><br><span class="line">    address = &quot;localhost:8500&quot;</span><br><span class="line">    scheme  = &quot;http&quot;</span><br><span class="line">    path    = &quot;localstack-aws&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    docdb          = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_ami&quot; &quot;ubuntu&quot; &#123;</span><br><span class="line">  most_recent = true</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;name&quot;</span><br><span class="line">    values = [&quot;ubuntu/images/hvm-ssd/ubuntu-trusty-14.04-amd64-server-20170727&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;virtualization-type&quot;</span><br><span class="line">    values = [&quot;hvm&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  owners = [&quot;099720109477&quot;] # Canonical</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = data.aws_ami.ubuntu.id</span><br><span class="line">  instance_type = &quot;t3.micro&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;HelloWorld&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">    command = &quot;sleep 1000&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次的变化是我们在 <code>aws_instance</code> 的定义上添加了一个 <code>local-exec</code> 类型的 Provisioner。Provisioner 我们在后续的章节中会专门叙述，在这里读者只需要理解，Terraform 进程在成功创建了该资源后，会在执行 Terraform 命令行的机器上执行一条命令：<code>sleep 1000</code>，这个时间足以将 Terraform 进程阻塞足够长的时间，以便让我们观察锁信息了。如果读者正在使用 Windows，可以把 <code>provisioner</code> 改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">provisioner &quot;local-exec&quot; &#123;</span><br><span class="line">  command = &quot;Start-Sleep -s 1000&quot;</span><br><span class="line">  interpreter = [&quot;PowerShell&quot;, &quot;-Command&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们执行<code>terraform apply</code>，这一次 apply 将会被 sleep 阻塞，而不会成功完成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">data.aws_ami.ubuntu: Reading...</span><br><span class="line">data.aws_ami.ubuntu: Read complete after 1s [<span class="built_in">id</span>=ami-1e749f67]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following  </span><br><span class="line">symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># aws_instance.web will be created</span></span><br><span class="line">  + resource <span class="string">&quot;aws_instance&quot;</span> <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">      + ami                                  = <span class="string">&quot;ami-1e749f67&quot;</span></span><br><span class="line">      + arn                                  = (known after apply)</span><br><span class="line">      + associate_public_ip_address          = (known after apply)</span><br><span class="line">      + availability_zone                    = (known after apply)</span><br><span class="line">      + cpu_core_count                       = (known after apply)</span><br><span class="line">      + cpu_threads_per_core                 = (known after apply)</span><br><span class="line">      + disable_api_stop                     = (known after apply)</span><br><span class="line">      + disable_api_termination              = (known after apply)</span><br><span class="line">      + ebs_optimized                        = (known after apply)</span><br><span class="line">      + get_password_data                    = <span class="literal">false</span></span><br><span class="line">      + host_id                              = (known after apply)</span><br><span class="line">      + host_resource_group_arn              = (known after apply)</span><br><span class="line">      + iam_instance_profile                 = (known after apply)</span><br><span class="line">      + <span class="built_in">id</span>                                   = (known after apply)</span><br><span class="line">      + instance_initiated_shutdown_behavior = (known after apply)</span><br><span class="line">      + instance_lifecycle                   = (known after apply)</span><br><span class="line">      + instance_state                       = (known after apply)</span><br><span class="line">      + instance_type                        = <span class="string">&quot;t3.micro&quot;</span></span><br><span class="line">      + ipv6_address_count                   = (known after apply)</span><br><span class="line">      + ipv6_addresses                       = (known after apply)</span><br><span class="line">      + key_name                             = (known after apply)</span><br><span class="line">      + monitoring                           = (known after apply)</span><br><span class="line">      + outpost_arn                          = (known after apply)</span><br><span class="line">      + password_data                        = (known after apply)</span><br><span class="line">      + placement_group                      = (known after apply)</span><br><span class="line">      + placement_partition_number           = (known after apply)</span><br><span class="line">      + primary_network_interface_id         = (known after apply)</span><br><span class="line">      + private_dns                          = (known after apply)</span><br><span class="line">      + private_ip                           = (known after apply)</span><br><span class="line">      + public_dns                           = (known after apply)</span><br><span class="line">      + public_ip                            = (known after apply)</span><br><span class="line">      + secondary_private_ips                = (known after apply)</span><br><span class="line">      + security_groups                      = (known after apply)</span><br><span class="line">      + source_dest_check                    = <span class="literal">true</span></span><br><span class="line">      + spot_instance_request_id             = (known after apply)</span><br><span class="line">      + subnet_id                            = (known after apply)</span><br><span class="line">      + tags                                 = &#123;</span><br><span class="line">          + <span class="string">&quot;Name&quot;</span> = <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      + tags_all                             = &#123;</span><br><span class="line">          + <span class="string">&quot;Name&quot;</span> = <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      + tenancy                              = (known after apply)</span><br><span class="line">      + user_data                            = (known after apply)</span><br><span class="line">      + user_data_base64                     = (known after apply)</span><br><span class="line">      + user_data_replace_on_change          = <span class="literal">false</span></span><br><span class="line">      + vpc_security_group_ids               = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line">aws_instance.web: Creating...</span><br><span class="line">aws_instance.web: Still creating... [10s elapsed]</span><br><span class="line">aws_instance.web: Provisioning with <span class="string">&#x27;local-exec&#x27;</span>...</span><br><span class="line">aws_instance.web (local-exec): Executing: [<span class="string">&quot;PowerShell&quot;</span> <span class="string">&quot;-Command&quot;</span> <span class="string">&quot;Start-Sleep -s 1000&quot;</span>]</span><br><span class="line">aws_instance.web: Still creating... [20s elapsed]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>让我们重新访问 <a target="_blank" rel="noopener" href="http://localhost:8500/ui/dc1/kv">http://localhost:8500/ui/dc1/kv</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225100309.png" alt="多了一个同名的文件夹"></p>
<p>图 1.3.2/6 - 多了一个同名的文件夹</p>
<p>这一次情况发生了变化，我们看到除了<code>localstack-aws</code>这个键之外，还多了一个同名的文件夹。让我们点击进入文件夹：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225100354.png" alt="localstack-aws 文件夹内部"></p>
<p>图 1.3.2/7 - localstack-aws 文件夹内部</p>
<p>在这里我们成功观测到了 <code>.lock</code> 和 <code>.lockinfo</code> 文件。让我们点击 <code>.lock</code> 看看：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225180803.png" alt=" 内容"></p>
<p>图 1.3.2/8 - `.lock` 内容</p>
<p>Consul UI提醒我们，该键值对目前正被锁定，而它的内容是空的。让我们查看 <code>.lockinfo</code> 的内容：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225180852.png" alt=" 内容"></p>
<p>图 1.3.2/9 - `.lockinfo` 内容</p>
<p><code>.lockinfo</code> 里记录了锁 <code>ID</code>、我们执行的操作，以及其他的一些信息。</p>
<p>让我们另起一个新的命令行窗口，在同一个工作目录下尝试另一次执行 <code>terraform apply</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ terraform apply</span><br><span class="line">Acquiring state lock. This may take a few moments...</span><br><span class="line">╷</span><br><span class="line">│ Error: Error acquiring the state lock</span><br><span class="line">│ </span><br><span class="line">│ Error message: Lock Info:</span><br><span class="line">│   ID:        11c859fd-d3e5-4eab-46d6-586b73133430</span><br><span class="line">│   Path:      localstack-aws</span><br><span class="line">│   Operation: OperationTypeApply</span><br><span class="line">│   Who:       ***</span><br><span class="line">│   Version:   1.7.3</span><br><span class="line">│   Created:   2024-02-25 02:00:21.3700184 +0000 UTC</span><br><span class="line">│   Info:      consul session: 11c859fd-d3e5-4eab-46d6-586b73133430</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">│ Terraform acquires a state lock to protect the state from being written</span><br><span class="line">│ by multiple <span class="built_in">users</span> at the same <span class="keyword">time</span>. Please resolve the issue above and try</span><br><span class="line">│ again. For most commands, you can <span class="built_in">disable</span> locking with the <span class="string">&quot;-lock=false&quot;</span></span><br><span class="line">│ flag, but this is not recommended.</span><br><span class="line">╵</span><br></pre></td></tr></table></figure>
<p>可以看到，同时另一个人试图对同一个 <code>tfstate</code> 执行变更的尝试失败了，因为它无法顺利获取到锁。</p>
<p>让我们用 <code>ctrl-c</code> 终止原先被阻塞的 <code>terraform apply</code> 的执行，然后用 <code>terraform force-unlock 11c859fd-d3e5-4eab-46d6-586b73133430</code> 解锁：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ terraform force-unlock 11c859fd-d3e5-4eab-46d6-586b73133430</span><br><span class="line">Do you really want to force-unlock?</span><br><span class="line">  Terraform will remove the lock on the remote state.</span><br><span class="line">  This will allow <span class="built_in">local</span> Terraform commands to modify this state, even though it</span><br><span class="line">  may still be <span class="keyword">in</span> use. Only <span class="string">&#x27;yes&#x27;</span> will be accepted to confirm.</span><br><span class="line"></span><br><span class="line">  Enter a value: <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">Terraform state has been successfully unlocked!</span><br><span class="line"></span><br><span class="line">The state has been unlocked, and Terraform commands should now be able to</span><br><span class="line">obtain a new lock on the remote state.</span><br></pre></td></tr></table></figure>
<p>然后重新访问 <a target="_blank" rel="noopener" href="http://localhost:8500/ui/dc1/kv">http://localhost:8500/ui/dc1/kv</a> ：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225101100.png" alt="重新访问Consul"></p>
<p>图 1.3.2/10 - 重新访问Consul</p>
<p>可以看到，包含锁的文件夹消失了。</p>
<h2 id="1-3-2-1-7-Backend-配置的动态赋值"><a href="#backend-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC"></a>1.3.2.1.7. Backend 配置的动态赋值</h2>
<p>有些读者会注意到，到目前为止我所写的代码里的配置项基本都是硬编码的，Terraform 是否支持运行时用变量动态赋值？答案是支持的，Terraform 可以通过 <code>variable</code> 变量来传值给 <code>provider</code>、<code>data</code> 和 <code>resource</code>。</p>
<p>但有一些例外，其中就有 <code>backend</code> 配置。<code>backend</code> 配置只允许硬编码，或者不传值。</p>
<p>这个问题是因为 Terraform 运行时本身设计的运行顺序导致的，一直到 2019 年 05 月官方才给出了解决方案，那就是“部分配置“(partial configuration)。</p>
<p>简单来说就是我们可以在 Terraform 代码的 <code>backend</code> 声明中不给出具体的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backend &quot;consul&quot; &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在另一个独立的文件中给出相关配置，例如我们在工作目录下创建一个名为 <code>backend.hcl</code> 的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address = &quot;localhost:8500&quot;</span><br><span class="line">scheme  = &quot;http&quot;</span><br><span class="line">path    = &quot;localstack-aws&quot;</span><br></pre></td></tr></table></figure>
<p>本质上我们就是把原本属于 <code>backend consul</code> 块的属性赋值代码搬迁到一个独立的 hcl 文件内，然后我们执行 <code>terraform init</code> 时附加 <code>backend-config</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ terraform init -backend-config=backend.hcl</span><br></pre></td></tr></table></figure>
<p>这样也可以初始化成功。通过这种打补丁的方式，我们可以复用他人预先写好的 Terraform 代码，在执行时把属于我们自己的 Backend 配置信息以独立的 <code>backend-config</code> 文件的形式传入来进行初始化。</p>
<h2 id="1-3-2-1-8-Backend-的权限控制以及版本控制"><a href="#backend-%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"></a>1.3.2.1.8. Backend 的权限控制以及版本控制</h2>
<p>Backend 本身并没有设计任何的权限以及版本控制，这方面完全依赖于具体的 Backend 实现。以 AWS S3 为例，我们可以针对不同的 Bucket 设置不同的 IAM，用以防止开发测试人员直接操作生产环境，或是给予部分人员对状态信息的只读权限；另外我们也可以开启 S3 的版本控制功能，以防我们错误修改了状态文件(Terraform 命令行有修改状态的相关指令)。</p>
<h2 id="1-3-2-1-9-状态的隔离存储"><a href="#%E7%8A%B6%E6%80%81%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AD%98%E5%82%A8"></a>1.3.2.1.9. 状态的隔离存储</h2>
<p>我们讲完 Backend，现在要讨论另一个问题。假设我们的 Terraform 代码可以创建一个通用的基础设施，比如说是云端的一个 EKS、AKS 集群，或者是一个基于 S3 的静态网站，那么我们可能要为很多团队创建并维护这些相似但要彼此隔离的 Stack，又或者我们要为部署的应用维护开发、测试、预发布、生产四套不同的部署。那么该如何做到不同的部署，彼此状态文件隔离存储和管理呢？</p>
<p>一种简单的方法就是分成不同的文件夹存储。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-17/1605571444613-image.png" alt="将代码复制到不同的文件夹中保存"></p>
<p>图 1.3.2/11 - 将代码复制到不同的文件夹中保存</p>
<p>我们可以把不同产品不同部门使用的基础设施分成不同的文件夹，在文件夹内维护相同的代码文件，配置不同的 <code>backend-config</code>，把状态文件保存到不同的 Backend 上。这种方法可以给予最大程度的隔离，缺点是我们需要拷贝许多份相同的代码。</p>
<p>第二种更加轻量级的方法就是 Workspace。注意，Terraform 开源版的 Workspace 与 Terraform Cloud 云服务的 Workspace 实际上是两个不同的概念，我们这里介绍的是开源版的 Workspace。</p>
<p>Workspace 允许我们在同一个文件夹内，使用同样的 Backend 配置，但可以维护任意多个彼此隔离的状态文件。还是我们刚才那个使用测试 Consul 服务作为 Backend 的例子：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225174932.png" alt="重新访问 Consul，目前有一个键"></p>
<p>图 1.3.2/12 - 重新访问 Consul，目前有一个键</p>
<p>当前我们有一个状态文件，名字是 <code>localstack-aws</code>。然后我们在工作目录下执行这样的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace new feature1</span><br><span class="line">Created and switched to workspace <span class="string">&quot;feature1&quot;</span>!</span><br><span class="line"></span><br><span class="line">You<span class="string">&#x27;re now on a new, empty workspace. Workspaces isolate their state,</span></span><br><span class="line"><span class="string">so if you run &quot;terraform plan&quot; Terraform will not see any existing state</span></span><br><span class="line"><span class="string">for this configuration.</span></span><br></pre></td></tr></table></figure>
<p>通过调用 <code>workspace</code> 命令，我们成功创建了名为 <code>feature1</code> 的 Workspace。这时我们观察 <code>.terraform</code> 文件夹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">├── environment</span><br><span class="line">├── providers</span><br><span class="line">│        └── registry.terraform.io</span><br><span class="line">│             └── hashicorp</span><br><span class="line">│                 └── aws</span><br><span class="line">│                     └── 5.38.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>我们会发现多了一个 <code>environment</code> 文件，它的内容是 <code>feature1</code>。这实际上就是 Terraform 用来保存当前上下文环境使用的是哪个 Workspace 的文件。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225175538.png" alt="Consul 中多了一个 "></p>
<p>图 1.3.2/13 - Consul 中多了一个 `localstack-aws-env:feature1`</p>
<p>重新观察 Consul 存储会发现多了一个文件：<code>localstack-aws-env:feature1</code>。这就是 Terraform 为 <code>feature1</code> 这个 Workspace 创建的独立的状态文件。让我们执行一下 apply，然后再看这个文件的内容：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225175806.png" alt="此时  的内容"></p>
<p>图 1.3.2/14 - 此时 `localstack-aws-env:feature1` 的内容</p>
<p>可以看到，状态被成功写入了 <code>feature1</code> 的状态文件。</p>
<p>我们可以通过以下命令来查询当前 Backend 下所有的 Workspace：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace list</span><br><span class="line">  default</span><br><span class="line">* feature1</span><br></pre></td></tr></table></figure>
<p>我们有 <code>default</code> 和 <code>feature1</code> 两个 Workspace，当前我们工作在 <code>feature1</code> 上。我们可以用以下命令切换回 <code>default</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace <span class="keyword">select</span> default</span><br><span class="line">Switched to workspace <span class="string">&quot;default&quot;</span>.</span><br></pre></td></tr></table></figure>
<p>我们可以用以下命令确认我们成功切换回了 <code>default</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace show</span><br><span class="line">default</span><br></pre></td></tr></table></figure>
<p>我们可以用以下命令删除 <code>feature1</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace delete feature1</span><br><span class="line">╷</span><br><span class="line">│ Error: Workspace is not empty</span><br><span class="line">│</span><br><span class="line">│ Workspace <span class="string">&quot;feature1&quot;</span> is currently tracking the following resource instances:</span><br><span class="line">│   - aws_instance.web</span><br><span class="line">│</span><br><span class="line">│ Deleting this workspace would cause Terraform to lose track of any associated remote objects, <span class="built_in">which</span> would <span class="keyword">then</span> require you to    </span><br><span class="line">│ delete them manually outside of Terraform. You should destroy these objects with Terraform before deleting the workspace.        </span><br><span class="line">│</span><br><span class="line">│ If you want to delete this workspace anyway, and have Terraform forget about these managed objects, use the -force option to     </span><br><span class="line">│ <span class="built_in">disable</span> this safety check.</span><br><span class="line">╵</span><br></pre></td></tr></table></figure>
<p>Terraform 发现 <code>feature1</code> 还有资源没有被销毁，所以它拒绝了我们的删除请求。因为我们目前是使用 LocalStack 模拟的例子，所以不会有资源泄漏的问题，我们可以用以下命令强制删除 <code>feature1</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ terraform workspace delete -force feature1</span><br><span class="line">Deleted workspace <span class="string">&quot;feature1&quot;</span>!</span><br><span class="line">WARNING: <span class="string">&quot;feature1&quot;</span> was non-empty.</span><br><span class="line">The resources managed by the deleted workspace may still exist,</span><br><span class="line">but are no longer manageable by Terraform since the state has</span><br><span class="line">been deleted.</span><br></pre></td></tr></table></figure>
<p>再观察 Consul 存储，就会发现 <code>feature1</code> 的状态文件被删除了：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/20240225180126.png" alt=" 被删除了"></p>
<p>图 1.3.2/15 - `localstack-aws-env:feature1` 被删除了</p>
<p>目前支持多工作区的 Backend 有：</p>
<ul>
<li>AzureRM</li>
<li>Consulf</li>
<li>COS</li>
<li>GCS</li>
<li>Kubernetes</li>
<li>Local</li>
<li>OSS</li>
<li>Postgres</li>
<li>Remote</li>
<li>S3</li>
</ul>
<h2 id="1-3-2-1-10-该使用哪种隔离"><a href="#%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9A%94%E7%A6%BB"></a>1.3.2.1.10. 该使用哪种隔离</h2>
<p>相比起多文件夹隔离的方式来说，基于 Workspace 的隔离更加简单，只需要保存一份代码，在代码中不需要为 Workspace 编写额外代码，用命令行就可以在不同工作区之间来回切换。</p>
<p>但是 Workspace 的缺点也同样明显，由于所有工作区的 Backend 配置是一样的，所以有权读写某一个 Workspace 的人可以读取同一个 Backend 路径下所有其他 Workspace；另外 Workspace 是隐式配置的(调用命令行)，所以有时人们会忘记自己工作在哪个 Workspace 下。</p>
<p>Terraform 官方为 Workspace 设计的场景是：有时开发人员想要对既有的基础设施做一些变更，并进行一些测试，但又不想直接冒险修改既有的环境。这时他可以利用 Workspace 复制出一个与既有环境完全一致的平行环境，在这个平行环境里做一些变更，并进行测试和实验工作。</p>
<p>Workspace 对应的源代码管理模型里的主干——分支模型，如果团队希望维护的是不同产品之间不同的基础设施，或是开发、测试、预发布、生产环境，那么最好还是使用不同的文件夹以及不同的 <code>backend-config</code> 进行管理。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2023/01/18/Teraform/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2023/01/17/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider%20copy/"
                            aria-label=": Terraform 基础概念-Provider"
                        >
                            Terraform 基础概念-Provider
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-17T17:43:45+08:00">
	
		    2023 年 1 月 17 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/devops/">devops</a>, <a class="category-link" href="../../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"><strong>1.3.1.1.</strong> Terraform 基础概念 —— Provider</a></p>
</li>
<li>
<p><a href="#%E4%B8%8B%E8%BD%BD-provider"><strong>1.3.1.1.1.</strong> 下载 Provider</a></p>
</li>
<li>
<p><a href="#%E6%90%9C%E7%B4%A2-provider"><strong>1.3.1.1.2.</strong> 搜索 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><strong>1.3.1.1.3.</strong> Provider 的声明</a></p>
</li>
<li>
<p><a href="#%E5%86%85%E5%BB%BA-provider"><strong>1.3.1.1.4.</strong> 内建 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.5.</strong> Provider 的配置</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><strong>1.3.1.1.6.</strong> 多 Provider 实例</a></p>
</li>
<li>
<p><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.1.</strong> 默认 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.2.</strong> 引用备用 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.3.</strong> 选择备用 Provider 配置</a></p>
</li>
</ul>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a></p>
<h2 id="1-3-1-1-Terraform-基础概念-——-Provider"><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a>1.3.1.1. Terraform 基础概念 —— Provider</h2>
<p>Terraform 被设计成一个多云基础设施编排工具，不像 CloudFormation 那样绑定 AWS 平台，Terraform 可以同时编排各种云平台或是其他基础设施的资源。Terraform 实现多云编排的方法就是 Provider 插件机制。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605496195438-image.png" alt="Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源"></p>
<p>图 1.3.1/1 - Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源</p>
<p>Terraform 使用的是 HashiCorp 自研的 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/go-plugin"><code>go-plugin</code> 库</a>)，本质上各个 Provider 插件都是独立的进程，与 Terraform 进程之间通过 Rpc 进行调用。Terraform 引擎首先读取并分析用户编写的 Terraform 代码，形成一个由 <code>data</code> 与 <code>resource</code> 组成的图(Graph)，再通过 Rpc 调用这些 <code>data</code> 与 <code>resource</code> 所对应的 Provider 插件；Provider 插件的编写者根据 Terraform 所制定的插件框架来定义各种 <code>data</code> 和 <code>resource</code>，并实现相应的 CRUD 方法；在实现这些 CRUD 方法时，可以调用目标平台提供的 SDK，或是直接通过调用 Http(s) API来操作目标平台。</p>
<h2 id="1-3-1-1-1-下载-Provider"><a href="#%E4%B8%8B%E8%BD%BD-provider"></a>1.3.1.1.1. 下载 Provider</h2>
<p>我们在第一章的小例子中，写完代码后在 <code>apply</code> 之前，首先我们执行了一次<code>terraform init</code>。<code>terraform init</code>会分析代码中所使用到的 Provider，并尝试下载 Provider 插件到本地。如果我们观察执行完第一章例子的文件夹，我们会发现有一个 <code>.terraform</code> 文件夹，我们所使用的 AWS Provider 插件就被下载安装在里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.terraform</span><br><span class="line">└── providers</span><br><span class="line">    └── registry.terraform.io</span><br><span class="line">        └── hashicorp</span><br><span class="line">            └── aws</span><br><span class="line">                └── 5.37.0</span><br><span class="line">                    └── windows_amd64</span><br><span class="line">                        └── terraform-provider-aws_v5.37.0_x5.exe</span><br></pre></td></tr></table></figure>
<p>有的时候下载某些 Provider 会非常缓慢，或是在开发环境中存在许多的 Terraform 项目，每个项目都保有自己独立的插件文件夹非常浪费磁盘，这时我们可以使用插件缓存。</p>
<p>有两种方式可以启用插件缓存：</p>
<p><strong>第一种方法</strong>是配置 <code>TF_PLUGIN_CACHE_DIR</code> 这个环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TF_PLUGIN_CACHE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.terraform.d/plugin-cache&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种方法</strong>是使用 CLI 配置文件。Windows 下是在相关用户的 <code>%APPDATA%</code> 目录下创建名为 <code>&quot;terraform.rc&quot;</code> 的文件，Macos 和 Linux 用户则是在用户的 <code>home</code> 下创建名为 <code>&quot;.terraformrc&quot;</code> 的文件。在文件中配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin_cache_dir = &quot;$HOME/.terraform.d/plugin-cache&quot;</span><br></pre></td></tr></table></figure>
<p>当启用插件缓存之后，每当执行 <code>terraform init</code> 命令时，Terraform 引擎会首先检查期望使用的插件在缓存文件夹中是否已经存在，如果存在，那么就会将缓存的插件拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。如果插件不存在，那么 Terraform 仍然会像之前那样下载插件，并首先保存在插件文件夹中，随后再从插件文件夹拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。为了尽量避免同一份插件被保存多次，只要操作系统提供支持，Terraform 就会使用符号连接而不是实际从插件缓存目录拷贝到工作目录。</p>
<p><strong>需要特别注意的是，Windows 系统下 <code>plugin_cache_dir</code> 的路径也必须使用 <code>/</code> 作为分隔符，应使用 <code>C:/somefolder/plugin_cahce</code> 而不是 <code>C:\somefolder\plugin_cache</code></strong></p>
<p>Terraform 引擎永远不会主动删除缓存文件夹中的插件，缓存文件夹的尺寸可能会随着时间而增长到非常大，这时需要手工清理。</p>
<h2 id="1-3-1-1-2-搜索-Provider"><a href="#%E6%90%9C%E7%B4%A2-provider"></a>1.3.1.1.2. 搜索 Provider</h2>
<p>想要了解有哪些被官方接纳的 Provider，就是前往<a target="_blank" rel="noopener" href="https://registry.terraform.io/browse/providers">registry.terraform.io</a>进行搜索：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-19/1605799350775-image.png" alt="registry.terraform.io上的插件页面"></p>
<p>图 1.3.1/2 - registry.terraform.io上的插件页面</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605498907942-image.png" alt="registry.terraform.io的搜索页面"></p>
<p>图 1.3.1/3 - registry.terraform.io的搜索页面</p>
<p>一般来说，相关 Provider 如何声明，以及相关 <code>data</code>、<code>resource</code> 的使用说明，都可以在 registry 上查阅到相关文档。</p>
<p><a target="_blank" rel="noopener" href="https://registry.terraform.io/"><code>registry.terraform.io</code></a> 不但可以查询 Provider，也可以用来发布 Provider；并且它也可以用来查询和发布模块(Module)，不过模块将是我们后续篇章讨论的话题。</p>
<h2 id="1-3-1-1-3-Provider-的声明"><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"></a>1.3.1.1.3. Provider 的声明</h2>
<p>一组 Terraform 代码要被执行，相关的 Provider 必须在代码中被声明。不少的 Provider 在声明时需要传入一些关键信息才能被使用，例如我们在第一章的例子中，必须给出访问密钥以及期望执行的 AWS 区域（Region）信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段 Provider 声明中，首先在 <code>terraform</code> 块的 <code>required_providers</code> 里声明了本段代码必须要名为 <code>aws</code> 的 Provider 才可以执行，<code>source = &quot;hashicorp/aws&quot;</code>这一行声明了 <code>aws</code> 这个插件的源地址(Source Address)。一个源地址是全球唯一的，它指示了 Terraform 如何下载该插件。一个源地址由三部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;HOSTNAME&gt;/]&lt;NAMESPACE&gt;/&lt;TYPE&gt;</span><br></pre></td></tr></table></figure>
<p><code>Hostname</code> 是选填的，默认是官方的 <code>registry.terraform.io</code>，读者也可以构建自己私有的Terraform仓库。<code>Namespace</code> 是在 Terraform 仓库内注册的组织名，这代表了发布和维护插件的组织或是个人。<code>Type</code> 是代表插件的一个短名，在特定的 <code>HostName</code>/<code>Namespace</code> 下 <code>Type</code> 必须唯一。</p>
<p><code>required_providers</code> 中的插件声明还声明了该源码所需要的插件的版本约束，在例子里就是 <code>version = &quot;~&gt;5.0&quot;</code>。Terraform 插件的版本号采用 <code>MAJOR.MINOR.PATCH</code> 的语义化格式，版本约束通常使用操作符和版本号表达约束条件，条件之间可以用逗号拼接，表达 <code>AND</code> 关联，例如 <code>&quot;&gt;= 1.2.0, &lt; 2.0.0&quot;</code>。可以采用的操作符有：</p>
<ul>
<li><code>=</code>(或者不加 <code>=</code>，直接使用版本号)：只允许特定版本号，不允许与其他条件合并使用</li>
<li><code>!=</code>：不允许特定版本号</li>
<li><code>\&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>：与特定版本号进行比较，可以是大于、大于等于、小于、小于等于</li>
<li><code>~&gt;</code>：只允许 <em>最右边</em> 的版本号增加。这种格式被称为 <em>悲观约束</em> 操作符。例如，要允许在特定的 <code>MINOR</code> 版本中允许新的 <code>PATCH</code> 版本：
<ul>
<li><code>~&gt; 1.0.4</code>：允许 Terraform 安装 <code>1.0.5</code> 和 <code>1.0.10</code>，但不允许 <code>1.1.0</code>。</li>
<li><code>~&gt; 1.1</code>：允许 Terraform 安装 <code>1.2</code> 和 <code>1.10</code>，但不允许 <code>2.0</code>。</li>
</ul>
</li>
</ul>
<p>Terraform 会检查当前工作环境或是插件缓存中是否存在满足版本约束的插件，如果不存在，那么 Terraform 会尝试下载。如果 Terraform 无法获得任何满足版本约束条件的插件，那么它会拒绝继续执行任何后续操作。</p>
<p>可以用添加后缀的方式来声明预览版，例如：<code>1.2.0-beta</code>。预览版只能通过 <code>&quot;=&quot;</code> 操作符(或是忽略操作符)后接明确的版本号的方式来指定，不可以与<code>&gt;=</code>、<code>~&gt;</code>等搭配使用。</p>
<ul>
<li>当依赖第三方模块时，需要指定特定版本，以确保只在您需要的时候进行更新。</li>
<li>对于在您的组织内维护的模块，如果一致使用语义版本控制，或者有一个定义良好的发布流程可以避免不必要的更新，那么指定版本范围可能是合适的。</li>
<li>可重用的模块应仅限制其 Terraform 和 Provider 的最低允许版本，例如 <code>&gt;= 0.12.0</code>。这有助于避免已知的不兼容性，同时允许模块的用户在不改变模块的情况下升级到 Terraform 的新版本。</li>
<li>根模块应使用 <code>~&gt;</code> 约束为它们依赖的每个 Provider 设置一个下限和上限版本。</li>
</ul>
<p>以上建议来自于 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/expressions/version-constraints#best-practices">HashiCorp 官方文档</a>，笔者个人给出一条个人建议：</p>
<ul>
<li>可复用的模块不但应该限制 Provider 的最低版本，同时也应该限制 Provider 的 <code>MAJOR</code> 版本。例如，<code>&gt;= 1.5.0, &lt; 2.0</code>。这样可以避免在 Provider 的 <code>MAJOR</code> 版本升级时，因为不兼容性导致的问题，Provider 的 <code>MAJOR</code> 版本升级通常会伴随着不兼容的改动，不应该在未加测试的情况下轻易升级。</li>
</ul>
<h2 id="1-3-1-1-4-内建-Provider"><a href="#%E5%86%85%E5%BB%BA-provider"></a>1.3.1.1.4. 内建 Provider</h2>
<p>绝大多数 Provider 是以插件形式单独分发的，但是目前有一个 Provider 是内建于Terraform主进程中的，那就是 <code>terraform_remote_state</code> data source。该 Provider 由于是内建的，所以使用时不需要在 <code>terraform</code> 中声明 <code>required_providers</code>。这个内建Provider的源地址是 <code>terraform.io/builtin/terraform</code>。这个地址有时可能出现在 Terraform 的错误消息和其他输出中，以便无歧义地引用内建 Provider，而不是假设的第三方提供者，其类型名称为 “terraform”。</p>
<p>还存在一个源地址为 <code>hashicorp/terraform</code> 的 Provider，这是现在内置 Provider 的旧版本，被 Terraform 的旧版本使用。<code>hashicorp/terraform</code> 与 Terraform v0.11 或更高版本不兼容，因此永远不应在 <code>required_providers</code> 块中声明。</p>
<h2 id="1-3-1-1-5-Provider-的配置"><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"></a>1.3.1.1.5. Provider 的配置</h2>
<p>Provider 的配置是声明在根模块中的一组 Terraform 配置。（子模块接收来自于根模块的 Provider 配置，更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider">模块的 <code>provider</code> 元参数</a>）</p>
<p>一个 Provider 配置是通过 <code>provider</code> 块来创建的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;google&quot; &#123;</span><br><span class="line">  project = &quot;acme-app&quot;</span><br><span class="line">  region  = &quot;us-central1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块头部设置的名称（例子中的 <code>&quot;google&quot;</code>）就是要配置的 Provider 的<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/providers/requirements#local-names">Local Name</a>。这个 Provider 必须已在 <code>required_providers</code> 块中声明。</p>
<p>块体（<code>&#123;</code> 和 <code>&#125;</code> 中间的内容）包含了 Provider 的配置参数。这些参数大多数是由 Provider 自己定义的；在这个例子中，<code>project</code> 和 <code>region</code> 都是 <code>google</code> Provider 特有的。</p>
<p>你可以在这些配置的值当中使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/8.%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，但是只能引用在配置 Provider 时已知的值。这意味着你可以安全地引用输入变量，但是不能引用从 <code>resource</code> 返回的属性（一个例外是直接在配置中硬编码的 <code>resource</code> 参数）。</p>
<p>一个 Provider 的文档应该列出它所需要的配置参数。对那些注册在 <a target="_blank" rel="noopener" href="https://registry.terraform.io/">Terraform Registry</a> 上的 Provider 来说，每个 Provider 的页面上都有版本化的文档，可以通过 Provider 页头的 “Documentation” 链接访问。</p>
<p>一些 Provider 可以使用环境变量（或是其他替代配置源，例如 AWS 的虚拟机实例 Profile）作为某些配置参数的值；我们建议尽可能使用这种方式来避免将凭证保存于版本控制的 Terraform 代码中。</p>
<p>There are also two “meta-arguments” that are defined by Terraform itself and available for all <code>provider</code> blocks:</p>
<p>有两个由 Terraform 自身定义的“元参数”，对所有 <code>provider</code> 块都可用：</p>
<ul>
<li><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><code>alias</code>，用以为不同的 <code>resource</code> 块配置参数不同的同类 Provider 实例</a></li>
<li><code>version</code>， 废弃，不推荐使用，现在请使用 <a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><code>required_providers</code></a></li>
</ul>
<p>与 Terraform 语言中的许多其他对象不同，如果 <code>provider</code> 块的内容为空，则可以省略该块。Terraform 假定未显式配置的任何 Provider 程序都具有空的默认配置。</p>
<h2 id="1-3-1-1-6-多-Provider-实例"><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"></a>1.3.1.1.6. 多 Provider 实例</h2>
<p><code>provider</code> 块声明了 <code>aws</code> 这个 Provider 所需要的各项配置。在上文的代码示例中，<code>provider &quot;aws&quot;</code>和<code>required_providers</code>中<code>aws = &#123;...&#125;</code>块里的<code>aws</code>，都是 Provider 的 Local Name，一个 Local Name 是在一个模块中对一个 Provider 的唯一的标识。</p>
<p>你可以选择为同一个 Provider 定义多个配置，并且可以根据每个资源或每个模块来选择使用哪一个。这主要是为了支持云平台的多个区域；其他例子包括针对多个 Docker 主机，多个 Consul 主机等。</p>
<p>要为某一个 Provider 创建多个配置，包括具有相同提供者名称的多个 <code>provider</code> 块。对于每个额外的非默认配置，使用 <code>alias</code> 元参数提供额外的名称段。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># The default provider configuration; resources that begin with `aws_` will use</span><br><span class="line"># it as the default, and it can be referenced as `aws`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Additional provider configuration for west coast region; resources can</span><br><span class="line"># reference this as `aws.west`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;west&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模块内声明配置 <code>alias</code> 以从父模块接收备用的 <code>provider</code> 配置，需要在该 <code>provider</code> 的 <code>required_providers</code> 条目中添加 <code>configuration_aliases</code> 参数。以下示例在包含的模块中声明了 <code>mycloud</code> 和 <code>mycloud.alternate</code> 的 <code>provider</code> 配置名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    mycloud = &#123;</span><br><span class="line">      source  = &quot;mycorp/mycloud&quot;</span><br><span class="line">      version = &quot;~&gt; 1.0&quot;</span><br><span class="line">      configuration_aliases = [ mycloud.alternate ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1-1-6-1-默认-Provider-配置"><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.1. 默认 Provider 配置</h3>
<p>没有 <code>alias</code> 参数的 <code>provider</code> 块是该 provider 的 <em>默认</em> 配置。未设置 <code>provider</code> 元参数的资源将使用与资源类型名称的第一个单词匹配的默认 provider 配置。（例如，除非另有说明，否则 <code>aws_instance</code> 资源将使用默认的 <code>aws</code> provider 配置。）</p>
<p>如果 provider 的每个显式配置都有别名，Terraform 将使用隐含的空配置作为该 provider 的默认配置。（如果 provider 有任何必需的配置参数，当资源默认使用空配置时，Terraform 将引发错误。）</p>
<h3 id="1-3-1-1-6-2-引用备用-Provider-配置"><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.2. 引用备用 Provider 配置</h3>
<p>当 Terraform 需要 provider 配置的名称时，它期望的是 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 形式的引用。在上面的例子中，<code>aws.west</code> 将引用 <code>us-west-2</code> 区域的 provider。</p>
<p>这些引用是特殊的表达式。像对其他命名实体（例如 <code>var.image_id</code>）的引用一样，它们不是字符串，不需要引号。但是它们只在 <code>resource</code>、<code>data</code> 和 <code>module</code> 块的特定元参数中有效，不能在任意表达式中使用。</p>
<h3 id="1-3-1-1-6-3-选择备用-Provider-配置"><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.3. 选择备用 Provider 配置</h3>
<p>默认情况下，资源使用从资源类型名称的第一个单词推断出的默认 provider 配置（没有 <code>alias</code> 参数的配置）。</p>
<p>要为资源或数据源指定备用 provider 配置，将其 <code>provider</code> 元参数设置为 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;foo&quot; &#123;</span><br><span class="line">  provider = aws.west</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要为子模块指定备用 provider 配置，使用其 <code>providers</code> 元参数指定应将哪些 provider 配置映射到模块内的哪些本地 provider 名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module &quot;aws_vpc&quot; &#123;</span><br><span class="line">  source = &quot;./aws_vpc&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws = aws.west</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在传递 provider 时，模块有一些特殊要求；有关更多详细信息，请参见 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html#module-providers">模块 <code>providers</code> 元参数</a>。在大多数情况下，只有 <em>根模块</em> 应定义 provider 配置，所有子模块都应从其父模块获取其 provider 配置。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2023/01/17/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider%20copy/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2023/01/17/Teraform/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider/"
                            aria-label=": Terraform 基础概念-Provider"
                        >
                            Terraform 基础概念-Provider
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-01-17T17:43:45+08:00">
	
		    2023 年 1 月 17 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/devops/">devops</a>, <a class="category-link" href="../../../../categories/devops/Terraform/">Terraform</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"><strong>1.3.1.1.</strong> Terraform 基础概念 —— Provider</a></p>
</li>
<li>
<p><a href="#%E4%B8%8B%E8%BD%BD-provider"><strong>1.3.1.1.1.</strong> 下载 Provider</a></p>
</li>
<li>
<p><a href="#%E6%90%9C%E7%B4%A2-provider"><strong>1.3.1.1.2.</strong> 搜索 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><strong>1.3.1.1.3.</strong> Provider 的声明</a></p>
</li>
<li>
<p><a href="#%E5%86%85%E5%BB%BA-provider"><strong>1.3.1.1.4.</strong> 内建 Provider</a></p>
</li>
<li>
<p><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.5.</strong> Provider 的配置</a></p>
</li>
<li>
<p><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><strong>1.3.1.1.6.</strong> 多 Provider 实例</a></p>
</li>
<li>
<p><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.1.</strong> 默认 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.2.</strong> 引用备用 Provider 配置</a></p>
</li>
<li>
<p><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"><strong>1.3.1.1.6.3.</strong> 选择备用 Provider 配置</a></p>
</li>
</ul>
<p><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a></p>
<h2 id="1-3-1-1-Terraform-基础概念-——-Provider"><a href="#terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E2%80%94%E2%80%94-provider"></a>1.3.1.1. Terraform 基础概念 —— Provider</h2>
<p>Terraform 被设计成一个多云基础设施编排工具，不像 CloudFormation 那样绑定 AWS 平台，Terraform 可以同时编排各种云平台或是其他基础设施的资源。Terraform 实现多云编排的方法就是 Provider 插件机制。</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605496195438-image.png" alt="Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源"></p>
<p>图 1.3.1/1 - Terraform通过RPC调用插件，插件代码通过调用SDK操作远程资源</p>
<p>Terraform 使用的是 HashiCorp 自研的 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/go-plugin"><code>go-plugin</code> 库</a>)，本质上各个 Provider 插件都是独立的进程，与 Terraform 进程之间通过 Rpc 进行调用。Terraform 引擎首先读取并分析用户编写的 Terraform 代码，形成一个由 <code>data</code> 与 <code>resource</code> 组成的图(Graph)，再通过 Rpc 调用这些 <code>data</code> 与 <code>resource</code> 所对应的 Provider 插件；Provider 插件的编写者根据 Terraform 所制定的插件框架来定义各种 <code>data</code> 和 <code>resource</code>，并实现相应的 CRUD 方法；在实现这些 CRUD 方法时，可以调用目标平台提供的 SDK，或是直接通过调用 Http(s) API来操作目标平台。</p>
<h2 id="1-3-1-1-1-下载-Provider"><a href="#%E4%B8%8B%E8%BD%BD-provider"></a>1.3.1.1.1. 下载 Provider</h2>
<p>我们在第一章的小例子中，写完代码后在 <code>apply</code> 之前，首先我们执行了一次<code>terraform init</code>。<code>terraform init</code>会分析代码中所使用到的 Provider，并尝试下载 Provider 插件到本地。如果我们观察执行完第一章例子的文件夹，我们会发现有一个 <code>.terraform</code> 文件夹，我们所使用的 AWS Provider 插件就被下载安装在里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.terraform</span><br><span class="line">└── providers</span><br><span class="line">    └── registry.terraform.io</span><br><span class="line">        └── hashicorp</span><br><span class="line">            └── aws</span><br><span class="line">                └── 5.37.0</span><br><span class="line">                    └── windows_amd64</span><br><span class="line">                        └── terraform-provider-aws_v5.37.0_x5.exe</span><br></pre></td></tr></table></figure>
<p>有的时候下载某些 Provider 会非常缓慢，或是在开发环境中存在许多的 Terraform 项目，每个项目都保有自己独立的插件文件夹非常浪费磁盘，这时我们可以使用插件缓存。</p>
<p>有两种方式可以启用插件缓存：</p>
<p><strong>第一种方法</strong>是配置 <code>TF_PLUGIN_CACHE_DIR</code> 这个环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TF_PLUGIN_CACHE_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.terraform.d/plugin-cache&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种方法</strong>是使用 CLI 配置文件。Windows 下是在相关用户的 <code>%APPDATA%</code> 目录下创建名为 <code>&quot;terraform.rc&quot;</code> 的文件，Macos 和 Linux 用户则是在用户的 <code>home</code> 下创建名为 <code>&quot;.terraformrc&quot;</code> 的文件。在文件中配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin_cache_dir = &quot;$HOME/.terraform.d/plugin-cache&quot;</span><br></pre></td></tr></table></figure>
<p>当启用插件缓存之后，每当执行 <code>terraform init</code> 命令时，Terraform 引擎会首先检查期望使用的插件在缓存文件夹中是否已经存在，如果存在，那么就会将缓存的插件拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。如果插件不存在，那么 Terraform 仍然会像之前那样下载插件，并首先保存在插件文件夹中，随后再从插件文件夹拷贝到当前工作目录下的 <code>.terraform</code> 文件夹内。为了尽量避免同一份插件被保存多次，只要操作系统提供支持，Terraform 就会使用符号连接而不是实际从插件缓存目录拷贝到工作目录。</p>
<p><strong>需要特别注意的是，Windows 系统下 <code>plugin_cache_dir</code> 的路径也必须使用 <code>/</code> 作为分隔符，应使用 <code>C:/somefolder/plugin_cahce</code> 而不是 <code>C:\somefolder\plugin_cache</code></strong></p>
<p>Terraform 引擎永远不会主动删除缓存文件夹中的插件，缓存文件夹的尺寸可能会随着时间而增长到非常大，这时需要手工清理。</p>
<h2 id="1-3-1-1-2-搜索-Provider"><a href="#%E6%90%9C%E7%B4%A2-provider"></a>1.3.1.1.2. 搜索 Provider</h2>
<p>想要了解有哪些被官方接纳的 Provider，就是前往<a target="_blank" rel="noopener" href="https://registry.terraform.io/browse/providers">registry.terraform.io</a>进行搜索：</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-19/1605799350775-image.png" alt="registry.terraform.io上的插件页面"></p>
<p>图 1.3.1/2 - registry.terraform.io上的插件页面</p>
<p><img src="https://raw.githubusercontent.com/lonegunmanb/introduction-to-terraform-pic/master/2020-11-16/1605498907942-image.png" alt="registry.terraform.io的搜索页面"></p>
<p>图 1.3.1/3 - registry.terraform.io的搜索页面</p>
<p>一般来说，相关 Provider 如何声明，以及相关 <code>data</code>、<code>resource</code> 的使用说明，都可以在 registry 上查阅到相关文档。</p>
<p><a target="_blank" rel="noopener" href="https://registry.terraform.io/"><code>registry.terraform.io</code></a> 不但可以查询 Provider，也可以用来发布 Provider；并且它也可以用来查询和发布模块(Module)，不过模块将是我们后续篇章讨论的话题。</p>
<h2 id="1-3-1-1-3-Provider-的声明"><a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"></a>1.3.1.1.3. Provider 的声明</h2>
<p>一组 Terraform 代码要被执行，相关的 Provider 必须在代码中被声明。不少的 Provider 在声明时需要传入一些关键信息才能被使用，例如我们在第一章的例子中，必须给出访问密钥以及期望执行的 AWS 区域（Region）信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt;5.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  access_key                  = &quot;test&quot;</span><br><span class="line">  secret_key                  = &quot;test&quot;</span><br><span class="line">  region                      = &quot;us-east-1&quot;</span><br><span class="line">  s3_use_path_style           = false</span><br><span class="line">  skip_credentials_validation = true</span><br><span class="line">  skip_metadata_api_check     = true</span><br><span class="line">  skip_requesting_account_id  = true</span><br><span class="line"></span><br><span class="line">  endpoints &#123;</span><br><span class="line">    apigateway     = &quot;http://localhost:4566&quot;</span><br><span class="line">    apigatewayv2   = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudformation = &quot;http://localhost:4566&quot;</span><br><span class="line">    cloudwatch     = &quot;http://localhost:4566&quot;</span><br><span class="line">    dynamodb       = &quot;http://localhost:4566&quot;</span><br><span class="line">    ec2            = &quot;http://localhost:4566&quot;</span><br><span class="line">    es             = &quot;http://localhost:4566&quot;</span><br><span class="line">    elasticache    = &quot;http://localhost:4566&quot;</span><br><span class="line">    firehose       = &quot;http://localhost:4566&quot;</span><br><span class="line">    iam            = &quot;http://localhost:4566&quot;</span><br><span class="line">    kinesis        = &quot;http://localhost:4566&quot;</span><br><span class="line">    lambda         = &quot;http://localhost:4566&quot;</span><br><span class="line">    rds            = &quot;http://localhost:4566&quot;</span><br><span class="line">    redshift       = &quot;http://localhost:4566&quot;</span><br><span class="line">    route53        = &quot;http://localhost:4566&quot;</span><br><span class="line">    s3             = &quot;http://s3.localhost.localstack.cloud:4566&quot;</span><br><span class="line">    secretsmanager = &quot;http://localhost:4566&quot;</span><br><span class="line">    ses            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sns            = &quot;http://localhost:4566&quot;</span><br><span class="line">    sqs            = &quot;http://localhost:4566&quot;</span><br><span class="line">    ssm            = &quot;http://localhost:4566&quot;</span><br><span class="line">    stepfunctions  = &quot;http://localhost:4566&quot;</span><br><span class="line">    sts            = &quot;http://localhost:4566&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段 Provider 声明中，首先在 <code>terraform</code> 块的 <code>required_providers</code> 里声明了本段代码必须要名为 <code>aws</code> 的 Provider 才可以执行，<code>source = &quot;hashicorp/aws&quot;</code>这一行声明了 <code>aws</code> 这个插件的源地址(Source Address)。一个源地址是全球唯一的，它指示了 Terraform 如何下载该插件。一个源地址由三部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;HOSTNAME&gt;/]&lt;NAMESPACE&gt;/&lt;TYPE&gt;</span><br></pre></td></tr></table></figure>
<p><code>Hostname</code> 是选填的，默认是官方的 <code>registry.terraform.io</code>，读者也可以构建自己私有的Terraform仓库。<code>Namespace</code> 是在 Terraform 仓库内注册的组织名，这代表了发布和维护插件的组织或是个人。<code>Type</code> 是代表插件的一个短名，在特定的 <code>HostName</code>/<code>Namespace</code> 下 <code>Type</code> 必须唯一。</p>
<p><code>required_providers</code> 中的插件声明还声明了该源码所需要的插件的版本约束，在例子里就是 <code>version = &quot;~&gt;5.0&quot;</code>。Terraform 插件的版本号采用 <code>MAJOR.MINOR.PATCH</code> 的语义化格式，版本约束通常使用操作符和版本号表达约束条件，条件之间可以用逗号拼接，表达 <code>AND</code> 关联，例如 <code>&quot;&gt;= 1.2.0, &lt; 2.0.0&quot;</code>。可以采用的操作符有：</p>
<ul>
<li><code>=</code>(或者不加 <code>=</code>，直接使用版本号)：只允许特定版本号，不允许与其他条件合并使用</li>
<li><code>!=</code>：不允许特定版本号</li>
<li><code>\&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>：与特定版本号进行比较，可以是大于、大于等于、小于、小于等于</li>
<li><code>~&gt;</code>：只允许 <em>最右边</em> 的版本号增加。这种格式被称为 <em>悲观约束</em> 操作符。例如，要允许在特定的 <code>MINOR</code> 版本中允许新的 <code>PATCH</code> 版本：
<ul>
<li><code>~&gt; 1.0.4</code>：允许 Terraform 安装 <code>1.0.5</code> 和 <code>1.0.10</code>，但不允许 <code>1.1.0</code>。</li>
<li><code>~&gt; 1.1</code>：允许 Terraform 安装 <code>1.2</code> 和 <code>1.10</code>，但不允许 <code>2.0</code>。</li>
</ul>
</li>
</ul>
<p>Terraform 会检查当前工作环境或是插件缓存中是否存在满足版本约束的插件，如果不存在，那么 Terraform 会尝试下载。如果 Terraform 无法获得任何满足版本约束条件的插件，那么它会拒绝继续执行任何后续操作。</p>
<p>可以用添加后缀的方式来声明预览版，例如：<code>1.2.0-beta</code>。预览版只能通过 <code>&quot;=&quot;</code> 操作符(或是忽略操作符)后接明确的版本号的方式来指定，不可以与<code>&gt;=</code>、<code>~&gt;</code>等搭配使用。</p>
<ul>
<li>当依赖第三方模块时，需要指定特定版本，以确保只在您需要的时候进行更新。</li>
<li>对于在您的组织内维护的模块，如果一致使用语义版本控制，或者有一个定义良好的发布流程可以避免不必要的更新，那么指定版本范围可能是合适的。</li>
<li>可重用的模块应仅限制其 Terraform 和 Provider 的最低允许版本，例如 <code>&gt;= 0.12.0</code>。这有助于避免已知的不兼容性，同时允许模块的用户在不改变模块的情况下升级到 Terraform 的新版本。</li>
<li>根模块应使用 <code>~&gt;</code> 约束为它们依赖的每个 Provider 设置一个下限和上限版本。</li>
</ul>
<p>以上建议来自于 <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/expressions/version-constraints#best-practices">HashiCorp 官方文档</a>，笔者个人给出一条个人建议：</p>
<ul>
<li>可复用的模块不但应该限制 Provider 的最低版本，同时也应该限制 Provider 的 <code>MAJOR</code> 版本。例如，<code>&gt;= 1.5.0, &lt; 2.0</code>。这样可以避免在 Provider 的 <code>MAJOR</code> 版本升级时，因为不兼容性导致的问题，Provider 的 <code>MAJOR</code> 版本升级通常会伴随着不兼容的改动，不应该在未加测试的情况下轻易升级。</li>
</ul>
<h2 id="1-3-1-1-4-内建-Provider"><a href="#%E5%86%85%E5%BB%BA-provider"></a>1.3.1.1.4. 内建 Provider</h2>
<p>绝大多数 Provider 是以插件形式单独分发的，但是目前有一个 Provider 是内建于Terraform主进程中的，那就是 <code>terraform_remote_state</code> data source。该 Provider 由于是内建的，所以使用时不需要在 <code>terraform</code> 中声明 <code>required_providers</code>。这个内建Provider的源地址是 <code>terraform.io/builtin/terraform</code>。这个地址有时可能出现在 Terraform 的错误消息和其他输出中，以便无歧义地引用内建 Provider，而不是假设的第三方提供者，其类型名称为 “terraform”。</p>
<p>还存在一个源地址为 <code>hashicorp/terraform</code> 的 Provider，这是现在内置 Provider 的旧版本，被 Terraform 的旧版本使用。<code>hashicorp/terraform</code> 与 Terraform v0.11 或更高版本不兼容，因此永远不应在 <code>required_providers</code> 块中声明。</p>
<h2 id="1-3-1-1-5-Provider-的配置"><a href="#provider-%E7%9A%84%E9%85%8D%E7%BD%AE"></a>1.3.1.1.5. Provider 的配置</h2>
<p>Provider 的配置是声明在根模块中的一组 Terraform 配置。（子模块接收来自于根模块的 Provider 配置，更多信息，请参阅<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97#%E6%98%BE%E5%BC%8F%E4%BC%A0%E9%80%92-provider">模块的 <code>provider</code> 元参数</a>）</p>
<p>一个 Provider 配置是通过 <code>provider</code> 块来创建的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">provider &quot;google&quot; &#123;</span><br><span class="line">  project = &quot;acme-app&quot;</span><br><span class="line">  region  = &quot;us-central1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块头部设置的名称（例子中的 <code>&quot;google&quot;</code>）就是要配置的 Provider 的<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/terraform/language/providers/requirements#local-names">Local Name</a>。这个 Provider 必须已在 <code>required_providers</code> 块中声明。</p>
<p>块体（<code>&#123;</code> 和 <code>&#125;</code> 中间的内容）包含了 Provider 的配置参数。这些参数大多数是由 Provider 自己定义的；在这个例子中，<code>project</code> 和 <code>region</code> 都是 <code>google</code> Provider 特有的。</p>
<p>你可以在这些配置的值当中使用<a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/3.Terraform%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B9%A6%E5%86%99/8.%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>，但是只能引用在配置 Provider 时已知的值。这意味着你可以安全地引用输入变量，但是不能引用从 <code>resource</code> 返回的属性（一个例外是直接在配置中硬编码的 <code>resource</code> 参数）。</p>
<p>一个 Provider 的文档应该列出它所需要的配置参数。对那些注册在 <a target="_blank" rel="noopener" href="https://registry.terraform.io/">Terraform Registry</a> 上的 Provider 来说，每个 Provider 的页面上都有版本化的文档，可以通过 Provider 页头的 “Documentation” 链接访问。</p>
<p>一些 Provider 可以使用环境变量（或是其他替代配置源，例如 AWS 的虚拟机实例 Profile）作为某些配置参数的值；我们建议尽可能使用这种方式来避免将凭证保存于版本控制的 Terraform 代码中。</p>
<p>There are also two “meta-arguments” that are defined by Terraform itself and available for all <code>provider</code> blocks:</p>
<p>有两个由 Terraform 自身定义的“元参数”，对所有 <code>provider</code> 块都可用：</p>
<ul>
<li><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"><code>alias</code>，用以为不同的 <code>resource</code> 块配置参数不同的同类 Provider 实例</a></li>
<li><code>version</code>， 废弃，不推荐使用，现在请使用 <a href="#provider-%E7%9A%84%E5%A3%B0%E6%98%8E"><code>required_providers</code></a></li>
</ul>
<p>与 Terraform 语言中的许多其他对象不同，如果 <code>provider</code> 块的内容为空，则可以省略该块。Terraform 假定未显式配置的任何 Provider 程序都具有空的默认配置。</p>
<h2 id="1-3-1-1-6-多-Provider-实例"><a href="#%E5%A4%9A-provider-%E5%AE%9E%E4%BE%8B"></a>1.3.1.1.6. 多 Provider 实例</h2>
<p><code>provider</code> 块声明了 <code>aws</code> 这个 Provider 所需要的各项配置。在上文的代码示例中，<code>provider &quot;aws&quot;</code>和<code>required_providers</code>中<code>aws = &#123;...&#125;</code>块里的<code>aws</code>，都是 Provider 的 Local Name，一个 Local Name 是在一个模块中对一个 Provider 的唯一的标识。</p>
<p>你可以选择为同一个 Provider 定义多个配置，并且可以根据每个资源或每个模块来选择使用哪一个。这主要是为了支持云平台的多个区域；其他例子包括针对多个 Docker 主机，多个 Consul 主机等。</p>
<p>要为某一个 Provider 创建多个配置，包括具有相同提供者名称的多个 <code>provider</code> 块。对于每个额外的非默认配置，使用 <code>alias</code> 元参数提供额外的名称段。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># The default provider configuration; resources that begin with `aws_` will use</span><br><span class="line"># it as the default, and it can be referenced as `aws`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-east-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Additional provider configuration for west coast region; resources can</span><br><span class="line"># reference this as `aws.west`.</span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  alias  = &quot;west&quot;</span><br><span class="line">  region = &quot;us-west-2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模块内声明配置 <code>alias</code> 以从父模块接收备用的 <code>provider</code> 配置，需要在该 <code>provider</code> 的 <code>required_providers</code> 条目中添加 <code>configuration_aliases</code> 参数。以下示例在包含的模块中声明了 <code>mycloud</code> 和 <code>mycloud.alternate</code> 的 <code>provider</code> 配置名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    mycloud = &#123;</span><br><span class="line">      source  = &quot;mycorp/mycloud&quot;</span><br><span class="line">      version = &quot;~&gt; 1.0&quot;</span><br><span class="line">      configuration_aliases = [ mycloud.alternate ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1-1-6-1-默认-Provider-配置"><a href="#%E9%BB%98%E8%AE%A4-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.1. 默认 Provider 配置</h3>
<p>没有 <code>alias</code> 参数的 <code>provider</code> 块是该 provider 的 <em>默认</em> 配置。未设置 <code>provider</code> 元参数的资源将使用与资源类型名称的第一个单词匹配的默认 provider 配置。（例如，除非另有说明，否则 <code>aws_instance</code> 资源将使用默认的 <code>aws</code> provider 配置。）</p>
<p>如果 provider 的每个显式配置都有别名，Terraform 将使用隐含的空配置作为该 provider 的默认配置。（如果 provider 有任何必需的配置参数，当资源默认使用空配置时，Terraform 将引发错误。）</p>
<h3 id="1-3-1-1-6-2-引用备用-Provider-配置"><a href="#%E5%BC%95%E7%94%A8%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.2. 引用备用 Provider 配置</h3>
<p>当 Terraform 需要 provider 配置的名称时，它期望的是 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 形式的引用。在上面的例子中，<code>aws.west</code> 将引用 <code>us-west-2</code> 区域的 provider。</p>
<p>这些引用是特殊的表达式。像对其他命名实体（例如 <code>var.image_id</code>）的引用一样，它们不是字符串，不需要引号。但是它们只在 <code>resource</code>、<code>data</code> 和 <code>module</code> 块的特定元参数中有效，不能在任意表达式中使用。</p>
<h3 id="1-3-1-1-6-3-选择备用-Provider-配置"><a href="#%E9%80%89%E6%8B%A9%E5%A4%87%E7%94%A8-provider-%E9%85%8D%E7%BD%AE"></a>1.3.1.1.6.3. 选择备用 Provider 配置</h3>
<p>默认情况下，资源使用从资源类型名称的第一个单词推断出的默认 provider 配置（没有 <code>alias</code> 参数的配置）。</p>
<p>要为资源或数据源指定备用 provider 配置，将其 <code>provider</code> 元参数设置为 <code>&lt;PROVIDER NAME&gt;.&lt;ALIAS&gt;</code> 引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_instance&quot; &quot;foo&quot; &#123;</span><br><span class="line">  provider = aws.west</span><br><span class="line"></span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要为子模块指定备用 provider 配置，使用其 <code>providers</code> 元参数指定应将哪些 provider 配置映射到模块内的哪些本地 provider 名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module &quot;aws_vpc&quot; &#123;</span><br><span class="line">  source = &quot;./aws_vpc&quot;</span><br><span class="line">  providers = &#123;</span><br><span class="line">    aws = aws.west</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在传递 provider 时，模块有一些特殊要求；有关更多详细信息，请参见 <a target="_blank" rel="noopener" href="https://lonegunmanb.github.io/introduction-terraform/5.Terraform%E6%A8%A1%E5%9D%97/2.%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97.html#module-providers">模块 <code>providers</code> 元参数</a>。在大多数情况下，只有 <em>根模块</em> 应定义 provider 配置，所有子模块都应从其父模块获取其 provider 配置。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2023/01/17/Teraform/Terraform-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Provider/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../../"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
        <li class="pagination-number">第 2 頁 共 2 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://chankein.github.io/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 211 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
