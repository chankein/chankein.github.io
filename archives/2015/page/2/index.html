
<!DOCTYPE html>
<html lang="zh-tw">
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
    
      <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/locale/zh-tw.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <script>
      window.algoliaConfig = {
        appId: 'AWFC86Q51O',
        apiKey: 'c9d952906eb1b154d75cf863e75c1ede',
        indexName: 'MyBlog'
      };
      var algoliaIndex = algoliasearch(
        algoliaConfig.appId,
        algoliaConfig.apiKey
      ).initIndex(algoliaConfig.indexName);
    </script>


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kein&#39;s blog">
    <title>所有文章: 2015 - Kein&#39;s blog</title>
    <meta name="author" content="Kein Chan">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Kein&#39;s blog">
<meta property="og:url" content="https://keinchan.com/archives/2015/page/2/index.html">
<meta property="og:site_name" content="Kein&#39;s blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Kein Chan">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://keinchan.com../../../../assets/images/profile.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../assets/css/style-l9zwheso7r7pnk98nvirovsz9dl7fhkrc9mlb5vmuxw7tk5movrk0eevsrpr.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../index.html"
            aria-label=""
        >
            Kein&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打開鏈接: ../../../../#about"
            >
        
        
            <img class="header-picture" src="../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="../../../../#about"
                    aria-label="閱讀有關作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="../../../../assets/images/profile.jpg" alt="作者的圖片"/>
                </a>
                <h4 class="sidebar-profile-name">Kein Chan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../index.html"
                            
                            rel="noopener"
                            title="首頁"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首頁</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-categories"
                            
                            rel="noopener"
                            title="分類"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分類</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-tags"
                            
                            rel="noopener"
                            title="標籤"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">標籤</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-archives"
                            
                            rel="noopener"
                            title="所有文章"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">所有文章</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜尋"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜尋</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="關於"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">關於</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/chankein/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../mailto:kein.chan85@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Email"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Email</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../atom.xml"
                            
                            rel="noopener"
                            title="Atom"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Atom</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/03/05/Algorithms/11.%E6%95%A3%E5%88%97%E8%A1%A8/"
                            aria-label=": 11. 散列表（哈希表）"
                        >
                            11. 散列表（哈希表）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-03-05T18:20:08+08:00">
	
		    2015 年 3 月 5 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>11. 散列表（哈希表）</h1>
<p>许多应用都需要一种动态集合，至少支持Insert，Search和Delete的字典操作。<br>
散列表（Hash Table）是实现字典操作的一种有效数据结构。尽管最坏情况下散列表查询一个元素的时间和链表的查询时间相同，为Θ(n)。但是在实际应用中，散列表的查询性能是极好的。在一些合理的假设下，散列表中扎寻一个元素的平均时间能为Ο(1)。</p>
<p>假设某应用需要用到一个动态集合，其中每个元素的KEY都是取自全域U={0, 1, …, m-1}。本章讨论方法都是基于这样的动态集合。</p>
<h2 id="直接寻址表">直接寻址表</h2>
<p>当KEY的全域U较小时，直接寻址表是一种简单而有效的技术。<br>
为了表示这个动态集合，我们用一个数组作为<strong>直接寻址表</strong>，记为T[0…m-1]，其中数组的每个位置称为<strong>槽</strong>，与全域U中的KEY一一对应。<br>
K集合表示实际存在的元素的KEY集合。<br>
槽k指向KEY为k的元素，如果K集合中没有k，那么T[k] = nil。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/11_1.PNG" alt="直接寻址表"></p>
<h2 id="散列表">散列表</h2>
<p>直接寻址表的缺点很明显：</p>
<ol>
<li>如果全域U非常大，则计算机无法存储</li>
<li>如果K集合相对于全域U非常小，那么将非常浪费空间</li>
</ol>
<p>如果直接寻址表占用的存储空间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>U</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(|U|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathrm">∣</span><span class="mclose">)</span></span></span></span>，那么散列表能将存储需求降至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>K</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(|K|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathrm">∣</span><span class="mclose">)</span></span></span></span>，同时散列表中查找一个元素的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#cc0000"><mtext><mi mathvariant="normal">\</mi><mi mathvariant="normal">O</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi></mtext></mstyle><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omicron(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm" style="color:#cc0000;">\</span><span class="mord mathrm" style="color:#cc0000;">O</span><span class="mord mathrm" style="color:#cc0000;">m</span><span class="mord mathrm" style="color:#cc0000;">i</span><span class="mord mathrm" style="color:#cc0000;">c</span><span class="mord mathrm" style="color:#cc0000;">r</span><span class="mord mathrm" style="color:#cc0000;">o</span><span class="mord mathrm" style="color:#cc0000;">n</span></span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>，不过是平均时间。</p>
<p>散列方式不同于直接寻址表的地方是，元素存储在散列表中的位置由散列函数决定，即k元素存储在散列表的h(k)位置。h(k)叫做k的散列值。</p>
<p>散列表T的大小比|U|小很多，所以肯定会有冲突的情况。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/11_2.PNG" alt="冲突"></p>
<p>冲突最简单的解决方式是使用<strong>链接法</strong>，后面还介绍一种<a href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95">开放寻址法</a>。<br>
下图是链接法的图示，当有两个k值映射到了同一个散列值时，将它们保存在一个链表内。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/11_3.PNG" alt="链接法"></p>
<h4 id="链接法散列分析">链接法散列分析</h4>
<p>如果要将n个数据存储在m大小的散列表中，我们称α = n/m为<strong>装载因子</strong>，即散列表的每个槽平均存放的数据。<br>
假设散列函数能等可能的把数据散列到m个槽中，我们称这个假设为<strong>简单均匀散列</strong>。<br>
这时每个槽存放元素个数的期望值为<strong>α</strong>。</p>
<p>所以，一次不成功查找的平均时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mn>1</mn><mo>+</mo><mi>α</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(1+\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>。（1 表示散列函数消耗的时间）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为每个槽的期望为α，而不成功的情况下，查找的期望时间就是从槽链表的头遍历到链表尾，所以期望时间就是槽链表的长度α。</span><br></pre></td></tr></table></figure>
<p>一次成功查找的平均时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mn>1</mn><mo>+</mo><mi>α</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(1+\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">具体证明参考公开课中老师的推理，或者书中推理。</span><br><span class="line">自我理解：一个元素在槽中的位置是等概率随机的(1/α)，而且期望时间为元素在槽中位置的期望。期望位置为(1+2+..+α)*(1/α) = (α+1)/2</span><br></pre></td></tr></table></figure>
<h2 id="散列函数">散列函数</h2>
<p>最好的散列函数便是能达到<strong>简单均匀散列</strong>。<br>
下面介绍一些的散列函数。其中全域散列能够达到这样的要求。</p>
<h3 id="除法散列">除法散列</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h(k) = k <span class="built_in">mod</span> m</span><br></pre></td></tr></table></figure>
<p>m最好是一个素数，并且不能太接近2或者10的乘方。</p>
<h3 id="乘法散列">乘法散列</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h(k) = [(a * k) <span class="built_in">mod</span> <span class="number">2</span>^w] &gt;&gt; (w − r)</span><br></pre></td></tr></table></figure>
<p>k是w bits的数<br>
m = 2^r<br>
a最好是一个奇数，并且不能太接近2或者10的乘方。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/11_MH.PNG" alt="乘法散列"></p>
<h3 id="全域散列">全域散列</h3>
<p>随机的选择散列函数，称为全域散列<br>
Example：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h(k) = [(ak+b) <span class="built_in">mod</span> p] <span class="built_in">mod</span> m </span><br><span class="line">where a and b are random ∈ &#123;<span class="number">0</span>, <span class="number">1</span>, . . . p−<span class="number">1</span>&#125;, and p is a large prime (&gt; |U|).</span><br></pre></td></tr></table></figure>
<p>证明全域散列为<strong>简单均匀散列</strong>的过程，参考公开课中老师的推理，或者书中推理。</p>
<h2 id="开放寻址法">开放寻址法</h2>
<ul>
<li>无链表，所有的元素都保存在table中</li>
<li>每个槽存储一个元素，<strong>m&gt;=n</strong></li>
<li>散列函数为h(k, i)，i从0开始，当有冲突后i++，直到找到一个空的位置，所以散列函数需要有如下性质：</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对同一个KEY做m次探查，能把散列表填满</span><br><span class="line"></span><br><span class="line">h : U × &#123;<span class="number">0</span>, <span class="number">1</span>,...,m − <span class="number">1</span>&#125; → &#123;<span class="number">0</span>, <span class="number">1</span>,...,m − <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;h(k, <span class="number">0</span>), h(k, <span class="number">1</span>), . . . , h(k, m − <span class="number">1</span>)&#125; == &#123;<span class="number">0</span>, <span class="number">1</span>,...,m − <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>删除时，不能直接删除！删除后需要标记此位为删除位。</p>
<h4 id="线性探查">线性探查</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h(k, <span class="built_in">i</span>) = (h1(k) +<span class="built_in">i</span>) <span class="built_in">mod</span> m</span><br></pre></td></tr></table></figure>
<h4 id="双重探查">双重探查</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h(k, <span class="built_in">i</span>) =(h1(k) + <span class="built_in">i</span>·h2(k)) <span class="built_in">mod</span> m</span><br><span class="line"></span><br><span class="line">h2(k) 需要和 m 互为质数</span><br><span class="line">e.g. m = <span class="number">2</span>^r, h2(k) 永远为奇数</span><br></pre></td></tr></table></figure>
<h4 id="开放寻址法分析">开放寻址法分析</h4>
<p>给定一个装载因子α = n/m < 1的开放寻址散列表，并假设是均匀散列的：<br>
对于一次不成功的查找，期望的探查次数至多为1/(1-α)<br>
对于一次成功的查找，期望的探查次数至多为\frac{1}{α}\ln(1/(1-α))</p>
<h2 id="完全散列">完全散列</h2>
<p>基于全域散列，完全没看。。。</p>
<h2 id="涉及数据结构">涉及数据结构</h2>
<blockquote>
<p>点击查看实现</p>
</blockquote>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-11-3-Hashing/Hashing.h">使用链接法的散列表</a></strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/03/05/Algorithms/11.%E6%95%A3%E5%88%97%E8%A1%A8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/03/04/Algorithms/10.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
                            aria-label=": 10. 基本数据结构"
                        >
                            10. 基本数据结构
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-03-04T18:20:08+08:00">
	
		    2015 年 3 月 4 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>10. 基本数据结构</h1>
<p>动态集合的基本数据结构。</p>
<h2 id="栈">栈</h2>
<p><strong>栈</strong>，后进先出，用数组存储，并用top保存栈顶位置。支持压入（Push）和弹出（Pop）操作。<br>
a-&gt;b产生了两次Push操作，压入了17和3。<br>
b-&gt;c产生了一次Pop操作，弹出了3。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/10_1.PNG" alt="栈"></p>
<h2 id="队列">队列</h2>
<p><strong>队列</strong>，先进先出，用数组存储，用head和tail保存队列的头和尾的位置。支持入队（Enqueue）和出队（Dequeue）操作。<br>
a-&gt;b产生了三次Enqueue操作，加入了17 3 5。<br>
b-&gt;c产生了一次Dequeue操作，去除了15。<br>
当head或者tail超出数组范围时，转移到数组头部。<br>
当tail等于head时，表示队列已满，不能再加入数据。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/10_2.PNG" alt="队列"></p>
<h2 id="链表">链表</h2>
<p>链表是一种对象按照线性排序的数据结构，不同于数组的是链表的顺序由各个对象里的指针表示。<br>
下图表示一个<strong>双向链表</strong>。每个对象包含prev指针，next指针，key值，或者附加一些卫星数据。<br>
prev指针指向上一个对象<br>
next指针指向下一个对象<br>
用一个head指针指向头结点，头结点的prev指针为null<br>
尾结点的next指针为null</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/10_3.PNG" alt="双向链表"><br>
单向链表为双向链表去除prev指针。</p>
<p>下图是一个带有哨兵的双向循环链表，说实话没看出这个哨兵的必要性。<br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/10_4.PNG" alt="有哨兵的双向循环链表"></p>
<h2 id="数组存储链表">数组存储链表</h2>
<p>不是所有的语言都支持指针，所以只能间接实现链表。<br>
下图给出一种用多个数组存储链表的方式，next数组和prev数组中存储next元素或prev元素的数组下标，从而间接的实现了双向链表。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/10_5.PNG" alt="多数组存储链表"></p>
<p>为了更方便快捷的在分配和释放数组中的元素，在数组中存储一个free单向连边。<br>
当需要分配元素时，分配free链表的头结点，并使free指向下一元素。<br>
当需要释放元素时，使该元素的next指向free指向的元素，并使得free指向该元素。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/10_7.PNG" alt="对象的分配与释放"></p>
<h2 id="二叉树">二叉树</h2>
<p>前面我们讨论过一种特殊二叉树——<strong>堆</strong>的存储，我们将堆存储在数组中。<br>
但对于一般的二叉树，我们将用链式数据结构表示。</p>
<p>每个元素包含三个指针——p、left、right分别指向父节点、左孩子、右孩子。<br>
根节点的p指向null，叶子节点的left和right指向null。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/10_9.PNG" alt="二叉树"></p>
<p>当我们需要存储一个N叉树时，按照上面的方法，每个元素则需要child1、child2…childN来存储，会占用很多额外空间，如果孩子个数是未知的这种方式则无法实现。<br>
下图展示了一种<strong>分支无限制的有限树</strong>的存储方式——<strong>左孩子右兄弟表示法</strong>。left指向第一个孩子，right指向兄弟节点。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/10_10.PNG" alt="分支无限制的有限树"></p>
<h2 id="涉及数据结构">涉及数据结构</h2>
<blockquote>
<p>点击查看实现</p>
</blockquote>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-10-2-DoublyLinkedList/DoublyLinkedList.h">双向链表</a></strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/03/04/Algorithms/10.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/03/02/Algorithms/9.%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/"
                            aria-label=": 9. 中位数和顺序统计量"
                        >
                            9. 中位数和顺序统计量
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-03-02T18:20:08+08:00">
	
		    2015 年 3 月 2 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>9. 中位数和顺序统计量</h1>
<p><strong>顺序统计量</strong>，第i个顺序统计量指n个元素集合中第i小的元素。<br>
<strong>最小值</strong>，第1个顺序统计量。<br>
<strong>最大值</strong>，第n个顺序统计量。<br>
<strong>中位数</strong>，第n/2个顺序统计量。（若n为偶数，取n/2-1）</p>
<p>我们可以通过一次遍历数组，取得最大值或者最小值。<br>
但是若要取得中位数或者其他顺序统计量，则没办法通过一次遍历数组得到。<br>
如果将数组排序，将可以直接得到中位数或者任意顺序统计量。由之前所学的排序算法可知，时间复杂度最好为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br>
本章讨论如何在线性时间找到中位数或者其他顺序统计量。</p>
<h2 id="期望为线性时间的选择算法">期望为线性时间的选择算法</h2>
<p>利用随机快速排序的思想，随机的挑选一个元素作为主元，并把数组分为两侧，一侧比主元小，一侧比主元大，如果主元的位置q就是想找的顺序统计量的位置i，则返回主元，否则继续递归的查找左侧数组或者右侧数组。伪代码如下：</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/09_RANDOMIZED_SELECT.PNG" alt="随机选择算法"></p>
<h2 id="最坏情况为线性时间的选择算法">最坏情况为线性时间的选择算法</h2>
<p>这个算法由几个大牛共同完成，发布在论文<a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0022000073800339">Time bounds for selection</a>中。</p>
<p>中文描述如下：<br>
<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1c021beb5e72">https://www.jianshu.com/p/1c021beb5e72</a></p>
<h2 id="涉及算法">涉及算法</h2>
<blockquote>
<p>点击查看实现</p>
</blockquote>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-09-2-RandomizedSelect/randomized_select_realization.cpp">随机选择算法（RANDOMIZED_SELECT）</a></strong></li>
</ul>
<h2 id="习题答案">习题答案</h2>
<h4 id="练习">练习</h4>
<p><strong>9.3-6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 如果k为1时，返回空数组</span><br><span class="line">2. 如果k为偶数，找到数组的中位数,并把数组分为两组（比中位数大的一组，比中位数小的一组），递归解决这两个子问题，并把中位数以及两个字问题的解合并返回</span><br><span class="line">3. 如果k为奇数，找到数组中间的两个分位数left和right，并把数组分出两组（比left小的一组，比right大的一组），递归解决这两个子问题，并把left right以及两个字问题的解合并返回</span><br></pre></td></tr></table></figure>
<p><strong>9.3-7</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 线性时间找到中位数</span><br><span class="line">2. 线性时间算出每个元素和中位数的距离（|x-middle|）</span><br><span class="line">3. 线性时间找到第k小的距离</span><br><span class="line">4. 线性时间找出比k小的距离对应的元素</span><br></pre></td></tr></table></figure>
<p><strong>9.3-8</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 选择X Y两数组的中位数作为主元Xk和Yk</span><br><span class="line">2. 比较Xk和Yk，如果Xk大于Yk，则取Xk左侧的元素作为新的X数组（包括X），取Yk右侧的元素作为新的Y数组（包括Y）</span><br><span class="line">3. 重复1 2 两部，直到每个数组只剩两个元素，剩下的四个元素中第二小的便是两数组的中位数</span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/03/02/Algorithms/9.%E4%B8%AD%E4%BD%8D%E6%95%B0%E5%92%8C%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/03/01/Algorithms/8.%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/"
                            aria-label=": 8. 线性时间排序"
                        >
                            8. 线性时间排序
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-03-01T18:20:08+08:00">
	
		    2015 年 3 月 1 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>8. 线性时间排序</h1>
<p>前边介绍了很多排序算法，他们有一个共同点：元素的排序依赖于对他们之间的比较，这类排序我们称其为<strong>比较排序</strong>。本章节讨论比较排序的下界以及一些线性时间的排序方法。</p>
<h2 id="比较排序的下界">比较排序的下界</h2>
<p>将比较排序抽象为一颗<strong>决策树</strong>。<br>
下图为三个元素排序的一颗决策树，叶子节点表示比较结果，其他节点表示某两个元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span>作比较，节点的左子节点表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a&lt;=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mord mathit">b</span></span></span></span>，节点的右子节点表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a&gt;b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">&gt;</span><span class="mord mathit">b</span></span></span></span>。可以发现叶子节点包含了三个元素比较的所有可能情况，而且从根节点到叶子节点用了最少的比较次数。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/08_1.PNG" alt="决策树"></p>
<p>接下来我们考虑n个元素排序的情况，因为n个元素排序可能会有n!种情况，所以叶子节点树小于等于n!，而这个树高度表示需要最坏情况的比较次数。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>&gt;</mo><mo>=</mo><mi>lg</mi><mo>(</mo><mi>n</mi><mo>!</mo><mo>)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h &gt;= \lg(n!) = \Omega(n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span><span class="mrel">&gt;</span><span class="mrel">=</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">!</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">Ω</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<p>所以在最坏情况下，任何比较排序算法都需要做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Ω</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>次比较。</p>
<h2 id="计数排序">计数排序</h2>
<p>假设n个元素都是0~k之间的整数，而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mstyle mathcolor="#cc0000"><mtext><mi mathvariant="normal">\</mi><mi mathvariant="normal">O</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi></mtext></mstyle><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">k=\Omicron(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">=</span><span class="text mord textstyle uncramped"><span class="mord mathrm" style="color:#cc0000;">\</span><span class="mord mathrm" style="color:#cc0000;">O</span><span class="mord mathrm" style="color:#cc0000;">m</span><span class="mord mathrm" style="color:#cc0000;">i</span><span class="mord mathrm" style="color:#cc0000;">c</span><span class="mord mathrm" style="color:#cc0000;">r</span><span class="mord mathrm" style="color:#cc0000;">o</span><span class="mord mathrm" style="color:#cc0000;">n</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>时，计数排序的运行时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>计数排序的基本思想为，首先得到0~k每一个值对应多少个元素，然后推算出每一个值对应元素在输出数组上的位置范围，最后将各个元素放到应该的位置。<br>
计数排序的伪代码和处理过程如下图所示：<br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/08_COUNTING_SORT.PNG" alt="计数排序"><br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/08_2.PNG" alt="计数排序"></p>
<h2 id="基数排序">基数排序</h2>
<p>基数排序的思想为，将带排序的数看做d位数，每一位的取值有K个可能，然后把待排数组从最低位开始做<strong>稳定排序</strong>（当有相同的数值时，排序后他们的顺序不变），一位接着一位直到最高位。伪代码，以及一个三位十进制数的排序过程如下：<br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/08_RADIX_SORT.PNG" alt="基数排序"><br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/08_3.PNG" alt="基数排序"></p>
<p>如果基数排序使用的稳定排序方法耗时为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，每个数为d位，那么基数排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>d</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(d(n+k))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<h2 id="桶排序">桶排序</h2>
<p>TODO:</p>
<h2 id="涉及算法">涉及算法</h2>
<blockquote>
<p>点击查看实现</p>
</blockquote>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-08-2-CountingSort/counting_sort_realization.cpp">计数排序</a></strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/03/01/Algorithms/8.%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/02/28/Algorithms/7.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"
                            aria-label=": 7. 快速排序"
                        >
                            7. 快速排序
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-02-28T18:20:08+08:00">
	
		    2015 年 2 月 28 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>7. 快速排序</h1>
<p>快速排序是一种最坏情况时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>的排序算法，虽然最坏情况的时间复杂度很差，但是快速排序通常是实际排序应用中最好的选择，因为它的平均性能非常好，它的期望时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>中隐含的常数因子非常小。另外它是原址排序。</p>
<h2 id="快速排序">快速排序</h2>
<p>快速排序也用了分治的思想。对子数组A[p…r]进行快速排序的过程如下：<br>
<strong>分解</strong> 将A[p…r]划分为两个数组A[p…q-1]和A[q+1…r]，使得A[p…q-1]的每一个元素小于等于A[q]，而A[q+1…r]的每一个元素大于等于A[q]。<br>
<strong>解决</strong> 递归调用快速排序，对子数组A[p…q-1]和A[q+1…r]进行排序。<br>
<strong>合并</strong> 因为是原址操作，所以无需合并，这时A[p…r]已经有序。</p>
<p>伪代码和分解过程如下：</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/07_QUICK_SORT.PNG" alt="快排"><br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/07_QUICK_SORT_PARTITION.PNG" alt="快排"><br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/07_1.PNG" alt="快排"></p>
<h2 id="性能">性能</h2>
<h3 id="最坏情况">最坏情况</h3>
<p>若每次分解时，都分解为一个空数组和一个n-1大小的数组,则为最坏情况。<br>
递归式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>T</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>+</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = T(n-1) + T(0) + \Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的解为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p>
<h3 id="最好情况">最好情况</h3>
<p>若每次分解时，都分解为两个一样大的子问题，这时为最好情况。<br>
递归式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>+</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = 2 T(n/2) + \Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的解为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p>
<h3 id="平衡的划分">平衡的划分</h3>
<p>若每次分解时，都按照一定比例分割，比如按照9:1划分。<br>
递归式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>T</mi><mo>(</mo><mn>9</mn><mi>n</mi><mi mathvariant="normal">/</mi><mn>1</mn><mn>0</mn><mo>)</mo><mo>+</mo><mi>T</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>1</mn><mn>0</mn><mo>)</mo><mo>+</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = T(9n/10) + T(n/10) + \Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathrm">9</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的解为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p>
<blockquote>
<p>可用代入法证明按照任何比例划分，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的解都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<h3 id="平均情况">平均情况</h3>
<p>若每次分解时，最好情况和最坏情况交替出现。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的解为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p>
<blockquote>
<p>可以将最好情况和最坏情况合并，时间复杂度并没变<br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/07_5.PNG" alt="快排"></p>
</blockquote>
<h3 id="随机快速排序">随机快速排序</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-07-1-QuickSort/randomized_quick_sort_realization.cpp">随机快速排序</a>可以避免特定输入（已排序的队列或逆序列）时运行时间较长的情况。<br>
分解时，随机的挑选数组中的一个元素来分解。</p>
<blockquote>
<p>TODO: 证明随机快速排序的期望运行时间</p>
</blockquote>
<h2 id="涉及算法">涉及算法</h2>
<blockquote>
<p>点击查看实现</p>
</blockquote>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-07-1-QuickSort/quick_sort_realization.cpp">快速排序</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-07-1-QuickSort/randomized_quick_sort_realization.cpp">随机快速排序</a></strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/02/28/Algorithms/7.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/02/27/Algorithms/6.%E5%A0%86%E6%8E%92%E5%BA%8F/"
                            aria-label=": 6. 堆排序"
                        >
                            6. 堆排序
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-02-27T18:20:08+08:00">
	
		    2015 年 2 月 27 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>6. 堆排序</h1>
<p>堆排序也是一种时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#cc0000"><mtext><mi mathvariant="normal">\</mi><mi mathvariant="normal">O</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi></mtext></mstyle><mo>(</mo><mi>n</mi><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omicron (n\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm" style="color:#cc0000;">\</span><span class="mord mathrm" style="color:#cc0000;">O</span><span class="mord mathrm" style="color:#cc0000;">m</span><span class="mord mathrm" style="color:#cc0000;">i</span><span class="mord mathrm" style="color:#cc0000;">c</span><span class="mord mathrm" style="color:#cc0000;">r</span><span class="mord mathrm" style="color:#cc0000;">o</span><span class="mord mathrm" style="color:#cc0000;">n</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的排序算法，但是与归并排序不同的是堆排序是一种原址排序，也就是说排序过程只是交换数据的位置。</p>
<h2 id="最大堆"><strong>最大堆</strong></h2>
<p><strong>堆</strong>是一个数组，存储一个近似完全二叉树，树上的每个结点对应数组中的一个元素，数组第一个元素存储根节点，第<strong>i</strong>个元素的左孩子在数组的<strong>2i</strong>位置，右孩子在数组的<strong>2i+1</strong>位置，父结点在数组的<strong>i/2</strong>位置。</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/06_HEAP.PNG" alt="堆"></p>
<p><strong>最大堆</strong>指一种父节点必然大于等于子节点的<strong>堆</strong>。下图为一个最大堆的存储情况：</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/06_1.PNG" alt="堆"></p>
<h2 id="MAX-HEAPIFY（维护最大堆）"><strong>MAX-HEAPIFY</strong>（维护最大堆）</h2>
<p><strong>MAX-HEAPIFY</strong>是维护最大堆性质的重要方法。MAX-HEAPIFY的输入为数组A和下标i，当调用MAX-HEAPIFY时，假定根节点为LEFT(i)和RIGHT(i)的二叉树都是最大堆，但是A[i]可能比它的子节点要小。MAX-HEAPIFY通过让A[i]的值在最大堆中逐级下降，从而使得以下标i为根节点的树符合最大堆的性质。以下是MAX-HEAPIFY的伪代码以及MAX-HEAPIFY(A, 2)的处理过程：</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/06_MAX_HEAPIFY.PNG" alt="堆"><br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/06_2.PNG" alt="堆"></p>
<p>因为堆的高度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>lg</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">\lg n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span></span></span></span>，所以该过程的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#cc0000"><mtext><mi mathvariant="normal">\</mi><mi mathvariant="normal">O</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi></mtext></mstyle><mo>(</mo><mi>lg</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omicron (\lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm" style="color:#cc0000;">\</span><span class="mord mathrm" style="color:#cc0000;">O</span><span class="mord mathrm" style="color:#cc0000;">m</span><span class="mord mathrm" style="color:#cc0000;">i</span><span class="mord mathrm" style="color:#cc0000;">c</span><span class="mord mathrm" style="color:#cc0000;">r</span><span class="mord mathrm" style="color:#cc0000;">o</span><span class="mord mathrm" style="color:#cc0000;">n</span></span><span class="mopen">(</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2 id="建堆">建堆</h2>
<p>自下而上的调用MAX-HEAPIFY可以把一个数组转换为最大堆。<br>
叶子节点不需要调用，所以从下标为n/2的的元素开始，一直到根节点。<br>
伪代码和建堆过程如下：</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/06_BUILD_MAX_HEAP.PNG" alt="堆"><br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/06_3.PNG" alt="堆"></p>
<h2 id="堆排序">堆排序</h2>
<ol>
<li>利用BUILD-MAX-HEAP方法构建最大堆</li>
<li>接着循环的堆的根节点和最后一个元素交换</li>
<li>堆的大小减一</li>
<li>调用MAX-HEAPIFY(A, 1)</li>
<li>循环2-4步，直到堆中只剩根节点</li>
</ol>
<p>伪代码，以及2-5步过程如下：</p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/06_HEAP_SORT.PNG" alt="堆"><br>
<img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/06_4.PNG" alt="堆"></p>
<h2 id="优先队列">优先队列</h2>
<p>堆除了堆排序还有很多应用，比如优先队列。优先队列也有两种最大优先队列和最小优先队列。<br>
一个最大优先队列支持以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT(S, x)</span><br><span class="line">MAXIMUM(S)</span><br><span class="line">EXTRACT-MAX(S)</span><br><span class="line">INCREASE-KEY(S, x, k)</span><br></pre></td></tr></table></figure>
<p>最大优先队列的应用有很多，其中一个是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业及他们之间的相对优先级。<br>
最小优先队列可以被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生时间作为其关键字。</p>
<h2 id="涉及算法">涉及算法</h2>
<blockquote>
<p>点击查看实现</p>
</blockquote>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-06-4-HeapSort/heap_sort_realization.cpp">堆排序</a></strong></li>
</ul>
<h2 id="习题答案">习题答案</h2>
<h4 id="思考题">思考题</h4>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Thinkings/T-06-3-YoungTableau/young_tableau_realization.cpp">6-43 Young氏矩阵</a></strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/02/27/Algorithms/6.%E5%A0%86%E6%8E%92%E5%BA%8F/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            5. 概率分析和随机算法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-02-26T18:20:08+08:00">
	
		    2015 年 2 月 26 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>5. 概率分析和随机算法</h1>
<p>当算法的时间和输入的数据有关时，往往我们需要使用概率分析得到算法运行时间的期望值（平均值）。<br>
雇用问题这种答案不唯一的问题，也需要概率分析来分析算法的期望值，从而评估算法的有效性。</p>
<p>随机算法也有很广的应用，比如<a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-07-1-QuickSort/randomized_quick_sort_realization.cpp">随机快速排序</a>可以避免特定输入（已排序的队列或逆序列）时运行时间较长的情况。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            4. 分治策略
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-02-25T18:20:08+08:00">
	
		    2015 年 2 月 25 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>4. 分治策略</h1>
<p>本着涉及更多的<a href="2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80.md#%E5%88%86%E6%B2%BB%E6%B3%95"><strong>分治法</strong></a>相关的算法，以及分治法运行时间的分析方法。</p>
<h3 id="递归式">递归式</h3>
<p>递归式可以很自然的刻画分支算法的运行时间。<br>
递归式通过更小的输入上的函数值来藐视一个函数。<br>
下图为归并排序的递归式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow></mtd><mtd><mrow><mi>i</mi><mi>f</mi><mspace width="1em"></mspace><mi>n</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mn>2</mn><mi>T</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>+</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mtd><mtd><mrow><mi>i</mi><mi>f</mi><mspace width="1em"></mspace><mi>n</mi><mo>&gt;</mo><mn>1</mn><mo separator="true">,</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> T(n)=\left\{
\begin{aligned}
&amp; \Theta(1) &amp; if \quad n=1, \\
&amp; 2T(n/2) + \Theta(n) &amp; if \quad n&gt;1,
\end{aligned}
\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.45em;"></span><span class="strut bottom" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="minner displaystyle textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.6099999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"></span></span><span style="top:0.5900000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="col-align-l"><span class="vlist"><span style="top:-0.6099999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord displaystyle textstyle uncramped"></span><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span><span style="top:0.5900000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord displaystyle textstyle uncramped"></span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:2em;"></span><span class="col-align-r"><span class="vlist"><span style="top:-0.6099999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mspace quad"></span><span class="mord mathit">n</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mpunct">,</span></span></span><span style="top:0.5900000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mspace quad"></span><span class="mord mathit">n</span><span class="mrel">&gt;</span><span class="mord mathrm">1</span><span class="mpunct">,</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
<h3 id="求解递归式的方法">求解递归式的方法</h3>
<ul>
<li>代入法<br>
猜测一个界，然后用数学归纳法证明这个界的正确性</li>
<li>递归树法<br>
将递归式转换为一棵树，其结点表示不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式。</li>
<li>主方法  可求解形式如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n) = aT(n/b) + f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的递归式的界</li>
</ul>
<h2 id="涉及算法">涉及算法</h2>
<blockquote>
<p>点击查看实现</p>
</blockquote>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-04-1-MaxSubArray/max_subarray_realization.cpp">最大子数组</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-04-2-MatrixMultiply/matrix_multiply_realization.cpp">矩阵乘法</a></strong></li>
</ul>
<h2 id="练习">练习</h2>
<p><strong>4.1-1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回最大的一个数组成的数组</span><br></pre></td></tr></table></figure>
<p><strong>4.1-2</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FIND-MAXIMUM-SUBARRAY(A, n)</span><br><span class="line">    low = <span class="number">1</span></span><br><span class="line">    high = <span class="number">1</span></span><br><span class="line">    <span class="built_in">sum</span> = A[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        max_sum = A[i]</span><br><span class="line">        tmp_sum = A[i]</span><br><span class="line">        <span class="keyword">for</span> j = i+<span class="number">1</span> to n</span><br><span class="line">            tmp_sum += A[j]</span><br><span class="line">            <span class="keyword">if</span> tmp_sum &gt; max_sum</span><br><span class="line">                max_sum = tmp_sum</span><br><span class="line">                tmp_low = i</span><br><span class="line">                tmp_high = j</span><br><span class="line">        <span class="keyword">if</span> max_sum &gt; <span class="built_in">sum</span></span><br><span class="line">            <span class="built_in">sum</span> = max_sum</span><br><span class="line">            low = tmp_low</span><br><span class="line">            high = tmp_high</span><br><span class="line">    <span class="keyword">return</span> (low, high, <span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>
<p><strong>4.1-4</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在比较left-sum, right-sum, cross-sum时，增加对0的比较，当0最大时，返回空数组</span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            3. 函数的增长
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-02-24T18:20:08+08:00">
	
		    2015 年 2 月 24 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>3. 函数的增长</h1>
<p>本章给出集中标准方法来简化算法的渐进分析。</p>
<h3 id="渐进符号">渐进符号</h3>
<h4 id="Θ-渐进紧确界">Θ 渐进紧确界</h4>
<p>   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=\Theta(g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 类似于 <strong>a = b</strong><br>
   当n&gt;n0时，存在常数c<sub>1</sub>和c<sub>2</sub>使得c<sub>1</sub>·g(n)  &lt;= f(n) &lt;= c<sub>2</sub>·g(n)</p>
<h4 id="Ο-渐进上界">Ο 渐进上界</h4>
<p>   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=O(g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 类似于 <strong>a ≤ b</strong><br>
   当n&gt;n<sub>0</sub>时，存在一个常数c使得 f(n) &lt;= c·g(n)</p>
<h4 id="Ω-渐进下界">Ω 渐进下界</h4>
<p>   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=\Omega(g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">Ω</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 类似于 <strong>a ≥ b</strong><br>
   当n&gt;n<sub>0</sub>时，存在一个常数c使得 f(n) &gt;= c·g(n)</p>
<h4 id="ο">ο</h4>
<p>   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>o</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=\omicron(g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">o</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 类似于 <strong>a &lt; b</strong></p>
<h4 id="ω">ω</h4>
<p>   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>ω</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=\omega(g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">ω</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 类似于 <strong>a &gt; b</strong></p>
<p><img src="https://raw.githubusercontent.com/maomao9003/Introduction-to-Algorithms/master/.res/03_1.PNG" alt="a"></p>
<blockquote>
<p>此图为书中截图，很好的说明了Θ Ο Ω 的含义</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="../../../../2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            2. 算法基础
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-02-23T18:20:08+08:00">
	
		    2015 年 2 月 23 日
    	
    </time>
    
        <span>分類 </span>
        
    <a class="category-link" href="../../../../categories/%E7%AE%97%E6%B3%95/">算法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1>2. 算法基础</h1>
<p>本章介绍了一个证明算法正确性的方法——循环不变式，对算法运行时间的简单分析，以及分治法。</p>
<h3 id="循环不变式">循环不变式</h3>
<p>类似于数学归纳法的一种证明算法正确性的方法。<br>
需要证明以下三步：</p>
<ul>
<li><strong>初始化</strong><br>
循环的第一次迭代前，它为真。</li>
<li><strong>保持</strong><br>
如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。</li>
<li><strong>终止</strong><br>
再循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。</li>
</ul>
<h3 id="分治法">分治法</h3>
<p>将原问题分解为几个规模较小但类似于原问题的子问题，递归求解这些子问题，然后合并这些子问题的解来建立原问题的解。<br>
每层递归时，都有如下三个步骤：</p>
<ul>
<li><strong>分解</strong><br>
将原问题分解为几个规模较小但类似于原问题的子问题</li>
<li><strong>解决</strong><br>
递归求解各个子问题，当子问题规模够小可以直接求解时，则直接求解</li>
<li><strong>合并</strong><br>
合并这些子问题的解来建立原问题的解</li>
</ul>
<h2 id="涉及算法">涉及算法</h2>
<blockquote>
<p>点击查看实现</p>
</blockquote>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-02-1-InsertionSort/insertion_sort_realization.cpp">插入排序</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Algorithms/A-02-3-MergeSort/merge_sort_realization.cpp">归并排序</a></strong></li>
</ul>
<h2 id="习题答案">习题答案</h2>
<h4 id="思考题">思考题</h4>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/maomao9003/Introduction-to-Algorithms/blob/master/Code/Thinkings/T-02-4-Inversion/inversion_realization.cpp">2-4 逆序对</a></strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="../../../../2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="../../"
                aria-label="上一頁"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一頁</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="../3/"
                aria-label="下一頁"
            >
              <span>下一頁</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 2 頁 共 3 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Kein Chan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="../../../../assets/images/profile.jpg" alt="作者的圖片"/>
        
            <h4 id="about-card-name">Kein Chan</h4>
        
            <div id="about-card-bio"><p>這是獨立全棧工程師Kein Chan的技術博客</br>分享一些技術教程,命令備忘(cheat-sheet)等</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>全棧工程師</br>資深技術顧問</br>數據科學家</br>Hit廣島觀光大使</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Tokyo/Macau
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">沒有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/27/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"
                            aria-label=": R语言-环境安装"
                        >
                            <h3 class="media-heading">R语言-环境安装</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月27日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/04/28/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"
                            aria-label=": R语言-基础"
                        >
                            <h3 class="media-heading">R语言-基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年4月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/01/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/"
                            aria-label=": R语言-读取数据"
                        >
                            <h3 class="media-heading">R语言-读取数据</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月1日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/02/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BB%98%E5%9B%BE/"
                            aria-label=": R语言-绘图"
                        >
                            <h3 class="media-heading">R语言-绘图</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月2日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2013/05/03/R%E8%AF%AD%E8%A8%80/R%E8%AF%AD%E8%A8%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"
                            aria-label=": R语言-线性回归"
                        >
                            <h3 class="media-heading">R语言-线性回归</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年5月3日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/22/Algorithms/1.%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"
                            aria-label=": 1. 算法在计算中的作用"
                        >
                            <h3 class="media-heading">1. 算法在计算中的作用</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/23/Algorithms/2.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"
                            aria-label=": 2. 算法基础"
                        >
                            <h3 class="media-heading">2. 算法基础</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/24/Algorithms/3.%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/"
                            aria-label=": 3. 函数的增长"
                        >
                            <h3 class="media-heading">3. 函数的增长</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月24日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/25/Algorithms/4.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"
                            aria-label=": 4. 分治策略"
                        >
                            <h3 class="media-heading">4. 分治策略</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月25日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://keinchan.com/2015/02/26/Algorithms/5.%E6%A6%82%E7%8E%87%E5%88%86%E6%9E%90%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"
                            aria-label=": 5. 概率分析和随机算法"
                        >
                            <h3 class="media-heading">5. 概率分析和随机算法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2015年2月26日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="沒有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 234 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../assets/images/cover.jpeg');"></div>
        <!--SCRIPTS-->

<script src="../../../../assets/js/script-qtzvvb63gamuirvfphht7lytrxkfllzng1escnm2phjtlt4tvvxi5gl0wx4o.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
